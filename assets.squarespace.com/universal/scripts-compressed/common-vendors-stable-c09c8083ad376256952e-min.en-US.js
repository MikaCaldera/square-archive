(self["webpackChunkextract_css"] = self["webpackChunkextract_css"] || []).push([[97684],{

/***/ 44001:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YUI": function() { return /* binding */ YUI; }
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
/* provided dependency */ var process = __webpack_require__(246118);
/**
@license
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

/**
The YUI module contains the components required for building the YUI seed file.
This includes the script loading mechanism, a simple queue, and the core
utilities for the library.

@module yui
@main yui
@submodule yui-base
**/

/*jshint eqeqeq: false*/
if (typeof YUI != 'undefined') {
    YUI._YUI = YUI;
}

/**
The YUI global namespace object. This is the constructor for all YUI instances.

This is a self-instantiable factory function, meaning you don't need to precede
it with the `new` operator. You can invoke it directly like this:

    YUI().use('*', function (Y) {
        // Y is a new YUI instance.
    });

But it also works like this:

    var Y = YUI();

The `YUI` constructor accepts an optional config object, like this:

    YUI({
        debug: true,
        combine: false
    }).use('node', function (Y) {
        // Y.Node is ready to use.
    });

See the API docs for the <a href="config.html">Config</a> class for the complete
list of supported configuration properties accepted by the YUI constuctor.

If a global `YUI` object is already defined, the existing YUI object will not be
overwritten, to ensure that defined namespaces are preserved.

Each YUI instance has full custom event support, but only if the event system is
available.

@class YUI
@uses EventTarget
@constructor
@global
@param {Object} [config]* Zero or more optional configuration objects. Config
    values are stored in the `Y.config` property. See the
    <a href="config.html">Config</a> docs for the list of supported properties.
**/

    /*global YUI*/
    /*global YUI_config*/
    var YUI = function() {
        var i = 0,
            Y = this,
            args = arguments,
            l = args.length,
            instanceOf = function(o, type) {
                return (o && o.hasOwnProperty && (o instanceof type));
            },
            gconf = (typeof YUI_config !== 'undefined') && YUI_config;

        if (!(instanceOf(Y, YUI))) {
            Y = new YUI();
        } else {
            // set up the core environment
            Y._init();

            /**
            Master configuration that might span multiple contexts in a non-
            browser environment. It is applied first to all instances in all
            contexts.

            @example

                YUI.GlobalConfig = {
                    filter: 'debug'
                };

                YUI().use('node', function (Y) {
                    // debug files used here
                });

                YUI({
                    filter: 'min'
                }).use('node', function (Y) {
                    // min files used here
                });

            @property {Object} GlobalConfig
            @global
            @static
            **/
            if (YUI.GlobalConfig) {
                Y.applyConfig(YUI.GlobalConfig);
            }

            /**
            Page-level config applied to all YUI instances created on the
            current page. This is applied after `YUI.GlobalConfig` and before
            any instance-level configuration.

            @example

                // Single global var to include before YUI seed file
                YUI_config = {
                    filter: 'debug'
                };

                YUI().use('node', function (Y) {
                    // debug files used here
                });

                YUI({
                    filter: 'min'
                }).use('node', function (Y) {
                    // min files used here
                });

            @property {Object} YUI_config
            @global
            **/
            if (gconf) {
                Y.applyConfig(gconf);
            }

            // bind the specified additional modules for this instance
            if (!l) {
                Y._setup();
            }
        }

        if (l) {
            // Each instance can accept one or more configuration objects.
            // These are applied after YUI.GlobalConfig and YUI_Config,
            // overriding values set in those config files if there is a
            // matching property.
            for (; i < l; i++) {
                Y.applyConfig(args[i]);
            }

            Y._setup();
        }

        Y.instanceOf = instanceOf;

        return Y;
    };

(function() {

    var proto, prop,
        VERSION = '3.17.2',
        PERIOD = '.',
        BASE = 'http://yui.yahooapis.com/',
        /*
            These CSS class names can't be generated by
            getClassName since it is not available at the
            time they are being used.
        */
        DOC_LABEL = 'yui3-js-enabled',
        CSS_STAMP_EL = 'yui3-css-stamp',
        NOOP = function() {},
        SLICE = Array.prototype.slice,
        APPLY_TO_AUTH = { 'io.xdrReady': 1,   // the functions applyTo
                          'io.xdrResponse': 1,   // can call. this should
                          'SWF.eventHandler': 1 }, // be done at build time
        hasWin = (typeof window != 'undefined'),
        win = (hasWin) ? window : null,
        doc = (hasWin) ? win.document : null,
        docEl = doc && doc.documentElement,
        docClass = docEl && docEl.className,
        instances = {},
        time = new Date().getTime(),
        add = function(el, type, fn, capture) {
            if (el && el.addEventListener) {
                el.addEventListener(type, fn, capture);
            } else if (el && el.attachEvent) {
                el.attachEvent('on' + type, fn);
            }
        },
        remove = function(el, type, fn, capture) {
            if (el && el.removeEventListener) {
                // this can throw an uncaught exception in FF
                try {
                    el.removeEventListener(type, fn, capture);
                } catch (ex) {}
            } else if (el && el.detachEvent) {
                el.detachEvent('on' + type, fn);
            }
        },
        handleReady = function() {
            YUI.Env.DOMReady = true;
            if (hasWin) {
                remove(doc, 'DOMContentLoaded', handleReady);
            }
        },
        handleLoad = function() {
            YUI.Env.windowLoaded = true;
            YUI.Env.DOMReady = true;
            if (hasWin) {
                remove(window, 'load', handleLoad);
            }
        },
        getLoader = function(Y, o) {
            var loader = Y.Env._loader,
                lCore = [ 'loader-base' ],
                G_ENV = YUI.Env,
                mods = G_ENV.mods;

            if (loader) {
                //loader._config(Y.config);
                loader.ignoreRegistered = false;
                loader.onEnd = null;
                loader.data = null;
                loader.required = [];
                loader.loadType = null;
            } else {
                loader = new Y.Loader(Y.config);
                Y.Env._loader = loader;
            }
            if (mods && mods.loader) {
                lCore = [].concat(lCore, YUI.Env.loaderExtras);
            }
            YUI.Env.core = Y.Array.dedupe([].concat(YUI.Env.core, lCore));

            return loader;
        },

        clobber = function(r, s) {
            for (var i in s) {
                if (s.hasOwnProperty(i)) {
                    r[i] = s[i];
                }
            }
        },

        ALREADY_DONE = { success: true };

//  Stamp the documentElement (HTML) with a class of "yui-loaded" to
//  enable styles that need to key off of JS being enabled.
if (docEl && docClass.indexOf(DOC_LABEL) == -1) {
    if (docClass) {
        docClass += ' ';
    }
    docClass += DOC_LABEL;
    docEl.className = docClass;
}

if (VERSION.indexOf('@') > -1) {
    VERSION = '3.5.0'; // dev time hack for cdn test
}

var DEFAULT_YUI_STATS = {};

proto = {
    stats: {
      getAll: function() {
        try {
          return window.top.YUIStats = window.top.YUIStats || DEFAULT_YUI_STATS;
        } catch (e) {
          return DEFAULT_YUI_STATS;
        }
      },
      getOne: function (name) {
        return proto.stats.getAll()[name] = proto.stats.getAll()[name] || { create: 0, initializer: 0, destructor: 0 };
      },
      getSerializedDataForReporter: function() {
        var trie = {};
        var allYUIStats = proto.stats.getAll();

        Y.Object.keys(allYUIStats).forEach(function (yuiClass) {
          var yuiClassData = allYUIStats[yuiClass];
          var createCalls = yuiClassData.create;
          var initializerCalls = yuiClassData.initializer;
          var destructorCalls = yuiClassData.destructor;

          if (!trie.hasOwnProperty(createCalls)) {
            trie[createCalls] = {};
          }

          if (!trie[createCalls].hasOwnProperty(initializerCalls)) {
            trie[createCalls][initializerCalls] = {};
          }

          if (!trie[createCalls][initializerCalls].hasOwnProperty(destructorCalls)) {
            trie[createCalls][initializerCalls][destructorCalls] = [];
          }

          trie[createCalls][initializerCalls][destructorCalls].push(yuiClass);
        });

        return trie;
      },
      markCreate: function (name) {
        var stat = proto.stats.getOne(name);
        stat.create++;
      },
      markInitializer: function (name) {
        var stat = proto.stats.getOne(name);
        stat.initializer++;
      },
      markDestructor: function (name) {
        var stat = proto.stats.getOne(name);
        stat.destructor++;
      }
    },
    /**
    Applies a new configuration object to the config of this YUI instance. This
    will merge new group/module definitions, and will also update the loader
    cache if necessary. Updating `Y.config` directly will not update the cache.

    @method applyConfig
    @param {Object} o the configuration object.
    @since 3.2.0
    **/
    applyConfig: function(o) {

        o = o || NOOP;

        var attr,
            name,
            // detail,
            config = this.config,
            mods = config.modules,
            groups = config.groups,
            aliases = config.aliases,
            loader = this.Env._loader;

        for (name in o) {
            if (o.hasOwnProperty(name)) {
                attr = o[name];
                if (mods && name == 'modules') {
                    clobber(mods, attr);
                } else if (aliases && name == 'aliases') {
                    clobber(aliases, attr);
                } else if (groups && name == 'groups') {
                    clobber(groups, attr);
                } else if (name == 'win') {
                    config[name] = (attr && attr.contentWindow) || attr;
                    config.doc = config[name] ? config[name].document : null;
                } else if (name == '_yuid') {
                    // preserve the guid
                } else {
                    config[name] = attr;
                }
            }
        }

        if (loader) {
            loader._config(o);
        }

    },

    /**
    Old way to apply a config to this instance (calls `applyConfig` under the
    hood).

    @private
    @method _config
    @param {Object} o The config to apply
    **/
    _config: function(o) {
        this.applyConfig(o);
    },

    /**
    Initializes this YUI instance.

    @private
    @method _init
    **/
    _init: function() {
        var filter, el,
            Y = this,
            G_ENV = YUI.Env,
            Env = Y.Env,
            prop;

        /**
        The version number of this YUI instance.

        This value is typically updated by a script when a YUI release is built,
        so it may not reflect the correct version number when YUI is run from
        the development source tree.

        @property {String} version
        **/
        Y.version = VERSION;

        if (!Env) {
            Y.Env = {
                core: ['get', 'features', 'intl-base', 'yui-log', 'yui-later'],
                loaderExtras: ['loader-rollup', 'loader-yui3'],
                mods: {}, // flat module map
                versions: {}, // version module map
                base: BASE,
                cdn: BASE + VERSION + '/build/',
                // bootstrapped: false,
                _idx: 0,
                _used: {},
                _attached: {},
                _exported: {},
                _missed: [],
                _yidx: 0,
                _uidx: 0,
                _guidp: 'y',
                _loaded: {},
                // serviced: {},
                // Regex in English:
                // I'll start at the \b(yui).
                // 1. Look in the test string for "yui" or
                //    "yui-base" or "yui-davglass" or "yui-foobar" that comes after a word break.  That is, it
                //    can't match "foyui" or "i_heart_yui". This can be anywhere in the string.
                // 2. After #1 must come a forward slash followed by the string matched in #1, so
                //    "yui-base/yui-base" or "yui-pants/yui-pants".
                // 3. The second occurence of the #1 token can optionally be followed by "-debug" or "-min",
                //    so "yui/yui-min", "yui/yui-debug", "yui-base/yui-base-debug". NOT "yui/yui-tshirt".
                // 4. This is followed by ".js", so "yui/yui.js".
                // 0. Going back to the beginning, now. If all that stuff in 1-4 comes after a "?" in the string,
                //    then capture the junk between the LAST "&" and the string in 1-4.  So
                //    "blah?foo/yui/yui.js" will capture "foo/" and "blah?some/thing.js&3.3.0/build/yui-davglass/yui-davglass.js"
                //    will capture "3.3.0/build/"
                //
                // Regex Exploded:
                // (?:\?             Find a ?
                //   (?:[^&]*&)      followed by 0..n characters followed by an &
                //   *               in fact, find as many sets of characters followed by a & as you can
                //   ([^&]*)         capture the stuff after the last & in \1
                // )?                but it's ok if all this ?junk&more_junk stuff isn't even there
                // \b(               after a word break find either the string
                //    yui(?:-\w+)?   "yui" optionally followed by a -, then more characters
                // )                 and store the yui-* string in \2
                // \/\2              then comes a / followed by the yui-* string in \2
                // (?:-(min|debug))? optionally followed by "-min" or "-debug"
                // .js               and ending in ".js"
                _BASE_RE: /(?:\?(?:[^&]*&)*([^&]*))?\b(yui(?:-\w+)?)\/\2(?:-(min|debug))?\.js/,
                parseBasePath: function(src, pattern) {
                    var match = src.match(pattern),
                        path, filter;

                    if (match) {
                        path = RegExp.leftContext || src.slice(0, src.indexOf(match[0]));

                        // this is to set up the path to the loader.  The file
                        // filter for loader should match the yui include.
                        filter = match[3];

                        // extract correct path for mixed combo urls
                        // http://yuilibrary.com/projects/yui3/ticket/2528423
                        if (match[1]) {
                            path += '?' + match[1];
                        }
                        path = {
                            filter: filter,
                            path: path
                        };
                    }
                    return path;
                },
                getBase: G_ENV && G_ENV.getBase ||
                        function(pattern) {
                            var nodes = (doc && doc.getElementsByTagName('script')) || [],
                                path = Env.cdn, parsed,
                                i, len, src;

                            for (i = 0, len = nodes.length; i < len; ++i) {
                                src = nodes[i].src;
                                if (src) {
                                    parsed = Y.Env.parseBasePath(src, pattern);
                                    if (parsed) {
                                        filter = parsed.filter;
                                        path = parsed.path;
                                        break;
                                    }
                                }
                            }

                            // use CDN default
                            return path;
                        }

            };

            Env = Y.Env;

            Env._loaded[VERSION] = {};

            if (G_ENV && Y !== YUI) {
                Env._yidx = ++G_ENV._yidx;
                Env._guidp = ('yui_' + VERSION + '_' +
                             Env._yidx + '_' + time).replace(/[^a-z0-9_]+/g, '_');
            } else if (YUI._YUI) {

                G_ENV = YUI._YUI.Env;
                Env._yidx += G_ENV._yidx;
                Env._uidx += G_ENV._uidx;

                for (prop in G_ENV) {
                    if (!(prop in Env)) {
                        Env[prop] = G_ENV[prop];
                    }
                }

                delete YUI._YUI;
            }

            Y.id = Y.stamp(Y);
            instances[Y.id] = Y;

        }

        Y.constructor = YUI;

        // configuration defaults
        Y.config = Y.config || {
            bootstrap: true,
            cacheUse: true,
            debug: true,
            doc: doc,
            fetchCSS: true,
            throwFail: true,
            useBrowserConsole: true,
            useNativeES5: true,
            win: win,
            global: Function('return this')()
        };

        //Register the CSS stamp element
        if (doc && !doc.getElementById(CSS_STAMP_EL)) {
            el = doc.createElement('div');
            el.innerHTML = '<div id="' + CSS_STAMP_EL + '" style="position: absolute !important; visibility: hidden !important"></div>';
            YUI.Env.cssStampEl = el.firstChild;
            if (doc.body) {
                doc.body.appendChild(YUI.Env.cssStampEl);
            } else {
                docEl.insertBefore(YUI.Env.cssStampEl, docEl.firstChild);
            }
        } else if (doc && doc.getElementById(CSS_STAMP_EL) && !YUI.Env.cssStampEl) {
            YUI.Env.cssStampEl = doc.getElementById(CSS_STAMP_EL);
        }

        Y.config.lang = Y.config.lang || 'en-US';

        Y.config.base = YUI.config.base || Y.Env.getBase(Y.Env._BASE_RE);

        if (!filter || (!('mindebug').indexOf(filter))) {
            filter = 'min';
        }
        filter = (filter) ? '-' + filter : filter;
        Y.config.loaderPath = YUI.config.loaderPath || 'loader/loader' + filter + '.js';

    },

    /**
    Finishes the instance setup. Attaches whatever YUI modules were defined
    at the time that this instance was created.

    @method _setup
    @private
    **/
    _setup: function() {
        var i, Y = this,
            core = [],
            mods = YUI.Env.mods,
            extras = Y.config.core || [].concat(YUI.Env.core); //Clone it..

        for (i = 0; i < extras.length; i++) {
            if (mods[extras[i]]) {
                core.push(extras[i]);
            }
        }

        Y._attach(['yui-base']);
        Y._attach(core);

        if (Y.Loader) {
            getLoader(Y);
        }

    },

    /**
    Executes the named method on the specified YUI instance if that method is
    whitelisted.

    @method applyTo
    @param {String} id YUI instance id.
    @param {String} method Name of the method to execute. For example:
        'Object.keys'.
    @param {Array} args Arguments to apply to the method.
    @return {Mixed} Return value from the applied method, or `null` if the
        specified instance was not found or the method was not whitelisted.
    **/
    applyTo: function(id, method, args) {
        if (!(method in APPLY_TO_AUTH)) {
            this.log(method + ': applyTo not allowed', 'warn', 'yui');
            return null;
        }

        var instance = instances[id], nest, m, i;
        if (instance) {
            nest = method.split('.');
            m = instance;
            for (i = 0; i < nest.length; i = i + 1) {
                m = m[nest[i]];
                if (!m) {
                    this.log('applyTo not found: ' + method, 'warn', 'yui');
                }
            }
            return m && m.apply(instance, args);
        }

        return null;
    },

/**
Registers a YUI module and makes it available for use in a `YUI().use()` call or
as a dependency for other modules.

The easiest way to create a first-class YUI module is to use
<a href="http://yui.github.com/shifter/">Shifter</a>, the YUI component build
tool.

Shifter will automatically wrap your module code in a `YUI.add()` call along
with any configuration info required for the module.

@example

    YUI.add('davglass', function (Y) {
        Y.davglass = function () {
        };
    }, '3.4.0', {
        requires: ['harley-davidson', 'mt-dew']
    });

@method add
@param {String} name Module name.
@param {Function} fn Function containing module code. This function will be
    executed whenever the module is attached to a specific YUI instance.

    @param {YUI} fn.Y The YUI instance to which this module is attached.
    @param {String} fn.name Name of the module

@param {String} version Module version number. This is currently used only for
    informational purposes, and is not used internally by YUI.

@param {Object} [details] Module config.
    @param {Array} [details.requires] Array of other module names that must be
        attached before this module can be attached.
    @param {Array} [details.optional] Array of optional module names that should
        be attached before this module is attached if they've already been
        loaded. If the `loadOptional` YUI option is `true`, optional modules
        that have not yet been loaded will be loaded just as if they were hard
        requirements.
    @param {Array} [details.use] Array of module names that are included within
        or otherwise provided by this module, and which should be attached
        automatically when this module is attached. This makes it possible to
        create "virtual rollup" modules that simply attach a collection of other
        modules or submodules.

@return {YUI} This YUI instance.
**/
    add: function(name, fn, version, details) {
        details = details || {};
        var env = YUI.Env,
            mod = {
                name: name,
                fn: fn,
                version: version,
                details: details
            },
            //Instance hash so we don't apply it to the same instance twice
            applied = {},
            loader, inst, modInfo,
            i, versions = env.versions;

        env.mods[name] = mod;
        versions[version] = versions[version] || {};
        versions[version][name] = mod;

        for (i in instances) {
            if (instances.hasOwnProperty(i)) {
                inst = instances[i];
                if (!applied[inst.id]) {
                    applied[inst.id] = true;
                    loader = inst.Env._loader;
                    if (loader) {
                        modInfo = loader.getModuleInfo(name);
                        if (!modInfo || modInfo.temp) {
                            loader.addModule(details, name);
                        }
                    }
                }
            }
        }

        return this;
    },

    /**
    Executes the callback function associated with each required module,
    attaching the module to this YUI instance.

    @method _attach
    @param {Array} r The array of modules to attach
    @param {Boolean} [moot=false] If `true`, don't throw a warning if the module
        is not attached.
    @private
    **/
    _attach: function(r, moot) {
        var i, name, mod, details, req, use, after,
            mods = YUI.Env.mods,
            aliases = YUI.Env.aliases,
            Y = this, j,
            cache = YUI.Env._renderedMods,
            loader = Y.Env._loader,
            done = Y.Env._attached,
            exported = Y.Env._exported,
            len = r.length, loader, def, go,
            c = [],
            modArgs, esCompat, reqlen, modInfo,
            condition,
            __exports__, __imports__;

        //Check for conditional modules (in a second+ instance) and add their requirements
        //TODO I hate this entire method, it needs to be fixed ASAP (3.5.0) ^davglass
        for (i = 0; i < len; i++) {
            name = r[i];
            mod = mods[name];
            c.push(name);
            if (loader && loader.conditions[name]) {
                for (j in loader.conditions[name]) {
                    if (loader.conditions[name].hasOwnProperty(j)) {
                        def = loader.conditions[name][j];
                        go = def && ((def.ua && Y.UA[def.ua]) || (def.test && def.test(Y)));
                        if (go) {
                            c.push(def.name);
                        }
                    }
                }
            }
        }
        r = c;
        len = r.length;

        for (i = 0; i < len; i++) {
            if (!done[r[i]]) {
                name = r[i];
                mod = mods[name];

                if (aliases && aliases[name] && !mod) {
                    Y._attach(aliases[name]);
                    continue;
                }
                if (!mod) {
                    modInfo = loader && loader.getModuleInfo(name);
                    if (modInfo) {
                        mod = modInfo;
                        moot = true;
                    }


                    //if (!loader || !loader.moduleInfo[name]) {
                    //if ((!loader || !loader.moduleInfo[name]) && !moot) {
                    if (!moot && name) {
                        if ((name.indexOf('skin-') === -1) && (name.indexOf('css') === -1)) {
                            Y.Env._missed.push(name);
                            Y.Env._missed = Y.Array.dedupe(Y.Env._missed);
                            Y.message('NOT loaded: ' + name, 'warn', 'yui');
                        }
                    }
                } else {
                    done[name] = true;
                    //Don't like this, but in case a mod was asked for once, then we fetch it
                    //We need to remove it from the missed list ^davglass
                    for (j = 0; j < Y.Env._missed.length; j++) {
                        if (Y.Env._missed[j] === name) {
                            Y.message('Found: ' + name + ' (was reported as missing earlier)', 'warn', 'yui');
                            Y.Env._missed.splice(j, 1);
                        }
                    }

                    // Optional dependencies normally work by modifying the
                    // dependency list of a module. If the dependency's test
                    // passes it is added to the list. If not, it's not loaded.
                    // This following check ensures that optional dependencies
                    // are not attached when they were already loaded into the
                    // page (when bundling for example)
                    if (loader && !loader._canBeAttached(name)) {
                        return true;
                    }

                    /*
                        If it's a temp module, we need to redo it's requirements if it's already loaded
                        since it may have been loaded by another instance and it's dependencies might
                        have been redefined inside the fetched file.
                    */
                    if (loader && cache && cache[name] && cache[name].temp) {
                        loader.getRequires(cache[name]);
                        req = [];
                        modInfo = loader.getModuleInfo(name);
                        for (j in modInfo.expanded_map) {
                            if (modInfo.expanded_map.hasOwnProperty(j)) {
                                req.push(j);
                            }
                        }
                        Y._attach(req);
                    }

                    details = mod.details;
                    req = details.requires;
                    esCompat = details.es;
                    use = details.use;
                    after = details.after;
                    //Force Intl load if there is a language (Loader logic) @todo fix this shit
                    if (details.lang) {
                        req = req || [];
                        req.unshift('intl');
                    }

                    if (req) {
                        reqlen = req.length;
                        for (j = 0; j < reqlen; j++) {
                            if (!done[req[j]]) {
                                if (!Y._attach(req)) {
                                    return false;
                                }
                                break;
                            }
                        }
                    }

                    if (after) {
                        for (j = 0; j < after.length; j++) {
                            if (!done[after[j]]) {
                                if (!Y._attach(after, true)) {
                                    return false;
                                }
                                break;
                            }
                        }
                    }

                    if (mod.fn) {
                        modArgs = [Y, name];
                        if (esCompat) {
                            __imports__ = {};
                            __exports__ = {};
                            // passing `exports` and `imports` onto the module function
                            modArgs.push(__imports__, __exports__);
                            if (req) {
                                reqlen = req.length;
                                for (j = 0; j < reqlen; j++) {
                                    __imports__[req[j]] = exported.hasOwnProperty(req[j]) ? exported[req[j]] : Y;
                                }
                            }
                        }
                        if (Y.config.throwFail) {
                            __exports__ = mod.fn.apply(esCompat ? undefined : mod, modArgs);
                        } else {
                            try {
                                __exports__ = mod.fn.apply(esCompat ? undefined : mod, modArgs);
                            } catch (e) {
                                Y.error('Attach error: ' + name, e, name);
                                return false;
                            }
                        }
                        if (esCompat) {
                            // store the `exports` in case others `es` modules requires it
                            exported[name] = __exports__;

                            // If an ES module is conditionally loaded and set
                            // to be used "instead" another module, replace the
                            // trigger module's content with the conditionally
                            // loaded one so the values returned by require()
                            // still makes sense
                            condition = mod.details.condition;
                            if (condition && condition.when === 'instead') {
                                exported[condition.trigger] = __exports__;
                            }
                        }
                    }

                    if (use) {
                        for (j = 0; j < use.length; j++) {
                            if (!done[use[j]]) {
                                if (!Y._attach(use)) {
                                    return false;
                                }
                                break;
                            }
                        }
                    }



                }
            }
        }

        return true;
    },

    /**
    Delays the `use` callback until another event has taken place such as
    `window.onload`, `domready`, `contentready`, or `available`.

    @private
    @method _delayCallback
    @param {Function} cb The original `use` callback.
    @param {String|Object} until Either an event name ('load', 'domready', etc.)
        or an object containing event/args keys for contentready/available.
    @return {Function}
    **/
    _delayCallback: function(cb, until) {

        var Y = this,
            mod = ['event-base'];

        until = (Y.Lang.isObject(until) ? until : { event: until });

        if (until.event === 'load') {
            mod.push('event-synthetic');
        }

        return function() {
            var args = arguments;
            Y._use(mod, function() {
                Y.on(until.event, function() {
                    args[1].delayUntil = until.event;
                    cb.apply(Y, args);
                }, until.args);
            });
        };
    },

    /**
    Attaches one or more modules to this YUI instance. When this is executed,
    the requirements of the desired modules are analyzed, and one of several
    things can happen:


      * All required modules have already been loaded, and just need to be
        attached to this YUI instance. In this case, the `use()` callback will
        be executed synchronously after the modules are attached.

      * One or more modules have not yet been loaded, or the Get utility is not
        available, or the `bootstrap` config option is `false`. In this case,
        a warning is issued indicating that modules are missing, but all
        available modules will still be attached and the `use()` callback will
        be executed synchronously.

      * One or more modules are missing and the Loader is not available but the
        Get utility is, and `bootstrap` is not `false`. In this case, the Get
        utility will be used to load the Loader, and we will then proceed to
        the following state:

      * One or more modules are missing and the Loader is available. In this
        case, the Loader will be used to resolve the dependency tree for the
        missing modules and load them and their dependencies. When the Loader is
        finished loading modules, the `use()` callback will be executed
        asynchronously.

    @example

        // Loads and attaches dd and its dependencies.
        YUI().use('dd', function (Y) {
            // ...
        });

        // Loads and attaches dd and node as well as all of their dependencies.
        YUI().use(['dd', 'node'], function (Y) {
            // ...
        });

        // Attaches all modules that have already been loaded.
        YUI().use('*', function (Y) {
            // ...
        });

        // Attaches a gallery module.
        YUI().use('gallery-yql', function (Y) {
            // ...
        });

        // Attaches a YUI 2in3 module.
        YUI().use('yui2-datatable', function (Y) {
            // ...
        });

    @method use
    @param {String|Array} modules* One or more module names to attach.
    @param {Function} [callback] Callback function to be executed once all
        specified modules and their dependencies have been attached.
    @param {YUI} callback.Y The YUI instance created for this sandbox.
    @param {Object} callback.status Object containing `success`, `msg` and
        `data` properties.
    @chainable
    **/
    use: function() {
        var args = SLICE.call(arguments, 0),
            callback = args[args.length - 1],
            Y = this,
            i = 0,
            name,
            Env = Y.Env,
            provisioned = true;

        // The last argument supplied to use can be a load complete callback
        if (Y.Lang.isFunction(callback)) {
            args.pop();
            if (Y.config.delayUntil) {
                callback = Y._delayCallback(callback, Y.config.delayUntil);
            }
        } else {
            callback = null;
        }
        if (Y.Lang.isArray(args[0])) {
            args = args[0];
        }

        if (Y.config.cacheUse) {
            while ((name = args[i++])) {
                if (!Env._attached[name]) {
                    provisioned = false;
                    break;
                }
            }

            if (provisioned) {
                if (args.length) {
                }
                Y._notify(callback, ALREADY_DONE, args);
                return Y;
            }
        }

        if (Y._loading) {
            Y._useQueue = Y._useQueue || new Y.Queue();
            Y._useQueue.add([args, callback]);
        } else {
            Y._use(args, function(Y, response) {
                Y._notify(callback, response, args);
            });
        }

        return Y;
    },

    /**
    Sugar for loading both legacy and ES6-based YUI modules.

    @method require
    @param {String} [modules*] List of module names to import or a single
        module name.
    @param {Function} callback Callback that gets called once all the modules
        were loaded. Each parameter of the callback is the export value of the
        corresponding module in the list. If the module is a legacy YUI module,
        the YUI instance is used instead of the module exports.
    @example
    ```
    YUI().require(['es6-set'], function (Y, imports) {
        var Set = imports.Set,
            set = new Set();
    });
    ```
    **/
    require: function () {
        var args = SLICE.call(arguments),
            callback;

        if (typeof args[args.length - 1] === 'function') {
            callback = args.pop();

            // only add the callback if one was provided
            // YUI().require('foo'); is valid
            args.push(function (Y) {
                var i, length = args.length,
                    exported = Y.Env._exported,
                    __imports__ = {};

                // Get only the imports requested as arguments
                for (i = 0; i < length; i++) {
                    if (exported.hasOwnProperty(args[i])) {
                        __imports__[args[i]] = exported[args[i]];
                    }
                }

                // Using `undefined` because:
                // - Using `Y.config.global` would force the value of `this` to be
                //   the global object even in strict mode
                // - Using `Y` goes against the goal of moving away from a shared
                //   object and start thinking in terms of imported and exported
                //   objects
                callback.call(undefined, Y, __imports__);
            });
        }
        // Do not return the Y object. This makes it hard to follow this
        // traditional pattern:
        //   var Y = YUI().use(...);
        // This is a good idea in the light of ES6 modules, to avoid working
        // in the global scope.
        // This also leaves the door open for returning a promise, once the
        // YUI loader is based on the ES6 loader which uses
        // loader.import(...).then(...)
        this.use.apply(this, args);
    },

    /**
    Handles Loader notifications about attachment/load errors.

    @method _notify
    @param {Function} callback Callback to pass to `Y.config.loadErrorFn`.
    @param {Object} response Response returned from Loader.
    @param {Array} args Arguments passed from Loader.
    @private
    **/
    _notify: function(callback, response, args) {
        if (!response.success && this.config.loadErrorFn) {
            this.config.loadErrorFn.call(this, this, callback, response, args);
        } else if (callback) {
            if (this.Env._missed && this.Env._missed.length) {
                response.msg = 'Missing modules: ' + this.Env._missed.join();
                response.success = false;
            }
            if (this.config.throwFail) {
                callback(this, response);
            } else {
                try {
                    callback(this, response);
                } catch (e) {
                    this.error('use callback error', e, args);
                }
            }
        }
    },

    /**
    Called from the `use` method queue to ensure that only one set of loading
    logic is performed at a time.

    @method _use
    @param {String} args* One or more modules to attach.
    @param {Function} [callback] Function to call once all required modules have
        been attached.
    @private
    **/
    _use: function(args, callback) {

        if (!this.Array) {
            this._attach(['yui-base']);
        }

        var len, loader, handleBoot,
            Y = this,
            G_ENV = YUI.Env,
            mods = G_ENV.mods,
            Env = Y.Env,
            used = Env._used,
            aliases = G_ENV.aliases,
            queue = G_ENV._loaderQueue,
            firstArg = args[0],
            YArray = Y.Array,
            config = Y.config,
            boot = config.bootstrap,
            missing = [],
            i,
            r = [],
            ret = true,
            fetchCSS = config.fetchCSS,
            process = function(names, skip) {

                var i = 0, a = [], name, len, m, req, use;

                if (!names.length) {
                    return;
                }

                if (aliases) {
                    len = names.length;
                    for (i = 0; i < len; i++) {
                        if (aliases[names[i]] && !mods[names[i]]) {
                            a = [].concat(a, aliases[names[i]]);
                        } else {
                            a.push(names[i]);
                        }
                    }
                    names = a;
                }

                len = names.length;

                for (i = 0; i < len; i++) {
                    name = names[i];
                    if (!skip) {
                        r.push(name);
                    }

                    // only attach a module once
                    if (used[name]) {
                        continue;
                    }

                    m = mods[name];
                    req = null;
                    use = null;

                    if (m) {
                        used[name] = true;
                        req = m.details.requires;
                        use = m.details.use;
                    } else {
                        // CSS files don't register themselves, see if it has
                        // been loaded
                        if (!G_ENV._loaded[VERSION][name]) {
                            missing.push(name);
                        } else {
                            used[name] = true; // probably css
                        }
                    }

                    // make sure requirements are attached
                    if (req && req.length) {
                        process(req);
                    }

                    // make sure we grab the submodule dependencies too
                    if (use && use.length) {
                        process(use, 1);
                    }
                }

            },

            handleLoader = function(fromLoader) {
                var response = fromLoader || {
                        success: true,
                        msg: 'not dynamic'
                    },
                    redo, origMissing,
                    ret = true,
                    data = response.data;

                Y._loading = false;

                if (data) {
                    origMissing = missing;
                    missing = [];
                    r = [];
                    process(data);
                    redo = missing.length;
                    if (redo) {
                        if ([].concat(missing).sort().join() ==
                                origMissing.sort().join()) {
                            redo = false;
                        }
                    }
                }

                if (redo && data) {
                    Y._loading = true;
                    Y._use(missing, function() {
                        if (Y._attach(data)) {
                            Y._notify(callback, response, data);
                        }
                    });
                } else {
                    if (data) {
                        ret = Y._attach(data);
                    }
                    if (ret) {
                        Y._notify(callback, response, args);
                    }
                }

                if (Y._useQueue && Y._useQueue.size() && !Y._loading) {
                    Y._use.apply(Y, Y._useQueue.next());
                }

            };


        // YUI().use('*'); // bind everything available
        if (firstArg === '*') {
            args = [];
            for (i in mods) {
                if (mods.hasOwnProperty(i)) {
                    args.push(i);
                }
            }
            ret = Y._attach(args);
            if (ret) {
                handleLoader();
            }
            return Y;
        }

        if ((mods.loader || mods['loader-base']) && !Y.Loader) {
            Y._attach(['loader' + ((!mods.loader) ? '-base' : '')]);
        }


        // use loader to expand dependencies and sort the
        // requirements if it is available.
        if (boot && Y.Loader && args.length) {
            loader = getLoader(Y);
            loader.require(args);
            loader.ignoreRegistered = true;
            loader._boot = true;
            loader.calculate(null, (fetchCSS) ? null : 'js');
            args = loader.sorted;
            loader._boot = false;
        }

        process(args);

        len = missing.length;


        if (len) {
            missing = YArray.dedupe(missing);
            len = missing.length;
        }


        // dynamic load
        if (boot && len && Y.Loader) {
            Y._loading = true;
            loader = getLoader(Y);
            loader.onEnd = handleLoader;
            loader.context = Y;
            loader.data = args;
            loader.ignoreRegistered = false;
            loader.require(missing);
            loader.insert(null, (fetchCSS) ? null : 'js');

        } else if (boot && len && Y.Get && !Env.bootstrapped) {

            Y._loading = true;

            handleBoot = function() {
                Y._loading = false;
                queue.running = false;
                Env.bootstrapped = true;
                G_ENV._bootstrapping = false;
                if (Y._attach(['loader'])) {
                    Y._use(args, callback);
                }
            };

            if (G_ENV._bootstrapping) {
                queue.add(handleBoot);
            } else {
                G_ENV._bootstrapping = true;
                Y.Get.script(config.base + config.loaderPath, {
                    onEnd: handleBoot
                });
            }

        } else {
            ret = Y._attach(args);
            if (ret) {
                handleLoader();
            }
        }

        return Y;
    },


    /**
    Utility method for safely creating namespaces if they don't already exist.
    May be called statically on the YUI global object or as a method on a YUI
    instance.

    When called statically, a namespace will be created on the YUI global
    object:

        // Create `YUI.your.namespace.here` as nested objects, preserving any
        // objects that already exist instead of overwriting them.
        YUI.namespace('your.namespace.here');

    When called as a method on a YUI instance, a namespace will be created on
    that instance:

        // Creates `Y.property.package`.
        Y.namespace('property.package');

    Dots in the input string cause `namespace` to create nested objects for each
    token. If any part of the requested namespace already exists, the current
    object will be left in place and will not be overwritten. This allows
    multiple calls to `namespace` to preserve existing namespaced properties.

    If the first token in the namespace string is "YAHOO", that token is
    discarded. This is legacy behavior for backwards compatibility with YUI 2.

    Be careful with namespace tokens. Reserved words may work in some browsers
    and not others. For instance, the following will fail in some browsers
    because the supported version of JavaScript reserves the word "long":

        Y.namespace('really.long.nested.namespace');

    Note: If you pass multiple arguments to create multiple namespaces, only the
    last one created is returned from this function.

    @method namespace
    @param {String} namespace* One or more namespaces to create.
    @return {Object} Reference to the last namespace object created.
    **/
    namespace: function() {
        var a = arguments, o, i = 0, j, d, arg;

        for (; i < a.length; i++) {
            o = this; //Reset base object per argument or it will get reused from the last
            arg = a[i];
            if (arg.indexOf(PERIOD) > -1) { //Skip this if no "." is present
                d = arg.split(PERIOD);
                for (j = (d[0] == 'YAHOO') ? 1 : 0; j < d.length; j++) {
                    o[d[j]] = o[d[j]] || {};
                    o = o[d[j]];
                }
            } else {
                o[arg] = o[arg] || {};
                o = o[arg]; //Reset base object to the new object so it's returned
            }
        }
        return o;
    },

    // this is replaced if the log module is included
    log: NOOP,
    message: NOOP,
    // this is replaced if the dump module is included
    dump: function (o) { return ''+o; },

    /**
    Reports an error.

    The reporting mechanism is controlled by the `throwFail` configuration
    attribute. If `throwFail` is falsy, the message is logged. If `throwFail` is
    truthy, a JS exception is thrown.

    If an `errorFn` is specified in the config it must return `true` to indicate
    that the exception was handled and keep it from being thrown.

    @method error
    @param {String} msg Error message.
    @param {Error|String} [e] JavaScript error object or an error string.
    @param {String} [src] Source of the error (such as the name of the module in
        which the error occurred).
    @chainable
    **/
    error: function(msg, e, src) {
        //TODO Add check for window.onerror here

        var Y = this, ret;

        if (Y.config.errorFn) {
            ret = Y.config.errorFn.apply(Y, arguments);
        }

        if (!ret) {
            throw (e || new Error(msg));
        } else {
            Y.message(msg, 'error', ''+src); // don't scrub this one
        }

        return Y;
    },

    /**
    Generates an id string that is unique among all YUI instances in this
    execution context.

    @method guid
    @param {String} [pre] Prefix.
    @return {String} Unique id.
    **/
    guid: function(pre) {
        var id = this.Env._guidp + '_' + (++this.Env._uidx);
        return (pre) ? (pre + id) : id;
    },

    /**
    Returns a unique id associated with the given object and (if *readOnly* is
    falsy) stamps the object with that id so it can be identified in the future.

    Stamping an object involves adding a `_yuid` property to it that contains
    the object's id. One exception to this is that in Internet Explorer, DOM
    nodes have a `uniqueID` property that contains a browser-generated unique
    id, which will be used instead of a YUI-generated id when available.

    @method stamp
    @param {Object} o Object to stamp.
    @param {Boolean} readOnly If truthy and the given object has not already
        been stamped, the object will not be modified and `null` will be
        returned.
    @return {String} Object's unique id, or `null` if *readOnly* was truthy and
        the given object was not already stamped.
    **/
    stamp: function(o, readOnly) {
        var uid;
        if (!o) {
            return o;
        }

        // IE generates its own unique ID for dom nodes
        // The uniqueID property of a document node returns a new ID
        if (o.uniqueID && o.nodeType && o.nodeType !== 9) {
            uid = o.uniqueID;
        } else {
            uid = (typeof o === 'string') ? o : o._yuid;
        }

        if (!uid) {
            uid = this.guid();
            if (!readOnly) {
                try {
                    o._yuid = uid;
                } catch (e) {
                    uid = null;
                }
            }
        }
        return uid;
    },

    /**
    Destroys this YUI instance.

    @method destroy
    @since 3.3.0
    **/
    destroy: function() {
        var Y = this;
        if (Y.Event) {
            Y.Event._unload();
        }
        delete instances[Y.id];
        delete Y.Env;
        delete Y.config;
    }

    /**
    Safe `instanceof` wrapper that works around a memory leak in IE when the
    object being tested is `window` or `document`.

    Unless you are testing objects that may be `window` or `document`, you
    should use the native `instanceof` operator instead of this method.

    @method instanceOf
    @param {Object} o Object to check.
    @param {Object} type Class to check against.
    @since 3.3.0
    **/
};

    YUI.prototype = proto;

    // inheritance utilities are not available yet
    for (prop in proto) {
        if (proto.hasOwnProperty(prop)) {
            YUI[prop] = proto[prop];
        }
    }

    /**
    Applies a configuration to all YUI instances in this execution context.

    The main use case for this method is in "mashups" where several third-party
    scripts need to write to a global YUI config, but cannot share a single
    centrally-managed config object. This way they can all call
    `YUI.applyConfig({})` instead of overwriting the single global config.

    @example

        YUI.applyConfig({
            modules: {
                davglass: {
                    fullpath: './davglass.js'
                }
            }
        });

        YUI.applyConfig({
            modules: {
                foo: {
                    fullpath: './foo.js'
                }
            }
        });

        YUI().use('davglass', function (Y) {
            // Module davglass will be available here.
        });

    @method applyConfig
    @param {Object} o Configuration object to apply.
    @static
    @since 3.5.0
    **/
    YUI.applyConfig = function(o) {
        if (!o) {
            return;
        }
        //If there is a GlobalConfig, apply it first to set the defaults
        if (YUI.GlobalConfig) {
            this.prototype.applyConfig.call(this, YUI.GlobalConfig);
        }
        //Apply this config to it
        this.prototype.applyConfig.call(this, o);
        //Reset GlobalConfig to the combined config
        YUI.GlobalConfig = this.config;
    };

    // set up the environment
    YUI._init();

    if (hasWin) {
        add(doc, 'DOMContentLoaded', handleReady);

        // add a window load event at load time so we can capture
        // the case where it fires before dynamic loading is
        // complete.
        add(window, 'load', handleLoad);
    } else {
        handleReady();
        handleLoad();
    }

    YUI.Env.add = add;
    YUI.Env.remove = remove;

    /*global exports*/
    // Support the CommonJS method for exporting our single global
    if (typeof exports == 'object') {
        exports.YUI = module.exports = YUI;
        /**
        * Set a method to be called when `Get.script` is called in Node.js
        * `Get` will open the file, then pass it's content and it's path
        * to this method before attaching it. Commonly used for code coverage
        * instrumentation. <strong>Calling this multiple times will only
        * attach the last hook method</strong>. This method is only
        * available in Node.js.
        * @method setLoadHook
        * @static
        * @param {Function} fn The function to set
        * @param {String} fn.data The content of the file
        * @param {String} fn.path The file path of the file
        */
        YUI.setLoadHook = function(fn) {
            YUI._getLoadHook = fn;
        };
        /**
        * Load hook for `Y.Get.script` in Node.js, see `YUI.setLoadHook`
        * @method _getLoadHook
        * @private
        * @param {String} data The content of the file
        * @param {String} path The file path of the file
        */
        YUI._getLoadHook = null;
    }

    YUI.Env[VERSION] = {};
}());


/**
Config object that contains all of the configuration options for
this `YUI` instance.

This object is supplied by the implementer when instantiating YUI. Some
properties have default values if they are not supplied by the implementer.

This object should not be updated directly because some values are cached. Use
`applyConfig()` to update the config object on a YUI instance that has already
been configured.

@class config
@static
**/

/**
If `true` (the default), YUI will "bootstrap" the YUI Loader and module metadata
if they're needed to load additional dependencies and aren't already available.

Setting this to `false` will prevent YUI from automatically loading the Loader
and module metadata, so you will need to manually ensure that they're available
or handle dependency resolution yourself.

@property {Boolean} bootstrap
@default true
**/

/**

@property {Object} filters
**/

/**
If `true`, YUI will use a combo handler to load multiple modules in as few
requests as possible.

The YUI CDN (which YUI uses by default) supports combo handling, but other
servers may not. If the server from which you're loading YUI does not support
combo handling, set this to `false`.

Providing a value for the `base` config property will cause `combine` to default
to `false` instead of `true`.

@property {Boolean} combine
@default true
*/

/**
Array of module names that should never be dynamically loaded.

@property {String[]} ignore
**/

/**
Array of module names that should always be loaded when required, even if
already present on the page.

@property {String[]} force
**/

/**
DOM element or id that should be used as the insertion point for dynamically
added `<script>` and `<link>` nodes.

@property {HTMLElement|String} insertBefore
**/

/**
Object hash containing attributes to add to dynamically added `<script>` nodes.

@property {Object} jsAttributes
**/

/**
Object hash containing attributes to add to dynamically added `<link>` nodes.

@property {Object} cssAttributes
**/

/**
Timeout in milliseconds before a dynamic JS or CSS request will be considered a
failure. If not set, no timeout will be enforced.

@property {Number} timeout
**/

/**
A hash of module definitions to add to the list of available YUI modules. These
modules can then be dynamically loaded via the `use()` method.

This is a hash in which keys are module names and values are objects containing
module metadata.

See `Loader.addModule()` for the supported module metadata fields. Also see
`groups`, which provides a way to configure the base and combo spec for a set of
modules.

@example

    modules: {
        mymod1: {
            requires: ['node'],
            fullpath: '/mymod1/mymod1.js'
        },

        mymod2: {
            requires: ['mymod1'],
            fullpath: '/mymod2/mymod2.js'
        },

        mymod3: '/js/mymod3.js',
        mycssmod: '/css/mycssmod.css'
    }

@property {Object} modules
**/

/**
Aliases are dynamic groups of modules that can be used as shortcuts.

@example

    YUI({
        aliases: {
            davglass: [ 'node', 'yql', 'dd' ],
            mine: [ 'davglass', 'autocomplete']
        }
    }).use('mine', function (Y) {
        // Node, YQL, DD & AutoComplete available here.
    });

@property {Object} aliases
**/

/**
A hash of module group definitions.

For each group you can specify a list of modules and the base path and
combo spec to use when dynamically loading the modules.

@example

    groups: {
        yui2: {
            // specify whether or not this group has a combo service
            combine: true,

            // The comboSeperator to use with this group's combo handler
            comboSep: ';',

            // The maxURLLength for this server
            maxURLLength: 500,

            // the base path for non-combo paths
            base: 'http://yui.yahooapis.com/2.8.0r4/build/',

            // the path to the combo service
            comboBase: 'http://yui.yahooapis.com/combo?',

            // a fragment to prepend to the path attribute when
            // when building combo urls
            root: '2.8.0r4/build/',

            // the module definitions
            modules:  {
                yui2_yde: {
                    path: "yahoo-dom-event/yahoo-dom-event.js"
                },
                yui2_anim: {
                    path: "animation/animation.js",
                    requires: ['yui2_yde']
                }
            }
        }
    }

@property {Object} groups
**/

/**
Path to the Loader JS file, relative to the `base` path.

This is used to dynamically bootstrap the Loader when it's needed and isn't yet
available.

@property {String} loaderPath
@default "loader/loader-min.js"
**/

/**
If `true`, YUI will attempt to load CSS dependencies and skins. Set this to
`false` to prevent YUI from loading any CSS, or set it to the string `"force"`
to force CSS dependencies to be loaded even if their associated JS modules are
already loaded.

@property {Boolean|String} fetchCSS
@default true
**/

/**
Default gallery version used to build gallery module urls.

@property {String} gallery
@since 3.1.0
**/

/**
Default YUI 2 version used to build YUI 2 module urls.

This is used for intrinsic YUI 2 support via the 2in3 project. Also see the
`2in3` config for pulling different revisions of the wrapped YUI 2 modules.

@property {String} yui2
@default "2.9.0"
@since 3.1.0
**/

/**
Revision number of YUI 2in3 modules that should be used when loading YUI 2in3.

@property {String} 2in3
@default "4"
@since 3.1.0
**/

/**
Alternate console log function that should be used in environments without a
supported native console. This function is executed with the YUI instance as its
`this` object.

@property {Function} logFn
@since 3.1.0
**/

/**
The minimum log level to log messages for. Log levels are defined
incrementally. Messages greater than or equal to the level specified will
be shown. All others will be discarded. The order of log levels in
increasing priority is:

    debug
    info
    warn
    error

@property {String} logLevel
@default 'debug'
@since 3.10.0
**/

/**
Callback to execute when `Y.error()` is called. It receives the error message
and a JavaScript error object if one was provided.

This function is executed with the YUI instance as its `this` object.

Returning `true` from this function will prevent an exception from being thrown.

@property {Function} errorFn
@param {String} errorFn.msg Error message
@param {Object} [errorFn.err] Error object (if one was provided).
@since 3.2.0
**/

/**
A callback to execute when Loader fails to load one or more resources.

This could be because of a script load failure. It could also be because a
module fails to register itself when the `requireRegistration` config is `true`.

If this function is defined, the `use()` callback will only be called when the
loader succeeds. Otherwise, `use()` will always executes unless there was a
JavaScript error when attaching a module.

@property {Function} loadErrorFn
@since 3.3.0
**/

/**
If `true`, Loader will expect all loaded scripts to be first-class YUI modules
that register themselves with the YUI global, and will trigger a failure if a
loaded script does not register a YUI module.

@property {Boolean} requireRegistration
@default false
@since 3.3.0
**/

/**
Cache serviced use() requests.

@property {Boolean} cacheUse
@default true
@since 3.3.0
@deprecated No longer used.
**/

/**
Whether or not YUI should use native ES5 functionality when available for
features like `Y.Array.each()`, `Y.Object()`, etc.

When `false`, YUI will always use its own fallback implementations instead of
relying on ES5 functionality, even when ES5 functionality is available.

@property {Boolean} useNativeES5
@default true
@since 3.5.0
**/

/**
 * Leverage native JSON stringify if the browser has a native
 * implementation.  In general, this is a good idea.  See the Known Issues
 * section in the JSON user guide for caveats.  The default value is true
 * for browsers with native JSON support.
 *
 * @property useNativeJSONStringify
 * @type Boolean
 * @default true
 * @since 3.8.0
 */

 /**
 * Leverage native JSON parse if the browser has a native implementation.
 * In general, this is a good idea.  See the Known Issues section in the
 * JSON user guide for caveats.  The default value is true for browsers with
 * native JSON support.
 *
 * @property useNativeJSONParse
 * @type Boolean
 * @default true
 * @since 3.8.0
 */

/**
Delay the `use` callback until a specific event has passed (`load`, `domready`, `contentready` or `available`)

@property {Object|String} delayUntil
@since 3.6.0
@example

You can use `load` or `domready` strings by default:

    YUI({
        delayUntil: 'domready'
    }, function (Y) {
        // This will not execute until 'domeready' occurs.
    });

Or you can delay until a node is available (with `available` or `contentready`):

    YUI({
        delayUntil: {
            event: 'available',
            args : '#foo'
        }
    }, function (Y) {
        // This will not execute until a node matching the selector "#foo" is
        // available in the DOM.
    });

**/
YUI.add('yui-base', function (Y, NAME) {

/*
 * YUI stub
 * @module yui
 * @submodule yui-base
 */
/**
 * The YUI module contains the components required for building the YUI
 * seed file.  This includes the script loading mechanism, a simple queue,
 * and the core utilities for the library.
 * @module yui
 * @submodule yui-base
 */

/**
 * Provides core language utilites and extensions used throughout YUI.
 *
 * @class Lang
 * @static
 */

var L = Y.Lang || (Y.Lang = {}),

STRING_PROTO = String.prototype,
TOSTRING     = Object.prototype.toString,

TYPES = {
    'undefined'        : 'undefined',
    'number'           : 'number',
    'boolean'          : 'boolean',
    'string'           : 'string',
    '[object Function]': 'function',
    '[object RegExp]'  : 'regexp',
    '[object Array]'   : 'array',
    '[object Date]'    : 'date',
    '[object Error]'   : 'error'
},

SUBREGEX         = /\{\s*([^|}]+?)\s*(?:\|([^}]*))?\s*\}/g,

WHITESPACE       = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF",
WHITESPACE_CLASS = "[\x09-\x0D\x20\xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+",
TRIM_LEFT_REGEX  = new RegExp("^" + WHITESPACE_CLASS),
TRIM_RIGHT_REGEX = new RegExp(WHITESPACE_CLASS + "$"),
TRIMREGEX        = new RegExp(TRIM_LEFT_REGEX.source + "|" + TRIM_RIGHT_REGEX.source, "g"),

NATIVE_FN_REGEX  = /\{\s*\[(?:native code|function)\]\s*\}/i;

// -- Protected Methods --------------------------------------------------------

/**
Returns `true` if the given function appears to be implemented in native code,
`false` otherwise. Will always return `false` -- even in ES5-capable browsers --
if the `useNativeES5` YUI config option is set to `false`.

This isn't guaranteed to be 100% accurate and won't work for anything other than
functions, but it can be useful for determining whether a function like
`Array.prototype.forEach` is native or a JS shim provided by another library.

There's a great article by @kangax discussing certain flaws with this technique:
<http://perfectionkills.com/detecting-built-in-host-methods/>

While his points are valid, it's still possible to benefit from this function
as long as it's used carefully and sparingly, and in such a way that false
negatives have minimal consequences. It's used internally to avoid using
potentially broken non-native ES5 shims that have been added to the page by
other libraries.

@method _isNative
@param {Function} fn Function to test.
@return {Boolean} `true` if _fn_ appears to be native, `false` otherwise.
@static
@protected
@since 3.5.0
**/
L._isNative = function (fn) {
    return !!(Y.config.useNativeES5 && fn && NATIVE_FN_REGEX.test(fn));
};

// -- Public Methods -----------------------------------------------------------

/**
 * Determines whether or not the provided item is an array.
 *
 * Returns `false` for array-like collections such as the function `arguments`
 * collection or `HTMLElement` collections. Use `Y.Array.test()` if you want to
 * test for an array-like collection.
 *
 * @method isArray
 * @param o The object to test.
 * @return {boolean} true if o is an array.
 * @static
 */
L.isArray = L._isNative(Array.isArray) ? Array.isArray : function (o) {
    return L.type(o) === 'array';
};

/**
 * Determines whether or not the provided item is a boolean.
 * @method isBoolean
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is a boolean.
 */
L.isBoolean = function(o) {
    return typeof o === 'boolean';
};

/**
 * Determines whether or not the supplied item is a date instance.
 * @method isDate
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is a date.
 */
L.isDate = function(o) {
    return L.type(o) === 'date' && o.toString() !== 'Invalid Date' && !isNaN(o);
};

/**
 * <p>
 * Determines whether or not the provided item is a function.
 * Note: Internet Explorer thinks certain functions are objects:
 * </p>
 *
 * <pre>
 * var obj = document.createElement("object");
 * Y.Lang.isFunction(obj.getAttribute) // reports false in IE
 * &nbsp;
 * var input = document.createElement("input"); // append to body
 * Y.Lang.isFunction(input.focus) // reports false in IE
 * </pre>
 *
 * <p>
 * You will have to implement additional tests if these functions
 * matter to you.
 * </p>
 *
 * @method isFunction
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is a function.
 */
L.isFunction = function(o) {
    return L.type(o) === 'function';
};

/**
 * Determines whether or not the provided item is null.
 * @method isNull
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is null.
 */
L.isNull = function(o) {
    return o === null;
};

/**
 * Determines whether or not the provided item is a legal number.
 * @method isNumber
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is a number.
 */
L.isNumber = function(o) {
    return typeof o === 'number' && isFinite(o);
};

/**
 * Determines whether or not the provided item is of type object
 * or function. Note that arrays are also objects, so
 * <code>Y.Lang.isObject([]) === true</code>.
 * @method isObject
 * @static
 * @param o The object to test.
 * @param failfn {boolean} fail if the input is a function.
 * @return {boolean} true if o is an object.
 * @see isPlainObject
 */
L.isObject = function(o, failfn) {
    var t = typeof o;
    return (o && (t === 'object' ||
        (!failfn && (t === 'function' || L.isFunction(o))))) || false;
};

/**
 * Determines whether or not the provided value is a regexp.
 * @method isRegExp
 * @static
 * @param value The value or object to test.
 * @return {boolean} true if value is a regexp.
 */
L.isRegExp = function(value) {
    return L.type(value) === 'regexp';
};

/**
 * Determines whether or not the provided item is a string.
 * @method isString
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is a string.
 */
L.isString = function(o) {
    return typeof o === 'string';
};

/**
 * Determines whether or not the provided item is undefined.
 * @method isUndefined
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is undefined.
 */
L.isUndefined = function(o) {
    return typeof o === 'undefined';
};

/**
 * A convenience method for detecting a legitimate non-null value.
 * Returns false for null/undefined/NaN, true for other values,
 * including 0/false/''
 * @method isValue
 * @static
 * @param o The item to test.
 * @return {boolean} true if it is not null/undefined/NaN || false.
 */
L.isValue = function(o) {
    var t = L.type(o);

    switch (t) {
        case 'number':
            return isFinite(o);

        case 'null': // fallthru
        case 'undefined':
            return false;

        default:
            return !!t;
    }
};

/**
 * Returns the current time in milliseconds.
 *
 * @method now
 * @return {Number} Current time in milliseconds.
 * @static
 * @since 3.3.0
 */
L.now = Date.now || function () {
    return new Date().getTime();
};

/**
 * Performs `{placeholder}` substitution on a string. The object passed as the
 * second parameter provides values to replace the `{placeholder}`s.
 * `{placeholder}` token names must match property names of the object. For example,
 *
 *`var greeting = Y.Lang.sub("Hello, {who}!", { who: "World" });`
 *
 * `{placeholder}` tokens that are undefined on the object map will be left
 * in tact (leaving unsightly `{placeholder}`'s in the output string).
 *
 * @method sub
 * @param {string} s String to be modified.
 * @param {object} o Object containing replacement values.
 * @return {string} the substitute result.
 * @static
 * @since 3.2.0
 */
L.sub = function(s, o) {
    return s.replace ? s.replace(SUBREGEX, function (match, key) {
        return L.isUndefined(o[key]) ? match : o[key];
    }) : s;
};

/**
 * Returns a string without any leading or trailing whitespace.  If
 * the input is not a string, the input will be returned untouched.
 * @method trim
 * @static
 * @param s {string} the string to trim.
 * @return {string} the trimmed string.
 */
L.trim = L._isNative(STRING_PROTO.trim) && !WHITESPACE.trim() ? function(s) {
    return s && s.trim ? s.trim() : s;
} : function (s) {
    try {
        return s.replace(TRIMREGEX, '');
    } catch (e) {
        return s;
    }
};

/**
 * Returns a string without any leading whitespace.
 * @method trimLeft
 * @static
 * @param s {string} the string to trim.
 * @return {string} the trimmed string.
 */
L.trimLeft = L._isNative(STRING_PROTO.trimLeft) && !WHITESPACE.trimLeft() ? function (s) {
    return s.trimLeft();
} : function (s) {
    return s.replace(TRIM_LEFT_REGEX, '');
};

/**
 * Returns a string without any trailing whitespace.
 * @method trimRight
 * @static
 * @param s {string} the string to trim.
 * @return {string} the trimmed string.
 */
L.trimRight = L._isNative(STRING_PROTO.trimRight) && !WHITESPACE.trimRight() ? function (s) {
    return s.trimRight();
} : function (s) {
    return s.replace(TRIM_RIGHT_REGEX, '');
};

/**
Returns one of the following strings, representing the type of the item passed
in:

 * "array"
 * "boolean"
 * "date"
 * "error"
 * "function"
 * "null"
 * "number"
 * "object"
 * "regexp"
 * "string"
 * "undefined"

Known issues:

 * `typeof HTMLElementCollection` returns function in Safari, but
    `Y.Lang.type()` reports "object", which could be a good thing --
    but it actually caused the logic in <code>Y.Lang.isObject</code> to fail.

@method type
@param o the item to test.
@return {string} the detected type.
@static
**/
L.type = function(o) {
    return TYPES[typeof o] || TYPES[TOSTRING.call(o)] || (o ? 'object' : 'null');
};
/**
@module yui
@submodule yui-base
*/

var Lang   = Y.Lang,
    Native = Array.prototype,

    hasOwn = Object.prototype.hasOwnProperty;

/**
Provides utility methods for working with arrays. Additional array helpers can
be found in the `collection` and `array-extras` modules.

`Y.Array(thing)` returns a native array created from _thing_. Depending on
_thing_'s type, one of the following will happen:

  * Arrays are returned unmodified unless a non-zero _startIndex_ is
    specified.
  * Array-like collections (see `Array.test()`) are converted to arrays.
  * For everything else, a new array is created with _thing_ as the sole
    item.

Note: elements that are also collections, such as `<form>` and `<select>`
elements, are not automatically converted to arrays. To force a conversion,
pass `true` as the value of the _force_ parameter.

@class Array
@constructor
@param {Any} thing The thing to arrayify.
@param {Number} [startIndex=0] If non-zero and _thing_ is an array or array-like
  collection, a subset of items starting at the specified index will be
  returned.
@param {Boolean} [force=false] If `true`, _thing_ will be treated as an
  array-like collection no matter what.
@return {Array} A native array created from _thing_, according to the rules
  described above.
**/
function YArray(thing, startIndex, force) {
    var len, result;

    /*jshint expr: true*/
    startIndex || (startIndex = 0);

    if (force || YArray.test(thing)) {
        // IE throws when trying to slice HTMLElement collections.
        try {
            return Native.slice.call(thing, startIndex);
        } catch (ex) {
            result = [];

            for (len = thing.length; startIndex < len; ++startIndex) {
                result.push(thing[startIndex]);
            }

            return result;
        }
    }

    return [thing];
}

Y.Array = YArray;

/**
Dedupes an array of strings, returning an array that's guaranteed to contain
only one copy of a given string.

This method differs from `Array.unique()` in that it's optimized for use only
with arrays consisting entirely of strings or entirely of numbers, whereas
`unique` may be used with other value types (but is slower).

Using `dedupe()` with values other than strings or numbers, or with arrays
containing a mix of strings and numbers, may result in unexpected behavior.

@method dedupe
@param {String[]|Number[]} array Array of strings or numbers to dedupe.
@return {Array} Copy of _array_ containing no duplicate values.
@static
@since 3.4.0
**/
YArray.dedupe = Lang._isNative(Object.create) ? function (array) {
    var hash    = Object.create(null),
        results = [],
        i, item, len;

    for (i = 0, len = array.length; i < len; ++i) {
        item = array[i];

        if (!hash[item]) {
            hash[item] = 1;
            results.push(item);
        }
    }

    return results;
} : function (array) {
    var hash    = {},
        results = [],
        i, item, len;

    for (i = 0, len = array.length; i < len; ++i) {
        item = array[i];

        if (!hasOwn.call(hash, item)) {
            hash[item] = 1;
            results.push(item);
        }
    }

    return results;
};

/**
Executes the supplied function on each item in the array. This method wraps
the native ES5 `Array.forEach()` method if available.

@method each
@param {Array} array Array to iterate.
@param {Function} fn Function to execute on each item in the array. The function
  will receive the following arguments:
    @param {Any} fn.item Current array item.
    @param {Number} fn.index Current array index.
    @param {Array} fn.array Array being iterated.
@param {Object} [thisObj] `this` object to use when calling _fn_.
@return {YUI} The YUI instance.
@static
**/
YArray.each = YArray.forEach = Lang._isNative(Native.forEach) ? function (array, fn, thisObj) {
    Native.forEach.call(array || [], fn, thisObj || Y);
    return Y;
} : function (array, fn, thisObj) {
    for (var i = 0, len = (array && array.length) || 0; i < len; ++i) {
        if (i in array) {
            fn.call(thisObj || Y, array[i], i, array);
        }
    }

    return Y;
};

/**
Alias for `each()`.

@method forEach
@static
**/

/**
Returns an object using the first array as keys and the second as values. If
the second array is not provided, or if it doesn't contain the same number of
values as the first array, then `true` will be used in place of the missing
values.

@example

    Y.Array.hash(['a', 'b', 'c'], ['foo', 'bar']);
    // => {a: 'foo', b: 'bar', c: true}

@method hash
@param {String[]} keys Array of strings to use as keys.
@param {Array} [values] Array to use as values.
@return {Object} Hash using the first array as keys and the second as values.
@static
**/
YArray.hash = function (keys, values) {
    var hash = {},
        vlen = (values && values.length) || 0,
        i, len;

    for (i = 0, len = keys.length; i < len; ++i) {
        if (i in keys) {
            hash[keys[i]] = vlen > i && i in values ? values[i] : true;
        }
    }

    return hash;
};

/**
Returns the index of the first item in the array that's equal (using a strict
equality check) to the specified _value_, or `-1` if the value isn't found.

This method wraps the native ES5 `Array.indexOf()` method if available.

@method indexOf
@param {Array} array Array to search.
@param {Any} value Value to search for.
@param {Number} [from=0] The index at which to begin the search.
@return {Number} Index of the item strictly equal to _value_, or `-1` if not
    found.
@static
**/
YArray.indexOf = Lang._isNative(Native.indexOf) ? function (array, value, from) {
    return Native.indexOf.call(array, value, from);
} : function (array, value, from) {
    // http://es5.github.com/#x15.4.4.14
    var len = array.length;

    from = +from || 0;
    from = (from > 0 || -1) * Math.floor(Math.abs(from));

    if (from < 0) {
        from += len;

        if (from < 0) {
            from = 0;
        }
    }

    for (; from < len; ++from) {
        if (from in array && array[from] === value) {
            return from;
        }
    }

    return -1;
};

/**
Numeric sort convenience function.

The native `Array.prototype.sort()` function converts values to strings and
sorts them in lexicographic order, which is unsuitable for sorting numeric
values. Provide `Array.numericSort` as a custom sort function when you want
to sort values in numeric order.

@example

    [42, 23, 8, 16, 4, 15].sort(Y.Array.numericSort);
    // => [4, 8, 15, 16, 23, 42]

@method numericSort
@param {Number} a First value to compare.
@param {Number} b Second value to compare.
@return {Number} Difference between _a_ and _b_.
@static
**/
YArray.numericSort = function (a, b) {
    return a - b;
};

/**
Executes the supplied function on each item in the array. Returning a truthy
value from the function will stop the processing of remaining items.

@method some
@param {Array} array Array to iterate over.
@param {Function} fn Function to execute on each item. The function will receive
  the following arguments:
    @param {Any} fn.value Current array item.
    @param {Number} fn.index Current array index.
    @param {Array} fn.array Array being iterated over.
@param {Object} [thisObj] `this` object to use when calling _fn_.
@return {Boolean} `true` if the function returns a truthy value on any of the
  items in the array; `false` otherwise.
@static
**/
YArray.some = Lang._isNative(Native.some) ? function (array, fn, thisObj) {
    return Native.some.call(array, fn, thisObj);
} : function (array, fn, thisObj) {
    for (var i = 0, len = array.length; i < len; ++i) {
        if (i in array && fn.call(thisObj, array[i], i, array)) {
            return true;
        }
    }

    return false;
};

/**
Evaluates _obj_ to determine if it's an array, an array-like collection, or
something else. This is useful when working with the function `arguments`
collection and `HTMLElement` collections.

Note: This implementation doesn't consider elements that are also
collections, such as `<form>` and `<select>`, to be array-like.

@method test
@param {Object} obj Object to test.
@return {Number} A number indicating the results of the test:

  * 0: Neither an array nor an array-like collection.
  * 1: Real array.
  * 2: Array-like collection.

@static
**/
YArray.test = function (obj) {
    var result = 0;

    if (Lang.isArray(obj)) {
        result = 1;
    } else if (Lang.isObject(obj)) {
        try {
            // indexed, but no tagName (element) or scrollTo/document (window. From DOM.isWindow test which we can't use here),
            // or functions without apply/call (Safari
            // HTMLElementCollection bug).
            if ('length' in obj && !obj.tagName && !(obj.scrollTo && obj.document) && !obj.apply) {
                result = 2;
            }
        } catch (ex) {}
    }

    return result;
};
/**
 * The YUI module contains the components required for building the YUI
 * seed file.  This includes the script loading mechanism, a simple queue,
 * and the core utilities for the library.
 * @module yui
 * @submodule yui-base
 */

/**
 * A simple FIFO queue.  Items are added to the Queue with add(1..n items) and
 * removed using next().
 *
 * @class Queue
 * @constructor
 * @param {MIXED} item* 0..n items to seed the queue.
 */
function Queue() {
    this._init();
    this.add.apply(this, arguments);
}

Queue.prototype = {
    /**
     * Initialize the queue
     *
     * @method _init
     * @protected
     */
    _init: function() {
        /**
         * The collection of enqueued items
         *
         * @property _q
         * @type Array
         * @protected
         */
        this._q = [];
    },

    /**
     * Get the next item in the queue. FIFO support
     *
     * @method next
     * @return {MIXED} the next item in the queue.
     */
    next: function() {
        return this._q.shift();
    },

    /**
     * Get the last in the queue. LIFO support.
     *
     * @method last
     * @return {MIXED} the last item in the queue.
     */
    last: function() {
        return this._q.pop();
    },

    /**
     * Add 0..n items to the end of the queue.
     *
     * @method add
     * @param {MIXED} item* 0..n items.
     * @return {object} this queue.
     */
    add: function() {
        this._q.push.apply(this._q, arguments);

        return this;
    },

    /**
     * Returns the current number of queued items.
     *
     * @method size
     * @return {Number} The size.
     */
    size: function() {
        return this._q.length;
    }
};

Y.Queue = Queue;

YUI.Env._loaderQueue = YUI.Env._loaderQueue || new Queue();

/**
The YUI module contains the components required for building the YUI seed file.
This includes the script loading mechanism, a simple queue, and the core
utilities for the library.

@module yui
@submodule yui-base
**/

var CACHED_DELIMITER = '__',

    hasOwn   = Object.prototype.hasOwnProperty,
    isObject = Y.Lang.isObject;

/**
Returns a wrapper for a function which caches the return value of that function,
keyed off of the combined string representation of the argument values provided
when the wrapper is called.

Calling this function again with the same arguments will return the cached value
rather than executing the wrapped function.

Note that since the cache is keyed off of the string representation of arguments
passed to the wrapper function, arguments that aren't strings and don't provide
a meaningful `toString()` method may result in unexpected caching behavior. For
example, the objects `{}` and `{foo: 'bar'}` would both be converted to the
string `[object Object]` when used as a cache key.

@method cached
@param {Function} source The function to memoize.
@param {Object} [cache={}] Object in which to store cached values. You may seed
  this object with pre-existing cached values if desired.
@param {any} [refetch] If supplied, this value is compared with the cached value
  using a `==` comparison. If the values are equal, the wrapped function is
  executed again even though a cached value exists.
@return {Function} Wrapped function.
@for YUI
**/
Y.cached = function (source, cache, refetch) {
    /*jshint expr: true*/
    cache || (cache = {});

    return function (arg) {
        var key = arguments.length > 1 ?
                Array.prototype.join.call(arguments, CACHED_DELIMITER) :
                String(arg);

        /*jshint eqeqeq: false*/
        if (!(key in cache) || (refetch && cache[key] == refetch)) {
            cache[key] = source.apply(source, arguments);
        }

        return cache[key];
    };
};

/**
Returns the `location` object from the window/frame in which this YUI instance
operates, or `undefined` when executing in a non-browser environment
(e.g. Node.js).

It is _not_ recommended to hold references to the `window.location` object
outside of the scope of a function in which its properties are being accessed or
its methods are being called. This is because of a nasty bug/issue that exists
in both Safari and MobileSafari browsers:
[WebKit Bug 34679](https://bugs.webkit.org/show_bug.cgi?id=34679).

@method getLocation
@return {location} The `location` object from the window/frame in which this YUI
    instance operates.
@since 3.5.0
**/
Y.getLocation = function () {
    // It is safer to look this up every time because yui-base is attached to a
    // YUI instance before a user's config is applied; i.e. `Y.config.win` does
    // not point the correct window object when this file is loaded.
    var win = Y.config.win;

    // It is not safe to hold a reference to the `location` object outside the
    // scope in which it is being used. The WebKit engine used in Safari and
    // MobileSafari will "disconnect" the `location` object from the `window`
    // when a page is restored from back/forward history cache.
    return win && win.location;
};

/**
Returns a new object containing all of the properties of all the supplied
objects. The properties from later objects will overwrite those in earlier
objects.

Passing in a single object will create a shallow copy of it. For a deep copy,
use `clone()`.

@method merge
@param {Object} objects* One or more objects to merge.
@return {Object} A new merged object.
**/
Y.merge = function () {
    var i      = 0,
        len    = arguments.length,
        result = {},
        key,
        obj;

    for (; i < len; ++i) {
        obj = arguments[i];

        for (key in obj) {
            if (hasOwn.call(obj, key)) {
                result[key] = obj[key];
            }
        }
    }

    return result;
};

/**
Mixes _supplier_'s properties into _receiver_.

Properties on _receiver_ or _receiver_'s prototype will not be overwritten or
shadowed unless the _overwrite_ parameter is `true`, and will not be merged
unless the _merge_ parameter is `true`.

In the default mode (0), only properties the supplier owns are copied (prototype
properties are not copied). The following copying modes are available:

  * `0`: _Default_. Object to object.
  * `1`: Prototype to prototype.
  * `2`: Prototype to prototype and object to object.
  * `3`: Prototype to object.
  * `4`: Object to prototype.

@method mix
@param {Function|Object} receiver The object or function to receive the mixed
  properties.
@param {Function|Object} supplier The object or function supplying the
  properties to be mixed.
@param {Boolean} [overwrite=false] If `true`, properties that already exist
  on the receiver will be overwritten with properties from the supplier.
@param {String[]} [whitelist] An array of property names to copy. If
  specified, only the whitelisted properties will be copied, and all others
  will be ignored.
@param {Number} [mode=0] Mix mode to use. See above for available modes.
@param {Boolean} [merge=false] If `true`, objects and arrays that already
  exist on the receiver will have the corresponding object/array from the
  supplier merged into them, rather than being skipped or overwritten. When
  both _overwrite_ and _merge_ are `true`, _merge_ takes precedence.
@return {Function|Object|YUI} The receiver, or the YUI instance if the
  specified receiver is falsy.
**/
Y.mix = function(receiver, supplier, overwrite, whitelist, mode, merge) {
    var alwaysOverwrite, exists, from, i, key, len, to;

    // If no supplier is given, we return the receiver. If no receiver is given,
    // we return Y. Returning Y doesn't make much sense to me, but it's
    // grandfathered in for backcompat reasons.
    if (!receiver || !supplier) {
        return receiver || Y;
    }

    if (mode) {
        // In mode 2 (prototype to prototype and object to object), we recurse
        // once to do the proto to proto mix. The object to object mix will be
        // handled later on.
        if (mode === 2) {
            Y.mix(receiver.prototype, supplier.prototype, overwrite,
                    whitelist, 0, merge);
        }

        // Depending on which mode is specified, we may be copying from or to
        // the prototypes of the supplier and receiver.
        from = mode === 1 || mode === 3 ? supplier.prototype : supplier;
        to   = mode === 1 || mode === 4 ? receiver.prototype : receiver;

        // If either the supplier or receiver doesn't actually have a
        // prototype property, then we could end up with an undefined `from`
        // or `to`. If that happens, we abort and return the receiver.
        if (!from || !to) {
            return receiver;
        }
    } else {
        from = supplier;
        to   = receiver;
    }

    // If `overwrite` is truthy and `merge` is falsy, then we can skip a
    // property existence check on each iteration and save some time.
    alwaysOverwrite = overwrite && !merge;

    if (whitelist) {
        for (i = 0, len = whitelist.length; i < len; ++i) {
            key = whitelist[i];

            // We call `Object.prototype.hasOwnProperty` instead of calling
            // `hasOwnProperty` on the object itself, since the object's
            // `hasOwnProperty` method may have been overridden or removed.
            // Also, some native objects don't implement a `hasOwnProperty`
            // method.
            if (!hasOwn.call(from, key)) {
                continue;
            }

            // The `key in to` check here is (sadly) intentional for backwards
            // compatibility reasons. It prevents undesired shadowing of
            // prototype members on `to`.
            exists = alwaysOverwrite ? false : key in to;

            if (merge && exists && isObject(to[key], true)
                    && isObject(from[key], true)) {
                // If we're in merge mode, and the key is present on both
                // objects, and the value on both objects is either an object or
                // an array (but not a function), then we recurse to merge the
                // `from` value into the `to` value instead of overwriting it.
                //
                // Note: It's intentional that the whitelist isn't passed to the
                // recursive call here. This is legacy behavior that lots of
                // code still depends on.
                Y.mix(to[key], from[key], overwrite, null, 0, merge);
            } else if (overwrite || !exists) {
                // We're not in merge mode, so we'll only copy the `from` value
                // to the `to` value if we're in overwrite mode or if the
                // current key doesn't exist on the `to` object.
                to[key] = from[key];
            }
        }
    } else {
        for (key in from) {
            // The code duplication here is for runtime performance reasons.
            // Combining whitelist and non-whitelist operations into a single
            // loop or breaking the shared logic out into a function both result
            // in worse performance, and Y.mix is critical enough that the byte
            // tradeoff is worth it.
            if (!hasOwn.call(from, key)) {
                continue;
            }

            // The `key in to` check here is (sadly) intentional for backwards
            // compatibility reasons. It prevents undesired shadowing of
            // prototype members on `to`.
            exists = alwaysOverwrite ? false : key in to;

            if (merge && exists && isObject(to[key], true)
                    && isObject(from[key], true)) {
                Y.mix(to[key], from[key], overwrite, null, 0, merge);
            } else if (overwrite || !exists) {
                to[key] = from[key];
            }
        }

        // If this is an IE browser with the JScript enumeration bug, force
        // enumeration of the buggy properties by making a recursive call with
        // the buggy properties as the whitelist.
        if (Y.Object._hasEnumBug) {
            Y.mix(to, from, overwrite, Y.Object._forceEnum, mode, merge);
        }
    }

    return receiver;
};
/**
 * The YUI module contains the components required for building the YUI
 * seed file.  This includes the script loading mechanism, a simple queue,
 * and the core utilities for the library.
 * @module yui
 * @submodule yui-base
 */

/**
 * Adds utilities to the YUI instance for working with objects.
 *
 * @class Object
 */

var Lang   = Y.Lang,
    hasOwn = Object.prototype.hasOwnProperty,

    UNDEFINED, // <-- Note the comma. We're still declaring vars.

/**
 * Returns a new object that uses _obj_ as its prototype. This method wraps the
 * native ES5 `Object.create()` method if available, but doesn't currently
 * pass through `Object.create()`'s second argument (properties) in order to
 * ensure compatibility with older browsers.
 *
 * @method ()
 * @param {Object} obj Prototype object.
 * @return {Object} New object using _obj_ as its prototype.
 * @static
 */
O = Y.Object = Lang._isNative(Object.create) ? function (obj) {
    // We currently wrap the native Object.create instead of simply aliasing it
    // to ensure consistency with our fallback shim, which currently doesn't
    // support Object.create()'s second argument (properties). Once we have a
    // safe fallback for the properties arg, we can stop wrapping
    // Object.create().
    return Object.create(obj);
} : (function () {
    // Reusable constructor function for the Object.create() shim.
    function F() {}

    // The actual shim.
    return function (obj) {
        F.prototype = obj;
        return new F();
    };
}()),

/**
 * Property names that IE doesn't enumerate in for..in loops, even when they
 * should be enumerable. When `_hasEnumBug` is `true`, it's necessary to
 * manually enumerate these properties.
 *
 * @property _forceEnum
 * @type String[]
 * @protected
 * @static
 */
forceEnum = O._forceEnum = [
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toString',
    'toLocaleString',
    'valueOf'
],

/**
 * `true` if this browser has the JScript enumeration bug that prevents
 * enumeration of the properties named in the `_forceEnum` array, `false`
 * otherwise.
 *
 * See:
 *   - <https://developer.mozilla.org/en/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug>
 *   - <http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation>
 *
 * @property _hasEnumBug
 * @type Boolean
 * @protected
 * @static
 */
hasEnumBug = O._hasEnumBug = !{valueOf: 0}.propertyIsEnumerable('valueOf'),

/**
 * `true` if this browser incorrectly considers the `prototype` property of
 * functions to be enumerable. Currently known to affect Opera 11.50 and Android 2.3.x.
 *
 * @property _hasProtoEnumBug
 * @type Boolean
 * @protected
 * @static
 */
hasProtoEnumBug = O._hasProtoEnumBug = (function () {}).propertyIsEnumerable('prototype'),

/**
 * Returns `true` if _key_ exists on _obj_, `false` if _key_ doesn't exist or
 * exists only on _obj_'s prototype. This is essentially a safer version of
 * `obj.hasOwnProperty()`.
 *
 * @method owns
 * @param {Object} obj Object to test.
 * @param {String} key Property name to look for.
 * @return {Boolean} `true` if _key_ exists on _obj_, `false` otherwise.
 * @static
 */
owns = O.owns = function (obj, key) {
    return !!obj && hasOwn.call(obj, key);
}; // <-- End of var declarations.

/**
 * Alias for `owns()`.
 *
 * @method hasKey
 * @param {Object} obj Object to test.
 * @param {String} key Property name to look for.
 * @return {Boolean} `true` if _key_ exists on _obj_, `false` otherwise.
 * @static
 */
O.hasKey = owns;

/**
 * Returns an array containing the object's enumerable keys. Does not include
 * prototype keys or non-enumerable keys.
 *
 * Note that keys are returned in enumeration order (that is, in the same order
 * that they would be enumerated by a `for-in` loop), which may not be the same
 * as the order in which they were defined.
 *
 * This method is an alias for the native ES5 `Object.keys()` method if
 * available and non-buggy. The Opera 11.50 and Android 2.3.x versions of
 * `Object.keys()` have an inconsistency as they consider `prototype` to be
 * enumerable, so a non-native shim is used to rectify the difference.
 *
 * @example
 *
 *     Y.Object.keys({a: 'foo', b: 'bar', c: 'baz'});
 *     // => ['a', 'b', 'c']
 *
 * @method keys
 * @param {Object} obj An object.
 * @return {String[]} Array of keys.
 * @static
 */
O.keys = Lang._isNative(Object.keys) && !hasProtoEnumBug ? Object.keys : function (obj) {
    if (!Lang.isObject(obj)) {
        throw new TypeError('Object.keys called on a non-object');
    }

    var keys = [],
        i, key, len;

    if (hasProtoEnumBug && typeof obj === 'function') {
        for (key in obj) {
            if (owns(obj, key) && key !== 'prototype') {
                keys.push(key);
            }
        }
    } else {
        for (key in obj) {
            if (owns(obj, key)) {
                keys.push(key);
            }
        }
    }

    if (hasEnumBug) {
        for (i = 0, len = forceEnum.length; i < len; ++i) {
            key = forceEnum[i];

            if (owns(obj, key)) {
                keys.push(key);
            }
        }
    }

    return keys;
};

/**
 * Returns an array containing the values of the object's enumerable keys.
 *
 * Note that values are returned in enumeration order (that is, in the same
 * order that they would be enumerated by a `for-in` loop), which may not be the
 * same as the order in which they were defined.
 *
 * @example
 *
 *     Y.Object.values({a: 'foo', b: 'bar', c: 'baz'});
 *     // => ['foo', 'bar', 'baz']
 *
 * @method values
 * @param {Object} obj An object.
 * @return {Array} Array of values.
 * @static
 */
O.values = function (obj) {
    var keys   = O.keys(obj),
        i      = 0,
        len    = keys.length,
        values = [];

    for (; i < len; ++i) {
        values.push(obj[keys[i]]);
    }

    return values;
};

/**
 * Returns the number of enumerable keys owned by an object.
 *
 * @method size
 * @param {Object} obj An object.
 * @return {Number} The object's size.
 * @static
 */
O.size = function (obj) {
    try {
        return O.keys(obj).length;
    } catch (ex) {
        return 0; // Legacy behavior for non-objects.
    }
};

/**
 * Returns `true` if the object owns an enumerable property with the specified
 * value.
 *
 * @method hasValue
 * @param {Object} obj An object.
 * @param {any} value The value to search for.
 * @return {Boolean} `true` if _obj_ contains _value_, `false` otherwise.
 * @static
 */
O.hasValue = function (obj, value) {
    return Y.Array.indexOf(O.values(obj), value) > -1;
};

/**
 * Executes a function on each enumerable property in _obj_. The function
 * receives the value, the key, and the object itself as parameters (in that
 * order).
 *
 * By default, only properties owned by _obj_ are enumerated. To include
 * prototype properties, set the _proto_ parameter to `true`.
 *
 * @method each
 * @param {Object} obj Object to enumerate.
 * @param {Function} fn Function to execute on each enumerable property.
 *   @param {mixed} fn.value Value of the current property.
 *   @param {String} fn.key Key of the current property.
 *   @param {Object} fn.obj Object being enumerated.
 * @param {Object} [thisObj] `this` object to use when calling _fn_.
 * @param {Boolean} [proto=false] Include prototype properties.
 * @return {YUI} the YUI instance.
 * @chainable
 * @static
 */
O.each = function (obj, fn, thisObj, proto) {
    var key;

    for (key in obj) {
        if (proto || owns(obj, key)) {
            fn.call(thisObj || Y, obj[key], key, obj);
        }
    }

    return Y;
};

/**
 * Executes a function on each enumerable property in _obj_, but halts if the
 * function returns a truthy value. The function receives the value, the key,
 * and the object itself as paramters (in that order).
 *
 * By default, only properties owned by _obj_ are enumerated. To include
 * prototype properties, set the _proto_ parameter to `true`.
 *
 * @method some
 * @param {Object} obj Object to enumerate.
 * @param {Function} fn Function to execute on each enumerable property.
 *   @param {mixed} fn.value Value of the current property.
 *   @param {String} fn.key Key of the current property.
 *   @param {Object} fn.obj Object being enumerated.
 * @param {Object} [thisObj] `this` object to use when calling _fn_.
 * @param {Boolean} [proto=false] Include prototype properties.
 * @return {Boolean} `true` if any execution of _fn_ returns a truthy value,
 *   `false` otherwise.
 * @static
 */
O.some = function (obj, fn, thisObj, proto) {
    var key;

    for (key in obj) {
        if (proto || owns(obj, key)) {
            if (fn.call(thisObj || Y, obj[key], key, obj)) {
                return true;
            }
        }
    }

    return false;
};

/**
 * Retrieves the sub value at the provided path,
 * from the value object provided.
 *
 * @method getValue
 * @static
 * @param o The object from which to extract the property value.
 * @param path {Array} A path array, specifying the object traversal path
 * from which to obtain the sub value.
 * @return {Any} The value stored in the path, undefined if not found,
 * undefined if the source is not an object.  Returns the source object
 * if an empty path is provided.
 */
O.getValue = function(o, path) {
    if (!Lang.isObject(o)) {
        return UNDEFINED;
    }

    var i,
        p = Y.Array(path),
        l = p.length;

    for (i = 0; o !== UNDEFINED && i < l; i++) {
        o = o[p[i]];
    }

    return o;
};

/**
 * Sets the sub-attribute value at the provided path on the
 * value object.  Returns the modified value object, or
 * undefined if the path is invalid.
 *
 * @method setValue
 * @static
 * @param o             The object on which to set the sub value.
 * @param path {Array}  A path array, specifying the object traversal path
 *                      at which to set the sub value.
 * @param val {Any}     The new value for the sub-attribute.
 * @return {Object}     The modified object, with the new sub value set, or
 *                      undefined, if the path was invalid.
 */
O.setValue = function(o, path, val) {
    var i,
        p = Y.Array(path),
        leafIdx = p.length - 1,
        ref = o;

    if (leafIdx >= 0) {
        for (i = 0; ref !== UNDEFINED && i < leafIdx; i++) {
            ref = ref[p[i]];
        }

        if (ref !== UNDEFINED) {
            ref[p[i]] = val;
        } else {
            return UNDEFINED;
        }
    }

    return o;
};

/**
 * Returns `true` if the object has no enumerable properties of its own.
 *
 * @method isEmpty
 * @param {Object} obj An object.
 * @return {Boolean} `true` if the object is empty.
 * @static
 * @since 3.2.0
 */
O.isEmpty = function (obj) {
    return !O.keys(Object(obj)).length;
};
/**
 * The YUI module contains the components required for building the YUI seed
 * file.  This includes the script loading mechanism, a simple queue, and the
 * core utilities for the library.
 * @module yui
 * @submodule yui-base
 */

/**
 * YUI user agent detection.
 * Do not fork for a browser if it can be avoided.  Use feature detection when
 * you can.  Use the user agent as a last resort.  For all fields listed
 * as @type float, UA stores a version number for the browser engine,
 * 0 otherwise.  This value may or may not map to the version number of
 * the browser using the engine.  The value is presented as a float so
 * that it can easily be used for boolean evaluation as well as for
 * looking for a particular range of versions.  Because of this,
 * some of the granularity of the version info may be lost.  The fields that
 * are @type string default to null.  The API docs list the values that
 * these fields can have.
 * @class UA
 * @static
 */

/**
* Static method on `YUI.Env` for parsing a UA string.  Called at instantiation
* to populate `Y.UA`.
*
* @static
* @method parseUA
* @param {String} [subUA=navigator.userAgent] UA string to parse
* @return {Object} The Y.UA object
*/
YUI.Env.parseUA = function(subUA) {

    var numberify = function(s) {
            var c = 0;
            return parseFloat(s.replace(/\./g, function() {
                return (c++ === 1) ? '' : '.';
            }));
        },

        win = Y.config.win,

        nav = win && win.navigator,

        o = {

        /**
         * Internet Explorer version number or 0.  Example: 6
         * @property ie
         * @type float
         * @static
         */
        ie: 0,

        /**
         * Opera version number or 0.  Example: 9.2
         * @property opera
         * @type float
         * @static
         */
        opera: 0,

        /**
         * Gecko engine revision number.  Will evaluate to 1 if Gecko
         * is detected but the revision could not be found. Other browsers
         * will be 0.  Example: 1.8
         * <pre>
         * Firefox 1.0.0.4: 1.7.8   <-- Reports 1.7
         * Firefox 1.5.0.9: 1.8.0.9 <-- 1.8
         * Firefox 2.0.0.3: 1.8.1.3 <-- 1.81
         * Firefox 3.0   <-- 1.9
         * Firefox 3.5   <-- 1.91
         * </pre>
         * @property gecko
         * @type float
         * @static
         */
        gecko: 0,

        /**
         * AppleWebKit version.  KHTML browsers that are not WebKit browsers
         * will evaluate to 1, other browsers 0.  Example: 418.9
         * <pre>
         * Safari 1.3.2 (312.6): 312.8.1 <-- Reports 312.8 -- currently the
         *                                   latest available for Mac OSX 10.3.
         * Safari 2.0.2:         416     <-- hasOwnProperty introduced
         * Safari 2.0.4:         418     <-- preventDefault fixed
         * Safari 2.0.4 (419.3): 418.9.1 <-- One version of Safari may run
         *                                   different versions of webkit
         * Safari 2.0.4 (419.3): 419     <-- Tiger installations that have been
         *                                   updated, but not updated
         *                                   to the latest patch.
         * Webkit 212 nightly:   522+    <-- Safari 3.0 precursor (with native
         * SVG and many major issues fixed).
         * Safari 3.0.4 (523.12) 523.12  <-- First Tiger release - automatic
         * update from 2.x via the 10.4.11 OS patch.
         * Webkit nightly 1/2008:525+    <-- Supports DOMContentLoaded event.
         *                                   yahoo.com user agent hack removed.
         * </pre>
         * http://en.wikipedia.org/wiki/Safari_version_history
         * @property webkit
         * @type float
         * @static
         */
        webkit: 0,

        /**
         * Safari will be detected as webkit, but this property will also
         * be populated with the Safari version number
         * @property safari
         * @type float
         * @static
         */
        safari: 0,

        /**
         * Chrome will be detected as webkit, but this property will also
         * be populated with the Chrome version number
         * @property chrome
         * @type float
         * @static
         */
        chrome: 0,

        /**
         * The mobile property will be set to a string containing any relevant
         * user agent information when a modern mobile browser is detected.
         * Currently limited to Safari on the iPhone/iPod Touch, Nokia N-series
         * devices with the WebKit-based browser, and Opera Mini.
         * @property mobile
         * @type string
         * @default null
         * @static
         */
        mobile: null,

        /**
         * Adobe AIR version number or 0.  Only populated if webkit is detected.
         * Example: 1.0
         * @property air
         * @type float
         */
        air: 0,
        /**
         * PhantomJS version number or 0.  Only populated if webkit is detected.
         * Example: 1.0
         * @property phantomjs
         * @type float
         */
        phantomjs: 0,
        /**
         * Detects Apple iPad's OS version
         * @property ipad
         * @type float
         * @static
         */
        ipad: 0,
        /**
         * Detects Apple iPhone's OS version
         * @property iphone
         * @type float
         * @static
         */
        iphone: 0,
        /**
         * Detects Apples iPod's OS version
         * @property ipod
         * @type float
         * @static
         */
        ipod: 0,
        /**
         * General truthy check for iPad, iPhone or iPod
         * @property ios
         * @type Boolean
         * @default null
         * @static
         */
        ios: null,
        /**
         * Detects Googles Android OS version
         * @property android
         * @type float
         * @static
         */
        android: 0,
        /**
         * Detects Kindle Silk
         * @property silk
         * @type float
         * @static
         */
        silk: 0,
        /**
         * Detects Ubuntu version
         * @property ubuntu
         * @type float
         * @static
         */
        ubuntu: 0,
        /**
         * Detects Kindle Silk Acceleration
         * @property accel
         * @type Boolean
         * @static
         */
        accel: false,
        /**
         * Detects Palms WebOS version
         * @property webos
         * @type float
         * @static
         */
        webos: 0,

        /**
         * Google Caja version number or 0.
         * @property caja
         * @type float
         */
        caja: nav && nav.cajaVersion,

        /**
         * Set to true if the page appears to be in SSL
         * @property secure
         * @type boolean
         * @static
         */
        secure: false,

        /**
         * The operating system.  Currently only detecting windows or macintosh
         * @property os
         * @type string
         * @default null
         * @static
         */
        os: null,

        /**
         * The Nodejs Version
         * @property nodejs
         * @type float
         * @default 0
         * @static
         */
        nodejs: 0,
        /**
        * Window8/IE10 Application host environment
        * @property winjs
        * @type Boolean
        * @static
        */
        winjs: !!((typeof Windows !== "undefined") && Windows.System),
        /**
        * Are touch/msPointer events available on this device
        * @property touchEnabled
        * @type Boolean
        * @static
        */
        touchEnabled: false
    },

    ua = subUA || nav && nav.userAgent,

    loc = win && win.location,

    href = loc && loc.href,

    m;

    /**
    * The User Agent string that was parsed
    * @property userAgent
    * @type String
    * @static
    */
    o.userAgent = ua;


    o.secure = href && (href.toLowerCase().indexOf('https') === 0);

    if (ua) {

        if ((/windows|win32/i).test(ua)) {
            o.os = 'windows';
        } else if ((/macintosh|mac_powerpc/i).test(ua)) {
            o.os = 'macintosh';
        } else if ((/android/i).test(ua)) {
            o.os = 'android';
        } else if ((/symbos/i).test(ua)) {
            o.os = 'symbos';
        } else if ((/linux/i).test(ua)) {
            o.os = 'linux';
        } else if ((/rhino/i).test(ua)) {
            o.os = 'rhino';
        }

        // Modern KHTML browsers should qualify as Safari X-Grade
        if ((/KHTML/).test(ua)) {
            o.webkit = 1;
        }
        if ((/IEMobile|XBLWP7/).test(ua)) {
            o.mobile = 'windows';
        }
        if ((/Fennec/).test(ua)) {
            o.mobile = 'gecko';
        }
        // Modern WebKit browsers are at least X-Grade
        m = ua.match(/AppleWebKit\/([^\s]*)/);
        if (m && m[1]) {
            o.webkit = numberify(m[1]);
            o.safari = o.webkit;

            if (/PhantomJS/.test(ua)) {
                m = ua.match(/PhantomJS\/([^\s]*)/);
                if (m && m[1]) {
                    o.phantomjs = numberify(m[1]);
                }
            }

            // Mobile browser check
            if (/ Mobile\//.test(ua) || (/iPad|iPod|iPhone/).test(ua)) {
                o.mobile = 'Apple'; // iPhone or iPod Touch

                m = ua.match(/OS ([^\s]*)/);
                if (m && m[1]) {
                    m = numberify(m[1].replace('_', '.'));
                }
                o.ios = m;
                o.os = 'ios';
                o.ipad = o.ipod = o.iphone = 0;

                m = ua.match(/iPad|iPod|iPhone/);
                if (m && m[0]) {
                    o[m[0].toLowerCase()] = o.ios;
                }
            } else {
                m = ua.match(/NokiaN[^\/]*|webOS\/\d\.\d/);
                if (m) {
                    // Nokia N-series, webOS, ex: NokiaN95
                    o.mobile = m[0];
                }
                if (/webOS/.test(ua)) {
                    o.mobile = 'WebOS';
                    m = ua.match(/webOS\/([^\s]*);/);
                    if (m && m[1]) {
                        o.webos = numberify(m[1]);
                    }
                }
                if (/ Android/.test(ua)) {
                    if (/Mobile/.test(ua)) {
                        o.mobile = 'Android';
                    }
                    m = ua.match(/Android ([^\s]*);/);
                    if (m && m[1]) {
                        o.android = numberify(m[1]);
                    }

                }
                if (/Silk/.test(ua)) {
                    m = ua.match(/Silk\/([^\s]*)/);
                    if (m && m[1]) {
                        o.silk = numberify(m[1]);
                    }
                    if (!o.android) {
                        o.android = 2.34; //Hack for desktop mode in Kindle
                        o.os = 'Android';
                    }
                    if (/Accelerated=true/.test(ua)) {
                        o.accel = true;
                    }
                }
            }

            m = ua.match(/OPR\/(\d+\.\d+)/);

            if (m && m[1]) {
                // Opera 15+ with Blink (pretends to be both Chrome and Safari)
                o.opera = numberify(m[1]);
            } else {
                m = ua.match(/(Chrome|CrMo|CriOS)\/([^\s]*)/);

                if (m && m[1] && m[2]) {
                    o.chrome = numberify(m[2]); // Chrome
                    o.safari = 0; //Reset safari back to 0
                    if (m[1] === 'CrMo') {
                        o.mobile = 'chrome';
                    }
                } else {
                    m = ua.match(/AdobeAIR\/([^\s]*)/);
                    if (m) {
                        o.air = m[0]; // Adobe AIR 1.0 or better
                    }
                }
            }
        }

        m = ua.match(/Ubuntu\ (\d+\.\d+)/);
        if (m && m[1]) {

            o.os = 'linux';
            o.ubuntu = numberify(m[1]);

            m = ua.match(/\ WebKit\/([^\s]*)/);
            if (m && m[1]) {
                o.webkit = numberify(m[1]);
            }
            m = ua.match(/\ Chromium\/([^\s]*)/);
            if (m && m[1]) {
                o.chrome = numberify(m[1]);
            }
            if (/ Mobile$/.test(ua)) {
                o.mobile = 'Ubuntu';
            }
        }

        if (!o.webkit) { // not webkit
// @todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)
            if (/Opera/.test(ua)) {
                m = ua.match(/Opera[\s\/]([^\s]*)/);
                if (m && m[1]) {
                    o.opera = numberify(m[1]);
                }
                m = ua.match(/Version\/([^\s]*)/);
                if (m && m[1]) {
                    o.opera = numberify(m[1]); // opera 10+
                }

                if (/Opera Mobi/.test(ua)) {
                    o.mobile = 'opera';
                    m = ua.replace('Opera Mobi', '').match(/Opera ([^\s]*)/);
                    if (m && m[1]) {
                        o.opera = numberify(m[1]);
                    }
                }
                m = ua.match(/Opera Mini[^;]*/);

                if (m) {
                    o.mobile = m[0]; // ex: Opera Mini/2.0.4509/1316
                }
            } else { // not opera or webkit
                m = ua.match(/MSIE ([^;]*)|Trident.*; rv:([0-9.]+)/);

                if (m && (m[1] || m[2])) {
                    o.ie = numberify(m[1] || m[2]);
                } else { // not opera, webkit, or ie
                    m = ua.match(/Gecko\/([^\s]*)/);

                    if (m) {
                        o.gecko = 1; // Gecko detected, look for revision
                        m = ua.match(/rv:([^\s\)]*)/);
                        if (m && m[1]) {
                            o.gecko = numberify(m[1]);
                            if (/Mobile|Tablet/.test(ua)) {
                                o.mobile = "ffos";
                            }
                        }
                    }
                }
            }
        }
    }

    //Check for known properties to tell if touch events are enabled on this device or if
    //the number of MSPointer touchpoints on this device is greater than 0.
    if (win && nav && !(o.chrome && o.chrome < 6)) {
        o.touchEnabled = (("ontouchstart" in win) || (("msMaxTouchPoints" in nav) && (nav.msMaxTouchPoints > 0)));
    }

    //It was a parsed UA, do not assign the global value.
    if (!subUA) {

        if (typeof process === 'object') {

            if (process.versions && process.versions.node) {
                //NodeJS
                o.os = process.platform;
                o.nodejs = numberify(process.versions.node);
            }
        }

        YUI.Env.UA = o;

    }

    return o;
};


Y.UA = YUI.Env.UA || YUI.Env.parseUA();

/**
Performs a simple comparison between two version numbers, accounting for
standard versioning logic such as the fact that "535.8" is a lower version than
"535.24", even though a simple numerical comparison would indicate that it's
greater. Also accounts for cases such as "1.1" vs. "1.1.0", which are
considered equivalent.

Returns -1 if version _a_ is lower than version _b_, 0 if they're equivalent,
1 if _a_ is higher than _b_.

Versions may be numbers or strings containing numbers and dots. For example,
both `535` and `"535.8.10"` are acceptable. A version string containing
non-numeric characters, like `"535.8.beta"`, may produce unexpected results.

@method compareVersions
@param {Number|String} a First version number to compare.
@param {Number|String} b Second version number to compare.
@return -1 if _a_ is lower than _b_, 0 if they're equivalent, 1 if _a_ is
    higher than _b_.
**/
Y.UA.compareVersions = function (a, b) {
    var aPart, aParts, bPart, bParts, i, len;

    if (a === b) {
        return 0;
    }

    aParts = (a + '').split('.');
    bParts = (b + '').split('.');

    for (i = 0, len = Math.max(aParts.length, bParts.length); i < len; ++i) {
        aPart = parseInt(aParts[i], 10);
        bPart = parseInt(bParts[i], 10);

        /*jshint expr: true*/
        isNaN(aPart) && (aPart = 0);
        isNaN(bPart) && (bPart = 0);

        if (aPart < bPart) {
            return -1;
        }

        if (aPart > bPart) {
            return 1;
        }
    }

    return 0;
};
YUI.Env.aliases = {
    "anim": ["anim-base","anim-color","anim-curve","anim-easing","anim-node-plugin","anim-scroll","anim-xy"],
    "anim-shape-transform": ["anim-shape"],
    "app": ["app-base","app-content","app-transitions","lazy-model-list","model","model-list","model-sync-rest","model-sync-local","router","view","view-node-map"],
    "attribute": ["attribute-base","attribute-complex"],
    "attribute-events": ["attribute-observable"],
    "autocomplete": ["autocomplete-base","autocomplete-sources","autocomplete-list","autocomplete-plugin"],
    "axes": ["axis-numeric","axis-category","axis-time","axis-stacked"],
    "axes-base": ["axis-numeric-base","axis-category-base","axis-time-base","axis-stacked-base"],
    "base": ["base-base","base-pluginhost","base-build"],
    "cache": ["cache-base","cache-offline","cache-plugin"],
    "charts": ["charts-base"],
    "collection": ["array-extras","arraylist","arraylist-add","arraylist-filter","array-invoke"],
    "color": ["color-base","color-hsl","color-harmony"],
    "controller": ["router"],
    "dataschema": ["dataschema-base","dataschema-json","dataschema-xml","dataschema-array","dataschema-text"],
    "datasource": ["datasource-local","datasource-io","datasource-get","datasource-function","datasource-cache","datasource-jsonschema","datasource-xmlschema","datasource-arrayschema","datasource-textschema","datasource-polling"],
    "datatable": ["datatable-core","datatable-table","datatable-head","datatable-body","datatable-base","datatable-column-widths","datatable-message","datatable-mutable","datatable-sort","datatable-datasource"],
    "datatype": ["datatype-date","datatype-number","datatype-xml"],
    "datatype-date": ["datatype-date-parse","datatype-date-format","datatype-date-math"],
    "datatype-number": ["datatype-number-parse","datatype-number-format"],
    "datatype-xml": ["datatype-xml-parse","datatype-xml-format"],
    "dd": ["dd-ddm-base","dd-ddm","dd-ddm-drop","dd-drag","dd-proxy","dd-constrain","dd-drop","dd-scroll","dd-delegate"],
    "dom": ["dom-base","dom-screen","dom-style","selector-native","selector"],
    "editor": ["frame","editor-selection","exec-command","editor-base","editor-para","editor-br","editor-bidi","editor-tab","createlink-base"],
    "event": ["event-base","event-delegate","event-synthetic","event-mousewheel","event-mouseenter","event-key","event-focus","event-resize","event-hover","event-outside","event-touch","event-move","event-flick","event-valuechange","event-tap"],
    "event-custom": ["event-custom-base","event-custom-complex"],
    "event-gestures": ["event-flick","event-move"],
    "handlebars": ["handlebars-compiler"],
    "highlight": ["highlight-base","highlight-accentfold"],
    "history": ["history-base","history-hash","history-html5"],
    "io": ["io-base","io-xdr","io-form","io-upload-iframe","io-queue"],
    "json": ["json-parse","json-stringify"],
    "loader": ["loader-base","loader-rollup","loader-yui3"],
    "node": ["node-base","node-event-delegate","node-pluginhost","node-screen","node-style"],
    "pluginhost": ["pluginhost-base","pluginhost-config"],
    "querystring": ["querystring-parse","querystring-stringify"],
    "recordset": ["recordset-base","recordset-sort","recordset-filter","recordset-indexer"],
    "resize": ["resize-base","resize-proxy","resize-constrain"],
    "slider": ["slider-base","slider-value-range","clickable-rail","range-slider"],
    "template": ["template-base","template-micro"],
    "text": ["text-accentfold","text-wordbreak"],
    "widget": ["widget-base","widget-htmlparser","widget-skin","widget-uievents"]
};


}, '3.17.2', {"use": ["get", "features", "intl-base", "yui-log", "yui-later"]});
YUI.add('get', function (Y, NAME) {

/*jslint boss:true, expr:true, laxbreak: true */

/**
Provides dynamic loading of remote JavaScript and CSS resources.

@module get
@class Get
@static
**/

var Lang = Y.Lang,

    CUSTOM_ATTRS, // defined lazily in Y.Get.Transaction._createNode()

    Get, Transaction;

Y.Get = Get = {
    // -- Public Properties ----------------------------------------------------

    /**
    Default options for CSS requests. Options specified here will override
    global defaults for CSS requests.

    See the `options` property for all available options.

    @property cssOptions
    @type Object
    @static
    @since 3.5.0
    **/
    cssOptions: {
        attributes: {
            rel: 'stylesheet'
        },

        doc         : Y.config.linkDoc || Y.config.doc,
        pollInterval: 50
    },

    /**
    Default options for JS requests. Options specified here will override global
    defaults for JS requests.

    See the `options` property for all available options.

    @property jsOptions
    @type Object
    @static
    @since 3.5.0
    **/
    jsOptions: {
        autopurge: true,
        doc      : Y.config.scriptDoc || Y.config.doc
    },

    /**
    Default options to use for all requests.

    Note that while all available options are documented here for ease of
    discovery, some options (like callback functions) only make sense at the
    transaction level.

    Callback functions specified via the options object or the `options`
    parameter of the `css()`, `js()`, or `load()` methods will receive the
    transaction object as a parameter. See `Y.Get.Transaction` for details on
    the properties and methods available on transactions.

    @static
    @since 3.5.0
    @property {Object} options

    @property {Boolean} [options.async=false] Whether or not to load scripts
        asynchronously, meaning they're requested in parallel and execution
        order is not guaranteed. Has no effect on CSS, since CSS is always
        loaded asynchronously.

    @property {Object} [options.attributes] HTML attribute name/value pairs that
        should be added to inserted nodes. By default, the `charset` attribute
        will be set to "utf-8" and nodes will be given an auto-generated `id`
        attribute, but you can override these with your own values if desired.

    @property {Boolean} [options.autopurge] Whether or not to automatically
        purge inserted nodes after the purge threshold is reached. This is
        `true` by default for JavaScript, but `false` for CSS since purging a
        CSS node will also remove any styling applied by the referenced file.

    @property {Object} [options.context] `this` object to use when calling
        callback functions. Defaults to the transaction object.

    @property {Mixed} [options.data] Arbitrary data object to pass to "on*"
        callbacks.

    @property {Document} [options.doc] Document into which nodes should be
        inserted. By default, the current document is used.

    @property {HTMLElement|String} [options.insertBefore] HTML element or id
        string of an element before which all generated nodes should be
        inserted. If not specified, Get will automatically determine the best
        place to insert nodes for maximum compatibility.

    @property {Function} [options.onEnd] Callback to execute after a transaction
        is complete, regardless of whether it succeeded or failed.

    @property {Function} [options.onFailure] Callback to execute after a
        transaction fails, times out, or is aborted.

    @property {Function} [options.onProgress] Callback to execute after each
        individual request in a transaction either succeeds or fails.

    @property {Function} [options.onSuccess] Callback to execute after a
        transaction completes successfully with no errors. Note that in browsers
        that don't support the `error` event on CSS `<link>` nodes, a failed CSS
        request may still be reported as a success because in these browsers
        it can be difficult or impossible to distinguish between success and
        failure for CSS resources.

    @property {Function} [options.onTimeout] Callback to execute after a
        transaction times out.

    @property {Number} [options.pollInterval=50] Polling interval (in
        milliseconds) for detecting CSS load completion in browsers that don't
        support the `load` event on `<link>` nodes. This isn't used for
        JavaScript.

    @property {Number} [options.purgethreshold=20] Number of nodes to insert
        before triggering an automatic purge when `autopurge` is `true`.

    @property {Number} [options.timeout] Number of milliseconds to wait before
        aborting a transaction. When a timeout occurs, the `onTimeout` callback
        is called, followed by `onFailure` and finally `onEnd`. By default,
        there is no timeout.

    @property {String} [options.type] Resource type ("css" or "js"). This option
        is set automatically by the `css()` and `js()` functions and will be
        ignored there, but may be useful when using the `load()` function. If
        not specified, the type will be inferred from the URL, defaulting to
        "js" if the URL doesn't contain a recognizable file extension.
    **/
    options: {
        attributes: {
            charset: 'utf-8'
        },

        purgethreshold: 20
    },

    // -- Protected Properties -------------------------------------------------

    /**
    Regex that matches a CSS URL. Used to guess the file type when it's not
    specified.

    @property REGEX_CSS
    @type RegExp
    @final
    @protected
    @static
    @since 3.5.0
    **/
    REGEX_CSS: /\.css(?:[?;].*)?$/i,

    /**
    Regex that matches a JS URL. Used to guess the file type when it's not
    specified.

    @property REGEX_JS
    @type RegExp
    @final
    @protected
    @static
    @since 3.5.0
    **/
    REGEX_JS : /\.js(?:[?;].*)?$/i,

    /**
    Contains information about the current environment, such as what script and
    link injection features it supports.

    This object is created and populated the first time the `_getEnv()` method
    is called.

    @property _env
    @type Object
    @protected
    @static
    @since 3.5.0
    **/

    /**
    Mapping of document _yuid strings to <head> or <base> node references so we
    don't have to look the node up each time we want to insert a request node.

    @property _insertCache
    @type Object
    @protected
    @static
    @since 3.5.0
    **/
    _insertCache: {},

    /**
    Information about the currently pending transaction, if any.

    This is actually an object with two properties: `callback`, containing the
    optional callback passed to `css()`, `load()`, or `js()`; and `transaction`,
    containing the actual transaction instance.

    @property _pending
    @type Object
    @protected
    @static
    @since 3.5.0
    **/
    _pending: null,

    /**
    HTML nodes eligible to be purged next time autopurge is triggered.

    @property _purgeNodes
    @type HTMLElement[]
    @protected
    @static
    @since 3.5.0
    **/
    _purgeNodes: [],

    /**
    Queued transactions and associated callbacks.

    @property _queue
    @type Object[]
    @protected
    @static
    @since 3.5.0
    **/
    _queue: [],

    // -- Public Methods -------------------------------------------------------

    /**
    Aborts the specified transaction.

    This will cause the transaction's `onFailure` callback to be called and
    will prevent any new script and link nodes from being added to the document,
    but any resources that have already been requested will continue loading
    (there's no safe way to prevent this, unfortunately).

    *Note:* This method is deprecated as of 3.5.0, and will be removed in a
    future version of YUI. Use the transaction-level `abort()` method instead.

    @method abort
    @param {Get.Transaction} transaction Transaction to abort.
    @deprecated Use the `abort()` method on the transaction instead.
    @static
    **/
    abort: function (transaction) {
        var i, id, item, len, pending;


        if (!transaction.abort) {
            id          = transaction;
            pending     = this._pending;
            transaction = null;

            if (pending && pending.transaction.id === id) {
                transaction   = pending.transaction;
                this._pending = null;
            } else {
                for (i = 0, len = this._queue.length; i < len; ++i) {
                    item = this._queue[i].transaction;

                    if (item.id === id) {
                        transaction = item;
                        this._queue.splice(i, 1);
                        break;
                    }
                }
            }
        }

        transaction && transaction.abort();
    },

    /**
    Loads one or more CSS files.

    The _urls_ parameter may be provided as a URL string, a request object,
    or an array of URL strings and/or request objects.

    A request object is just an object that contains a `url` property and zero
    or more options that should apply specifically to that request.
    Request-specific options take priority over transaction-level options and
    default options.

    URLs may be relative or absolute, and do not have to have the same origin
    as the current page.

    The `options` parameter may be omitted completely and a callback passed in
    its place, if desired.

    @example

        // Load a single CSS file and log a message on completion.
        Y.Get.css('foo.css', function (err) {
            if (err) {
            } else {
            }
        });

        // Load multiple CSS files and log a message when all have finished
        // loading.
        var urls = ['foo.css', 'http://example.com/bar.css', 'baz/quux.css'];

        Y.Get.css(urls, function (err) {
            if (err) {
            } else {
            }
        });

        // Specify transaction-level options, which will apply to all requests
        // within the transaction.
        Y.Get.css(urls, {
            attributes: {'class': 'my-css'},
            timeout   : 5000
        });

        // Specify per-request options, which override transaction-level and
        // default options.
        Y.Get.css([
            {url: 'foo.css', attributes: {id: 'foo'}},
            {url: 'bar.css', attributes: {id: 'bar', charset: 'iso-8859-1'}}
        ]);

    @method css
    @param {String|Object|Array} urls URL string, request object, or array
        of URLs and/or request objects to load.
    @param {Object} [options] Options for this transaction. See the
        `Y.Get.options` property for a complete list of available options.
    @param {Function} [callback] Callback function to be called on completion.
        This is a general callback and will be called before any more granular
        callbacks (`onSuccess`, `onFailure`, etc.) specified in the `options`
        object.

        @param {Array|null} callback.err Array of errors that occurred during
            the transaction, or `null` on success.
        @param {Get.Transaction} callback.transaction Transaction object.

    @return {Get.Transaction} Transaction object.
    @static
    **/
    css: function (urls, options, callback) {
        return this._load('css', urls, options, callback);
    },

    /**
    Loads one or more JavaScript resources.

    The _urls_ parameter may be provided as a URL string, a request object,
    or an array of URL strings and/or request objects.

    A request object is just an object that contains a `url` property and zero
    or more options that should apply specifically to that request.
    Request-specific options take priority over transaction-level options and
    default options.

    URLs may be relative or absolute, and do not have to have the same origin
    as the current page.

    The `options` parameter may be omitted completely and a callback passed in
    its place, if desired.

    Scripts will be executed in the order they're specified unless the `async`
    option is `true`, in which case they'll be loaded in parallel and executed
    in whatever order they finish loading.

    @example

        // Load a single JS file and log a message on completion.
        Y.Get.js('foo.js', function (err) {
            if (err) {
            } else {
            }
        });

        // Load multiple JS files, execute them in order, and log a message when
        // all have finished loading.
        var urls = ['foo.js', 'http://example.com/bar.js', 'baz/quux.js'];

        Y.Get.js(urls, function (err) {
            if (err) {
            } else {
            }
        });

        // Specify transaction-level options, which will apply to all requests
        // within the transaction.
        Y.Get.js(urls, {
            attributes: {'class': 'my-js'},
            timeout   : 5000
        });

        // Specify per-request options, which override transaction-level and
        // default options.
        Y.Get.js([
            {url: 'foo.js', attributes: {id: 'foo'}},
            {url: 'bar.js', attributes: {id: 'bar', charset: 'iso-8859-1'}}
        ]);

    @method js
    @param {String|Object|Array} urls URL string, request object, or array
        of URLs and/or request objects to load.
    @param {Object} [options] Options for this transaction. See the
        `Y.Get.options` property for a complete list of available options.
    @param {Function} [callback] Callback function to be called on completion.
        This is a general callback and will be called before any more granular
        callbacks (`onSuccess`, `onFailure`, etc.) specified in the `options`
        object.

        @param {Array|null} callback.err Array of errors that occurred during
            the transaction, or `null` on success.
        @param {Get.Transaction} callback.transaction Transaction object.

    @return {Get.Transaction} Transaction object.
    @since 3.5.0
    @static
    **/
    js: function (urls, options, callback) {
        return this._load('js', urls, options, callback);
    },

    /**
    Loads one or more CSS and/or JavaScript resources in the same transaction.

    Use this method when you want to load both CSS and JavaScript in a single
    transaction and be notified when all requested URLs have finished loading,
    regardless of type.

    Behavior and options are the same as for the `css()` and `js()` methods. If
    a resource type isn't specified in per-request options or transaction-level
    options, Get will guess the file type based on the URL's extension (`.css`
    or `.js`, with or without a following query string). If the file type can't
    be guessed from the URL, a warning will be logged and Get will assume the
    URL is a JavaScript resource.

    @example

        // Load both CSS and JS files in a single transaction, and log a message
        // when all files have finished loading.
        Y.Get.load(['foo.css', 'bar.js', 'baz.css'], function (err) {
            if (err) {
            } else {
            }
        });

    @method load
    @param {String|Object|Array} urls URL string, request object, or array
        of URLs and/or request objects to load.
    @param {Object} [options] Options for this transaction. See the
        `Y.Get.options` property for a complete list of available options.
    @param {Function} [callback] Callback function to be called on completion.
        This is a general callback and will be called before any more granular
        callbacks (`onSuccess`, `onFailure`, etc.) specified in the `options`
        object.

        @param {Array|null} err Array of errors that occurred during the
            transaction, or `null` on success.
        @param {Get.Transaction} Transaction object.

    @return {Get.Transaction} Transaction object.
    @since 3.5.0
    @static
    **/
    load: function (urls, options, callback) {
        return this._load(null, urls, options, callback);
    },

    // -- Protected Methods ----------------------------------------------------

    /**
    Triggers an automatic purge if the purge threshold has been reached.

    @method _autoPurge
    @param {Number} threshold Purge threshold to use, in milliseconds.
    @protected
    @since 3.5.0
    @static
    **/
    _autoPurge: function (threshold) {
        if (threshold && this._purgeNodes.length >= threshold) {
            this._purge(this._purgeNodes);
        }
    },

    /**
    Populates the `_env` property with information about the current
    environment.

    @method _getEnv
    @return {Object} Environment information.
    @protected
    @since 3.5.0
    @static
    **/
    _getEnv: function () {
        var doc = Y.config.doc,
            ua  = Y.UA;

        // Note: some of these checks require browser sniffs since it's not
        // feasible to load test files on every pageview just to perform a
        // feature test. I'm sorry if this makes you sad.
        return (this._env = {

            // True if this is a browser that supports disabling async mode on
            // dynamically created script nodes. See
            // https://developer.mozilla.org/En/HTML/Element/Script#Attributes

            // IE10 doesn't return true for the MDN feature test, so setting it explicitly,
            // because it is async by default, and allows you to disable async by setting it to false
            async: (doc && doc.createElement('script').async === true) || (ua.ie >= 10),

            // True if this browser fires an event when a dynamically injected
            // link node fails to load. This is currently true for Firefox 9+
            // and WebKit 535.24+
            cssFail: ua.gecko >= 9 || ua.compareVersions(ua.webkit, 535.24) >= 0,

            // True if this browser fires an event when a dynamically injected
            // link node finishes loading. This is currently true for IE, Opera,
            // Firefox 9+, and WebKit 535.24+. Note that IE versions <9 fire the
            // DOM 0 "onload" event, but not "load". All versions of IE fire
            // "onload".
            // davglass: Seems that Chrome on Android needs this to be false.
            cssLoad: (
                    (!ua.gecko && !ua.webkit) || ua.gecko >= 9 ||
                    ua.compareVersions(ua.webkit, 535.24) >= 0
                ) && !(ua.chrome && ua.chrome <= 18),

            // True if this browser preserves script execution order while
            // loading scripts in parallel as long as the script node's `async`
            // attribute is set to false to explicitly disable async execution.
            preservesScriptOrder: !!(ua.gecko || ua.opera || (ua.ie && ua.ie >= 10))
        });
    },

    _getTransaction: function (urls, options) {
        var requests = [],
            i, len, req, url;

        if (!Lang.isArray(urls)) {
            urls = [urls];
        }

        options = Y.merge(this.options, options);

        // Clone the attributes object so we don't end up modifying it by ref.
        options.attributes = Y.merge(this.options.attributes,
                options.attributes);

        for (i = 0, len = urls.length; i < len; ++i) {
            url = urls[i];
            req = {attributes: {}};

            // If `url` is a string, we create a URL object for it, then mix in
            // global options and request-specific options. If it's an object
            // with a "url" property, we assume it's a request object containing
            // URL-specific options.
            if (typeof url === 'string') {
                req.url = url;
            } else if (url.url) {
                // URL-specific options override both global defaults and
                // request-specific options.
                Y.mix(req, url, false, null, 0, true);
                url = url.url; // Make url a string so we can use it later.
            } else {
                continue;
            }

            Y.mix(req, options, false, null, 0, true);

            // If we didn't get an explicit type for this URL either in the
            // request options or the URL-specific options, try to determine
            // one from the file extension.
            if (!req.type) {
                if (this.REGEX_CSS.test(url)) {
                    req.type = 'css';
                } else {
                    if (!this.REGEX_JS.test(url)) {
                    }

                    req.type = 'js';
                }
            }

            // Mix in type-specific default options, but don't overwrite any
            // options that have already been set.
            Y.mix(req, req.type === 'js' ? this.jsOptions : this.cssOptions,
                false, null, 0, true);

            // Give the node an id attribute if it doesn't already have one.
            req.attributes.id || (req.attributes.id = Y.guid());

            // Backcompat for <3.5.0 behavior.
            if (req.win) {
                req.doc = req.win.document;
            } else {
                req.win = req.doc.defaultView || req.doc.parentWindow;
            }

            if (req.charset) {
                req.attributes.charset = req.charset;
            }

            requests.push(req);
        }

        return new Transaction(requests, options);
    },

    _load: function (type, urls, options, callback) {
        var transaction;

        // Allow callback as third param.
        if (typeof options === 'function') {
            callback = options;
            options  = {};
        }

        options || (options = {});
        options.type = type;

        options._onFinish = Get._onTransactionFinish;

        if (!this._env) {
            this._getEnv();
        }

        transaction = this._getTransaction(urls, options);

        this._queue.push({
            callback   : callback,
            transaction: transaction
        });

        this._next();

        return transaction;
    },

    _onTransactionFinish : function() {
        Get._pending = null;
        Get._next();
    },

    _next: function () {
        var item;

        if (this._pending) {
            return;
        }

        item = this._queue.shift();

        if (item) {
            this._pending = item;
            item.transaction.execute(item.callback);
        }
    },

    _purge: function (nodes) {
        var purgeNodes    = this._purgeNodes,
            isTransaction = nodes !== purgeNodes,
            index, node;

        while (node = nodes.pop()) { // assignment
            // Don't purge nodes that haven't finished loading (or errored out),
            // since this can hang the transaction.
            if (!node._yuiget_finished) {
                continue;
            }

            node.parentNode && node.parentNode.removeChild(node);

            // If this is a transaction-level purge and this node also exists in
            // the Get-level _purgeNodes array, we need to remove it from
            // _purgeNodes to avoid creating a memory leak. The indexOf lookup
            // sucks, but until we get WeakMaps, this is the least troublesome
            // way to do this (we can't just hold onto node ids because they may
            // not be in the same document).
            if (isTransaction) {
                index = Y.Array.indexOf(purgeNodes, node);

                if (index > -1) {
                    purgeNodes.splice(index, 1);
                }
            }
        }
    }
};

/**
Alias for `js()`.

@method script
@static
**/
Get.script = Get.js;

/**
Represents a Get transaction, which may contain requests for one or more JS or
CSS files.

This class should not be instantiated manually. Instances will be created and
returned as needed by Y.Get's `css()`, `js()`, and `load()` methods.

@class Get.Transaction
@constructor
@since 3.5.0
**/
Get.Transaction = Transaction = function (requests, options) {
    var self = this;

    self.id       = Transaction._lastId += 1;
    self.data     = options.data;
    self.errors   = [];
    self.nodes    = [];
    self.options  = options;
    self.requests = requests;

    self._callbacks = []; // callbacks to call after execution finishes
    self._queue     = [];
    self._reqsWaiting   = 0;

    // Deprecated pre-3.5.0 properties.
    self.tId = self.id; // Use `id` instead.
    self.win = options.win || Y.config.win;
};

/**
Arbitrary data object associated with this transaction.

This object comes from the options passed to `Get.css()`, `Get.js()`, or
`Get.load()`, and will be `undefined` if no data object was specified.

@property {Object} data
**/

/**
Array of errors that have occurred during this transaction, if any. Each error
object has the following properties:
`errors.error`: Error message.
`errors.request`: Request object related to the error.

@since 3.5.0
@property {Object[]} errors
**/

/**
Numeric id for this transaction, unique among all transactions within the same
YUI sandbox in the current pageview.

@property {Number} id
@since 3.5.0
**/

/**
HTMLElement nodes (native ones, not YUI Node instances) that have been inserted
during the current transaction.

@property {HTMLElement[]} nodes
**/

/**
Options associated with this transaction.

See `Get.options` for the full list of available options.

@property {Object} options
@since 3.5.0
**/

/**
Request objects contained in this transaction. Each request object represents
one CSS or JS URL that will be (or has been) requested and loaded into the page.

@property {Object} requests
@since 3.5.0
**/

/**
Id of the most recent transaction.

@property _lastId
@type Number
@protected
@static
**/
Transaction._lastId = 0;

Transaction.prototype = {
    // -- Public Properties ----------------------------------------------------

    /**
    Current state of this transaction. One of "new", "executing", or "done".

    @property _state
    @type String
    @protected
    **/
    _state: 'new', // "new", "executing", or "done"

    // -- Public Methods -------------------------------------------------------

    /**
    Aborts this transaction.

    This will cause the transaction's `onFailure` callback to be called and
    will prevent any new script and link nodes from being added to the document,
    but any resources that have already been requested will continue loading
    (there's no safe way to prevent this, unfortunately).

    @method abort
    @param {String} [msg="Aborted."] Optional message to use in the `errors`
        array describing why the transaction was aborted.
    **/
    abort: function (msg) {
        this._pending    = null;
        this._pendingCSS = null;
        this._pollTimer  = clearTimeout(this._pollTimer);
        this._queue      = [];
        this._reqsWaiting    = 0;

        this.errors.push({error: msg || 'Aborted'});
        this._finish();
    },

    /**
    Begins execting the transaction.

    There's usually no reason to call this manually, since Get will call it
    automatically when other pending transactions have finished. If you really
    want to execute your transaction before Get does, you can, but be aware that
    this transaction's scripts may end up executing before the scripts in other
    pending transactions.

    If the transaction is already executing, the specified callback (if any)
    will be queued and called after execution finishes. If the transaction has
    already finished, the callback will be called immediately (the transaction
    will not be executed again).

    @method execute
    @param {Function} callback Callback function to execute after all requests
        in the transaction are complete, or after the transaction is aborted.
    **/
    execute: function (callback) {
        var self     = this,
            requests = self.requests,
            state    = self._state,
            i, len, queue, req;

        if (state === 'done') {
            callback && callback(self.errors.length ? self.errors : null, self);
            return;
        } else {
            callback && self._callbacks.push(callback);

            if (state === 'executing') {
                return;
            }
        }

        self._state = 'executing';
        self._queue = queue = [];

        if (self.options.timeout) {
            self._timeout = setTimeout(function () {
                self.abort('Timeout');
            }, self.options.timeout);
        }

        self._reqsWaiting = requests.length;

        for (i = 0, len = requests.length; i < len; ++i) {
            req = requests[i];

            if (req.async || req.type === 'css') {
                // No need to queue CSS or fully async JS.
                self._insert(req);
            } else {
                queue.push(req);
            }
        }

        self._next();
    },

    /**
    Manually purges any `<script>` or `<link>` nodes this transaction has
    created.

    Be careful when purging a transaction that contains CSS requests, since
    removing `<link>` nodes will also remove any styles they applied.

    @method purge
    **/
    purge: function () {
        Get._purge(this.nodes);
    },

    // -- Protected Methods ----------------------------------------------------
    _createNode: function (name, attrs, doc) {
        var node = doc.createElement(name),
            attr, testEl;

        if (!CUSTOM_ATTRS) {
            // IE6 and IE7 expect property names rather than attribute names for
            // certain attributes. Rather than sniffing, we do a quick feature
            // test the first time _createNode() runs to determine whether we
            // need to provide a workaround.
            testEl = doc.createElement('div');
            testEl.setAttribute('class', 'a');

            CUSTOM_ATTRS = testEl.className === 'a' ? {} : {
                'for'  : 'htmlFor',
                'class': 'className'
            };
        }

        for (attr in attrs) {
            if (attrs.hasOwnProperty(attr)) {
                node.setAttribute(CUSTOM_ATTRS[attr] || attr, attrs[attr]);
            }
        }

        return node;
    },

    _finish: function () {
        var errors  = this.errors.length ? this.errors : null,
            options = this.options,
            thisObj = options.context || this,
            data, i, len;

        if (this._state === 'done') {
            return;
        }

        this._state = 'done';

        for (i = 0, len = this._callbacks.length; i < len; ++i) {
            this._callbacks[i].call(thisObj, errors, this);
        }

        data = this._getEventData();

        if (errors) {
            if (options.onTimeout && errors[errors.length - 1].error === 'Timeout') {
                options.onTimeout.call(thisObj, data);
            }

            if (options.onFailure) {
                options.onFailure.call(thisObj, data);
            }
        } else if (options.onSuccess) {
            options.onSuccess.call(thisObj, data);
        }

        if (options.onEnd) {
            options.onEnd.call(thisObj, data);
        }

        if (options._onFinish) {
            options._onFinish();
        }
    },

    _getEventData: function (req) {
        if (req) {
            // This merge is necessary for backcompat. I hate it.
            return Y.merge(this, {
                abort  : this.abort, // have to copy these because the prototype isn't preserved
                purge  : this.purge,
                request: req,
                url    : req.url,
                win    : req.win
            });
        } else {
            return this;
        }
    },

    _getInsertBefore: function (req) {
        var doc = req.doc,
            el  = req.insertBefore,
            cache, docStamp;

        if (el) {
            return typeof el === 'string' ? doc.getElementById(el) : el;
        }

        cache    = Get._insertCache;
        docStamp = Y.stamp(doc);

        if ((el = cache[docStamp])) { // assignment
            return el;
        }

        // Inserting before a <base> tag apparently works around an IE bug
        // (according to a comment from pre-3.5.0 Y.Get), but I'm not sure what
        // bug that is, exactly. Better safe than sorry?
        if ((el = doc.getElementsByTagName('base')[0])) { // assignment
            return (cache[docStamp] = el);
        }

        // Look for a <head> element.
        el = doc.head || doc.getElementsByTagName('head')[0];

        if (el) {
            // Create a marker node at the end of <head> to use as an insertion
            // point. Inserting before this node will ensure that all our CSS
            // gets inserted in the correct order, to maintain style precedence.
            el.appendChild(doc.createTextNode(''));
            return (cache[docStamp] = el.lastChild);
        }

        // If all else fails, just insert before the first script node on the
        // page, which is virtually guaranteed to exist.
        return (cache[docStamp] = doc.getElementsByTagName('script')[0]);
    },

    _insert: function (req) {
        var env          = Get._env,
            insertBefore = this._getInsertBefore(req),
            isScript     = req.type === 'js',
            node         = req.node,
            self         = this,
            ua           = Y.UA,
            cssTimeout, nodeType;

        if (!node) {
            if (isScript) {
                nodeType = 'script';
            } else if (!env.cssLoad && ua.gecko) {
                nodeType = 'style';
            } else {
                nodeType = 'link';
            }

            node = req.node = this._createNode(nodeType, req.attributes,
                req.doc);
        }

        function onError() {
            self._progress('Failed to load ' + req.url, req);
        }

        function onLoad() {
            if (cssTimeout) {
                clearTimeout(cssTimeout);
            }

            self._progress(null, req);
        }

        // Deal with script asynchronicity.
        if (isScript) {
            node.setAttribute('src', req.url);

            if (req.async) {
                // Explicitly indicate that we want the browser to execute this
                // script asynchronously. This is necessary for older browsers
                // like Firefox <4.
                node.async = true;
            } else {
                if (env.async) {
                    // This browser treats injected scripts as async by default
                    // (standard HTML5 behavior) but asynchronous loading isn't
                    // desired, so tell the browser not to mark this script as
                    // async.
                    node.async = false;
                }

                // If this browser doesn't preserve script execution order based
                // on insertion order, we'll need to avoid inserting other
                // scripts until this one finishes loading.
                if (!env.preservesScriptOrder) {
                    this._pending = req;
                }
            }
        } else {
            if (!env.cssLoad && ua.gecko) {
                // In Firefox <9, we can import the requested URL into a <style>
                // node and poll for the existence of node.sheet.cssRules. This
                // gives us a reliable way to determine CSS load completion that
                // also works for cross-domain stylesheets.
                //
                // Props to Zach Leatherman for calling my attention to this
                // technique.
                node.innerHTML = (req.attributes.charset ?
                    '@charset "' + req.attributes.charset + '";' : '') +
                    '@import "' + req.url + '";';
            } else {
                node.setAttribute('href', req.url);
            }
        }

        // Inject the node.
        if (isScript && ua.ie && (ua.ie < 9 || (document.documentMode && document.documentMode < 9))) {
            // Script on IE < 9, and IE 9+ when in IE 8 or older modes, including quirks mode.
            node.onreadystatechange = function () {
                if (/loaded|complete/.test(node.readyState)) {
                    node.onreadystatechange = null;
                    onLoad();
                }
            };
        } else if (!isScript && !env.cssLoad) {
            // CSS on Firefox <9 or WebKit.
            this._poll(req);
        } else {
            // Script or CSS on everything else. Using DOM 0 events because that
            // evens the playing field with older IEs.

            if (ua.ie >= 10) {

                // We currently need to introduce a timeout for IE10, since it
                // calls onerror/onload synchronously for 304s - messing up existing
                // program flow.

                // Remove this block if the following bug gets fixed by GA
                /*jshint maxlen: 1500 */
                // https://connect.microsoft.com/IE/feedback/details/763871/dynamically-loaded-scripts-with-304s-responses-interrupt-the-currently-executing-js-thread-onload
                node.onerror = function() { setTimeout(onError, 0); };
                node.onload  = function() { setTimeout(onLoad, 0); };
            } else {
                node.onerror = onError;
                node.onload  = onLoad;
            }

            // If this browser doesn't fire an event when CSS fails to load,
            // fail after a timeout to avoid blocking the transaction queue.
            if (!env.cssFail && !isScript) {
                cssTimeout = setTimeout(onError, req.timeout || 3000);
            }
        }

        this.nodes.push(node);
        insertBefore.parentNode.insertBefore(node, insertBefore);
    },

    _next: function () {
        if (this._pending) {
            return;
        }

        // If there are requests in the queue, insert the next queued request.
        // Otherwise, if we're waiting on already-inserted requests to finish,
        // wait longer. If there are no queued requests and we're not waiting
        // for anything to load, then we're done!
        if (this._queue.length) {
            this._insert(this._queue.shift());
        } else if (!this._reqsWaiting) {
            this._finish();
        }
    },

    _poll: function (newReq) {
        var self       = this,
            pendingCSS = self._pendingCSS,
            isWebKit   = Y.UA.webkit,
            i, hasRules, j, nodeHref, req, sheets;

        if (newReq) {
            pendingCSS || (pendingCSS = self._pendingCSS = []);
            pendingCSS.push(newReq);

            if (self._pollTimer) {
                // A poll timeout is already pending, so no need to create a
                // new one.
                return;
            }
        }

        self._pollTimer = null;

        // Note: in both the WebKit and Gecko hacks below, a CSS URL that 404s
        // will still be treated as a success. There's no good workaround for
        // this.

        for (i = 0; i < pendingCSS.length; ++i) {
            req = pendingCSS[i];

            if (isWebKit) {
                // Look for a stylesheet matching the pending URL.
                sheets   = req.doc.styleSheets;
                j        = sheets.length;
                nodeHref = req.node.href;

                while (--j >= 0) {
                    if (sheets[j].href === nodeHref) {
                        pendingCSS.splice(i, 1);
                        i -= 1;
                        self._progress(null, req);
                        break;
                    }
                }
            } else {
                // Many thanks to Zach Leatherman for calling my attention to
                // the @import-based cross-domain technique used here, and to
                // Oleg Slobodskoi for an earlier same-domain implementation.
                //
                // See Zach's blog for more details:
                // http://www.zachleat.com/web/2010/07/29/load-css-dynamically/
                try {
                    // We don't really need to store this value since we never
                    // use it again, but if we don't store it, Closure Compiler
                    // assumes the code is useless and removes it.
                    hasRules = !!req.node.sheet.cssRules;

                    // If we get here, the stylesheet has loaded.
                    pendingCSS.splice(i, 1);
                    i -= 1;
                    self._progress(null, req);
                } catch (ex) {
                    // An exception means the stylesheet is still loading.
                }
            }
        }

        if (pendingCSS.length) {
            self._pollTimer = setTimeout(function () {
                self._poll.call(self);
            }, self.options.pollInterval);
        }
    },

    _progress: function (err, req) {
        var options = this.options;

        if (err) {
            req.error = err;

            this.errors.push({
                error  : err,
                request: req
            });

        }

        req.node._yuiget_finished = req.finished = true;

        if (options.onProgress) {
            options.onProgress.call(options.context || this,
                this._getEventData(req));
        }

        if (req.autopurge) {
            // Pre-3.5.0 Get always excludes the most recent node from an
            // autopurge. I find this odd, but I'm keeping that behavior for
            // the sake of backcompat.
            Get._autoPurge(this.options.purgethreshold);
            Get._purgeNodes.push(req.node);
        }

        if (this._pending === req) {
            this._pending = null;
        }

        this._reqsWaiting -= 1;

        this._next();
    }
};


}, '3.17.2', {"requires": ["yui-base"]});
YUI.add('features', function (Y, NAME) {

var feature_tests = {};

/**
Contains the core of YUI's feature test architecture.
@module features
*/

/**
* Feature detection
* @class Features
* @static
*/

Y.mix(Y.namespace('Features'), {

    /**
    * Object hash of all registered feature tests
    * @property tests
    * @type Object
    */
    tests: feature_tests,

    /**
    * Add a test to the system
    *
    *   ```
    *   Y.Features.add("load", "1", {});
    *   ```
    *
    * @method add
    * @param {String} cat The category, right now only 'load' is supported
    * @param {String} name The number sequence of the test, how it's reported in the URL or config: 1, 2, 3
    * @param {Object} o Object containing test properties
    * @param {String} o.name The name of the test
    * @param {Function} o.test The test function to execute, the only argument to the function is the `Y` instance
    * @param {String} o.trigger The module that triggers this test.
    */
    add: function(cat, name, o) {
        feature_tests[cat] = feature_tests[cat] || {};
        feature_tests[cat][name] = o;
    },
    /**
    * Execute all tests of a given category and return the serialized results
    *
    *   ```
    *   caps=1:1;2:1;3:0
    *   ```
    * @method all
    * @param {String} cat The category to execute
    * @param {Array} args The arguments to pass to the test function
    * @return {String} A semi-colon separated string of tests and their success/failure: 1:1;2:1;3:0
    */
    all: function(cat, args) {
        var cat_o = feature_tests[cat],
            // results = {};
            result = [];
        if (cat_o) {
            Y.Object.each(cat_o, function(v, k) {
                result.push(k + ':' + (Y.Features.test(cat, k, args) ? 1 : 0));
            });
        }

        return (result.length) ? result.join(';') : '';
    },
    /**
    * Run a specific test and return a Boolean response.
    *
    *   ```
    *   Y.Features.test("load", "1");
    *   ```
    *
    * @method test
    * @param {String} cat The category of the test to run
    * @param {String} name The name of the test to run
    * @param {Array} args The arguments to pass to the test function
    * @return {Boolean} True or false if the test passed/failed.
    */
    test: function(cat, name, args) {
        args = args || [];
        var result, ua, test,
            cat_o = feature_tests[cat],
            feature = cat_o && cat_o[name];

        if (!feature) {
        } else {

            result = feature.result;

            if (Y.Lang.isUndefined(result)) {

                ua = feature.ua;
                if (ua) {
                    result = (Y.UA[ua]);
                }

                test = feature.test;
                if (test && ((!ua) || result)) {
                    result = test.apply(Y, args);
                }

                feature.result = result;
            }
        }

        return result;
    }
});

// Y.Features.add("load", "1", {});
// Y.Features.test("load", "1");
// caps=1:1;2:0;3:1;

/* This file is auto-generated by (yogi.js loader --mix --yes) */
/*jshint maxlen:900, eqeqeq: false */
var add = Y.Features.add;
// app-transitions-native
add('load', '0', {
    "name": "app-transitions-native",
    "test": function (Y) {
    var doc  = Y.config.doc,
        node = doc ? doc.documentElement : null;

    if (node && node.style) {
        return ('MozTransition' in node.style || 'WebkitTransition' in node.style || 'transition' in node.style);
    }

    return false;
},
    "trigger": "app-transitions"
});
// autocomplete-list-keys
add('load', '1', {
    "name": "autocomplete-list-keys",
    "test": function (Y) {
    // Only add keyboard support to autocomplete-list if this doesn't appear to
    // be an iOS or Android-based mobile device.
    //
    // There's currently no feasible way to actually detect whether a device has
    // a hardware keyboard, so this sniff will have to do. It can easily be
    // overridden by manually loading the autocomplete-list-keys module.
    //
    // Worth noting: even though iOS supports bluetooth keyboards, Mobile Safari
    // doesn't fire the keyboard events used by AutoCompleteList, so there's
    // no point loading the -keys module even when a bluetooth keyboard may be
    // available.
    return !(Y.UA.ios || Y.UA.android);
},
    "trigger": "autocomplete-list"
});
// dd-gestures
add('load', '2', {
    "name": "dd-gestures",
    "trigger": "dd-drag",
    "ua": "touchEnabled"
});
// dom-style-ie
add('load', '3', {
    "name": "dom-style-ie",
    "test": function (Y) {

    var testFeature = Y.Features.test,
        addFeature = Y.Features.add,
        WINDOW = Y.config.win,
        DOCUMENT = Y.config.doc,
        DOCUMENT_ELEMENT = 'documentElement',
        ret = false;

    addFeature('style', 'computedStyle', {
        test: function() {
            return WINDOW && 'getComputedStyle' in WINDOW;
        }
    });

    addFeature('style', 'opacity', {
        test: function() {
            return DOCUMENT && 'opacity' in DOCUMENT[DOCUMENT_ELEMENT].style;
        }
    });

    ret =  (!testFeature('style', 'opacity') &&
            !testFeature('style', 'computedStyle'));

    return ret;
},
    "trigger": "dom-style"
});
// editor-para-ie
add('load', '4', {
    "name": "editor-para-ie",
    "trigger": "editor-para",
    "ua": "ie",
    "when": "instead"
});
// event-base-ie
add('load', '5', {
    "name": "event-base-ie",
    "test": function(Y) {
    var imp = Y.config.doc && Y.config.doc.implementation;
    return (imp && (!imp.hasFeature('Events', '2.0')));
},
    "trigger": "node-base"
});
// graphics-canvas
add('load', '6', {
    "name": "graphics-canvas",
    "test": function(Y) {
    var DOCUMENT = Y.config.doc,
        useCanvas = Y.config.defaultGraphicEngine && Y.config.defaultGraphicEngine == "canvas",
		canvas = DOCUMENT && DOCUMENT.createElement("canvas"),
        svg = (DOCUMENT && DOCUMENT.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"));
    return (!svg || useCanvas) && (canvas && canvas.getContext && canvas.getContext("2d"));
},
    "trigger": "graphics"
});
// graphics-canvas-default
add('load', '7', {
    "name": "graphics-canvas-default",
    "test": function(Y) {
    var DOCUMENT = Y.config.doc,
        useCanvas = Y.config.defaultGraphicEngine && Y.config.defaultGraphicEngine == "canvas",
		canvas = DOCUMENT && DOCUMENT.createElement("canvas"),
        svg = (DOCUMENT && DOCUMENT.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"));
    return (!svg || useCanvas) && (canvas && canvas.getContext && canvas.getContext("2d"));
},
    "trigger": "graphics"
});
// graphics-svg
add('load', '8', {
    "name": "graphics-svg",
    "test": function(Y) {
    var DOCUMENT = Y.config.doc,
        useSVG = !Y.config.defaultGraphicEngine || Y.config.defaultGraphicEngine != "canvas",
		canvas = DOCUMENT && DOCUMENT.createElement("canvas"),
        svg = (DOCUMENT && DOCUMENT.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"));

    return svg && (useSVG || !canvas);
},
    "trigger": "graphics"
});
// graphics-svg-default
add('load', '9', {
    "name": "graphics-svg-default",
    "test": function(Y) {
    var DOCUMENT = Y.config.doc,
        useSVG = !Y.config.defaultGraphicEngine || Y.config.defaultGraphicEngine != "canvas",
		canvas = DOCUMENT && DOCUMENT.createElement("canvas"),
        svg = (DOCUMENT && DOCUMENT.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"));

    return svg && (useSVG || !canvas);
},
    "trigger": "graphics"
});
// graphics-vml
add('load', '10', {
    "name": "graphics-vml",
    "test": function(Y) {
    var DOCUMENT = Y.config.doc,
		canvas = DOCUMENT && DOCUMENT.createElement("canvas");
    return (DOCUMENT && !DOCUMENT.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") && (!canvas || !canvas.getContext || !canvas.getContext("2d")));
},
    "trigger": "graphics"
});
// graphics-vml-default
add('load', '11', {
    "name": "graphics-vml-default",
    "test": function(Y) {
    var DOCUMENT = Y.config.doc,
		canvas = DOCUMENT && DOCUMENT.createElement("canvas");
    return (DOCUMENT && !DOCUMENT.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") && (!canvas || !canvas.getContext || !canvas.getContext("2d")));
},
    "trigger": "graphics"
});
// history-hash-ie
add('load', '12', {
    "name": "history-hash-ie",
    "test": function (Y) {
    var docMode = Y.config.doc && Y.config.doc.documentMode;

    return Y.UA.ie && (!('onhashchange' in Y.config.win) ||
            !docMode || docMode < 8);
},
    "trigger": "history-hash"
});
// io-nodejs
add('load', '13', {
    "name": "io-nodejs",
    "trigger": "io-base",
    "ua": "nodejs"
});
// json-parse-shim
add('load', '14', {
    "name": "json-parse-shim",
    "test": function (Y) {
    var _JSON = Y.config.global.JSON,
        Native = Object.prototype.toString.call(_JSON) === '[object JSON]' && _JSON,
        nativeSupport = Y.config.useNativeJSONParse !== false && !!Native;

    function workingNative( k, v ) {
        return k === "ok" ? true : v;
    }

    // Double check basic functionality.  This is mainly to catch early broken
    // implementations of the JSON API in Firefox 3.1 beta1 and beta2
    if ( nativeSupport ) {
        try {
            nativeSupport = ( Native.parse( '{"ok":false}', workingNative ) ).ok;
        }
        catch ( e ) {
            nativeSupport = false;
        }
    }

    return !nativeSupport;
},
    "trigger": "json-parse"
});
// json-stringify-shim
add('load', '15', {
    "name": "json-stringify-shim",
    "test": function (Y) {
    var _JSON = Y.config.global.JSON,
        Native = Object.prototype.toString.call(_JSON) === '[object JSON]' && _JSON,
        nativeSupport = Y.config.useNativeJSONStringify !== false && !!Native;

    // Double check basic native functionality.  This is primarily to catch broken
    // early JSON API implementations in Firefox 3.1 beta1 and beta2.
    if ( nativeSupport ) {
        try {
            nativeSupport = ( '0' === Native.stringify(0) );
        } catch ( e ) {
            nativeSupport = false;
        }
    }


    return !nativeSupport;
},
    "trigger": "json-stringify"
});
// scrollview-base-ie
add('load', '16', {
    "name": "scrollview-base-ie",
    "trigger": "scrollview-base",
    "ua": "ie"
});
// selector-css2
add('load', '17', {
    "name": "selector-css2",
    "test": function (Y) {
    var DOCUMENT = Y.config.doc,
        ret = DOCUMENT && !('querySelectorAll' in DOCUMENT);

    return ret;
},
    "trigger": "selector"
});
// transition-timer
add('load', '18', {
    "name": "transition-timer",
    "test": function (Y) {
    var DOCUMENT = Y.config.doc,
        node = (DOCUMENT) ? DOCUMENT.documentElement: null,
        ret = true;

    if (node && node.style) {
        ret = !('MozTransition' in node.style || 'WebkitTransition' in node.style || 'transition' in node.style);
    }

    return ret;
},
    "trigger": "transition"
});
// widget-base-ie
add('load', '19', {
    "name": "widget-base-ie",
    "trigger": "widget-base",
    "ua": "ie"
});
// yql-jsonp
add('load', '20', {
    "name": "yql-jsonp",
    "test": function (Y) {
    /* Only load the JSONP module when not in nodejs or winjs
    TODO Make the winjs module a CORS module
    */
    return (!Y.UA.nodejs && !Y.UA.winjs);
},
    "trigger": "yql"
});
// yql-nodejs
add('load', '21', {
    "name": "yql-nodejs",
    "trigger": "yql",
    "ua": "nodejs"
});
// yql-winjs
add('load', '22', {
    "name": "yql-winjs",
    "trigger": "yql",
    "ua": "winjs"
});

}, '3.17.2', {"requires": ["yui-base"]});
YUI.add('intl-base', function (Y, NAME) {

/**
 * The Intl utility provides a central location for managing sets of
 * localized resources (strings and formatting patterns).
 *
 * @class Intl
 * @uses EventTarget
 * @static
 */

var SPLIT_REGEX = /[, ]/;

Y.mix(Y.namespace('Intl'), {

 /**
    * Returns the language among those available that
    * best matches the preferred language list, using the Lookup
    * algorithm of BCP 47.
    * If none of the available languages meets the user's preferences,
    * then "" is returned.
    * Extended language ranges are not supported.
    *
    * @method lookupBestLang
    * @param {String[] | String} preferredLanguages The list of preferred
    * languages in descending preference order, represented as BCP 47
    * language tags. A string array or a comma-separated list.
    * @param {String[]} availableLanguages The list of languages
    * that the application supports, represented as BCP 47 language
    * tags.
    *
    * @return {String} The available language that best matches the
    * preferred language list, or "".
    * @since 3.1.0
    */
    lookupBestLang: function(preferredLanguages, availableLanguages) {

        var i, language, result, index;

        // check whether the list of available languages contains language;
        // if so return it
        function scan(language) {
            var i;
            for (i = 0; i < availableLanguages.length; i += 1) {
                if (language.toLowerCase() ===
                            availableLanguages[i].toLowerCase()) {
                    return availableLanguages[i];
                }
            }
        }

        if (Y.Lang.isString(preferredLanguages)) {
            preferredLanguages = preferredLanguages.split(SPLIT_REGEX);
        }

        for (i = 0; i < preferredLanguages.length; i += 1) {
            language = preferredLanguages[i];
            if (!language || language === '*') {
                continue;
            }
            // check the fallback sequence for one language
            while (language.length > 0) {
                result = scan(language);
                if (result) {
                    return result;
                } else {
                    index = language.lastIndexOf('-');
                    if (index >= 0) {
                        language = language.substring(0, index);
                        // one-character subtags get cut along with the
                        // following subtag
                        if (index >= 2 && language.charAt(index - 2) === '-') {
                            language = language.substring(0, index - 2);
                        }
                    } else {
                        // nothing available for this language
                        break;
                    }
                }
            }
        }

        return '';
    }
});


}, '3.17.2', {"requires": ["yui-base"]});
YUI.add('yui-log', function (Y, NAME) {

/**
 * Provides console log capability and exposes a custom event for
 * console implementations. This module is a `core` YUI module,
 * <a href="../classes/YUI.html#method_log">it's documentation is located under the YUI class</a>.
 *
 * @module yui
 * @submodule yui-log
 */

var INSTANCE = Y,
    LOGEVENT = 'yui:log',
    UNDEFINED = 'undefined',
    LEVELS = { debug: 1,
               info: 2,
               warn: 4,
               error: 8 };

/**
 * If the 'debug' config is true, a 'yui:log' event will be
 * dispatched, which the Console widget and anything else
 * can consume.  If the 'useBrowserConsole' config is true, it will
 * write to the browser console if available.  YUI-specific log
 * messages will only be present in the -debug versions of the
 * JS files.  The build system is supposed to remove log statements
 * from the raw and minified versions of the files.
 *
 * @method log
 * @for YUI
 * @param  {String}  msg  The message to log.
 * @param  {String}  cat  The log category for the message.  Default
 *                        categories are "info", "warn", "error", "debug".
 *                        Custom categories can be used as well. (opt).
 * @param  {String}  src  The source of the the message (opt).
 * @param  {boolean} silent If true, the log event won't fire.
 * @return {YUI}      YUI instance.
 */
INSTANCE.log = function(msg, cat, src, silent) {
    var bail, excl, incl, m, f, minlevel,
        Y = INSTANCE,
        c = Y.config,
        publisher = (Y.fire) ? Y : YUI.Env.globalEvents;
    // suppress log message if the config is off or the event stack
    // or the event call stack contains a consumer of the yui:log event
    if (c.debug) {
        // apply source filters
        src = src || "";
        if (typeof src !== "undefined") {
            excl = c.logExclude;
            incl = c.logInclude;
            if (incl && !(src in incl)) {
                bail = 1;
            } else if (incl && (src in incl)) {
                bail = !incl[src];
            } else if (excl && (src in excl)) {
                bail = excl[src];
            }

            // Set a default category of info if the category was not defined.
            if ((typeof cat === 'undefined')) {
                cat = 'info';
            }

            // Determine the current minlevel as defined in configuration
            Y.config.logLevel = Y.config.logLevel || 'debug';
            minlevel = LEVELS[Y.config.logLevel.toLowerCase()];

            if (cat in LEVELS && LEVELS[cat] < minlevel) {
                // Skip this message if the we don't meet the defined minlevel
                bail = 1;
            }
        }
        if (!bail) {
            if (c.useBrowserConsole) {
                m = (src) ? src + ': ' + msg : msg;
                if (Y.Lang.isFunction(c.logFn)) {
                    c.logFn.call(Y, msg, cat, src);
                } else if (typeof console !== UNDEFINED && console.log) {
                    f = (cat && console[cat] && (cat in LEVELS)) ? cat : 'log';
                    console[f](m);
                } else if (typeof opera !== UNDEFINED) {
                    opera.postError(m);
                }
            }

            if (publisher && !silent) {

                if (publisher === Y && (!publisher.getEvent(LOGEVENT))) {
                    publisher.publish(LOGEVENT, {
                        broadcast: 2
                    });
                }

                publisher.fire(LOGEVENT, {
                    msg: msg,
                    cat: cat,
                    src: src
                });
            }
        }
    }

    return Y;
};

/**
 * Write a system message.  This message will be preserved in the
 * minified and raw versions of the YUI files, unlike log statements.
 * @method message
 * @for YUI
 * @param  {String}  msg  The message to log.
 * @param  {String}  cat  The log category for the message.  Default
 *                        categories are "info", "warn", "error", "debug".
 *                        Custom categories can be used as well. (opt).
 * @param  {String}  src  The source of the the message (opt).
 * @param  {boolean} silent If true, the log event won't fire.
 * @return {YUI}      YUI instance.
 */
INSTANCE.message = function() {
    return INSTANCE.log.apply(INSTANCE, arguments);
};


}, '3.17.2', {"requires": ["yui-base"]});
YUI.add('yui-later', function (Y, NAME) {

/**
 * Provides a setTimeout/setInterval wrapper. This module is a `core` YUI module,
 * <a href="../classes/YUI.html#method_later">it's documentation is located under the YUI class</a>.
 *
 * @module yui
 * @submodule yui-later
 */

var NO_ARGS = [];

/**
 * Executes the supplied function in the context of the supplied
 * object 'when' milliseconds later.  Executes the function a
 * single time unless periodic is set to true.
 * @for YUI
 * @method later
 * @param when {Number} the number of milliseconds to wait until the fn
 * is executed.
 * @param o the context object.
 * @param fn {Function|String} the function to execute or the name of
 * the method in the 'o' object to execute.
 * @param data [Array] data that is provided to the function.  This
 * accepts either a single item or an array.  If an array is provided,
 * the function is executed with one parameter for each array item.
 * If you need to pass a single array parameter, it needs to be wrapped
 * in an array [myarray].
 *
 * Note: native methods in IE may not have the call and apply methods.
 * In this case, it will work, but you are limited to four arguments.
 *
 * @param periodic {boolean} if true, executes continuously at supplied
 * interval until canceled.
 * @return {object} a timer object. Call the cancel() method on this
 * object to stop the timer.
 */
Y.later = function(when, o, fn, data, periodic) {
    when = when || 0;
    data = (!Y.Lang.isUndefined(data)) ? Y.Array(data) : NO_ARGS;
    o = o || Y.config.win || Y;

    var cancelled = false,
        method = (o && Y.Lang.isString(fn)) ? o[fn] : fn,
        wrapper = function() {
            // IE 8- may execute a setInterval callback one last time
            // after clearInterval was called, so in order to preserve
            // the cancel() === no more runny-run, we have to jump through
            // an extra hoop.
            if (!cancelled) {
                if (!method.apply) {
                    method(data[0], data[1], data[2], data[3]);
                } else {
                    method.apply(o, data || NO_ARGS);
                }
            }
        },
        id = (periodic) ? Y.config.win.setInterval(wrapper, when) : Y.config.win.setTimeout(wrapper, when);

    return {
        id: id,
        interval: periodic,
        cancel: function() {
            cancelled = true;
            if (this.interval) {
                Y.config.win.clearInterval(id);
            } else {
                Y.config.win.clearTimeout(id);
            }
        }
    };
};

Y.Lang.later = Y.later;



}, '3.17.2', {"requires": ["yui-base"]});
YUI.add('yui', function (Y, NAME) {}, '3.17.2', {"use": ["get", "features", "intl-base", "yui-log", "yui-later"]});

/*** EXPORTS FROM exports-loader ***/



/***/ }),

/***/ 126945:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(44001);
var ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__(715259);
var ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;
var ___EXPOSE_LOADER_IMPORT_MODULE_LOCAL_NAME___ = ___EXPOSE_LOADER_IMPORT___.YUI
___EXPOSE_LOADER_GLOBAL_THIS___["YUI"] = ___EXPOSE_LOADER_IMPORT_MODULE_LOCAL_NAME___;
module.exports = ___EXPOSE_LOADER_IMPORT___;


/***/ }),

/***/ 878515:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('anim-base', function (Y, NAME) {

/**
* The Animation Utility provides an API for creating advanced transitions.
* @module anim
*/

/**
* Provides the base Anim class, for animating numeric properties.
*
* @module anim
* @submodule anim-base
*/

    /**
     * A class for constructing animation instances.
     * @class Anim
     * @for Anim
     * @constructor
     * @extends Base
     */

    var RUNNING = 'running',
        START_TIME = 'startTime',
        ELAPSED_TIME = 'elapsedTime',
        /**
        * @for Anim
        * @event start
        * @description fires when an animation begins.
        * @param {Event} ev The start event.
        * @type Event.Custom
        */
        START = 'start',

        /**
        * @event tween
        * @description fires every frame of the animation.
        * @param {Event} ev The tween event.
        * @type Event.Custom
        */
        TWEEN = 'tween',

        /**
        * @event end
        * @description fires after the animation completes.
        * @param {Event} ev The end event.
        * @type Event.Custom
        */
        END = 'end',
        NODE = 'node',
        PAUSED = 'paused',
        REVERSE = 'reverse', // TODO: cleanup
        ITERATION_COUNT = 'iterationCount',

        NUM = Number;

    var _running = {},
        _timer;

    Y.Anim = function() {
        Y.Anim.superclass.constructor.apply(this, arguments);
        Y.Anim._instances[Y.stamp(this)] = this;
    };

    Y.Anim.NAME = 'anim';

    Y.Anim._instances = {};

    /**
     * Regex of properties that should use the default unit.
     *
     * @property RE_DEFAULT_UNIT
     * @static
     */
    Y.Anim.RE_DEFAULT_UNIT = /^width|height|top|right|bottom|left|margin.*|padding.*|border.*$/i;

    /**
     * The default unit to use with properties that pass the RE_DEFAULT_UNIT test.
     *
     * @property DEFAULT_UNIT
     * @static
     */
    Y.Anim.DEFAULT_UNIT = 'px';

    Y.Anim.DEFAULT_EASING = function (t, b, c, d) {
        return c * t / d + b; // linear easing
    };

    /**
     * Time in milliseconds passed to setInterval for frame processing
     *
     * @property intervalTime
     * @default 20
     * @static
     */
    Y.Anim._intervalTime = 20;

    /**
     * Bucket for custom getters and setters
     *
     * @property behaviors
     * @static
     */
    Y.Anim.behaviors = {
        left: {
            get: function(anim, attr) {
                return anim._getOffset(attr);
            }
        }
    };

    Y.Anim.behaviors.top = Y.Anim.behaviors.left;

    /**
     * The default setter to use when setting object properties.
     *
     * @property DEFAULT_SETTER
     * @static
     */
    Y.Anim.DEFAULT_SETTER = function(anim, att, from, to, elapsed, duration, fn, unit) {
        var node = anim._node,
            domNode = node._node,
            val = fn(elapsed, NUM(from), NUM(to) - NUM(from), duration);

        if (domNode) {
            if ('style' in domNode && (att in domNode.style || att in Y.DOM.CUSTOM_STYLES)) {
                unit = unit || '';
                node.setStyle(att, val + unit);
            } else if ('attributes' in domNode && att in domNode.attributes) {
                node.setAttribute(att, val);
            } else if (att in domNode) {
                domNode[att] = val;
            }
        } else if (node.set) {
            node.set(att, val);
        } else if (att in node) {
            node[att] = val;
        }
    };

    /**
     * The default getter to use when getting object properties.
     *
     * @property DEFAULT_GETTER
     * @static
     */
    Y.Anim.DEFAULT_GETTER = function(anim, att) {
        var node = anim._node,
            domNode = node._node,
            val = '';

        if (domNode) {
            if ('style' in domNode && (att in domNode.style || att in Y.DOM.CUSTOM_STYLES)) {
                val = node.getComputedStyle(att);
            } else if ('attributes' in domNode && att in domNode.attributes) {
                val = node.getAttribute(att);
            } else if (att in domNode) {
                val = domNode[att];
            }
        } else if (node.get) {
            val = node.get(att);
        } else if (att in node) {
            val = node[att];
        }

        return val;
    };

    Y.Anim.ATTRS = {
        /**
         * The object to be animated.
         * @attribute node
         * @type Node
         */
        node: {
            setter: function(node) {
                if (node) {
                    if (typeof node === 'string' || node.nodeType) {
                        node = Y.one(node);
                    }
                }

                this._node = node;
                if (!node) {
                }
                return node;
            }
        },

        /**
         * The length of the animation.  Defaults to "1" (second).
         * @attribute duration
         * @type NUM
         */
        duration: {
            value: 1
        },

        /**
         * The method that will provide values to the attribute(s) during the animation.
         * Defaults to "Easing.easeNone".
         * @attribute easing
         * @type Function
         */
        easing: {
            value: Y.Anim.DEFAULT_EASING,

            setter: function(val) {
                if (typeof val === 'string' && Y.Easing) {
                    return Y.Easing[val];
                }
            }
        },

        /**
         * The starting values for the animated properties.
         *
         * Fields may be strings, numbers, or functions.
         * If a function is used, the return value becomes the from value.
         * If no from value is specified, the DEFAULT_GETTER will be used.
         * Supports any unit, provided it matches the "to" (or default)
         * unit (e.g. `{width: '10em', color: 'rgb(0, 0, 0)', borderColor: '#ccc'}`).
         *
         * If using the default ('px' for length-based units), the unit may be omitted
         * (e.g. `{width: 100}, borderColor: 'ccc'}`, which defaults to pixels
         * and hex, respectively).
         *
         * @attribute from
         * @type Object
         */
        from: {},

        /**
         * The ending values for the animated properties.
         *
         * Fields may be strings, numbers, or functions.
         * Supports any unit, provided it matches the "from" (or default)
         * unit (e.g. `{width: '50%', color: 'red', borderColor: '#ccc'}`).
         *
         * If using the default ('px' for length-based units), the unit may be omitted
         * (e.g. `{width: 100, borderColor: 'ccc'}`, which defaults to pixels
         * and hex, respectively).
         *
         * @attribute to
         * @type Object
         */
        to: {},

        /**
         * Date stamp for the first frame of the animation.
         * @attribute startTime
         * @type Int
         * @default 0
         * @readOnly
         */
        startTime: {
            value: 0,
            readOnly: true
        },

        /**
         * Current time the animation has been running.
         * @attribute elapsedTime
         * @type Int
         * @default 0
         * @readOnly
         */
        elapsedTime: {
            value: 0,
            readOnly: true
        },

        /**
         * Whether or not the animation is currently running.
         * @attribute running
         * @type Boolean
         * @default false
         * @readOnly
         */
        running: {
            getter: function() {
                return !!_running[Y.stamp(this)];
            },
            value: false,
            readOnly: true
        },

        /**
         * The number of times the animation should run
         * @attribute iterations
         * @type Int
         * @default 1
         */
        iterations: {
            value: 1
        },

        /**
         * The number of iterations that have occurred.
         * Resets when an animation ends (reaches iteration count or stop() called).
         * @attribute iterationCount
         * @type Int
         * @default 0
         * @readOnly
         */
        iterationCount: {
            value: 0,
            readOnly: true
        },

        /**
         * How iterations of the animation should behave.
         * Possible values are "normal" and "alternate".
         * Normal will repeat the animation, alternate will reverse on every other pass.
         *
         * @attribute direction
         * @type String
         * @default "normal"
         */
        direction: {
            value: 'normal' // | alternate (fwd on odd, rev on even per spec)
        },

        /**
         * Whether or not the animation is currently paused.
         * @attribute paused
         * @type Boolean
         * @default false
         * @readOnly
         */
        paused: {
            readOnly: true,
            value: false
        },

        /**
         * If true, the `from` and `to` attributes are swapped, 
         * and the animation is then run starting from `from`.
         * @attribute reverse
         * @type Boolean
         * @default false
         */
        reverse: {
            value: false
        }


    };

    /**
     * Runs all animation instances.
     * @method run
     * @static
     */
    Y.Anim.run = function() {
        var instances = Y.Anim._instances,
            i;
        for (i in instances) {
            if (instances[i].run) {
                instances[i].run();
            }
        }
    };

    /**
     * Pauses all animation instances.
     * @method pause
     * @static
     */
    Y.Anim.pause = function() {
        for (var i in _running) { // stop timer if nothing running
            if (_running[i].pause) {
                _running[i].pause();
            }
        }

        Y.Anim._stopTimer();
    };

    /**
     * Stops all animation instances.
     * @method stop
     * @static
     */
    Y.Anim.stop = function() {
        for (var i in _running) { // stop timer if nothing running
            if (_running[i].stop) {
                _running[i].stop();
            }
        }
        Y.Anim._stopTimer();
    };

    Y.Anim._startTimer = function() {
        if (!_timer) {
            _timer = setInterval(Y.Anim._runFrame, Y.Anim._intervalTime);
        }
    };

    Y.Anim._stopTimer = function() {
        clearInterval(_timer);
        _timer = 0;
    };

    /**
     * Called per Interval to handle each animation frame.
     * @method _runFrame
     * @private
     * @static
     */
    Y.Anim._runFrame = function() {
        var done = true,
            anim;
        for (anim in _running) {
            if (_running[anim]._runFrame) {
                done = false;
                _running[anim]._runFrame();
            }
        }

        if (done) {
            Y.Anim._stopTimer();
        }
    };

    Y.Anim.RE_UNITS = /^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/;

    var proto = {
        /**
         * Starts or resumes an animation.
         * @method run
         * @chainable
         */
        run: function() {
            if (this.get(PAUSED)) {
                this._resume();
            } else if (!this.get(RUNNING)) {
                this._start();
            }
            return this;
        },

        /**
         * Pauses the animation and
         * freezes it in its current state and time.
         * Calling run() will continue where it left off.
         * @method pause
         * @chainable
         */
        pause: function() {
            if (this.get(RUNNING)) {
                this._pause();
            }
            return this;
        },

        /**
         * Stops the animation and resets its time.
         * @method stop
         * @param {Boolean} finish If true, the animation will move to the last frame
         * @chainable
         */
        stop: function(finish) {
            if (this.get(RUNNING) || this.get(PAUSED)) {
                this._end(finish);
            }
            return this;
        },

        _added: false,

        _start: function() {
            this._set(START_TIME, new Date() - this.get(ELAPSED_TIME));
            this._actualFrames = 0;
            if (!this.get(PAUSED)) {
                this._initAnimAttr();
            }
            _running[Y.stamp(this)] = this;
            Y.Anim._startTimer();

            this.fire(START);
        },

        _pause: function() {
            this._set(START_TIME, null);
            this._set(PAUSED, true);
            delete _running[Y.stamp(this)];

            /**
            * @event pause
            * @description fires when an animation is paused.
            * @param {Event} ev The pause event.
            * @type Event.Custom
            */
            this.fire('pause');
        },

        _resume: function() {
            this._set(PAUSED, false);
            _running[Y.stamp(this)] = this;
            this._set(START_TIME, new Date() - this.get(ELAPSED_TIME));
            Y.Anim._startTimer();

            /**
            * @event resume
            * @description fires when an animation is resumed (run from pause).
            * @param {Event} ev The pause event.
            * @type Event.Custom
            */
            this.fire('resume');
        },

        _end: function(finish) {
            var duration = this.get('duration') * 1000;
            if (finish) { // jump to last frame
                this._runAttrs(duration, duration, this.get(REVERSE));
            }

            this._set(START_TIME, null);
            this._set(ELAPSED_TIME, 0);
            this._set(PAUSED, false);

            delete _running[Y.stamp(this)];
            this.fire(END, {elapsed: this.get(ELAPSED_TIME)});
        },

        _runFrame: function() {
            var d = this._runtimeAttr.duration,
                t = new Date() - this.get(START_TIME),
                reverse = this.get(REVERSE),
                done = (t >= d);

            this._runAttrs(t, d, reverse);
            this._actualFrames += 1;
            this._set(ELAPSED_TIME, t);

            this.fire(TWEEN);
            if (done) {
                this._lastFrame();
            }
        },

        _runAttrs: function(t, d, reverse) {
            var attr = this._runtimeAttr,
                customAttr = Y.Anim.behaviors,
                easing = attr.easing,
                lastFrame = d,
                done = false,
                attribute,
                setter,
                i;

            if (t >= d) {
                done = true;
            }

            if (reverse) {
                t = d - t;
                lastFrame = 0;
            }

            for (i in attr) {
                if (attr[i].to) {
                    attribute = attr[i];
                    setter = (i in customAttr && 'set' in customAttr[i]) ?
                            customAttr[i].set : Y.Anim.DEFAULT_SETTER;

                    if (!done) {
                        setter(this, i, attribute.from, attribute.to, t, d, easing, attribute.unit);
                    } else {
                        setter(this, i, attribute.from, attribute.to, lastFrame, d, easing, attribute.unit);
                    }
                }
            }


        },

        _lastFrame: function() {
            var iter = this.get('iterations'),
                iterCount = this.get(ITERATION_COUNT);

            iterCount += 1;
            if (iter === 'infinite' || iterCount < iter) {
                if (this.get('direction') === 'alternate') {
                    this.set(REVERSE, !this.get(REVERSE)); // flip it
                }
                /**
                * @event iteration
                * @description fires when an animation begins an iteration.
                * @param {Event} ev The iteration event.
                * @type Event.Custom
                */
                this.fire('iteration');
            } else {
                iterCount = 0;
                this._end();
            }

            this._set(START_TIME, new Date());
            this._set(ITERATION_COUNT, iterCount);
        },

        _initAnimAttr: function() {
            var from = this.get('from') || {},
                to = this.get('to') || {},
                attr = {
                    duration: this.get('duration') * 1000,
                    easing: this.get('easing')
                },
                customAttr = Y.Anim.behaviors,
                node = this.get(NODE), // implicit attr init
                unit, begin, end;

            Y.each(to, function(val, name) {
                if (typeof val === 'function') {
                    val = val.call(this, node);
                }

                begin = from[name];
                if (begin === undefined) {
                    begin = (name in customAttr && 'get' in customAttr[name])  ?
                            customAttr[name].get(this, name) : Y.Anim.DEFAULT_GETTER(this, name);
                } else if (typeof begin === 'function') {
                    begin = begin.call(this, node);
                }

                var mFrom = Y.Anim.RE_UNITS.exec(begin),
                    mTo = Y.Anim.RE_UNITS.exec(val);

                begin = mFrom ? mFrom[1] : begin;
                end = mTo ? mTo[1] : val;
                unit = mTo ? mTo[2] : mFrom ?  mFrom[2] : ''; // one might be zero TODO: mixed units

                if (!unit && Y.Anim.RE_DEFAULT_UNIT.test(name)) {
                    unit = Y.Anim.DEFAULT_UNIT;
                }

                if (!begin || !end) {
                    Y.error('invalid "from" or "to" for "' + name + '"', 'Anim');
                    return;
                }

                attr[name] = {
                    from: Y.Lang.isObject(begin) ? Y.clone(begin) : begin,
                    to: end,
                    unit: unit
                };

            }, this);

            this._runtimeAttr = attr;
        },


        // TODO: move to computedStyle? (browsers dont agree on default computed offsets)
        _getOffset: function(attr) {
            var node = this._node,
                val = node.getComputedStyle(attr),
                get = (attr === 'left') ? 'getX': 'getY',
                set = (attr === 'left') ? 'setX': 'setY',
                position;

            if (val === 'auto') {
                position = node.getStyle('position');
                if (position === 'absolute' || position === 'fixed') {
                    val = node[get]();
                    node[set](val);
                } else {
                    val = 0;
                }
            }

            return val;
        },

        destructor: function() {
            delete Y.Anim._instances[Y.stamp(this)];
        }
    };

    Y.extend(Y.Anim, Y.Base, proto);


}, '3.17.2', {"requires": ["base-base", "node-style", "color-base"]});


/***/ }),

/***/ 568096:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('anim-color', function (Y, NAME) {

/**
 * Adds support for color properties in <code>to</code>
 * and <code>from</code> attributes.
 * @module anim
 * @submodule anim-color
 */

var NUM = Number;

Y.Anim.getUpdatedColorValue = function(fromColor, toColor, elapsed, duration,  fn)
{
    fromColor = Y.Color.re_RGB.exec(Y.Color.toRGB(fromColor));
    toColor = Y.Color.re_RGB.exec(Y.Color.toRGB(toColor));

    if (!fromColor || fromColor.length < 3 || !toColor || toColor.length < 3) {
        Y.error('invalid from or to passed to color behavior');
    }

    return 'rgb(' + [
        Math.floor(fn(elapsed, NUM(fromColor[1]), NUM(toColor[1]) - NUM(fromColor[1]), duration)),
        Math.floor(fn(elapsed, NUM(fromColor[2]), NUM(toColor[2]) - NUM(fromColor[2]), duration)),
        Math.floor(fn(elapsed, NUM(fromColor[3]), NUM(toColor[3]) - NUM(fromColor[3]), duration))
    ].join(', ') + ')';
};

Y.Anim.behaviors.color = {
    set: function(anim, att, from, to, elapsed, duration, fn) {
        anim._node.setStyle(att, Y.Anim.getUpdatedColorValue(from, to, elapsed, duration, fn));
    },

    // TODO: default bgcolor const
    get: function(anim, att) {
        var val = anim._node.getComputedStyle(att);
        val = (val === 'transparent') ? 'rgb(255, 255, 255)' : val;
        return val;
    }
};

Y.each(['backgroundColor',
        'borderColor',
        'borderTopColor',
        'borderRightColor',
        'borderBottomColor',
        'borderLeftColor'],
        function(v) {
            Y.Anim.behaviors[v] = Y.Anim.behaviors.color;
        }
);


}, '3.17.2', {"requires": ["anim-base"]});


/***/ }),

/***/ 263446:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('anim-curve', function (Y, NAME) {

/**
 * Adds support for the <code>curve</code> property for the <code>to</code>
 * attribute.  A curve is zero or more control points and an end point.
 * @module anim
 * @submodule anim-curve
 */

Y.Anim.behaviors.curve = {
    set: function(anim, att, from, to, elapsed, duration, fn) {
        from = from.slice.call(from);
        to = to.slice.call(to);
        var t = fn(elapsed, 0, 100, duration) / 100;
        to.unshift(from);
        anim._node.setXY(Y.Anim.getBezier(to, t));
    },

    get: function(anim) {
        return anim._node.getXY();
    }
};

/**
 * Get the current position of the animated element based on t.
 * Each point is an array of "x" and "y" values (0 = x, 1 = y)
 * At least 2 points are required (start and end).
 * First point is start. Last point is end.
 * Additional control points are optional.
 * @for Anim
 * @method getBezier
 * @static
 * @param {Number[]} points An array containing Bezier points
 * @param {Number} t A number between 0 and 1 which is the basis for determining current position
 * @return {Number[]} An array containing int x and y member data
 */
Y.Anim.getBezier = function(points, t) {
    var n = points.length,
        tmp = [],
        i,
        j;

    for (i = 0; i < n; ++i){
        tmp[i] = [points[i][0], points[i][1]]; // save input
    }

    for (j = 1; j < n; ++j) {
        for (i = 0; i < n - j; ++i) {
            tmp[i][0] = (1 - t) * tmp[i][0] + t * tmp[parseInt(i + 1, 10)][0];
            tmp[i][1] = (1 - t) * tmp[i][1] + t * tmp[parseInt(i + 1, 10)][1];
        }
    }

    return [ tmp[0][0], tmp[0][1] ];

};


}, '3.17.2', {"requires": ["anim-xy"]});


/***/ }),

/***/ 699993:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('anim-easing', function (Y, NAME) {

/*
TERMS OF USE - EASING EQUATIONS
Open source under the BSD License.
Copyright 2001 Robert Penner All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
 * Neither the name of the author nor the names of contributors may be used to
    endorse or promote products derived from this software without specific prior
    written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/**
 * The easing module provides methods for customizing
 * how an animation behaves during each run.
 * @class Easing
 * @module anim
 * @submodule anim-easing
 */

var Easing = {

    /**
     * Uniform speed between points.
     * @for Easing
     * @method easeNone
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeNone: function (t, b, c, d) {
        return c*t/d + b;
    },

    /**
     * Begins slowly and accelerates towards end. (quadratic)
     * @method easeIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeIn: function (t, b, c, d) {
        return c*(t/=d)*t + b;
    },

    /**
     * Begins quickly and decelerates towards end.  (quadratic)
     * @method easeOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeOut: function (t, b, c, d) {
        return -c *(t/=d)*(t-2) + b;
    },

    /**
     * Begins slowly and decelerates towards end. (quadratic)
     * @method easeBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeBoth: function (t, b, c, d) {
        if ((t /= d/2) < 1) {
            return c/2*t*t + b;
        }

        return -c/2 * ((--t)*(t-2) - 1) + b;
    },

    /**
     * Begins slowly and accelerates towards end. (quartic)
     * @method easeInStrong
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeInStrong: function (t, b, c, d) {
        return c*(t/=d)*t*t*t + b;
    },

    /**
     * Begins quickly and decelerates towards end.  (quartic)
     * @method easeOutStrong
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeOutStrong: function (t, b, c, d) {
        return -c * ((t=t/d-1)*t*t*t - 1) + b;
    },

    /**
     * Begins slowly and decelerates towards end. (quartic)
     * @method easeBothStrong
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeBothStrong: function (t, b, c, d) {
        if ((t /= d/2) < 1) {
            return c/2*t*t*t*t + b;
        }

        return -c/2 * ((t-=2)*t*t*t - 2) + b;
    },

    /**
     * Snap in elastic effect.
     * @method elasticIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} a Amplitude (optional)
     * @param {Number} p Period (optional)
     * @return {Number} The computed value for the current animation frame
     */

    elasticIn: function (t, b, c, d, a, p) {
        var s;
        if (t === 0) {
            return b;
        }
        if ( (t /= d) === 1 ) {
            return b+c;
        }
        if (!p) {
            p = d* 0.3;
        }

        if (!a || a < Math.abs(c)) {
            a = c;
            s = p/4;
        }
        else {
            s = p/(2*Math.PI) * Math.asin (c/a);
        }

        return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
    },

    /**
     * Snap out elastic effect.
     * @method elasticOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} a Amplitude (optional)
     * @param {Number} p Period (optional)
     * @return {Number} The computed value for the current animation frame
     */
    elasticOut: function (t, b, c, d, a, p) {
        var s;
        if (t === 0) {
            return b;
        }
        if ( (t /= d) === 1 ) {
            return b+c;
        }
        if (!p) {
            p=d * 0.3;
        }

        if (!a || a < Math.abs(c)) {
            a = c;
            s = p / 4;
        }
        else {
            s = p/(2*Math.PI) * Math.asin (c/a);
        }

        return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
    },

    /**
     * Snap both elastic effect.
     * @method elasticBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} a Amplitude (optional)
     * @param {Number} p Period (optional)
     * @return {Number} The computed value for the current animation frame
     */
    elasticBoth: function (t, b, c, d, a, p) {
        var s;
        if (t === 0) {
            return b;
        }

        if ( (t /= d/2) === 2 ) {
            return b+c;
        }

        if (!p) {
            p = d*(0.3*1.5);
        }

        if ( !a || a < Math.abs(c) ) {
            a = c;
            s = p/4;
        }
        else {
            s = p/(2*Math.PI) * Math.asin (c/a);
        }

        if (t < 1) {
            return -0.5*(a*Math.pow(2,10*(t-=1)) *
                    Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
        }
        return a*Math.pow(2,-10*(t-=1)) *
                Math.sin( (t*d-s)*(2*Math.PI)/p )*0.5 + c + b;
    },


    /**
     * Backtracks slightly, then reverses direction and moves to end.
     * @method backIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} s Overshoot (optional)
     * @return {Number} The computed value for the current animation frame
     */
    backIn: function (t, b, c, d, s) {
        if (s === undefined) {
            s = 1.70158;
        }
        if (t === d) {
            t -= 0.001;
        }
        return c*(t/=d)*t*((s+1)*t - s) + b;
    },

    /**
     * Overshoots end, then reverses and comes back to end.
     * @method backOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} s Overshoot (optional)
     * @return {Number} The computed value for the current animation frame
     */
    backOut: function (t, b, c, d, s) {
        if (typeof s === 'undefined') {
            s = 1.70158;
        }
        return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
    },

    /**
     * Backtracks slightly, then reverses direction, overshoots end,
     * then reverses and comes back to end.
     * @method backBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} s Overshoot (optional)
     * @return {Number} The computed value for the current animation frame
     */
    backBoth: function (t, b, c, d, s) {
        if (typeof s === 'undefined') {
            s = 1.70158;
        }

        if ((t /= d/2 ) < 1) {
            return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
        }
        return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
    },

    /**
     * Bounce off of start.
     * @method bounceIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    bounceIn: function (t, b, c, d) {
        return c - Y.Easing.bounceOut(d-t, 0, c, d) + b;
    },

    /**
     * Bounces off end.
     * @method bounceOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    bounceOut: function (t, b, c, d) {
        if ((t/=d) < (1/2.75)) {
                return c*(7.5625*t*t) + b;
        } else if (t < (2/2.75)) {
                return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b;
        } else if (t < (2.5/2.75)) {
                return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b;
        }
        return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b;
    },

    /**
     * Bounces off start and end.
     * @method bounceBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    bounceBoth: function (t, b, c, d) {
        if (t < d/2) {
            return Y.Easing.bounceIn(t * 2, 0, c, d) * 0.5 + b;
        }
        return Y.Easing.bounceOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    }
};

Y.Easing = Easing;


}, '3.17.2', {"requires": ["anim-base"]});


/***/ }),

/***/ 305531:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('anim-node-plugin', function (Y, NAME) {

/**
 *  Binds an Anim instance to a Node instance
 * @module anim
 * @class Plugin.NodeFX
 * @extends Anim
 * @submodule anim-node-plugin
 */

var NodeFX = function(config) {
    config = (config) ? Y.merge(config) : {};
    config.node = config.host;
    NodeFX.superclass.constructor.apply(this, arguments);
};

NodeFX.NAME = "nodefx";
NodeFX.NS = "fx";

Y.extend(NodeFX, Y.Anim);

Y.namespace('Plugin');
Y.Plugin.NodeFX = NodeFX;


}, '3.17.2', {"requires": ["node-pluginhost", "anim-base"]});


/***/ }),

/***/ 991950:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('anim-scroll', function (Y, NAME) {

/**
 * Adds support for the <code>scroll</code> property in <code>to</code>
 * and <code>from</code> attributes.
 * @module anim
 * @submodule anim-scroll
 */

var NUM = Number;

//TODO: deprecate for scrollTop/Left properties?
Y.Anim.behaviors.scroll = {
    set: function(anim, att, from, to, elapsed, duration, fn) {
        var
            node = anim._node,
            val = ([
            fn(elapsed, NUM(from[0]), NUM(to[0]) - NUM(from[0]), duration),
            fn(elapsed, NUM(from[1]), NUM(to[1]) - NUM(from[1]), duration)
        ]);

        if (val[0]) {
            node.set('scrollLeft', val[0]);
        }

        if (val[1]) {
            node.set('scrollTop', val[1]);
        }
    },
    get: function(anim) {
        var node = anim._node;
        return [node.get('scrollLeft'), node.get('scrollTop')];
    }
};



}, '3.17.2', {"requires": ["anim-base"]});


/***/ }),

/***/ 605585:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('anim-xy', function (Y, NAME) {

/**
 * Adds support for the <code>xy</code> property in <code>from</code> and
 * <code>to</code> attributes.
 * @module anim
 * @submodule anim-xy
 */

var NUM = Number;

Y.Anim.behaviors.xy = {
    set: function(anim, att, from, to, elapsed, duration, fn) {
        anim._node.setXY([
            fn(elapsed, NUM(from[0]), NUM(to[0]) - NUM(from[0]), duration),
            fn(elapsed, NUM(from[1]), NUM(to[1]) - NUM(from[1]), duration)
        ]);
    },
    get: function(anim) {
        return anim._node.getXY();
    }
};



}, '3.17.2', {"requires": ["anim-base", "node-screen"]});


/***/ }),

/***/ 3299:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('array-extras', function (Y, NAME) {

/**
Adds additional utility methods to the `Y.Array` class.

@module collection
@submodule array-extras
**/

var A          = Y.Array,
    L          = Y.Lang,
    ArrayProto = Array.prototype;

/**
Returns the index of the last item in the array that contains the specified
value, or `-1` if the value isn't found.

@method lastIndexOf
@param {Array} a Array to search in.
@param {Any} val Value to search for.
@param {Number} [fromIndex] Index at which to start searching backwards.
  Defaults to the array's length - 1. If negative, it will be taken as an offset
  from the end of the array. If the calculated index is less than 0, the array
  will not be searched and `-1` will be returned.
@return {Number} Index of the item that contains the value, or `-1` if not
  found.
@static
@for Array
**/
A.lastIndexOf = L._isNative(ArrayProto.lastIndexOf) ?
    function(a, val, fromIndex) {
        // An undefined fromIndex is still considered a value by some (all?)
        // native implementations, so we can't pass it unless it's actually
        // specified.
        return fromIndex || fromIndex === 0 ? a.lastIndexOf(val, fromIndex) :
                a.lastIndexOf(val);
    } :
    function(a, val, fromIndex) {
        var len = a.length,
            i   = len - 1;

        if (fromIndex || fromIndex === 0) {
            i = Math.min(fromIndex < 0 ? len + fromIndex : fromIndex, len);
        }

        if (i > -1 && len > 0) {
            for (; i > -1; --i) {
                if (i in a && a[i] === val) {
                    return i;
                }
            }
        }

        return -1;
    };

/**
Returns a copy of the input array with duplicate items removed.

Note: If the input array only contains strings, the `Y.Array.dedupe()` method is
a much faster alternative.

@method unique
@param {Array} array Array to dedupe.
@param {Function} [testFn] Custom function to use to test the equality of two
    values. A truthy return value indicates that the values are equal. A falsy
    return value indicates that the values are not equal.

    @param {Any} testFn.a First value to compare.
    @param {Any} testFn.b Second value to compare.
    @param {Number} testFn.index Index of the current item in the original
        array.
    @param {Array} testFn.array The original array.
    @return {Boolean} _true_ if the items are equal, _false_ otherwise.

@return {Array} Copy of the input array with duplicate items removed.
@static
**/
A.unique = function (array, testFn) {
    var i       = 0,
        len     = array.length,
        results = [],
        j, result, resultLen, value;

    // Note the label here. It's used to jump out of the inner loop when a value
    // is not unique.
    outerLoop: for (; i < len; i++) {
        value = array[i];

        // For each value in the input array, iterate through the result array
        // and check for uniqueness against each result value.
        for (j = 0, resultLen = results.length; j < resultLen; j++) {
            result = results[j];

            // If the test function returns true or there's no test function and
            // the value equals the current result item, stop iterating over the
            // results and continue to the next value in the input array.
            if (testFn) {
                if (testFn.call(array, value, result, i, array)) {
                    continue outerLoop;
                }
            } else if (value === result) {
                continue outerLoop;
            }
        }

        // If we get this far, that means the current value is not already in
        // the result array, so add it.
        results.push(value);
    }

    return results;
};

/**
Executes the supplied function on each item in the array. Returns a new array
containing the items for which the supplied function returned a truthy value.

@method filter
@param {Array} a Array to filter.
@param {Function} f Function to execute on each item.
@param {Object} [o] Optional context object.
@return {Array} Array of items for which the supplied function returned a
  truthy value (empty if it never returned a truthy value).
@static
*/
A.filter = L._isNative(ArrayProto.filter) ?
    function(a, f, o) {
        return ArrayProto.filter.call(a, f, o);
    } :
    function(a, f, o) {
        var i       = 0,
            len     = a.length,
            results = [],
            item;

        for (; i < len; ++i) {
            if (i in a) {
                item = a[i];

                if (f.call(o, item, i, a)) {
                    results.push(item);
                }
            }
        }

        return results;
    };

/**
The inverse of `Array.filter()`. Executes the supplied function on each item.
Returns a new array containing the items for which the supplied function
returned `false`.

@method reject
@param {Array} a the array to iterate.
@param {Function} f the function to execute on each item.
@param {object} [o] Optional context object.
@return {Array} The items for which the supplied function returned `false`.
@static
*/
A.reject = function(a, f, o) {
    return A.filter(a, function(item, i, a) {
        return !f.call(o, item, i, a);
    });
};

/**
Executes the supplied function on each item in the array. Iteration stops if the
supplied function does not return a truthy value.

@method every
@param {Array} a the array to iterate.
@param {Function} f the function to execute on each item.
@param {Object} [o] Optional context object.
@return {Boolean} `true` if every item in the array returns `true` from the
  supplied function, `false` otherwise.
@static
*/
A.every = L._isNative(ArrayProto.every) ?
    function(a, f, o) {
        return ArrayProto.every.call(a, f, o);
    } :
    function(a, f, o) {
        for (var i = 0, l = a.length; i < l; ++i) {
            if (i in a && !f.call(o, a[i], i, a)) {
                return false;
            }
        }

        return true;
    };

/**
Executes the supplied function on each item in the array and returns a new array
containing all the values returned by the supplied function.

@example

    // Convert an array of numbers into an array of strings.
    Y.Array.map([1, 2, 3, 4], function (item) {
      return '' + item;
    });
    // => ['1', '2', '3', '4']

@method map
@param {Array} a the array to iterate.
@param {Function} f the function to execute on each item.
@param {object} [o] Optional context object.
@return {Array} A new array containing the return value of the supplied function
  for each item in the original array.
@static
*/
A.map = L._isNative(ArrayProto.map) ?
    function(a, f, o) {
        return ArrayProto.map.call(a, f, o);
    } :
    function(a, f, o) {
        var i       = 0,
            len     = a.length,
            results = ArrayProto.concat.call(a);

        for (; i < len; ++i) {
            if (i in a) {
                results[i] = f.call(o, a[i], i, a);
            }
        }

        return results;
    };


/**
Executes the supplied function on each item in the array, "folding" the array
into a single value.

@method reduce
@param {Array} a Array to iterate.
@param {Any} init Initial value to start with.
@param {Function} f Function to execute on each item. This function should
  update and return the value of the computation. It will receive the following
  arguments:
    @param {Any} f.previousValue Value returned from the previous iteration,
      or the initial value if this is the first iteration.
    @param {Any} f.currentValue Value of the current item being iterated.
    @param {Number} f.index Index of the current item.
    @param {Array} f.array Array being iterated.
@param {Object} [o] Optional context object.
@return {Any} Final result from iteratively applying the given function to each
  element in the array.
@static
*/
A.reduce = L._isNative(ArrayProto.reduce) ?
    function(a, init, f, o) {
        // ES5 Array.reduce doesn't support a thisObject, so we need to
        // implement it manually.
        return ArrayProto.reduce.call(a, function(init, item, i, a) {
            return f.call(o, init, item, i, a);
        }, init);
    } :
    function(a, init, f, o) {
        var i      = 0,
            len    = a.length,
            result = init;

        for (; i < len; ++i) {
            if (i in a) {
                result = f.call(o, result, a[i], i, a);
            }
        }

        return result;
    };

/**
Executes the supplied function on each item in the array, searching for the
first item that matches the supplied function.

@method find
@param {Array} a the array to search.
@param {Function} f the function to execute on each item. Iteration is stopped
  as soon as this function returns `true`.
@param {Object} [o] Optional context object.
@return {Object} the first item that the supplied function returns `true` for,
  or `null` if it never returns `true`.
@static
*/
A.find = function(a, f, o) {
    for (var i = 0, l = a.length; i < l; i++) {
        if (i in a && f.call(o, a[i], i, a)) {
            return a[i];
        }
    }
    return null;
};

/**
Iterates over an array, returning a new array of all the elements that match the
supplied regular expression.

@method grep
@param {Array} a Array to iterate over.
@param {RegExp} pattern Regular expression to test against each item.
@return {Array} All the items in the array that produce a match against the
  supplied regular expression. If no items match, an empty array is returned.
@static
*/
A.grep = function(a, pattern) {
    return A.filter(a, function(item, index) {
        return pattern.test(item);
    });
};

/**
Partitions an array into two new arrays, one with the items for which the
supplied function returns `true`, and one with the items for which the function
returns `false`.

@method partition
@param {Array} a Array to iterate over.
@param {Function} f Function to execute for each item in the array. It will
  receive the following arguments:
    @param {Any} f.item Current item.
    @param {Number} f.index Index of the current item.
    @param {Array} f.array The array being iterated.
@param {Object} [o] Optional execution context.
@return {Object} An object with two properties: `matches` and `rejects`. Each is
  an array containing the items that were selected or rejected by the test
  function (or an empty array if none).
@static
*/
A.partition = function(a, f, o) {
    var results = {
        matches: [],
        rejects: []
    };

    A.each(a, function(item, index) {
        var set = f.call(o, item, index, a) ? results.matches : results.rejects;
        set.push(item);
    });

    return results;
};

/**
Creates an array of arrays by pairing the corresponding elements of two arrays
together into a new array.

@method zip
@param {Array} a Array to iterate over.
@param {Array} a2 Another array whose values will be paired with values of the
  first array.
@return {Array} An array of arrays formed by pairing each element of the first
  array with an item in the second array having the corresponding index.
@static
*/
A.zip = function(a, a2) {
    var results = [];
    A.each(a, function(item, index) {
        results.push([item, a2[index]]);
    });
    return results;
};

/**
Flattens an array of nested arrays at any abitrary depth into a single, flat
array.

@method flatten
@param {Array} a Array with nested arrays to flatten.
@return {Array} An array whose nested arrays have been flattened.
@static
@since 3.7.0
**/
A.flatten = function(a) {
    var result = [],
        i, len, val;

    // Always return an array.
    if (!a) {
        return result;
    }

    for (i = 0, len = a.length; i < len; ++i) {
        val = a[i];

        if (L.isArray(val)) {
            // Recusively flattens any nested arrays.
            result.push.apply(result, A.flatten(val));
        } else {
            result.push(val);
        }
    }

    return result;
};


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 623339:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('array-invoke', function (Y, NAME) {

/**
@module collection
@submodule array-invoke
*/

/**
Executes a named method on each item in an array of objects. Items in the array
that do not have a function by that name will be skipped.

@example

    Y.Array.invoke(arrayOfDrags, 'plug', Y.Plugin.DDProxy);

@method invoke
@param {Array} items Array of objects supporting the named method.
@param {String} name the name of the method to execute on each item.
@param {Any} [args*] Any number of additional args are passed as parameters to
  the execution of the named method.
@return {Array} All return values, indexed according to the item index.
@static
@for Array
**/
Y.Array.invoke = function(items, name) {
    var args = Y.Array(arguments, 2, true),
        isFunction = Y.Lang.isFunction,
        ret = [];

    Y.Array.each(Y.Array(items), function(item, i) {
        if (item && isFunction(item[name])) {
            ret[i] = item[name].apply(item, args);
        }
    });

    return ret;
};


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 241601:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('arraylist', function (Y, NAME) {

/**
 * Collection utilities beyond what is provided in the YUI core
 * @module collection
 * @submodule arraylist
 */

var YArray      = Y.Array,
    YArray_each = YArray.each,
    ArrayListProto;

/**
 * Generic ArrayList class for managing lists of items and iterating operations
 * over them.  The targeted use for this class is for augmentation onto a
 * class that is responsible for managing multiple instances of another class
 * (e.g. NodeList for Nodes).  The recommended use is to augment your class with
 * ArrayList, then use ArrayList.addMethod to mirror the API of the constituent
 * items on the list's API.
 *
 * The default implementation creates immutable lists, but mutability can be
 * provided via the arraylist-add submodule or by implementing mutation methods
 * directly on the augmented class's prototype.
 *
 * @class ArrayList
 * @constructor
 * @param items { Array } array of items this list will be responsible for
 */
function ArrayList( items ) {
    if ( items !== undefined ) {
        this._items = Y.Lang.isArray( items ) ? items : YArray( items );
    } else {
        // ||= to support lazy initialization from augment
        this._items = this._items || [];
    }
}

ArrayListProto = {
    /**
     * Get an item by index from the list.  Override this method if managing a
     * list of objects that have a different public representation (e.g. Node
     * instances vs DOM nodes).  The iteration methods that accept a user
     * function will use this method for access list items for operation.
     *
     * @method item
     * @param i { Integer } index to fetch
     * @return { mixed } the item at the requested index
     */
    item: function ( i ) {
        return this._items[i];
    },

    /**
     * <p>Execute a function on each item of the list, optionally providing a
     * custom execution context.  Default context is the item.</p>
     *
     * <p>The callback signature is <code>callback( item, index )</code>.</p>
     *
     * @method each
     * @param fn { Function } the function to execute
     * @param context { mixed } optional override 'this' in the function
     * @return { ArrayList } this instance
     * @chainable
     */
    each: function ( fn, context ) {
        YArray_each( this._items, function ( item, i ) {
            item = this.item( i );

            fn.call( context || item, item, i, this );
        }, this);

        return this;
    },

    /**
     * <p>Execute a function on each item of the list, optionally providing a
     * custom execution context.  Default context is the item.</p>
     *
     * <p>The callback signature is <code>callback( item, index )</code>.</p>
     *
     * <p>Unlike <code>each</code>, if the callback returns true, the
     * iteration will stop.</p>
     *
     * @method some
     * @param fn { Function } the function to execute
     * @param context { mixed } optional override 'this' in the function
     * @return { Boolean } True if the function returned true on an item
     */
    some: function ( fn, context ) {
        return YArray.some( this._items, function ( item, i ) {
            item = this.item( i );

            return fn.call( context || item, item, i, this );
        }, this);
    },

    /**
     * Finds the first index of the needle in the managed array of items.
     *
     * @method indexOf
     * @param needle { mixed } The item to search for
     * @return { Integer } Array index if found.  Otherwise -1
     */
    indexOf: function ( needle ) {
        return YArray.indexOf( this._items, needle );
    },

    /**
     * How many items are in this list?
     *
     * @method size
     * @return { Integer } Number of items in the list
     */
    size: function () {
        return this._items.length;
    },

    /**
     * Is this instance managing any items?
     *
     * @method isEmpty
     * @return { Boolean } true if 1 or more items are being managed
     */
    isEmpty: function () {
        return !this.size();
    },

    /**
     * Provides an array-like representation for JSON.stringify.
     *
     * @method toJSON
     * @return { Array } an array representation of the ArrayList
     */
    toJSON: function () {
        return this._items;
    }
};
// Default implementation does not distinguish between public and private
// item getter
/**
 * Protected method for optimizations that may be appropriate for API
 * mirroring. Similar in functionality to <code>item</code>, but is used by
 * methods added with <code>ArrayList.addMethod()</code>.
 *
 * @method _item
 * @protected
 * @param i { Integer } Index of item to fetch
 * @return { mixed } The item appropriate for pass through API methods
 */
ArrayListProto._item = ArrayListProto.item;

// Mixed onto existing proto to preserve constructor NOT being an own property.
// This has bitten me when composing classes by enumerating, copying prototypes.
Y.mix(ArrayList.prototype, ArrayListProto);

Y.mix( ArrayList, {

    /**
     * <p>Adds a pass through method to dest (typically the prototype of a list
     * class) that calls the named method on each item in the list with
     * whatever parameters are passed in.  Allows for API indirection via list
     * instances.</p>
     *
     * <p>Accepts a single string name or an array of string names.</p>
     *
     * <pre><code>list.each( function ( item ) {
     *     item.methodName( 1, 2, 3 );
     * } );
     * // becomes
     * list.methodName( 1, 2, 3 );</code></pre>
     *
     * <p>Additionally, the pass through methods use the item retrieved by the
     * <code>_item</code> method in case there is any special behavior that is
     * appropriate for API mirroring.</p>
     *
     * <p>If the iterated method returns a value, the return value from the
     * added method will be an array of values with each value being at the
     * corresponding index for that item.  If the iterated method does not
     * return a value, the added method will be chainable.
     *
     * @method addMethod
     * @static
     * @param dest {Object} Object or prototype to receive the iterator method
     * @param name {String|String[]} Name of method of methods to create
     */
    addMethod: function ( dest, names ) {

        names = YArray( names );

        YArray_each( names, function ( name ) {
            dest[ name ] = function () {
                var args = YArray( arguments, 0, true ),
                    ret  = [];

                YArray_each( this._items, function ( item, i ) {
                    item = this._item( i );

                    var result = item[ name ].apply( item, args );

                    if ( result !== undefined && result !== item ) {
                        ret[i] = result;
                    }
                }, this);

                return ret.length ? ret : this;
            };
        } );
    }
} );

Y.ArrayList = ArrayList;


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 983810:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('async-queue', function (Y, NAME) {

/**
 * <p>AsyncQueue allows you create a chain of function callbacks executed
 * via setTimeout (or synchronously) that are guaranteed to run in order.
 * Items in the queue can be promoted or removed.  Start or resume the
 * execution chain with run().  pause() to temporarily delay execution, or
 * stop() to halt and clear the queue.</p>
 *
 * @module async-queue
 */

/**
 * <p>A specialized queue class that supports scheduling callbacks to execute
 * sequentially, iteratively, even asynchronously.</p>
 *
 * <p>Callbacks can be function refs or objects with the following keys.  Only
 * the <code>fn</code> key is required.</p>
 *
 * <ul>
 * <li><code>fn</code> -- The callback function</li>
 * <li><code>context</code> -- The execution context for the callbackFn.</li>
 * <li><code>args</code> -- Arguments to pass to callbackFn.</li>
 * <li><code>timeout</code> -- Millisecond delay before executing callbackFn.
 *                     (Applies to each iterative execution of callback)</li>
 * <li><code>iterations</code> -- Number of times to repeat the callback.
 * <li><code>until</code> -- Repeat the callback until this function returns
 *                         true.  This setting trumps iterations.</li>
 * <li><code>autoContinue</code> -- Set to false to prevent the AsyncQueue from
 *                        executing the next callback in the Queue after
 *                        the callback completes.</li>
 * <li><code>id</code> -- Name that can be used to get, promote, get the
 *                        indexOf, or delete this callback.</li>
 * </ul>
 *
 * @class AsyncQueue
 * @extends EventTarget
 * @constructor
 * @param callback* {Function|Object} 0..n callbacks to seed the queue
 */
Y.AsyncQueue = function() {
    this._init();
    this.add.apply(this, arguments);
};

var Queue   = Y.AsyncQueue,
    EXECUTE = 'execute',
    SHIFT   = 'shift',
    PROMOTE = 'promote',
    REMOVE  = 'remove',

    isObject   = Y.Lang.isObject,
    isFunction = Y.Lang.isFunction;

/**
 * <p>Static default values used to populate callback configuration properties.
 * Preconfigured defaults include:</p>
 *
 * <ul>
 *  <li><code>autoContinue</code>: <code>true</code></li>
 *  <li><code>iterations</code>: 1</li>
 *  <li><code>timeout</code>: 10 (10ms between callbacks)</li>
 *  <li><code>until</code>: (function to run until iterations &lt;= 0)</li>
 * </ul>
 *
 * @property defaults
 * @type {Object}
 * @static
 */
Queue.defaults = Y.mix({
    autoContinue : true,
    iterations   : 1,
    timeout      : 10,
    until        : function () {
        this.iterations |= 0;
        return this.iterations <= 0;
    }
}, Y.config.queueDefaults || {});

Y.extend(Queue, Y.EventTarget, {
    /**
     * Used to indicate the queue is currently executing a callback.
     *
     * @property _running
     * @type {Boolean|Object} true for synchronous callback execution, the
     *                        return handle from Y.later for async callbacks.
     *                        Otherwise false.
     * @protected
     */
    _running : false,

    /**
     * Initializes the AsyncQueue instance properties and events.
     *
     * @method _init
     * @protected
     */
    _init : function () {
        Y.EventTarget.call(this, { prefix: 'queue', emitFacade: true });

        this._q = [];

        /**
         * Callback defaults for this instance.  Static defaults that are not
         * overridden are also included.
         *
         * @property defaults
         * @type {Object}
         */
        this.defaults = {};

        this._initEvents();
    },

    /**
     * Initializes the instance events.
     *
     * @method _initEvents
     * @protected
     */
    _initEvents : function () {
        this.publish({
            'execute' : { defaultFn : this._defExecFn,    emitFacade: true },
            'shift'   : { defaultFn : this._defShiftFn,   emitFacade: true },
            'add'     : { defaultFn : this._defAddFn,     emitFacade: true },
            'promote' : { defaultFn : this._defPromoteFn, emitFacade: true },
            'remove'  : { defaultFn : this._defRemoveFn,  emitFacade: true }
        });
    },

    /**
     * Returns the next callback needing execution.  If a callback is
     * configured to repeat via iterations or until, it will be returned until
     * the completion criteria is met.
     *
     * When the queue is empty, null is returned.
     *
     * @method next
     * @return {Function} the callback to execute
     */
    next : function () {
        var callback;

        while (this._q.length) {
            callback = this._q[0] = this._prepare(this._q[0]);
            if (callback && callback.until()) {
                this.fire(SHIFT, { callback: callback });
                callback = null;
            } else {
                break;
            }
        }

        return callback || null;
    },

    /**
     * Default functionality for the &quot;shift&quot; event.  Shifts the
     * callback stored in the event object's <em>callback</em> property from
     * the queue if it is the first item.
     *
     * @method _defShiftFn
     * @param e {Event} The event object
     * @protected
     */
    _defShiftFn : function (e) {
        if (this.indexOf(e.callback) === 0) {
            this._q.shift();
        }
    },

    /**
     * Creates a wrapper function to execute the callback using the aggregated
     * configuration generated by combining the static AsyncQueue.defaults, the
     * instance defaults, and the specified callback settings.
     *
     * The wrapper function is decorated with the callback configuration as
     * properties for runtime modification.
     *
     * @method _prepare
     * @param callback {Object|Function} the raw callback
     * @return {Function} a decorated function wrapper to execute the callback
     * @protected
     */
    _prepare: function (callback) {
        if (isFunction(callback) && callback._prepared) {
            return callback;
        }

        var config = Y.merge(
            Queue.defaults,
            { context : this, args: [], _prepared: true },
            this.defaults,
            (isFunction(callback) ? { fn: callback } : callback)),

            wrapper = Y.bind(function () {
                if (!wrapper._running) {
                    wrapper.iterations--;
                }
                if (isFunction(wrapper.fn)) {
                    wrapper.fn.apply(wrapper.context || Y,
                                     Y.Array(wrapper.args));
                }
            }, this);

        return Y.mix(wrapper, config);
    },

    /**
     * Sets the queue in motion.  All queued callbacks will be executed in
     * order unless pause() or stop() is called or if one of the callbacks is
     * configured with autoContinue: false.
     *
     * @method run
     * @return {AsyncQueue} the AsyncQueue instance
     * @chainable
     */
    run : function () {
        var callback,
            cont = true;

        if (this._executing) {
            this._running = true;
            return this;
        }

        for (callback = this.next();
            callback && !this.isRunning();
            callback = this.next())
        {
            cont = (callback.timeout < 0) ?
                this._execute(callback) :
                this._schedule(callback);

            // Break to avoid an extra call to next (final-expression of the
            // 'for' loop), because the until function of the next callback
            // in the queue may return a wrong result if it depends on the
            // not-yet-finished work of the previous callback.
            if (!cont) {
                break;
            }
        }

        if (!callback) {
            /**
             * Event fired when there is no remaining callback in the running queue. Also fired after stop().
             * @event complete
             */
            this.fire('complete');
        }

        return this;
    },

    /**
     * Handles the execution of callbacks. Returns a boolean indicating
     * whether it is appropriate to continue running.
     *
     * @method _execute
     * @param callback {Object} the callback object to execute
     * @return {Boolean} whether the run loop should continue
     * @protected
     */
    _execute : function (callback) {

        this._running   = callback._running = true;
        this._executing = callback;

        callback.iterations--;
        this.fire(EXECUTE, { callback: callback });

        var cont = this._running && callback.autoContinue;

        this._running   = callback._running = false;
        this._executing = false;

        return cont;
    },

    /**
     * Schedules the execution of asynchronous callbacks.
     *
     * @method _schedule
     * @param callback {Object} the callback object to execute
     * @return {Boolean} whether the run loop should continue
     * @protected
     */
    _schedule : function (callback) {
        this._running = Y.later(callback.timeout, this, function () {
            if (this._execute(callback)) {
                this.run();
            }
        });

        return false;
    },

    /**
     * Determines if the queue is waiting for a callback to complete execution.
     *
     * @method isRunning
     * @return {Boolean} true if queue is waiting for a
     *                   from any initiated transactions
     */
    isRunning : function () {
        return !!this._running;
    },

    /**
     * Default functionality for the &quot;execute&quot; event.  Executes the
     * callback function
     *
     * @method _defExecFn
     * @param e {Event} the event object
     * @protected
     */
    _defExecFn : function (e) {
        e.callback();
    },

    /**
     * Add any number of callbacks to the end of the queue. Callbacks may be
     * provided as functions or objects.
     *
     * @method add
     * @param callback* {Function|Object} 0..n callbacks
     * @return {AsyncQueue} the AsyncQueue instance
     * @chainable
     */
    add : function () {
        this.fire('add', { callbacks: Y.Array(arguments,0,true) });

        return this;
    },

    /**
     * Default functionality for the &quot;add&quot; event.  Adds the callbacks
     * in the event facade to the queue. Callbacks successfully added to the
     * queue are present in the event's <code>added</code> property in the
     * after phase.
     *
     * @method _defAddFn
     * @param e {Event} the event object
     * @protected
     */
    _defAddFn : function(e) {
        var _q = this._q,
            added = [];

        Y.Array.each(e.callbacks, function (c) {
            if (isObject(c)) {
                _q.push(c);
                added.push(c);
            }
        });

        e.added = added;
    },

    /**
     * Pause the execution of the queue after the execution of the current
     * callback completes.  If called from code outside of a queued callback,
     * clears the timeout for the pending callback. Paused queue can be
     * restarted with q.run()
     *
     * @method pause
     * @return {AsyncQueue} the AsyncQueue instance
     * @chainable
     */
    pause: function () {
        if (this._running && isObject(this._running)) {
            this._running.cancel();
        }

        this._running = false;

        return this;
    },

    /**
     * Stop and clear the queue after the current execution of the
     * current callback completes.
     *
     * @method stop
     * @return {AsyncQueue} the AsyncQueue instance
     * @chainable
     */
    stop : function () {

        this._q = [];

        if (this._running && isObject(this._running)) {
            this._running.cancel();
            this._running = false;
        }
        // otherwise don't systematically set this._running to false, because if
        // stop has been called from inside a queued callback, the _execute method
        // currenty running needs to call run() one more time for the 'complete'
        // event to be fired.

        // if stop is called from outside a callback, we need to explicitely call
        // run() once again to fire the 'complete' event.
        if (!this._executing) {
            this.run();
        }

        return this;
    },

    /**
     * Returns the current index of a callback.  Pass in either the id or
     * callback function from getCallback.
     *
     * @method indexOf
     * @param callback {String|Function} the callback or its specified id
     * @return {Number} index of the callback or -1 if not found
     */
    indexOf : function (callback) {
        var i = 0, len = this._q.length, c;

        for (; i < len; ++i) {
            c = this._q[i];
            if (c === callback || c.id === callback) {
                return i;
            }
        }

        return -1;
    },

    /**
     * Retrieve a callback by its id.  Useful to modify the configuration
     * while the queue is running.
     *
     * @method getCallback
     * @param id {String} the id assigned to the callback
     * @return {Object} the callback object
     */
    getCallback : function (id) {
        var i = this.indexOf(id);

        return (i > -1) ? this._q[i] : null;
    },

    /**
     * Promotes the named callback to the top of the queue. If a callback is
     * currently executing or looping (via until or iterations), the promotion
     * is scheduled to occur after the current callback has completed.
     *
     * @method promote
     * @param callback {String|Object} the callback object or a callback's id
     * @return {AsyncQueue} the AsyncQueue instance
     * @chainable
     */
    promote : function (callback) {
        var payload = { callback : callback },e;

        if (this.isRunning()) {
            e = this.after(SHIFT, function () {
                    this.fire(PROMOTE, payload);
                    e.detach();
                }, this);
        } else {
            this.fire(PROMOTE, payload);
        }

        return this;
    },

    /**
     * <p>Default functionality for the &quot;promote&quot; event.  Promotes the
     * named callback to the head of the queue.</p>
     *
     * <p>The event object will contain a property &quot;callback&quot;, which
     * holds the id of a callback or the callback object itself.</p>
     *
     * @method _defPromoteFn
     * @param e {Event} the custom event
     * @protected
     */
    _defPromoteFn : function (e) {
        var i = this.indexOf(e.callback),
            promoted = (i > -1) ? this._q.splice(i,1)[0] : null;

        e.promoted = promoted;

        if (promoted) {
            this._q.unshift(promoted);
        }
    },

    /**
     * Removes the callback from the queue.  If the queue is active, the
     * removal is scheduled to occur after the current callback has completed.
     *
     * @method remove
     * @param callback {String|Object} the callback object or a callback's id
     * @return {AsyncQueue} the AsyncQueue instance
     * @chainable
     */
    remove : function (callback) {
        var payload = { callback : callback },e;

        // Can't return the removed callback because of the deferral until
        // current callback is complete
        if (this.isRunning()) {
            e = this.after(SHIFT, function () {
                    this.fire(REMOVE, payload);
                    e.detach();
                },this);
        } else {
            this.fire(REMOVE, payload);
        }

        return this;
    },

    /**
     * <p>Default functionality for the &quot;remove&quot; event.  Removes the
     * callback from the queue.</p>
     *
     * <p>The event object will contain a property &quot;callback&quot;, which
     * holds the id of a callback or the callback object itself.</p>
     *
     * @method _defRemoveFn
     * @param e {Event} the custom event
     * @protected
     */
    _defRemoveFn : function (e) {
        var i = this.indexOf(e.callback);

        e.removed = (i > -1) ? this._q.splice(i,1)[0] : null;
    },

    /**
     * Returns the number of callbacks in the queue.
     *
     * @method size
     * @return {Number}
     */
    size : function () {
        // next() flushes callbacks that have met their until() criteria and
        // therefore shouldn't count since they wouldn't execute anyway.
        if (!this.isRunning()) {
            this.next();
        }

        return this._q.length;
    }
});



}, '3.17.2', {"requires": ["event-custom"]});


/***/ }),

/***/ 917645:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('attribute-base', function (Y, NAME) {

    /**
     * The attribute module provides an augmentable Attribute implementation, which
     * adds configurable attributes and attribute change events to the class being
     * augmented. It also provides a State class, which is used internally by Attribute,
     * but can also be used independently to provide a name/property/value data structure to
     * store state.
     *
     * @module attribute
     */

    /**
     * The attribute-base submodule provides core attribute handling support, with everything
     * aside from complex attribute handling in the provider's constructor.
     *
     * @module attribute
     * @submodule attribute-base
     */

    /**
     * <p>
     * Attribute provides configurable attribute support along with attribute change events. It is designed to be
     * augmented on to a host class, and provides the host with the ability to configure attributes to store and retrieve state,
     * along with attribute change events.
     * </p>
     * <p>For example, attributes added to the host can be configured:</p>
     * <ul>
     *     <li>As read only.</li>
     *     <li>As write once.</li>
     *     <li>With a setter function, which can be used to manipulate
     *     values passed to Attribute's <a href="#method_set">set</a> method, before they are stored.</li>
     *     <li>With a getter function, which can be used to manipulate stored values,
     *     before they are returned by Attribute's <a href="#method_get">get</a> method.</li>
     *     <li>With a validator function, to validate values before they are stored.</li>
     * </ul>
     *
     * <p>See the <a href="#method_addAttr">addAttr</a> method, for the complete set of configuration
     * options available for attributes.</p>
     *
     * <p><strong>NOTE:</strong> Most implementations will be better off extending the <a href="Base.html">Base</a> class,
     * instead of augmenting Attribute directly. Base augments Attribute and will handle the initial configuration
     * of attributes for derived classes, accounting for values passed into the constructor.</p>
     *
     * @class Attribute
     * @param attrs {Object} The attributes to add during construction (passed through to <a href="#method_addAttrs">addAttrs</a>).
     *        These can also be defined on the constructor being augmented with Attribute by defining the ATTRS property on the constructor.
     * @param values {Object} The initial attribute values to apply (passed through to <a href="#method_addAttrs">addAttrs</a>).
     *        These are not merged/cloned. The caller is responsible for isolating user provided values if required.
     * @param lazy {boolean} Whether or not to add attributes lazily (passed through to <a href="#method_addAttrs">addAttrs</a>).
     * @uses AttributeCore
     * @uses AttributeObservable
     * @uses EventTarget
     * @uses AttributeExtras
     */
    function Attribute() {
        Y.AttributeCore.apply(this, arguments);
        Y.AttributeObservable.apply(this, arguments);
        Y.AttributeExtras.apply(this, arguments);
    }

    Y.mix(Attribute, Y.AttributeCore, false, null, 1);
    Y.mix(Attribute, Y.AttributeExtras, false, null, 1);

    // Needs to be `true`, to overwrite methods from AttributeCore
    Y.mix(Attribute, Y.AttributeObservable, true, null, 1);

    /**
     * <p>The value to return from an attribute setter in order to prevent the set from going through.</p>
     *
     * <p>You can return this value from your setter if you wish to combine validator and setter
     * functionality into a single setter function, which either returns the massaged value to be stored or
     * AttributeCore.INVALID_VALUE to prevent invalid values from being stored.</p>
     *
     * @property INVALID_VALUE
     * @type Object
     * @static
     * @final
     */
    Attribute.INVALID_VALUE = Y.AttributeCore.INVALID_VALUE;

    /**
     * The list of properties which can be configured for
     * each attribute (e.g. setter, getter, writeOnce etc.).
     *
     * This property is used internally as a whitelist for faster
     * Y.mix operations.
     *
     * @property _ATTR_CFG
     * @type Array
     * @static
     * @protected
     */
    Attribute._ATTR_CFG = Y.AttributeCore._ATTR_CFG.concat(Y.AttributeObservable._ATTR_CFG);

    /**
     * Utility method to protect an attribute configuration hash, by merging the
     * entire object and the individual attr config objects.
     *
     * @method protectAttrs
     * @static
     * @param {Object} attrs A hash of attribute to configuration object pairs.
     * @return {Object} A protected version of the `attrs` argument.
     */
    Attribute.protectAttrs = Y.AttributeCore.protectAttrs;

    Y.Attribute = Attribute;


}, '3.17.2', {"requires": ["attribute-core", "attribute-observable", "attribute-extras"]});


/***/ }),

/***/ 725707:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('attribute-complex', function (Y, NAME) {

    /**
     * Adds support for attribute providers to handle complex attributes in the constructor
     *
     * @module attribute
     * @submodule attribute-complex
     * @for Attribute
     * @deprecated AttributeComplex's overrides are now part of AttributeCore.
     */

    var Attribute = Y.Attribute;

    Attribute.Complex = function() {};
    Attribute.Complex.prototype = {

        /**
         * Utility method to split out simple attribute name/value pairs ("x")
         * from complex attribute name/value pairs ("x.y.z"), so that complex
         * attributes can be keyed by the top level attribute name.
         *
         * @method _normAttrVals
         * @param {Object} valueHash An object with attribute name/value pairs
         *
         * @return {Object} An object literal with 2 properties - "simple" and "complex",
         * containing simple and complex attribute values respectively keyed
         * by the top level attribute name, or null, if valueHash is falsey.
         *
         * @private
         */
        _normAttrVals : Attribute.prototype._normAttrVals,

        /**
         * Returns the initial value of the given attribute from
         * either the default configuration provided, or the
         * over-ridden value if it exists in the set of initValues
         * provided and the attribute is not read-only.
         *
         * @param {String} attr The name of the attribute
         * @param {Object} cfg The attribute configuration object
         * @param {Object} initValues The object with simple and complex attribute name/value pairs returned from _normAttrVals
         *
         * @return {Any} The initial value of the attribute.
         *
         * @method _getAttrInitVal
         * @private
         */
        _getAttrInitVal : Attribute.prototype._getAttrInitVal

    };

    // Consistency with the rest of the Attribute addons for now.
    Y.AttributeComplex = Attribute.Complex;


}, '3.17.2', {"requires": ["attribute-base"]});


/***/ }),

/***/ 659413:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('attribute-core', function (Y, NAME) {

    /**
     * The State class maintains state for a collection of named items, with
     * a varying number of properties defined.
     *
     * It avoids the need to create a separate class for the item, and separate instances
     * of these classes for each item, by storing the state in a 2 level hash table,
     * improving performance when the number of items is likely to be large.
     *
     * @constructor
     * @class State
     */
    Y.State = function() {
        /**
         * Hash of attributes
         * @property data
         */
        this.data = {};
    };

    Y.State.prototype = {

        /**
         * Adds a property to an item.
         *
         * @method add
         * @param name {String} The name of the item.
         * @param key {String} The name of the property.
         * @param val {Any} The value of the property.
         */
        add: function(name, key, val) {
            var item = this.data[name];

            if (!item) {
                item = this.data[name] = {};
            }

            item[key] = val;
        },

        /**
         * Adds multiple properties to an item.
         *
         * @method addAll
         * @param name {String} The name of the item.
         * @param obj {Object} A hash of property/value pairs.
         */
        addAll: function(name, obj) {
            var item = this.data[name],
                key;

            if (!item) {
                item = this.data[name] = {};
            }

            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    item[key] = obj[key];
                }
            }
        },

        /**
         * Removes a property from an item.
         *
         * @method remove
         * @param name {String} The name of the item.
         * @param key {String} The property to remove.
         */
        remove: function(name, key) {
            var item = this.data[name];

            if (item) {
                delete item[key];
            }
        },

        /**
         * Removes multiple properties from an item, or removes the item completely.
         *
         * @method removeAll
         * @param name {String} The name of the item.
         * @param obj {Object|Array} Collection of properties to delete. If not provided, the entire item is removed.
         */
        removeAll: function(name, obj) {
            var data;

            if (!obj) {
                data = this.data;

                if (name in data) {
                    delete data[name];
                }
            } else {
                Y.each(obj, function(value, key) {
                    this.remove(name, typeof key === 'string' ? key : value);
                }, this);
            }
        },

        /**
         * For a given item, returns the value of the property requested, or undefined if not found.
         *
         * @method get
         * @param name {String} The name of the item
         * @param key {String} Optional. The property value to retrieve.
         * @return {Any} The value of the supplied property.
         */
        get: function(name, key) {
            var item = this.data[name];

            if (item) {
                return item[key];
            }
        },

        /**
         * For the given item, returns an object with all of the
         * item's property/value pairs. By default the object returned
         * is a shallow copy of the stored data, but passing in true
         * as the second parameter will return a reference to the stored
         * data.
         *
         * @method getAll
         * @param name {String} The name of the item
         * @param reference {boolean} true, if you want a reference to the stored
         * object
         * @return {Object} An object with property/value pairs for the item.
         */
        getAll : function(name, reference) {
            var item = this.data[name],
                key, obj;

            if (reference) {
                obj = item;
            } else if (item) {
                obj = {};

                for (key in item) {
                    if (item.hasOwnProperty(key)) {
                        obj[key] = item[key];
                    }
                }
            }

            return obj;
        }
    };
    /*For log lines*/
    /*jshint maxlen:200*/

    /**
     * The attribute module provides an augmentable Attribute implementation, which
     * adds configurable attributes and attribute change events to the class being
     * augmented. It also provides a State class, which is used internally by Attribute,
     * but can also be used independently to provide a name/property/value data structure to
     * store state.
     *
     * @module attribute
     */

    /**
     * The attribute-core submodule provides the lightest level of attribute handling support
     * without Attribute change events, or lesser used methods such as reset(), modifyAttrs(),
     * and removeAttr().
     *
     * @module attribute
     * @submodule attribute-core
     */
    var O = Y.Object,
        Lang = Y.Lang,

        DOT = ".",

        // Externally configurable props
        GETTER = "getter",
        SETTER = "setter",
        READ_ONLY = "readOnly",
        WRITE_ONCE = "writeOnce",
        INIT_ONLY = "initOnly",
        VALIDATOR = "validator",
        VALUE = "value",
        VALUE_FN = "valueFn",
        LAZY_ADD = "lazyAdd",

        // Used for internal state management
        ADDED = "added",
        BYPASS_PROXY = "_bypassProxy",
        INIT_VALUE = "initValue",
        LAZY = "lazy",

        INVALID_VALUE;

    /**
     * <p>
     * AttributeCore provides the lightest level of configurable attribute support. It is designed to be
     * augmented on to a host class, and provides the host with the ability to configure
     * attributes to store and retrieve state, <strong>but without support for attribute change events</strong>.
     * </p>
     * <p>For example, attributes added to the host can be configured:</p>
     * <ul>
     *     <li>As read only.</li>
     *     <li>As write once.</li>
     *     <li>With a setter function, which can be used to manipulate
     *     values passed to Attribute's <a href="#method_set">set</a> method, before they are stored.</li>
     *     <li>With a getter function, which can be used to manipulate stored values,
     *     before they are returned by Attribute's <a href="#method_get">get</a> method.</li>
     *     <li>With a validator function, to validate values before they are stored.</li>
     * </ul>
     *
     * <p>See the <a href="#method_addAttr">addAttr</a> method, for the complete set of configuration
     * options available for attributes.</p>
     *
     * <p>Object/Classes based on AttributeCore can augment <a href="AttributeObservable.html">AttributeObservable</a>
     * (with true for overwrite) and <a href="AttributeExtras.html">AttributeExtras</a> to add attribute event and
     * additional, less commonly used attribute methods, such as `modifyAttr`, `removeAttr` and `reset`.</p>
     *
     * @class AttributeCore
     * @param attrs {Object} The attributes to add during construction (passed through to <a href="#method_addAttrs">addAttrs</a>).
     *        These can also be defined on the constructor being augmented with Attribute by defining the ATTRS property on the constructor.
     * @param values {Object} The initial attribute values to apply (passed through to <a href="#method_addAttrs">addAttrs</a>).
     *        These are not merged/cloned. The caller is responsible for isolating user provided values if required.
     * @param lazy {boolean} Whether or not to add attributes lazily (passed through to <a href="#method_addAttrs">addAttrs</a>).
     */
    function AttributeCore(attrs, values, lazy) {
        // HACK: Fix #2531929
        // Complete hack, to make sure the first clone of a node value in IE doesn't doesn't hurt state - maintains 3.4.1 behavior.
        // Too late in the release cycle to do anything about the core problem.
        // The root issue is that cloning a Y.Node instance results in an object which barfs in IE, when you access it's properties (since 3.3.0).
        this._yuievt = null;

        this._initAttrHost(attrs, values, lazy);
    }

    /**
     * <p>The value to return from an attribute setter in order to prevent the set from going through.</p>
     *
     * <p>You can return this value from your setter if you wish to combine validator and setter
     * functionality into a single setter function, which either returns the massaged value to be stored or
     * AttributeCore.INVALID_VALUE to prevent invalid values from being stored.</p>
     *
     * @property INVALID_VALUE
     * @type Object
     * @static
     * @final
     */
    AttributeCore.INVALID_VALUE = {};
    INVALID_VALUE = AttributeCore.INVALID_VALUE;

    /**
     * The list of properties which can be configured for
     * each attribute (e.g. setter, getter, writeOnce etc.).
     *
     * This property is used internally as a whitelist for faster
     * Y.mix operations.
     *
     * @property _ATTR_CFG
     * @type Array
     * @static
     * @protected
     */
    AttributeCore._ATTR_CFG = [SETTER, GETTER, VALIDATOR, VALUE, VALUE_FN, WRITE_ONCE, READ_ONLY, LAZY_ADD, BYPASS_PROXY];

    /**
     * Utility method to protect an attribute configuration hash, by merging the
     * entire object and the individual attr config objects.
     *
     * @method protectAttrs
     * @static
     * @param {Object} attrs A hash of attribute to configuration object pairs.
     * @return {Object} A protected version of the `attrs` argument.
     */
    AttributeCore.protectAttrs = function (attrs) {
        if (attrs) {
            attrs = Y.merge(attrs);
            for (var attr in attrs) {
                if (attrs.hasOwnProperty(attr)) {
                    attrs[attr] = Y.merge(attrs[attr]);
                }
            }
        }

        return attrs;
    };

    AttributeCore.prototype = {

        /**
         * Constructor logic for attributes. Initializes the host state, and sets up the inital attributes passed to the
         * constructor.
         *
         * @method _initAttrHost
         * @param attrs {Object} The attributes to add during construction (passed through to <a href="#method_addAttrs">addAttrs</a>).
         *        These can also be defined on the constructor being augmented with Attribute by defining the ATTRS property on the constructor.
         * @param values {Object} The initial attribute values to apply (passed through to <a href="#method_addAttrs">addAttrs</a>).
         *        These are not merged/cloned. The caller is responsible for isolating user provided values if required.
         * @param lazy {boolean} Whether or not to add attributes lazily (passed through to <a href="#method_addAttrs">addAttrs</a>).
         * @private
         */
        _initAttrHost : function(attrs, values, lazy) {
            this._state = new Y.State();
            this._initAttrs(attrs, values, lazy);
        },

        /**
         * <p>
         * Adds an attribute with the provided configuration to the host object.
         * </p>
         * <p>
         * The config argument object supports the following properties:
         * </p>
         *
         * <dl>
         *    <dt>value &#60;Any&#62;</dt>
         *    <dd>The initial value to set on the attribute</dd>
         *
         *    <dt>valueFn &#60;Function | String&#62;</dt>
         *    <dd>
         *    <p>A function, which will return the initial value to set on the attribute. This is useful
         *    for cases where the attribute configuration is defined statically, but needs to
         *    reference the host instance ("this") to obtain an initial value. If both the value and valueFn properties are defined,
         *    the value returned by the valueFn has precedence over the value property, unless it returns undefined, in which
         *    case the value property is used.</p>
         *
         *    <p>valueFn can also be set to a string, representing the name of the instance method to be used to retrieve the value.</p>
         *    </dd>
         *
         *    <dt>readOnly &#60;boolean&#62;</dt>
         *    <dd>Whether or not the attribute is read only. Attributes having readOnly set to true
         *        cannot be modified by invoking the set method.</dd>
         *
         *    <dt>writeOnce &#60;boolean&#62; or &#60;string&#62;</dt>
         *    <dd>
         *        Whether or not the attribute is "write once". Attributes having writeOnce set to true,
         *        can only have their values set once, be it through the default configuration,
         *        constructor configuration arguments, or by invoking set.
         *        <p>The writeOnce attribute can also be set to the string "initOnly",
         *         in which case the attribute can only be set during initialization
         *        (when used with Base, this means it can only be set during construction)</p>
         *    </dd>
         *
         *    <dt>setter &#60;Function | String&#62;</dt>
         *    <dd>
         *    <p>The setter function used to massage or normalize the value passed to the set method for the attribute.
         *    The value returned by the setter will be the final stored value. Returning
         *    <a href="#property_Attribute.INVALID_VALUE">Attribute.INVALID_VALUE</a>, from the setter will prevent
         *    the value from being stored.
         *    </p>
         *
         *    <p>setter can also be set to a string, representing the name of the instance method to be used as the setter function.</p>
         *    </dd>
         *
         *    <dt>getter &#60;Function | String&#62;</dt>
         *    <dd>
         *    <p>
         *    The getter function used to massage or normalize the value returned by the get method for the attribute.
         *    The value returned by the getter function is the value which will be returned to the user when they
         *    invoke get.
         *    </p>
         *
         *    <p>getter can also be set to a string, representing the name of the instance method to be used as the getter function.</p>
         *    </dd>
         *
         *    <dt>validator &#60;Function | String&#62;</dt>
         *    <dd>
         *    <p>
         *    The validator function invoked prior to setting the stored value. Returning
         *    false from the validator function will prevent the value from being stored.
         *    </p>
         *
         *    <p>validator can also be set to a string, representing the name of the instance method to be used as the validator function.</p>
         *    </dd>
         *
         *    <dt>lazyAdd &#60;boolean&#62;</dt>
         *    <dd>Whether or not to delay initialization of the attribute until the first call to get/set it.
         *    This flag can be used to over-ride lazy initialization on a per attribute basis, when adding multiple attributes through
         *    the <a href="#method_addAttrs">addAttrs</a> method.</dd>
         *
         * </dl>
         *
         * <p>The setter, getter and validator are invoked with the value and name passed in as the first and second arguments, and with
         * the context ("this") set to the host object.</p>
         *
         * <p>Configuration properties outside of the list mentioned above are considered private properties used internally by attribute,
         * and are not intended for public use.</p>
         *
         * @method addAttr
         *
         * @param {String} name The name of the attribute.
         * @param {Object} config An object with attribute configuration property/value pairs, specifying the configuration for the attribute.
         *
         * <p>
         * <strong>NOTE:</strong> The configuration object is modified when adding an attribute, so if you need
         * to protect the original values, you will need to merge the object.
         * </p>
         *
         * @param {boolean} lazy (optional) Whether or not to add this attribute lazily (on the first call to get/set).
         *
         * @return {Object} A reference to the host object.
         *
         * @chainable
         */
        addAttr : function(name, config, lazy) {


            var host = this, // help compression
                state = host._state,
                data = state.data,
                value,
                added,
                hasValue;

            config = config || {};

            if (LAZY_ADD in config) {
                lazy = config[LAZY_ADD];
            }

            added = state.get(name, ADDED);

            if (lazy && !added) {
                state.data[name] = {
                    lazy : config,
                    added : true
                };
            } else {


                if (!added || config.isLazyAdd) {

                    hasValue = (VALUE in config);


                    if (hasValue) {

                        // We'll go through set, don't want to set value in config directly

                        // PERF TODO: VALIDATE: See if setting this to undefined is sufficient. We use to delete before.
                        // In certain code paths/use cases, undefined may not be the same as not present.
                        // If not, we can set it to some known fixed value (like INVALID_VALUE, say INITIALIZING_VALUE) for performance,
                        // to avoid a delete which seems to help a lot.

                        value = config.value;
                        config.value = undefined;
                    }

                    config.added = true;
                    config.initializing = true;

                    data[name] = config;

                    if (hasValue) {
                        // Go through set, so that raw values get normalized/validated
                        host.set(name, value);
                    }

                    config.initializing = false;
                }
            }

            return host;
        },

        /**
         * Checks if the given attribute has been added to the host
         *
         * @method attrAdded
         * @param {String} name The name of the attribute to check.
         * @return {boolean} true if an attribute with the given name has been added, false if it hasn't.
         *         This method will return true for lazily added attributes.
         */
        attrAdded: function(name) {
            return !!(this._state.get(name, ADDED));
        },

        /**
         * Returns the current value of the attribute. If the attribute
         * has been configured with a 'getter' function, this method will delegate
         * to the 'getter' to obtain the value of the attribute.
         *
         * @method get
         *
         * @param {String} name The name of the attribute. If the value of the attribute is an Object,
         * dot notation can be used to obtain the value of a property of the object (e.g. <code>get("x.y.z")</code>)
         *
         * @return {Any} The value of the attribute
         */
        get : function(name) {
            return this._getAttr(name);
        },

        /**
         * Checks whether or not the attribute is one which has been
         * added lazily and still requires initialization.
         *
         * @method _isLazyAttr
         * @private
         * @param {String} name The name of the attribute
         * @return {boolean} true if it's a lazily added attribute, false otherwise.
         */
        _isLazyAttr: function(name) {
            return this._state.get(name, LAZY);
        },

        /**
         * Finishes initializing an attribute which has been lazily added.
         *
         * @method _addLazyAttr
         * @private
         * @param {Object} name The name of the attribute
         * @param {Object} [lazyCfg] Optional config hash for the attribute. This is added for performance
         * along the critical path, where the calling method has already obtained lazy config from state.
         */
        _addLazyAttr: function(name, lazyCfg) {
            var state = this._state;

            lazyCfg = lazyCfg || state.get(name, LAZY);

            if (lazyCfg) {

                // PERF TODO: For App's id override, otherwise wouldn't be
                // needed. It expects to find it in the cfg for it's
                // addAttr override. Would like to remove, once App override is
                // removed.
                state.data[name].lazy = undefined;

                lazyCfg.isLazyAdd = true;

                this.addAttr(name, lazyCfg);
            }
        },

        /**
         * Sets the value of an attribute.
         *
         * @method set
         * @chainable
         *
         * @param {String} name The name of the attribute. If the
         * current value of the attribute is an Object, dot notation can be used
         * to set the value of a property within the object (e.g. <code>set("x.y.z", 5)</code>).
         * @param {Any} value The value to set the attribute to.
         * @param {Object} [opts] Optional data providing the circumstances for the change.
         * @return {Object} A reference to the host object.
         */
        set : function(name, val, opts) {
            return this._setAttr(name, val, opts);
        },

        /**
         * Allows setting of readOnly/writeOnce attributes. See <a href="#method_set">set</a> for argument details.
         *
         * @method _set
         * @protected
         * @chainable
         *
         * @param {String} name The name of the attribute.
         * @param {Any} val The value to set the attribute to.
         * @param {Object} [opts] Optional data providing the circumstances for the change.
         * @return {Object} A reference to the host object.
         */
        _set : function(name, val, opts) {
            return this._setAttr(name, val, opts, true);
        },

        /**
         * Provides the common implementation for the public set and protected _set methods.
         *
         * See <a href="#method_set">set</a> for argument details.
         *
         * @method _setAttr
         * @protected
         * @chainable
         *
         * @param {String} name The name of the attribute.
         * @param {Any} value The value to set the attribute to.
         * @param {Object} [opts] Optional data providing the circumstances for the change.
         * @param {boolean} force If true, allows the caller to set values for
         * readOnly or writeOnce attributes which have already been set.
         *
         * @return {Object} A reference to the host object.
         */
        _setAttr : function(name, val, opts, force)  {
            var allowSet = true,
                state = this._state,
                stateProxy = this._stateProxy,
                tCfgs = this._tCfgs,
                cfg,
                initialSet,
                strPath,
                path,
                currVal,
                writeOnce,
                initializing;

            if (name.indexOf(DOT) !== -1) {
                strPath = name;

                path = name.split(DOT);
                name = path.shift();
            }

            // On Demand - Should be rare - handles out of order valueFn, setter, getter references
            if (tCfgs && tCfgs[name]) {
                this._addOutOfOrder(name, tCfgs[name]);
            }

            cfg = state.data[name] || {};

            if (cfg.lazy) {
                cfg = cfg.lazy;
                this._addLazyAttr(name, cfg);
            }

            initialSet = (cfg.value === undefined);

            if (stateProxy && name in stateProxy && !cfg._bypassProxy) {
                // TODO: Value is always set for proxy. Can we do any better? Maybe take a snapshot as the initial value for the first call to set?
                initialSet = false;
            }

            writeOnce = cfg.writeOnce;
            initializing = cfg.initializing;

            if (!initialSet && !force) {

                if (writeOnce) {
                    allowSet = false;
                }

                if (cfg.readOnly) {
                    allowSet = false;
                }
            }

            if (!initializing && !force && writeOnce === INIT_ONLY) {
                allowSet = false;
            }

            if (allowSet) {
                // Don't need currVal if initialSet (might fail in custom getter if it always expects a non-undefined/non-null value)
                if (!initialSet) {
                    currVal =  this.get(name);
                }

                if (path) {
                   val = O.setValue(Y.clone(currVal), path, val);

                   if (val === undefined) {
                       allowSet = false;
                   }
                }

                if (allowSet) {
                    if (!this._fireAttrChange || initializing) {
                        this._setAttrVal(name, strPath, currVal, val, opts, cfg);
                    } else {
                        // HACK - no real reason core needs to know about _fireAttrChange, but
                        // it adds fn hops if we want to break it out. Not sure it's worth it for this critical path
                        this._fireAttrChange(name, strPath, currVal, val, opts, cfg);
                    }
                }
            }

            return this;
        },

        /**
         * Utility method used by get/set to add attributes
         * encountered out of order when calling addAttrs().
         *
         * For example, if:
         *
         *     this.addAttrs({
         *          foo: {
         *              setter: function() {
         *                 // make sure this bar is available when foo is added
         *                 this.get("bar");
         *              }
         *          },
         *          bar: {
         *              value: ...
         *          }
         *     });
         *
         * @method _addOutOfOrder
         * @private
         * @param name {String} attribute name
         * @param cfg {Object} attribute configuration
         */
        _addOutOfOrder : function(name, cfg) {

            var attrs = {};
            attrs[name] = cfg;

            delete this._tCfgs[name];

            // TODO: The original code went through addAttrs, so
            // sticking with it for this pass. Seems like we could
            // just jump straight to _addAttr() and get some perf
            // improvement.
            this._addAttrs(attrs, this._tVals);
        },

        /**
         * Provides the common implementation for the public get method,
         * allowing Attribute hosts to over-ride either method.
         *
         * See <a href="#method_get">get</a> for argument details.
         *
         * @method _getAttr
         * @protected
         * @chainable
         *
         * @param {String} name The name of the attribute.
         * @return {Any} The value of the attribute.
         */
        _getAttr : function(name) {
            var fullName = name,
                tCfgs = this._tCfgs,
                path,
                getter,
                val,
                attrCfg;

            if (name.indexOf(DOT) !== -1) {
                path = name.split(DOT);
                name = path.shift();
            }

            // On Demand - Should be rare - handles out of
            // order valueFn, setter, getter references
            if (tCfgs && tCfgs[name]) {
                this._addOutOfOrder(name, tCfgs[name]);
            }

            attrCfg = this._state.data[name] || {};

            // Lazy Init
            if (attrCfg.lazy) {
                attrCfg = attrCfg.lazy;
                this._addLazyAttr(name, attrCfg);
            }

            val = this._getStateVal(name, attrCfg);

            getter = attrCfg.getter;

            if (getter && !getter.call) {
                getter = this[getter];
            }

            val = (getter) ? getter.call(this, val, fullName) : val;
            val = (path) ? O.getValue(val, path) : val;

            return val;
        },

        /**
         * Gets the stored value for the attribute, from either the
         * internal state object, or the state proxy if it exits
         *
         * @method _getStateVal
         * @private
         * @param {String} name The name of the attribute
         * @param {Object} [cfg] Optional config hash for the attribute. This is added for performance along the critical path,
         * where the calling method has already obtained the config from state.
         *
         * @return {Any} The stored value of the attribute
         */
        _getStateVal : function(name, cfg) {
            var stateProxy = this._stateProxy;

            if (!cfg) {
                cfg = this._state.getAll(name) || {};
            }

            return (stateProxy && (name in stateProxy) && !(cfg._bypassProxy)) ? stateProxy[name] : cfg.value;
        },

        /**
         * Sets the stored value for the attribute, in either the
         * internal state object, or the state proxy if it exits
         *
         * @method _setStateVal
         * @private
         * @param {String} name The name of the attribute
         * @param {Any} value The value of the attribute
         */
        _setStateVal : function(name, value) {
            var stateProxy = this._stateProxy;
            if (stateProxy && (name in stateProxy) && !this._state.get(name, BYPASS_PROXY)) {
                stateProxy[name] = value;
            } else {
                this._state.add(name, VALUE, value);
            }
        },

        /**
         * Updates the stored value of the attribute in the privately held State object,
         * if validation and setter passes.
         *
         * @method _setAttrVal
         * @private
         * @param {String} attrName The attribute name.
         * @param {String} subAttrName The sub-attribute name, if setting a sub-attribute property ("x.y.z").
         * @param {Any} prevVal The currently stored value of the attribute.
         * @param {Any} newVal The value which is going to be stored.
         * @param {Object} [opts] Optional data providing the circumstances for the change.
         * @param {Object} [attrCfg] Optional config hash for the attribute. This is added for performance along the critical path,
         * where the calling method has already obtained the config from state.
         *
         * @return {Boolean} true if the new attribute value was stored, false if not.
         */
        _setAttrVal : function(attrName, subAttrName, prevVal, newVal, opts, attrCfg) {

            var host = this,
                allowSet = true,
                cfg = attrCfg || this._state.data[attrName] || {},
                validator = cfg.validator,
                setter = cfg.setter,
                initializing = cfg.initializing,
                prevRawVal = this._getStateVal(attrName, cfg),
                name = subAttrName || attrName,
                retVal,
                valid;

            if (validator) {
                if (!validator.call) {
                    // Assume string - trying to keep critical path tight, so avoiding Lang check
                    validator = this[validator];
                }
                if (validator) {
                    valid = validator.call(host, newVal, name, opts);

                    if (!valid && initializing) {
                        newVal = cfg.defaultValue;
                        valid = true; // Assume it's valid, for perf.
                    }
                }
            }

            if (!validator || valid) {
                if (setter) {
                    if (!setter.call) {
                        // Assume string - trying to keep critical path tight, so avoiding Lang check
                        setter = this[setter];
                    }
                    if (setter) {
                        retVal = setter.call(host, newVal, name, opts);

                        if (retVal === INVALID_VALUE) {
                            if (initializing) {
                                newVal = cfg.defaultValue;
                            } else {
                                allowSet = false;
                            }
                        } else if (retVal !== undefined){
                            newVal = retVal;
                        }
                    }
                }

                if (allowSet) {
                    if(!subAttrName && (newVal === prevRawVal) && !Lang.isObject(newVal)) {
                        allowSet = false;
                    } else {
                        // Store value
                        if (!(INIT_VALUE in cfg)) {
                            cfg.initValue = newVal;
                        }
                        host._setStateVal(attrName, newVal);
                    }
                }

            } else {
                allowSet = false;
            }

            return allowSet;
        },

        /**
         * Sets multiple attribute values.
         *
         * @method setAttrs
         * @param {Object} attrs  An object with attributes name/value pairs.
         * @param {Object} [opts] Optional data providing the circumstances for the change.
         * @return {Object} A reference to the host object.
         * @chainable
         */
        setAttrs : function(attrs, opts) {
            return this._setAttrs(attrs, opts);
        },

        /**
         * Implementation behind the public setAttrs method, to set multiple attribute values.
         *
         * @method _setAttrs
         * @protected
         * @param {Object} attrs  An object with attributes name/value pairs.
         * @param {Object} [opts] Optional data providing the circumstances for the change
         * @return {Object} A reference to the host object.
         * @chainable
         */
        _setAttrs : function(attrs, opts) {
            var attr;
            for (attr in attrs) {
                if ( attrs.hasOwnProperty(attr) ) {
                    this.set(attr, attrs[attr], opts);
                }
            }
            return this;
        },

        /**
         * Gets multiple attribute values.
         *
         * @method getAttrs
         * @param {String[]|Boolean} attrs Optional. An array of attribute names. If omitted, all attribute values are
         * returned. If set to true, all attributes modified from their initial values are returned.
         * @return {Object} An object with attribute name/value pairs.
         */
        getAttrs : function(attrs) {
            return this._getAttrs(attrs);
        },

        /**
         * Implementation behind the public getAttrs method, to get multiple attribute values.
         *
         * @method _getAttrs
         * @protected
         * @param {String[]|Boolean} attrs Optional. An array of attribute names. If omitted, all attribute values are
         * returned. If set to true, all attributes modified from their initial values are returned.
         * @return {Object} An object with attribute name/value pairs.
         */
        _getAttrs : function(attrs) {
            var obj = {},
                attr, i, len,
                modifiedOnly = (attrs === true);

            // TODO - figure out how to get all "added"
            if (!attrs || modifiedOnly) {
                attrs = O.keys(this._state.data);
            }

            for (i = 0, len = attrs.length; i < len; i++) {
                attr = attrs[i];

                if (!modifiedOnly || this._getStateVal(attr) != this._state.get(attr, INIT_VALUE)) {
                    // Go through get, to honor cloning/normalization
                    obj[attr] = this.get(attr);
                }
            }

            return obj;
        },

        /**
         * Configures a group of attributes, and sets initial values.
         *
         * <p>
         * <strong>NOTE:</strong> This method does not isolate the configuration object by merging/cloning.
         * The caller is responsible for merging/cloning the configuration object if required.
         * </p>
         *
         * @method addAttrs
         * @chainable
         *
         * @param {Object} cfgs An object with attribute name/configuration pairs.
         * @param {Object} values An object with attribute name/value pairs, defining the initial values to apply.
         * Values defined in the cfgs argument will be over-written by values in this argument unless defined as read only.
         * @param {boolean} lazy Whether or not to delay the intialization of these attributes until the first call to get/set.
         * Individual attributes can over-ride this behavior by defining a lazyAdd configuration property in their configuration.
         * See <a href="#method_addAttr">addAttr</a>.
         *
         * @return {Object} A reference to the host object.
         */
        addAttrs : function(cfgs, values, lazy) {
            if (cfgs) {
                this._tCfgs = cfgs;
                this._tVals = (values) ? this._normAttrVals(values) : null;
                this._addAttrs(cfgs, this._tVals, lazy);
                this._tCfgs = this._tVals = null;
            }

            return this;
        },

        /**
         * Implementation behind the public addAttrs method.
         *
         * This method is invoked directly by get if it encounters a scenario
         * in which an attribute's valueFn attempts to obtain the
         * value an attribute in the same group of attributes, which has not yet
         * been added (on demand initialization).
         *
         * @method _addAttrs
         * @private
         * @param {Object} cfgs An object with attribute name/configuration pairs.
         * @param {Object} values An object with attribute name/value pairs, defining the initial values to apply.
         * Values defined in the cfgs argument will be over-written by values in this argument unless defined as read only.
         * @param {boolean} lazy Whether or not to delay the intialization of these attributes until the first call to get/set.
         * Individual attributes can over-ride this behavior by defining a lazyAdd configuration property in their configuration.
         * See <a href="#method_addAttr">addAttr</a>.
         */
        _addAttrs : function(cfgs, values, lazy) {
            var tCfgs = this._tCfgs,
                tVals = this._tVals,
                attr,
                attrCfg,
                value;

            for (attr in cfgs) {
                if (cfgs.hasOwnProperty(attr)) {

                    // Not Merging. Caller is responsible for isolating configs
                    attrCfg = cfgs[attr];
                    attrCfg.defaultValue = attrCfg.value;

                    // Handle simple, complex and user values, accounting for read-only
                    value = this._getAttrInitVal(attr, attrCfg, tVals);

                    if (value !== undefined) {
                        attrCfg.value = value;
                    }

                    if (tCfgs[attr]) {
                        tCfgs[attr] = undefined;
                    }

                    this.addAttr(attr, attrCfg, lazy);
                }
            }
        },

        /**
         * Utility method to protect an attribute configuration
         * hash, by merging the entire object and the individual
         * attr config objects.
         *
         * @method _protectAttrs
         * @protected
         * @param {Object} attrs A hash of attribute to configuration object pairs.
         * @return {Object} A protected version of the attrs argument.
         * @deprecated Use `AttributeCore.protectAttrs()` or
         *   `Attribute.protectAttrs()` which are the same static utility method.
         */
        _protectAttrs : AttributeCore.protectAttrs,

        /**
         * Utility method to normalize attribute values. The base implementation
         * simply merges the hash to protect the original.
         *
         * @method _normAttrVals
         * @param {Object} valueHash An object with attribute name/value pairs
         *
         * @return {Object} An object literal with 2 properties - "simple" and "complex",
         * containing simple and complex attribute values respectively keyed
         * by the top level attribute name, or null, if valueHash is falsey.
         *
         * @private
         */
        _normAttrVals : function(valueHash) {
            var vals,
                subvals,
                path,
                attr,
                v, k;

            if (!valueHash) {
                return null;
            }

            vals = {};

            for (k in valueHash) {
                if (valueHash.hasOwnProperty(k)) {
                    if (k.indexOf(DOT) !== -1) {
                        path = k.split(DOT);
                        attr = path.shift();

                        subvals = subvals || {};

                        v = subvals[attr] = subvals[attr] || [];
                        v[v.length] = {
                            path : path,
                            value: valueHash[k]
                        };
                    } else {
                        vals[k] = valueHash[k];
                    }
                }
            }

            return { simple:vals, complex:subvals };
        },

        /**
         * Returns the initial value of the given attribute from
         * either the default configuration provided, or the
         * over-ridden value if it exists in the set of initValues
         * provided and the attribute is not read-only.
         *
         * @param {String} attr The name of the attribute
         * @param {Object} cfg The attribute configuration object
         * @param {Object} initValues The object with simple and complex attribute name/value pairs returned from _normAttrVals
         *
         * @return {Any} The initial value of the attribute.
         *
         * @method _getAttrInitVal
         * @private
         */
        _getAttrInitVal : function(attr, cfg, initValues) {
            var val = cfg.value,
                valFn = cfg.valueFn,
                tmpVal,
                initValSet = false,
                readOnly = cfg.readOnly,
                simple,
                complex,
                i,
                l,
                path,
                subval,
                subvals;

            if (!readOnly && initValues) {
                // Simple Attributes
                simple = initValues.simple;
                if (simple && simple.hasOwnProperty(attr)) {
                    val = simple[attr];
                    initValSet = true;
                }
            }

            if (valFn && !initValSet) {
                if (!valFn.call) {
                    valFn = this[valFn];
                }
                if (valFn) {
                    tmpVal = valFn.call(this, attr);
                    val = tmpVal;
                }
            }

            if (!readOnly && initValues) {

                // Complex Attributes (complex values applied, after simple, in case both are set)
                complex = initValues.complex;

                if (complex && complex.hasOwnProperty(attr) && (val !== undefined) && (val !== null)) {
                    subvals = complex[attr];
                    for (i = 0, l = subvals.length; i < l; ++i) {
                        path = subvals[i].path;
                        subval = subvals[i].value;
                        O.setValue(val, path, subval);
                    }
                }
            }

            return val;
        },

        /**
         * Utility method to set up initial attributes defined during construction,
         * either through the constructor.ATTRS property, or explicitly passed in.
         *
         * @method _initAttrs
         * @protected
         * @param attrs {Object} The attributes to add during construction (passed through to <a href="#method_addAttrs">addAttrs</a>).
         *        These can also be defined on the constructor being augmented with Attribute by defining the ATTRS property on the constructor.
         * @param values {Object} The initial attribute values to apply (passed through to <a href="#method_addAttrs">addAttrs</a>).
         *        These are not merged/cloned. The caller is responsible for isolating user provided values if required.
         * @param lazy {boolean} Whether or not to add attributes lazily (passed through to <a href="#method_addAttrs">addAttrs</a>).
         */
        _initAttrs : function(attrs, values, lazy) {
            // ATTRS support for Node, which is not Base based
            attrs = attrs || this.constructor.ATTRS;

            var Base = Y.Base,
                BaseCore = Y.BaseCore,
                baseInst = (Base && Y.instanceOf(this, Base)),
                baseCoreInst = (!baseInst && BaseCore && Y.instanceOf(this, BaseCore));

            if (attrs && !baseInst && !baseCoreInst) {
                this.addAttrs(Y.AttributeCore.protectAttrs(attrs), values, lazy);
            }
        }
    };

    Y.AttributeCore = AttributeCore;


}, '3.17.2', {"requires": ["oop"]});


/***/ }),

/***/ 756426:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('attribute-extras', function (Y, NAME) {

    /**
     * The attribute module provides an augmentable Attribute implementation, which
     * adds configurable attributes and attribute change events to the class being
     * augmented. It also provides a State class, which is used internally by Attribute,
     * but can also be used independently to provide a name/property/value data structure to
     * store state.
     *
     * @module attribute
     */

    /**
     * The attribute-extras submodule provides less commonly used attribute methods, and can
     * be augmented/mixed into an implemention which used attribute-core.
     *
     * @module attribute
     * @submodule attribute-extras
     */
    var BROADCAST = "broadcast",
        PUBLISHED = "published",
        INIT_VALUE = "initValue",

        MODIFIABLE = {
            readOnly:1,
            writeOnce:1,
            getter:1,
            broadcast:1
        };

    /**
     * A augmentable implementation for AttributeCore, providing less frequently used
     * methods for Attribute management such as modifyAttrs(), removeAttr and reset()
     *
     * @class AttributeExtras
     * @extensionfor AttributeCore
     */
    function AttributeExtras() {}

    AttributeExtras.prototype = {

        /**
         * Updates the configuration of an attribute which has already been added.
         * <p>
         * The properties which can be modified through this interface are limited
         * to the following subset of attributes, which can be safely modified
         * after a value has already been set on the attribute:
         * </p>
         * <dl>
         *  <dt>readOnly;</dt>
         *  <dt>writeOnce;</dt>
         *  <dt>broadcast; and</dt>
         *  <dt>getter.</dt>
         * </dl>
         * <p>
         * Note: New attributes cannot be added using this interface. New attributes must be
         * added using {{#crossLink "AttributeCore/addAttr:method"}}addAttr{{/crossLink}}, or an
         * appropriate manner for a class which utilises Attributes (e.g. the
         * {{#crossLink "Base/ATTRS:property"}}ATTRS{{/crossLink}} property in
         * {{#crossLink "Base"}}Base{{/crossLink}}).
         * </p>
         * @method modifyAttr
         * @param {String} name The name of the attribute whose configuration is to be updated.
         * @param {Object} config An object with configuration property/value pairs, specifying the configuration properties to modify.
         */
        modifyAttr: function(name, config) {
            var host = this, // help compression
                prop, state;

            if (host.attrAdded(name)) {

                if (host._isLazyAttr(name)) {
                    host._addLazyAttr(name);
                }

                state = host._state;
                for (prop in config) {
                    if (MODIFIABLE[prop] && config.hasOwnProperty(prop)) {
                        state.add(name, prop, config[prop]);

                        // If we reconfigured broadcast, need to republish
                        if (prop === BROADCAST) {
                            state.remove(name, PUBLISHED);
                        }
                    }
                }
            } else {
            }
        },

        /**
         * Removes an attribute from the host object
         *
         * @method removeAttr
         * @param {String} name The name of the attribute to be removed.
         */
        removeAttr: function(name) {
            this._state.removeAll(name);
        },

        /**
         * Resets the attribute (or all attributes) to its initial value, as long as
         * the attribute is not readOnly, or writeOnce.
         *
         * @method reset
         * @param {String} name Optional. The name of the attribute to reset.  If omitted, all attributes are reset.
         * @return {Object} A reference to the host object.
         * @chainable
         */
        reset : function(name) {
            var host = this;  // help compression

            if (name) {
                if (host._isLazyAttr(name)) {
                    host._addLazyAttr(name);
                }
                host.set(name, host._state.get(name, INIT_VALUE));
            } else {
                Y.Object.each(host._state.data, function(v, n) {
                    host.reset(n);
                });
            }
            return host;
        },

        /**
         * Returns an object with the configuration properties (and value)
         * for the given attribute. If attrName is not provided, returns the
         * configuration properties for all attributes.
         *
         * @method _getAttrCfg
         * @protected
         * @param {String} name Optional. The attribute name. If not provided, the method will return the configuration for all attributes.
         * @return {Object} The configuration properties for the given attribute, or all attributes.
         */
        _getAttrCfg : function(name) {
            var o,
                state = this._state;

            if (name) {
                o = state.getAll(name) || {};
            } else {
                o = {};
                Y.each(state.data, function(v, n) {
                    o[n] = state.getAll(n);
                });
            }

            return o;
        }
    };

    Y.AttributeExtras = AttributeExtras;


}, '3.17.2', {"requires": ["oop"]});


/***/ }),

/***/ 132266:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('attribute-observable', function (Y, NAME) {

    /*For log lines*/
    /*jshint maxlen:200*/


    /**
     * The attribute module provides an augmentable Attribute implementation, which
     * adds configurable attributes and attribute change events to the class being
     * augmented. It also provides a State class, which is used internally by Attribute,
     * but can also be used independently to provide a name/property/value data structure to
     * store state.
     *
     * @module attribute
     */

    /**
     * The `attribute-observable` submodule provides augmentable attribute change event support
     * for AttributeCore based implementations.
     *
     * @module attribute
     * @submodule attribute-observable
     */
    var EventTarget = Y.EventTarget,

        CHANGE = "Change",
        BROADCAST = "broadcast";

    /**
     * Provides an augmentable implementation of attribute change events for
     * AttributeCore.
     *
     * @class AttributeObservable
     * @extensionfor AttributeCore
     * @uses EventTarget
     */
    function AttributeObservable() {
        // Perf tweak - avoid creating event literals if not required.
        this._ATTR_E_FACADE = {};

        EventTarget.call(this, {emitFacade:true});
    }

    AttributeObservable._ATTR_CFG = [BROADCAST];

    AttributeObservable.prototype = {

        /**
         * Sets the value of an attribute.
         *
         * @method set
         * @chainable
         *
         * @param {String} name The name of the attribute. If the
         * current value of the attribute is an Object, dot notation can be used
         * to set the value of a property within the object (e.g. <code>set("x.y.z", 5)</code>).
         *
         * @param {Any} value The value to set the attribute to.
         *
         * @param {Object} opts (Optional) Optional event data to be mixed into
         * the event facade passed to subscribers of the attribute's change event. This
         * can be used as a flexible way to identify the source of a call to set, allowing
         * the developer to distinguish between set called internally by the host, vs.
         * set called externally by the application developer.
         *
         * @return {Object} A reference to the host object.
         */
        set : function(name, val, opts) {
            return this._setAttr(name, val, opts);
        },

        /**
         * Allows setting of readOnly/writeOnce attributes. See <a href="#method_set">set</a> for argument details.
         *
         * @method _set
         * @protected
         * @chainable
         *
         * @param {String} name The name of the attribute.
         * @param {Any} val The value to set the attribute to.
         * @param {Object} opts (Optional) Optional event data to be mixed into
         * the event facade passed to subscribers of the attribute's change event.
         * @return {Object} A reference to the host object.
         */
        _set : function(name, val, opts) {
            return this._setAttr(name, val, opts, true);
        },

        /**
         * Sets multiple attribute values.
         *
         * @method setAttrs
         * @param {Object} attrs  An object with attributes name/value pairs.
         * @param {Object} opts  Properties to mix into the event payload. These are shared and mixed into each set
         * @return {Object} A reference to the host object.
         * @chainable
         */
        setAttrs : function(attrs, opts) {
            return this._setAttrs(attrs, opts);
        },

        /**
         * Implementation behind the public setAttrs method, to set multiple attribute values.
         *
         * @method _setAttrs
         * @protected
         * @param {Object} attrs  An object with attributes name/value pairs.
         * @param {Object} opts  Properties to mix into the event payload. These are shared and mixed into each set
         * @return {Object} A reference to the host object.
         * @chainable
         */
        _setAttrs : function(attrs, opts) {
            var attr;
            for (attr in attrs) {
                if ( attrs.hasOwnProperty(attr) ) {
                    this.set(attr, attrs[attr], opts);
                }
            }
            return this;
        },

        /**
         * Utility method to help setup the event payload and fire the attribute change event.
         *
         * @method _fireAttrChange
         * @private
         * @param {String} attrName The name of the attribute
         * @param {String} subAttrName The full path of the property being changed,
         * if this is a sub-attribute value being change. Otherwise null.
         * @param {Any} currVal The current value of the attribute
         * @param {Any} newVal The new value of the attribute
         * @param {Object} opts Any additional event data to mix into the attribute change event's event facade.
         * @param {Object} [cfg] The attribute config stored in State, if already available.
         */
        _fireAttrChange : function(attrName, subAttrName, currVal, newVal, opts, cfg) {
            var host = this,
                eventName = this._getFullType(attrName + CHANGE),
                state = host._state,
                facade,
                broadcast,
                e;

            if (!cfg) {
                cfg = state.data[attrName] || {};
            }

            if (!cfg.published) {

                // PERF: Using lower level _publish() for
                // critical path performance
                e = host._publish(eventName);

                e.emitFacade = true;
                e.defaultTargetOnly = true;
                e.defaultFn = host._defAttrChangeFn;

                broadcast = cfg.broadcast;
                if (broadcast !== undefined) {
                    e.broadcast = broadcast;
                }

                cfg.published = true;
            }

            if (opts) {
                facade = Y.merge(opts);
                facade._attrOpts = opts;
            } else {
                facade = host._ATTR_E_FACADE;
            }

            // Not using the single object signature for fire({type:..., newVal:...}), since
            // we don't want to override type. Changed to the fire(type, {newVal:...}) signature.

            facade.attrName = attrName;
            facade.subAttrName = subAttrName;
            facade.prevVal = currVal;
            facade.newVal = newVal;

            if (host._hasPotentialSubscribers(eventName)) {
                host.fire(eventName, facade);
            } else {
                this._setAttrVal(attrName, subAttrName, currVal, newVal, opts, cfg);
            }
        },

        /**
         * Default function for attribute change events.
         *
         * @private
         * @method _defAttrChangeFn
         * @param {EventFacade} e The event object for attribute change events.
         * @param {boolean} eventFastPath Whether or not we're using this as a fast path in the case of no listeners or not
         */
        _defAttrChangeFn : function(e, eventFastPath) {

            var opts = e._attrOpts;
            if (opts) {
                delete e._attrOpts;
            }

            if (!this._setAttrVal(e.attrName, e.subAttrName, e.prevVal, e.newVal, opts)) {


                if (!eventFastPath) {
                    // Prevent "after" listeners from being invoked since nothing changed.
                    e.stopImmediatePropagation();
                }

            } else {
                if (!eventFastPath) {
                    e.newVal = this.get(e.attrName);
                }
            }
        }
    };

    // Basic prototype augment - no lazy constructor invocation.
    Y.mix(AttributeObservable, EventTarget, false, null, 1);

    Y.AttributeObservable = AttributeObservable;

    /**
    The `AttributeEvents` class extension was deprecated in YUI 3.8.0 and is now
    an alias for the `AttributeObservable` class extension. Use that class
    extnesion instead. This alias will be removed in a future version of YUI.

    @class AttributeEvents
    @uses EventTarget
    @deprecated Use `AttributeObservable` instead.
    @see AttributeObservable
    **/
    Y.AttributeEvents = AttributeObservable;


}, '3.17.2', {"requires": ["event-custom"]});


/***/ }),

/***/ 922770:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('base-base', function (Y, NAME) {

    /**
     * The base module provides the Base class, which objects requiring attribute and custom event support can extend.
     * The module also provides two ways to reuse code - It augments Base with the Plugin.Host interface which provides
     * plugin support and also provides the BaseCore.build method which provides a way to build custom classes using extensions.
     *
     * @module base
     */

    /**
     * The base-base submodule provides the Base class without the Plugin support, provided by Plugin.Host,
     * and without the extension support provided by BaseCore.build.
     *
     * @module base
     * @submodule base-base
     */

    var AttributeCore   = Y.AttributeCore,
        AttributeExtras = Y.AttributeExtras,
        BaseCore        = Y.BaseCore,
        BaseObservable  = Y.BaseObservable;

    /**
     * <p>
     * A base class which objects requiring attributes and custom event support can
     * extend. Base also handles the chaining of initializer and destructor methods across
     * the hierarchy as part of object construction and destruction. Additionally, attributes configured
     * through the static <a href="#property_ATTRS">ATTRS</a> property for each class
     * in the hierarchy will be initialized by Base.
     * </p>
     *
     * <p>
     * **NOTE:** Prior to version 3.11.0, ATTRS would get added a class at a time. That is,
     * Base would loop through each class in the hierarchy, and add the class' ATTRS, and
     * then call it's initializer, and move on to the subclass' ATTRS and initializer. As of
     * 3.11.0, ATTRS from all classes in the hierarchy are added in one `addAttrs` call before
     * any initializers are called. This fixes subtle edge-case issues with subclass ATTRS overriding
     * superclass `setter`, `getter` or `valueFn` definitions and being unable to get/set attributes
     * defined by the subclass. This order of operation change may impact `setter`, `getter` or `valueFn`
     * code which expects a superclass' initializer to have run. This is expected to be rare, but to support
     * it, Base supports a `_preAddAttrs()`, method hook (same signature as `addAttrs`). Components can
     * implement this method on their prototype for edge cases which do require finer control over
     * the order in which attributes are added (see widget-htmlparser).
     * </p>
     *
     * <p>
     * The static <a href="#property_NAME">NAME</a> property of each class extending
     * from Base will be used as the identifier for the class, and is used by Base to prefix
     * all events fired by instances of that class.
     * </p>
     *
     * @class Base
     * @constructor
     * @uses BaseCore
     * @uses BaseObservable
     * @uses AttributeCore
     * @uses AttributeObservable
     * @uses AttributeExtras
     * @uses EventTarget
     *
     * @param {Object} config Object with configuration property name/value pairs. The object can be
     * used to provide default values for the objects published attributes.
     *
     * <p>
     * The config object can also contain the following non-attribute properties, providing a convenient
     * way to configure events listeners and plugins for the instance, as part of the constructor call:
     * </p>
     *
     * <dl>
     *   <dt>on</dt>
     *   <dd>An event name to listener function map, to register event listeners for the "on" moment of the event.
     *       A constructor convenience property for the <a href="Base.html#method_on">on</a> method.</dd>
     *   <dt>after</dt>
     *   <dd>An event name to listener function map, to register event listeners for the "after" moment of the event.
     *       A constructor convenience property for the <a href="Base.html#method_after">after</a> method.</dd>
     *   <dt>bubbleTargets</dt>
     *   <dd>An object, or array of objects, to register as bubble targets for bubbled events fired by this instance.
     *       A constructor convenience property for the <a href="EventTarget.html#method_addTarget">addTarget</a> method.</dd>
     *   <dt>plugins</dt>
     *   <dd>A plugin, or array of plugins to be plugged into the instance (see PluginHost's plug method for signature details).
     *       A constructor convenience property for the <a href="Plugin.Host.html#method_plug">plug</a> method.</dd>
     * </dl>
     */
    function Base() {
        BaseCore.apply(this, arguments);
        BaseObservable.apply(this, arguments);
        AttributeExtras.apply(this, arguments);
    }

    /**
     * The list of properties which can be configured for
     * each attribute (e.g. setter, getter, writeOnce, readOnly etc.)
     *
     * @property _ATTR_CFG
     * @type Array
     * @static
     * @private
     */
    Base._ATTR_CFG = BaseCore._ATTR_CFG.concat(BaseObservable._ATTR_CFG);

    /**
     * The array of non-attribute configuration properties supported by this class.
     *
     * `Base` supports "on", "after", "plugins" and "bubbleTargets" properties,
     * which are not set up as attributes.
     *
     * This property is primarily required so that when
     * <a href="#property__allowAdHocAttrs">`_allowAdHocAttrs`</a> is enabled by
     * a class, non-attribute configurations don't get added as ad-hoc attributes.
     *
     * @property _NON_ATTRS_CFG
     * @type Array
     * @static
     * @private
     */
    Base._NON_ATTRS_CFG = BaseCore._NON_ATTRS_CFG.concat(BaseObservable._NON_ATTRS_CFG);

    /**
     * <p>
     * The string to be used to identify instances of
     * this class, for example in prefixing events.
     * </p>
     * <p>
     * Classes extending Base, should define their own
     * static NAME property, which should be camelCase by
     * convention (e.g. MyClass.NAME = "myClass";).
     * </p>
     * @property NAME
     * @type String
     * @static
     */
    Base.NAME = 'base';

    /**
     * The default set of attributes which will be available for instances of this class, and
     * their configuration. In addition to the configuration properties listed by
     * Attribute's <a href="Attribute.html#method_addAttr">addAttr</a> method, the attribute
     * can also be configured with a "cloneDefaultValue" property, which defines how the statically
     * defined value field should be protected ("shallow", "deep" and false are supported values).
     *
     * By default if the value is an object literal or an array it will be "shallow" cloned, to
     * protect the default value.
     *
     * @property ATTRS
     * @type Object
     * @static
     */
    Base.ATTRS = AttributeCore.protectAttrs(BaseCore.ATTRS);

    /**
    Provides a way to safely modify a `Y.Base` subclass' static `ATTRS` after
    the class has been defined or created.

    Base-based classes cache information about the class hierarchy in order to
    efficiently create instances. This cache includes includes the aggregated
    `ATTRS` configs. If the static `ATTRS` configs need to be modified after the
    class has been defined or create, then use this method which will make sure
    to clear any cached data before making any modifications.

    @method modifyAttrs
    @param {Function} [ctor] The constructor function whose `ATTRS` should be
        modified. If a `ctor` function is not specified, then `this` is assumed
        to be the constructor which hosts the `ATTRS`.
    @param {Object} configs The collection of `ATTRS` configs to mix with the
        existing attribute configurations.
    @static
    @since 3.10.0
    **/
    Base.modifyAttrs = BaseCore.modifyAttrs;

    Y.mix(Base, BaseCore, false, null, 1);
    Y.mix(Base, AttributeExtras, false, null, 1);

    // Needs to be `true`, to overwrite methods from `BaseCore`.
    Y.mix(Base, BaseObservable, true, null, 1);

    // Fix constructor
    Base.prototype.constructor = Base;

    Y.Base = Base;


}, '3.17.2', {"requires": ["attribute-base", "base-core", "base-observable"]});


/***/ }),

/***/ 230070:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('base-build', function (Y, NAME) {

    /**
     * The base-build submodule provides Base.build functionality, which
     * can be used to create custom classes, by aggregating extensions onto
     * a main class.
     *
     * @module base
     * @submodule base-build
     * @for Base
     */
    var BaseCore = Y.BaseCore,
        Base     = Y.Base,
        L        = Y.Lang,

        INITIALIZER = "initializer",
        DESTRUCTOR  = "destructor",
        AGGREGATES  = ["_PLUG", "_UNPLUG"],

        build;

    // Utility function used in `_buildCfg` to aggregate array values into a new
    // array from the sender constructor to the receiver constructor.
    function arrayAggregator(prop, r, s) {
        if (s[prop]) {
            r[prop] = (r[prop] || []).concat(s[prop]);
        }
    }

    // Utility function used in `_buildCfg` to aggregate `_ATTR_CFG` array
    // values from the sender constructor into a new array on receiver's
    // constructor, and clear the cached hash.
    function attrCfgAggregator(prop, r, s) {
        if (s._ATTR_CFG) {
            // Clear cached hash.
            r._ATTR_CFG_HASH = null;

            arrayAggregator.apply(null, arguments);
        }
    }

    // Utility function used in `_buildCfg` to aggregate ATTRS configs from one
    // the sender constructor to the receiver constructor.
    function attrsAggregator(prop, r, s) {
        BaseCore.modifyAttrs(r, s.ATTRS);
    }

    Base._build = function(name, main, extensions, px, sx, cfg) {

        var build = Base._build,

            builtClass = build._ctor(main, cfg),
            buildCfg = build._cfg(main, cfg, extensions),

            _mixCust = build._mixCust,

            dynamic = builtClass._yuibuild.dynamic,

            i, l, extClass, extProto,
            initializer,
            destructor;

        // Augment/Aggregate
        for (i = 0, l = extensions.length; i < l; i++) {
            extClass = extensions[i];

            extProto = extClass.prototype;

            initializer = extProto[INITIALIZER];
            destructor = extProto[DESTRUCTOR];
            delete extProto[INITIALIZER];
            delete extProto[DESTRUCTOR];

            // Prototype, old non-displacing augment
            Y.mix(builtClass, extClass, true, null, 1);

            // Custom Statics
            _mixCust(builtClass, extClass, buildCfg);

            if (initializer) {
                extProto[INITIALIZER] = initializer;
            }

            if (destructor) {
                extProto[DESTRUCTOR] = destructor;
            }

            builtClass._yuibuild.exts.push(extClass);
        }

        if (px) {
            Y.mix(builtClass.prototype, px, true);
        }

        if (sx) {
            Y.mix(builtClass, build._clean(sx, buildCfg), true);
            _mixCust(builtClass, sx, buildCfg);
        }

        builtClass.prototype.hasImpl = build._impl;

        if (dynamic) {
            builtClass.NAME = name;
            builtClass.prototype.constructor = builtClass;

            // Carry along the reference to `modifyAttrs()` from `main`.
            builtClass.modifyAttrs = main.modifyAttrs;
        }

        return builtClass;
    };

    build = Base._build;

    Y.mix(build, {

        _mixCust: function(r, s, cfg) {

            var aggregates,
                custom,
                statics,
                aggr,
                l,
                i;

            if (cfg) {
                aggregates = cfg.aggregates;
                custom = cfg.custom;
                statics = cfg.statics;
            }

            if (statics) {
                Y.mix(r, s, true, statics);
            }

            if (aggregates) {
                for (i = 0, l = aggregates.length; i < l; i++) {
                    aggr = aggregates[i];
                    if (!r.hasOwnProperty(aggr) && s.hasOwnProperty(aggr)) {
                        r[aggr] = L.isArray(s[aggr]) ? [] : {};
                    }
                    Y.aggregate(r, s, true, [aggr]);
                }
            }

            if (custom) {
                for (i in custom) {
                    if (custom.hasOwnProperty(i)) {
                        custom[i](i, r, s);
                    }
                }
            }

        },

        _tmpl: function(main) {

            function BuiltClass() {
                BuiltClass.superclass.constructor.apply(this, arguments);
            }
            Y.extend(BuiltClass, main);

            return BuiltClass;
        },

        _impl : function(extClass) {
            var classes = this._getClasses(), i, l, cls, exts, ll, j;
            for (i = 0, l = classes.length; i < l; i++) {
                cls = classes[i];
                if (cls._yuibuild) {
                    exts = cls._yuibuild.exts;
                    ll = exts.length;

                    for (j = 0; j < ll; j++) {
                        if (exts[j] === extClass) {
                            return true;
                        }
                    }
                }
            }
            return false;
        },

        _ctor : function(main, cfg) {

           var dynamic = (cfg && false === cfg.dynamic) ? false : true,
               builtClass = (dynamic) ? build._tmpl(main) : main,
               buildCfg = builtClass._yuibuild;

            if (!buildCfg) {
                buildCfg = builtClass._yuibuild = {};
            }

            buildCfg.id = buildCfg.id || null;
            buildCfg.exts = buildCfg.exts || [];
            buildCfg.dynamic = dynamic;

            return builtClass;
        },

        _cfg : function(main, cfg, exts) {
            var aggr = [],
                cust = {},
                statics = [],
                buildCfg,
                cfgAggr = (cfg && cfg.aggregates),
                cfgCustBuild = (cfg && cfg.custom),
                cfgStatics = (cfg && cfg.statics),
                c = main,
                i,
                l;

            // Prototype Chain
            while (c && c.prototype) {
                buildCfg = c._buildCfg;
                if (buildCfg) {
                    if (buildCfg.aggregates) {
                        aggr = aggr.concat(buildCfg.aggregates);
                    }
                    if (buildCfg.custom) {
                        Y.mix(cust, buildCfg.custom, true);
                    }
                    if (buildCfg.statics) {
                        statics = statics.concat(buildCfg.statics);
                    }
                }
                c = c.superclass ? c.superclass.constructor : null;
            }

            // Exts
            if (exts) {
                for (i = 0, l = exts.length; i < l; i++) {
                    c = exts[i];
                    buildCfg = c._buildCfg;
                    if (buildCfg) {
                        if (buildCfg.aggregates) {
                            aggr = aggr.concat(buildCfg.aggregates);
                        }
                        if (buildCfg.custom) {
                            Y.mix(cust, buildCfg.custom, true);
                        }
                        if (buildCfg.statics) {
                            statics = statics.concat(buildCfg.statics);
                        }
                    }
                }
            }

            if (cfgAggr) {
                aggr = aggr.concat(cfgAggr);
            }

            if (cfgCustBuild) {
                Y.mix(cust, cfg.cfgBuild, true);
            }

            if (cfgStatics) {
                statics = statics.concat(cfgStatics);
            }

            return {
                aggregates: aggr,
                custom: cust,
                statics: statics
            };
        },

        _clean : function(sx, cfg) {
            var prop, i, l, sxclone = Y.merge(sx),
                aggregates = cfg.aggregates,
                custom = cfg.custom;

            for (prop in custom) {
                if (sxclone.hasOwnProperty(prop)) {
                    delete sxclone[prop];
                }
            }

            for (i = 0, l = aggregates.length; i < l; i++) {
                prop = aggregates[i];
                if (sxclone.hasOwnProperty(prop)) {
                    delete sxclone[prop];
                }
            }

            return sxclone;
        }
    });

    /**
     * <p>
     * Builds a custom constructor function (class) from the
     * main function, and array of extension functions (classes)
     * provided. The NAME field for the constructor function is
     * defined by the first argument passed in.
     * </p>
     * <p>
     * The cfg object supports the following properties
     * </p>
     * <dl>
     *    <dt>dynamic &#60;boolean&#62;</dt>
     *    <dd>
     *    <p>If true (default), a completely new class
     *    is created which extends the main class, and acts as the
     *    host on which the extension classes are augmented.</p>
     *    <p>If false, the extensions classes are augmented directly to
     *    the main class, modifying the main class' prototype.</p>
     *    </dd>
     *    <dt>aggregates &#60;String[]&#62;</dt>
     *    <dd>An array of static property names, which will get aggregated
     *    on to the built class, in addition to the default properties build
     *    will always aggregate as defined by the main class' static _buildCfg
     *    property.
     *    </dd>
     * </dl>
     *
     * @method build
     * @deprecated Use the more convenient Base.create and Base.mix methods instead
     * @static
     * @param {Function} name The name of the new class. Used to define the NAME property for the new class.
     * @param {Function} main The main class on which to base the built class
     * @param {Function[]} extensions The set of extension classes which will be
     * augmented/aggregated to the built class.
     * @param {Object} cfg Optional. Build configuration for the class (see description).
     * @return {Function} A custom class, created from the provided main and extension classes
     */
    Base.build = function(name, main, extensions, cfg) {
        return build(name, main, extensions, null, null, cfg);
    };

    /**
     * Creates a new class (constructor function) which extends the base class passed in as the second argument,
     * and mixes in the array of extensions provided.
     *
     * Prototype properties or methods can be added to the new class, using the px argument (similar to Y.extend).
     *
     * Static properties or methods can be added to the new class, using the sx argument (similar to Y.extend).
     *
     * **NOTE FOR COMPONENT DEVELOPERS**: Both the `base` class, and `extensions` can define static a `_buildCfg`
     * property, which acts as class creation meta-data, and drives how special static properties from the base
     * class, or extensions should be copied, aggregated or (custom) mixed into the newly created class.
     *
     * The `_buildCfg` property is a hash with 3 supported properties: `statics`, `aggregates` and `custom`, e.g:
     *
     *     // If the Base/Main class is the thing introducing the property:
     *
     *     MyBaseClass._buildCfg = {
     *
     *        // Static properties/methods to copy (Alias) to the built class.
     *        statics: ["CopyThisMethod", "CopyThisProperty"],
     *
     *        // Static props to aggregate onto the built class.
     *        aggregates: ["AggregateThisProperty"],
     *
     *        // Static properties which need custom handling (e.g. deep merge etc.)
     *        custom: {
     *           "CustomProperty" : function(property, Receiver, Supplier) {
     *              ...
     *              var triggers = Receiver.CustomProperty.triggers;
     *              Receiver.CustomProperty.triggers = triggers.concat(Supplier.CustomProperty.triggers);
     *              ...
     *           }
     *        }
     *     };
     *
     *     MyBaseClass.CopyThisMethod = function() {...};
     *     MyBaseClass.CopyThisProperty = "foo";
     *     MyBaseClass.AggregateThisProperty = {...};
     *     MyBaseClass.CustomProperty = {
     *        triggers: [...]
     *     }
     *
     *     // Or, if the Extension is the thing introducing the property:
     *
     *     MyExtension._buildCfg = {
     *         statics : ...
     *         aggregates : ...
     *         custom : ...
     *     }
     *
     * This way, when users pass your base or extension class to `Y.Base.create` or `Y.Base.mix`, they don't need to
     * know which properties need special handling. `Y.Base` has a buildCfg which defines `ATTRS` for custom mix handling
     * (to protect the static config objects), and `Y.Widget` has a buildCfg which specifies `HTML_PARSER` for
     * straight up aggregation.
     *
     * @method create
     * @static
     * @param {String} name The name of the newly created class. Used to define the NAME property for the new class.
     * @param {Function} main The base class which the new class should extend.
     * This class needs to be Base or a class derived from base (e.g. Widget).
     * @param {Function[]} extensions The list of extensions which will be mixed into the built class.
     * @param {Object} px The set of prototype properties/methods to add to the built class.
     * @param {Object} sx The set of static properties/methods to add to the built class.
     * @return {Function} The newly created class.
     */
    Base.create = function(name, base, extensions, px, sx) {
        if (Y.config.win === Y.config.win.top) {
            YUI.stats.markCreate(name);
        }
        return build(name, base, extensions, px, sx);
    };

    /**
     * <p>Mixes in a list of extensions to an existing class.</p>
     * @method mix
     * @static
     * @param {Function} main The existing class into which the extensions should be mixed.
     * The class needs to be Base or a class derived from Base (e.g. Widget)
     * @param {Function[]} extensions The set of extension classes which will mixed into the existing main class.
     * @return {Function} The modified main class, with extensions mixed in.
     */
    Base.mix = function(main, extensions) {

        if (main._CACHED_CLASS_DATA) {
            main._CACHED_CLASS_DATA = null;
        }

        return build(null, main, extensions, null, null, {dynamic:false});
    };

    /**
     * The build configuration for the Base class.
     *
     * Defines the static fields which need to be aggregated when the Base class
     * is used as the main class passed to the
     * <a href="#method_Base.build">Base.build</a> method.
     *
     * @property _buildCfg
     * @type Object
     * @static
     * @final
     * @private
     */
    BaseCore._buildCfg = {
        aggregates: AGGREGATES.concat(),

        custom: {
            ATTRS         : attrsAggregator,
            _ATTR_CFG     : attrCfgAggregator,
            _NON_ATTRS_CFG: arrayAggregator
        }
    };

    // Makes sure Base and BaseCore use separate `_buildCfg` objects.
    Base._buildCfg = {
        aggregates: AGGREGATES.concat(),

        custom: {
            ATTRS         : attrsAggregator,
            _ATTR_CFG     : attrCfgAggregator,
            _NON_ATTRS_CFG: arrayAggregator
        }
    };


}, '3.17.2', {"requires": ["base-base"]});


/***/ }),

/***/ 60471:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('base-core', function (Y, NAME) {

    /**
     * The base module provides the Base class, which objects requiring attribute and custom event support can extend.
     * The module also provides two ways to reuse code - It augments Base with the Plugin.Host interface which provides
     * plugin support and also provides the BaseCore.build method which provides a way to build custom classes using extensions.
     *
     * @module base
     */

    /**
     * <p>The base-core module provides the BaseCore class, the lightest version of Base,
     * which provides Base's basic lifecycle management and ATTRS construction support,
     * but doesn't fire init/destroy or attribute change events.</p>
     *
     * <p>It mixes in AttributeCore, which is the lightest version of Attribute</p>
     *
     * @module base
     * @submodule base-core
     */
    var O = Y.Object,
        L = Y.Lang,
        DOT = ".",
        INITIALIZED = "initialized",
        DESTROYED = "destroyed",
        INITIALIZER = "initializer",
        VALUE = "value",
        OBJECT_CONSTRUCTOR = Object.prototype.constructor,
        DEEP = "deep",
        SHALLOW = "shallow",
        DESTRUCTOR = "destructor",

        AttributeCore = Y.AttributeCore,

        _wlmix = function(r, s, wlhash) {
            var p;
            for (p in s) {
                if(wlhash[p]) {
                    r[p] = s[p];
                }
            }
            return r;
        };

    /**
     * The BaseCore class, is the lightest version of Base, and provides Base's
     * basic lifecycle management and ATTRS construction support, but doesn't
     * fire init/destroy or attribute change events.
     *
     * BaseCore also handles the chaining of initializer and destructor methods across
     * the hierarchy as part of object construction and destruction. Additionally, attributes
     * configured through the static <a href="#property_BaseCore.ATTRS">ATTRS</a>
     * property for each class in the hierarchy will be initialized by BaseCore.
     *
     * Classes which require attribute support, but don't intend to use/expose attribute
     * change events can extend BaseCore instead of Base for optimal kweight and
     * runtime performance.
     *
     * **3.11.0 BACK COMPAT NOTE FOR COMPONENT DEVELOPERS**
     *
     * Prior to version 3.11.0, ATTRS would get added a class at a time. That is:
     *
     * <pre>
     *    for each (class in the hierarchy) {
     *       Call the class Extension constructors.
     *
     *       Add the class ATTRS.
     *
     *       Call the class initializer
     *       Call the class Extension initializers.
     *    }
     * </pre>
     *
     * As of 3.11.0, ATTRS from all classes in the hierarchy are added in one `addAttrs` call
     * before **any** initializers are called. That is, the flow becomes:
     *
     * <pre>
     *    for each (class in the hierarchy) {
     *       Call the class Extension constructors.
     *    }
     *
     *    Add ATTRS for all classes
     *
     *    for each (class in the hierarchy) {
     *       Call the class initializer.
     *       Call the class Extension initializers.
     *    }
     * </pre>
     *
     * Adding all ATTRS at once fixes subtle edge-case issues with subclass ATTRS overriding
     * superclass `setter`, `getter` or `valueFn` definitions and being unable to get/set attributes
     * defined by the subclass. It also leaves us with a cleaner order of operation flow moving
     * forward.
     *
     * However, it may require component developers to upgrade their components, for the following
     * scenarios:
     *
     * 1. It impacts components which may have `setter`, `getter` or `valueFn` code which
     * expects a superclass' initializer to have run.
     *
     * This is expected to be rare, but to support it, Base now supports a `_preAddAttrs()`, method
     * hook (same signature as `addAttrs`). Components can implement this method on their prototype
     * for edge cases which do require finer control over the order in which attributes are added
     * (see widget-htmlparser for example).
     *
     * 2. Extension developers may need to move code from Extension constructors to `initializer`s
     *
     * Older extensions, which were written before `initializer` support was added, had a lot of
     * initialization code in their constructors. For example, code which acccessed superclass
     * attributes. With the new flow this code would not be able to see attributes. The recommendation
     * is to move this initialization code to an `initializer` on the Extension, which was the
     * recommendation for anything created after `initializer` support for Extensions was added.
     *
     * @class BaseCore
     * @constructor
     * @uses AttributeCore
     * @param {Object} cfg Object with configuration property name/value pairs.
     * The object can be used to provide initial values for the objects published
     * attributes.
     */
    function BaseCore(cfg) {
        if (!this._BaseInvoked) {
            this._BaseInvoked = true;

            this._initBase(cfg);
        }
    }

    /**
     * The list of properties which can be configured for each attribute
     * (e.g. setter, getter, writeOnce, readOnly etc.)
     *
     * @property _ATTR_CFG
     * @type Array
     * @static
     * @private
     */
    BaseCore._ATTR_CFG = AttributeCore._ATTR_CFG.concat("cloneDefaultValue");

    /**
     * The array of non-attribute configuration properties supported by this class.
     *
     * For example `BaseCore` defines a "plugins" configuration property which
     * should not be set up as an attribute. This property is primarily required so
     * that when <a href="#property__allowAdHocAttrs">`_allowAdHocAttrs`</a> is enabled by a class,
     * non-attribute configuration properties don't get added as ad-hoc attributes.
     *
     * @property _NON_ATTRS_CFG
     * @type Array
     * @static
     * @private
     */
    BaseCore._NON_ATTRS_CFG = ["plugins"];

    /**
     * This property controls whether or not instances of this class should
     * allow users to add ad-hoc attributes through the constructor configuration
     * hash.
     *
     * AdHoc attributes are attributes which are not defined by the class, and are
     * not handled by the MyClass._NON_ATTRS_CFG
     *
     * @property _allowAdHocAttrs
     * @type boolean
     * @default undefined (false)
     * @protected
     */

    /**
     * The string to be used to identify instances of this class.
     *
     * Classes extending BaseCore, should define their own
     * static NAME property, which should be camelCase by
     * convention (e.g. MyClass.NAME = "myClass";).
     *
     * @property NAME
     * @type String
     * @static
     */
    BaseCore.NAME = "baseCore";

    /**
     * The default set of attributes which will be available for instances of this class, and
     * their configuration. In addition to the configuration properties listed by
     * AttributeCore's <a href="AttributeCore.html#method_addAttr">addAttr</a> method,
     * the attribute can also be configured with a "cloneDefaultValue" property, which
     * defines how the statically defined value field should be protected
     * ("shallow", "deep" and false are supported values).
     *
     * By default if the value is an object literal or an array it will be "shallow"
     * cloned, to protect the default value.
     *
     * @property ATTRS
     * @type Object
     * @static
     */
    BaseCore.ATTRS = {
        /**
         * Flag indicating whether or not this object
         * has been through the init lifecycle phase.
         *
         * @attribute initialized
         * @readonly
         * @default false
         * @type boolean
         */
        initialized: {
            readOnly:true,
            value:false
        },

        /**
         * Flag indicating whether or not this object
         * has been through the destroy lifecycle phase.
         *
         * @attribute destroyed
         * @readonly
         * @default false
         * @type boolean
         */
        destroyed: {
            readOnly:true,
            value:false
        }
    };

    /**
    Provides a way to safely modify a `Y.BaseCore` subclass' static `ATTRS`
    after the class has been defined or created.

    BaseCore-based classes cache information about the class hierarchy in order
    to efficiently create instances. This cache includes includes the aggregated
    `ATTRS` configs. If the static `ATTRS` configs need to be modified after the
    class has been defined or create, then use this method which will make sure
    to clear any cached data before making any modifications.

    @method modifyAttrs
    @param {Function} [ctor] The constructor function whose `ATTRS` should be
        modified. If a `ctor` function is not specified, then `this` is assumed
        to be the constructor which hosts the `ATTRS`.
    @param {Object} configs The collection of `ATTRS` configs to mix with the
        existing attribute configurations.
    @static
    @since 3.10.0
    **/
    BaseCore.modifyAttrs = function (ctor, configs) {
        // When called without a constructor, assume `this` is the constructor.
        if (typeof ctor !== 'function') {
            configs = ctor;
            ctor    = this;
        }

        var attrs, attr, name;

        // Eagerly create the `ATTRS` object if it doesn't already exist.
        attrs = ctor.ATTRS || (ctor.ATTRS = {});

        if (configs) {
            // Clear cache because it has ATTRS aggregation data which is about
            // to be modified.
            ctor._CACHED_CLASS_DATA = null;

            for (name in configs) {
                if (configs.hasOwnProperty(name)) {
                    attr = attrs[name] || (attrs[name] = {});
                    Y.mix(attr, configs[name], true);
                }
            }
        }
    };

    BaseCore.prototype = {

        /**
         * Internal construction logic for BaseCore.
         *
         * @method _initBase
         * @param {Object} config The constructor configuration object
         * @private
         */
        _initBase : function(config) {

            Y.stamp(this);

            this._initAttribute(config);

            // If Plugin.Host has been augmented [ through base-pluginhost ], setup it's
            // initial state, but don't initialize Plugins yet. That's done after initialization.
            var PluginHost = Y.Plugin && Y.Plugin.Host;
            if (this._initPlugins && PluginHost) {
                PluginHost.call(this);
            }

            if (this._lazyAddAttrs !== false) { this._lazyAddAttrs = true; }

            /**
             * The string used to identify the class of this object.
             *
             * @deprecated Use this.constructor.NAME
             * @property name
             * @type String
             */
            this.name = this.constructor.NAME;

            this.init.apply(this, arguments);
        },

        /**
         * Initializes AttributeCore
         *
         * @method _initAttribute
         * @private
         */
        _initAttribute: function() {
            AttributeCore.call(this);
        },

        /**
         * Init lifecycle method, invoked during construction. Sets up attributes
         * and invokes initializers for the class hierarchy.
         *
         * @method init
         * @chainable
         * @param {Object} cfg Object with configuration property name/value pairs
         * @return {BaseCore} A reference to this object
         */
        init: function(cfg) {

            this._baseInit(cfg);

            return this;
        },

        /**
         * Internal initialization implementation for BaseCore
         *
         * @method _baseInit
         * @private
         */
        _baseInit: function(cfg) {
            this._initHierarchy(cfg);

            if (this._initPlugins) {
                // Need to initPlugins manually, to handle constructor parsing, static Plug parsing
                this._initPlugins(cfg);
            }
            this._set(INITIALIZED, true);
        },

        /**
         * Destroy lifecycle method. Invokes destructors for the class hierarchy.
         *
         * @method destroy
         * @return {BaseCore} A reference to this object
         * @chainable
         */
        destroy: function() {
            this._baseDestroy();
            return this;
        },

        /**
         * Internal destroy implementation for BaseCore
         *
         * @method _baseDestroy
         * @private
         */
        _baseDestroy : function() {
            if (this._destroyPlugins) {
                this._destroyPlugins();
            }
            this._destroyHierarchy();
            this._set(DESTROYED, true);
        },

        /**
         * Returns the class hierarchy for this object, with BaseCore being the last class in the array.
         *
         * @method _getClasses
         * @protected
         * @return {Function[]} An array of classes (constructor functions), making up the class hierarchy for this object.
         * This value is cached the first time the method, or _getAttrCfgs, is invoked. Subsequent invocations return the
         * cached value.
         */
        _getClasses : function() {
            if (!this._classes) {
                this._initHierarchyData();
            }
            return this._classes;
        },

        /**
         * Returns an aggregated set of attribute configurations, by traversing
         * the class hierarchy.
         *
         * @method _getAttrCfgs
         * @protected
         * @return {Object} The hash of attribute configurations, aggregated across classes in the hierarchy
         * This value is cached the first time the method, or _getClasses, is invoked. Subsequent invocations return
         * the cached value.
         */
        _getAttrCfgs : function() {
            if (!this._attrs) {
                this._initHierarchyData();
            }
            return this._attrs;
        },

        /**
         * A helper method used to isolate the attrs config for this instance to pass to `addAttrs`,
         * from the static cached ATTRS for the class.
         *
         * @method _getInstanceAttrCfgs
         * @private
         *
         * @param {Object} allCfgs The set of all attribute configurations for this instance.
         * Attributes will be removed from this set, if they belong to the filtered class, so
         * that by the time all classes are processed, allCfgs will be empty.
         *
         * @return {Object} The set of attributes to be added for this instance, suitable
         * for passing through to `addAttrs`.
         */
        _getInstanceAttrCfgs : function(allCfgs) {

            var cfgs = {},
                cfg,
                val,
                subAttr,
                subAttrs,
                subAttrPath,
                attr,
                attrCfg,
                allSubAttrs = allCfgs._subAttrs,
                attrCfgProperties = this._attrCfgHash();

            for (attr in allCfgs) {

                if (allCfgs.hasOwnProperty(attr) && attr !== "_subAttrs") {

                    attrCfg = allCfgs[attr];

                    // Need to isolate from allCfgs, because we're going to set values etc.
                    cfg = cfgs[attr] = _wlmix({}, attrCfg, attrCfgProperties);

                    val = cfg.value;

                    if (val && (typeof val === "object")) {
                        this._cloneDefaultValue(attr, cfg);
                    }

                    if (allSubAttrs && allSubAttrs.hasOwnProperty(attr)) {
                        subAttrs = allCfgs._subAttrs[attr];

                        for (subAttrPath in subAttrs) {
                            subAttr = subAttrs[subAttrPath];

                            if (subAttr.path) {
                                O.setValue(cfg.value, subAttr.path, subAttr.value);
                            }
                        }
                    }
                }
            }

            return cfgs;
        },

        /**
         * @method _filterAdHocAttrs
         * @private
         *
         * @param {Object} allAttrs The set of all attribute configurations for this instance.
         * Attributes will be removed from this set, if they belong to the filtered class, so
         * that by the time all classes are processed, allCfgs will be empty.
         * @param {Object} userVals The config object passed in by the user, from which adhoc attrs are to be filtered.
         * @return {Object} The set of adhoc attributes passed in, in the form
         * of an object with attribute name/configuration pairs.
         */
        _filterAdHocAttrs : function(allAttrs, userVals) {
            var adHocs,
                nonAttrs = this._nonAttrs,
                attr;

            if (userVals) {
                adHocs = {};
                for (attr in userVals) {
                    if (!allAttrs[attr] && !nonAttrs[attr] && userVals.hasOwnProperty(attr)) {
                        adHocs[attr] = {
                            value:userVals[attr]
                        };
                    }
                }
            }

            return adHocs;
        },

        /**
         * A helper method used by _getClasses and _getAttrCfgs, which determines both
         * the array of classes and aggregate set of attribute configurations
         * across the class hierarchy for the instance.
         *
         * @method _initHierarchyData
         * @private
         */
        _initHierarchyData : function() {

            var ctor = this.constructor,
                cachedClassData = ctor._CACHED_CLASS_DATA,
                c,
                i,
                l,
                attrCfg,
                attrCfgHash,
                needsAttrCfgHash = !ctor._ATTR_CFG_HASH,
                nonAttrsCfg,
                nonAttrs = {},
                classes = [],
                attrs = [];

            // Start with `this` instance's constructor.
            c = ctor;

            if (!cachedClassData) {

                while (c) {
                    // Add to classes
                    classes[classes.length] = c;

                    // Add to attributes
                    if (c.ATTRS) {
                        attrs[attrs.length] = c.ATTRS;
                    }

                    // Aggregate ATTR cfg whitelist.
                    if (needsAttrCfgHash) {
                        attrCfg     = c._ATTR_CFG;
                        attrCfgHash = attrCfgHash || {};

                        if (attrCfg) {
                            for (i = 0, l = attrCfg.length; i < l; i += 1) {
                                attrCfgHash[attrCfg[i]] = true;
                            }
                        }
                    }

                    // Commenting out the if. We always aggregate, since we don't
                    // know if we'll be needing this on the instance or not.
                    // if (this._allowAdHocAttrs) {
                        nonAttrsCfg = c._NON_ATTRS_CFG;
                        if (nonAttrsCfg) {
                            for (i = 0, l = nonAttrsCfg.length; i < l; i++) {
                                nonAttrs[nonAttrsCfg[i]] = true;
                            }
                        }
                    //}

                    c = c.superclass ? c.superclass.constructor : null;
                }

                // Cache computed `_ATTR_CFG_HASH` on the constructor.
                if (needsAttrCfgHash) {
                    ctor._ATTR_CFG_HASH = attrCfgHash;
                }

                cachedClassData = ctor._CACHED_CLASS_DATA = {
                    classes : classes,
                    nonAttrs : nonAttrs,
                    attrs : this._aggregateAttrs(attrs)
                };

            }

            this._classes = cachedClassData.classes;
            this._attrs = cachedClassData.attrs;
            this._nonAttrs = cachedClassData.nonAttrs;
        },

        /**
         * Utility method to define the attribute hash used to filter/whitelist property mixes for
         * this class for iteration performance reasons.
         *
         * @method _attrCfgHash
         * @private
         */
        _attrCfgHash: function() {
            return this.constructor._ATTR_CFG_HASH;
        },

        /**
         * This method assumes that the value has already been checked to be an object.
         * Since it's on a critical path, we don't want to re-do the check.
         *
         * @method _cloneDefaultValue
         * @param {Object} cfg
         * @private
         */
        _cloneDefaultValue : function(attr, cfg) {

            var val = cfg.value,
                clone = cfg.cloneDefaultValue;

            if (clone === DEEP || clone === true) {
                cfg.value = Y.clone(val);
            } else if (clone === SHALLOW) {
                cfg.value = Y.merge(val);
            } else if ((clone === undefined && (OBJECT_CONSTRUCTOR === val.constructor || L.isArray(val)))) {
                cfg.value = Y.clone(val);
            }
            // else if (clone === false), don't clone the static default value.
            // It's intended to be used by reference.
        },

        /**
         * A helper method, used by _initHierarchyData to aggregate
         * attribute configuration across the instances class hierarchy.
         *
         * The method will protect the attribute configuration value to protect the statically defined
         * default value in ATTRS if required (if the value is an object literal, array or the
         * attribute configuration has cloneDefaultValue set to shallow or deep).
         *
         * @method _aggregateAttrs
         * @private
         * @param {Array} allAttrs An array of ATTRS definitions across classes in the hierarchy
         * (subclass first, Base last)
         * @return {Object} The aggregate set of ATTRS definitions for the instance
         */
        _aggregateAttrs : function(allAttrs) {

            var attr,
                attrs,
                subAttrsHash,
                cfg,
                path,
                i,
                cfgPropsHash = this._attrCfgHash(),
                aggAttr,
                aggAttrs = {};

            if (allAttrs) {
                for (i = allAttrs.length-1; i >= 0; --i) {

                    attrs = allAttrs[i];

                    for (attr in attrs) {
                        if (attrs.hasOwnProperty(attr)) {

                            // PERF TODO: Do we need to merge here, since we're merging later in getInstanceAttrCfgs
                            // Should we move this down to only merge if we hit the path or valueFn ifs below?
                            cfg = _wlmix({}, attrs[attr], cfgPropsHash);

                            path = null;
                            if (attr.indexOf(DOT) !== -1) {
                                path = attr.split(DOT);
                                attr = path.shift();
                            }

                            aggAttr = aggAttrs[attr];

                            if (path && aggAttr && aggAttr.value) {

                                subAttrsHash = aggAttrs._subAttrs;

                                if (!subAttrsHash) {
                                    subAttrsHash = aggAttrs._subAttrs = {};
                                }

                                if (!subAttrsHash[attr]) {
                                    subAttrsHash[attr] = {};
                                }

                                subAttrsHash[attr][path.join(DOT)] = {
                                    value: cfg.value,
                                    path : path
                                };

                            } else if (!path) {

                                if (!aggAttr) {
                                    aggAttrs[attr] = cfg;
                                } else {
                                    if (aggAttr.valueFn && VALUE in cfg) {
                                        aggAttr.valueFn = null;
                                    }

                                    // Mix into existing config.
                                    _wlmix(aggAttr, cfg, cfgPropsHash);
                                }
                            }
                        }
                    }
                }
            }

            return aggAttrs;
        },

        /**
         * Initializes the class hierarchy for the instance, which includes
         * initializing attributes for each class defined in the class's
         * static <a href="#property_BaseCore.ATTRS">ATTRS</a> property and
         * invoking the initializer method on the prototype of each class in the hierarchy.
         *
         * @method _initHierarchy
         * @param {Object} userVals Object with configuration property name/value pairs
         * @private
         */
        _initHierarchy : function(userVals) {

            var lazy = this._lazyAddAttrs,
                constr,
                constrProto,
                i,
                l,
                ci,
                ei,
                el,
                ext,
                extProto,
                exts,
                instanceAttrs,
                initializers = [],
                classes = this._getClasses(),
                attrCfgs = this._getAttrCfgs(),
                cl = classes.length - 1;

            // Constructors
            for (ci = cl; ci >= 0; ci--) {

                constr = classes[ci];
                constrProto = constr.prototype;
                exts = constr._yuibuild && constr._yuibuild.exts;

                // Using INITIALIZER in hasOwnProperty check, for performance reasons (helps IE6 avoid GC thresholds when
                // referencing string literals). Not using it in apply, again, for performance "." is faster.

                if (Y.config.win === Y.config.win.top) {
                    YUI.stats.markInitializer(constr.NAME);
                }

                if (constrProto.hasOwnProperty(INITIALIZER)) {
                    // Store initializer while we're here and looping
                    initializers[initializers.length] = constrProto.initializer;
                }

                if (exts) {
                    for (ei = 0, el = exts.length; ei < el; ei++) {

                        ext = exts[ei];
                        if (Y.config.win === Y.config.win.top) {
                            YUI.stats.markInitializer(ext.NAME);
                        }
                        // Ext Constructor
                        ext.apply(this, arguments);

                        extProto = ext.prototype;
                        if (extProto.hasOwnProperty(INITIALIZER)) {
                            // Store initializer while we're here and looping
                            initializers[initializers.length] = extProto.initializer;
                        }
                    }
                }
            }

            // ATTRS
            instanceAttrs = this._getInstanceAttrCfgs(attrCfgs);

            if (this._preAddAttrs) {
                this._preAddAttrs(instanceAttrs, userVals, lazy);
            }

            if (this._allowAdHocAttrs) {
                this.addAttrs(this._filterAdHocAttrs(attrCfgs, userVals), userVals, lazy);
            }

            this.addAttrs(instanceAttrs, userVals, lazy);

            // Initializers
            for (i = 0, l = initializers.length; i < l; i++) {
                initializers[i].apply(this, arguments);
            }
        },

        /**
         * Destroys the class hierarchy for this instance by invoking
         * the destructor method on the prototype of each class in the hierarchy.
         *
         * @method _destroyHierarchy
         * @private
         */
        _destroyHierarchy : function() {
            var constr,
                constrProto,
                ci, cl, ei, el, exts, extProto,
                classes = this._getClasses();

            for (ci = 0, cl = classes.length; ci < cl; ci++) {
                constr = classes[ci];
                constrProto = constr.prototype;
                exts = constr._yuibuild && constr._yuibuild.exts;

                if (exts) {
                    for (ei = 0, el = exts.length; ei < el; ei++) {
                        extProto = exts[ei].prototype;
                        if (extProto.hasOwnProperty(DESTRUCTOR)) {
                            if (Y.config.win === Y.config.win.top) {
                                YUI.stats.markDestructor(exts[ei].NAME);
                            }
                            extProto.destructor.apply(this, arguments);
                        }
                    }
                }

                if (constrProto.hasOwnProperty(DESTRUCTOR)) {
                    if (Y.config.win === Y.config.win.top) {
                        YUI.stats.markDestructor(constr.NAME);
                    }
                    constrProto.destructor.apply(this, arguments);
                }
            }
        },

        /**
         * Default toString implementation. Provides the constructor NAME
         * and the instance guid, if set.
         *
         * @method toString
         * @return {String} String representation for this object
         */
        toString: function() {
            return this.name + "[" + Y.stamp(this, true) + "]";
        }
    };

    // Straightup augment, no wrapper functions
    Y.mix(BaseCore, AttributeCore, false, null, 1);

    // Fix constructor
    BaseCore.prototype.constructor = BaseCore;

    Y.BaseCore = BaseCore;


}, '3.17.2', {"requires": ["attribute-core"]});


/***/ }),

/***/ 115470:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('base-observable', function (Y, NAME) {

    /**
    The `base-observable` submodule adds observability to Base's lifecycle and
    attributes, and also make it an `EventTarget`.

    @module base
    @submodule base-observable
    **/
    var L = Y.Lang,

        DESTROY = "destroy",
        INIT = "init",

        BUBBLETARGETS = "bubbleTargets",
        _BUBBLETARGETS = "_bubbleTargets",

        AttributeObservable = Y.AttributeObservable,
        BaseCore            = Y.BaseCore;

    /**
    Provides an augmentable implementation of lifecycle and attribute events for
    `BaseCore`.

    @class BaseObservable
    @extensionfor BaseCore
    @uses AttributeObservable
    @uses EventTarget
    @since 3.8.0
    **/
    function BaseObservable() {}

    BaseObservable._ATTR_CFG      = AttributeObservable._ATTR_CFG.concat();
    BaseObservable._NON_ATTRS_CFG = ["on", "after", "bubbleTargets"];

    BaseObservable.prototype = {

        /**
         * Initializes Attribute
         *
         * @method _initAttribute
         * @private
         */
        _initAttribute: function() {
            BaseCore.prototype._initAttribute.apply(this, arguments);
            AttributeObservable.call(this);

            this._eventPrefix = this.constructor.EVENT_PREFIX || this.constructor.NAME;
            this._yuievt.config.prefix = this._eventPrefix;
        },

        /**
         * Init lifecycle method, invoked during construction.
         * Fires the init event prior to setting up attributes and
         * invoking initializers for the class hierarchy.
         *
         * @method init
         * @chainable
         * @param {Object} config Object with configuration property name/value pairs
         * @return {Base} A reference to this object
         */
        init: function(config) {

            /**
             * <p>
             * Lifecycle event for the init phase, fired prior to initialization.
             * Invoking the preventDefault() method on the event object provided
             * to subscribers will prevent initialization from occuring.
             * </p>
             * <p>
             * Subscribers to the "after" momemt of this event, will be notified
             * after initialization of the object is complete (and therefore
             * cannot prevent initialization).
             * </p>
             *
             * @event init
             * @preventable _defInitFn
             * @param {EventFacade} e Event object, with a cfg property which
             * refers to the configuration object passed to the constructor.
             */

            // PERF: Using lower level _publish() for
            // critical path performance

            var type = this._getFullType(INIT),
                e = this._publish(type);

            e.emitFacade = true;
            e.fireOnce = true;
            e.defaultTargetOnly = true;
            e.defaultFn = this._defInitFn;

            this._preInitEventCfg(config);

            if (e._hasPotentialSubscribers()) {
                this.fire(type, {cfg: config});
            } else {

                this._baseInit(config);

                // HACK. Major hack actually. But really fast for no-listeners.
                // Since it's fireOnce, subscribers may come along later, so since we're
                // bypassing the event stack the first time, we need to tell the published
                // event that it's been "fired". Could extract it into a CE method?
                e.fired = true;
                e.firedWith = [{cfg:config}];
            }

            return this;
        },

        /**
         * Handles the special on, after and target properties which allow the user to
         * easily configure on and after listeners as well as bubble targets during
         * construction, prior to init.
         *
         * @private
         * @method _preInitEventCfg
         * @param {Object} config The user configuration object
         */
        _preInitEventCfg : function(config) {
            if (config) {
                if (config.on) {
                    this.on(config.on);
                }
                if (config.after) {
                    this.after(config.after);
                }
            }

            var i, l, target,
                userTargets = (config && BUBBLETARGETS in config);

            if (userTargets || _BUBBLETARGETS in this) {
                target = userTargets ? (config && config.bubbleTargets) : this._bubbleTargets;

                if (L.isArray(target)) {
                    for (i = 0, l = target.length; i < l; i++) {
                        this.addTarget(target[i]);
                    }
                } else if (target) {
                    this.addTarget(target);
                }
            }
        },

        /**
         * <p>
         * Destroy lifecycle method. Fires the destroy
         * event, prior to invoking destructors for the
         * class hierarchy.
         * </p>
         * <p>
         * Subscribers to the destroy
         * event can invoke preventDefault on the event object, to prevent destruction
         * from proceeding.
         * </p>
         * @method destroy
         * @return {Base} A reference to this object
         * @chainable
         */
        destroy: function() {

            /**
             * <p>
             * Lifecycle event for the destroy phase,
             * fired prior to destruction. Invoking the preventDefault
             * method on the event object provided to subscribers will
             * prevent destruction from proceeding.
             * </p>
             * <p>
             * Subscribers to the "after" moment of this event, will be notified
             * after destruction is complete (and as a result cannot prevent
             * destruction).
             * </p>
             * @event destroy
             * @preventable _defDestroyFn
             * @param {EventFacade} e Event object
             */
            this.publish(DESTROY, {
                fireOnce:true,
                defaultTargetOnly:true,
                defaultFn: this._defDestroyFn
            });
            this.fire(DESTROY);

            this.detachAll();
            return this;
        },

        /**
         * Default init event handler
         *
         * @method _defInitFn
         * @param {EventFacade} e Event object, with a cfg property which
         * refers to the configuration object passed to the constructor.
         * @protected
         */
        _defInitFn : function(e) {
            this._baseInit(e.cfg);
        },

        /**
         * Default destroy event handler
         *
         * @method _defDestroyFn
         * @param {EventFacade} e Event object
         * @protected
         */
        _defDestroyFn : function(e) {
            this._baseDestroy(e.cfg);
        }
    };

    Y.mix(BaseObservable, AttributeObservable, false, null, 1);

    Y.BaseObservable = BaseObservable;


}, '3.17.2', {"requires": ["attribute-observable", "base-core"]});


/***/ }),

/***/ 585784:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('base-pluginhost', function (Y, NAME) {

    /**
     * The base-pluginhost submodule adds Plugin support to Base, by augmenting Base with
     * Plugin.Host and setting up static (class level) Base.plug and Base.unplug methods.
     *
     * @module base
     * @submodule base-pluginhost
     * @for Base
     */

    var Base = Y.Base,
        PluginHost = Y.Plugin.Host;

    Y.mix(Base, PluginHost, false, null, 1);

    /**
     * Alias for <a href="Plugin.Host.html#method_Plugin.Host.plug">Plugin.Host.plug</a>. See aliased
     * method for argument and return value details.
     *
     * @method plug
     * @static
     */
    Base.plug = PluginHost.plug;

    /**
     * Alias for <a href="Plugin.Host.html#method_Plugin.Host.unplug">Plugin.Host.unplug</a>. See the
     * aliased method for argument and return value details.
     *
     * @method unplug
     * @static
     */
    Base.unplug = PluginHost.unplug;


}, '3.17.2', {"requires": ["base-base", "pluginhost"]});


/***/ }),

/***/ 521956:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('classnamemanager', function (Y, NAME) {

/**
* Contains a singleton (ClassNameManager) that enables easy creation and caching of
* prefixed class names.
* @module classnamemanager
*/

/**
 * A singleton class providing:
 *
 * <ul>
 *    <li>Easy creation of prefixed class names</li>
 *    <li>Caching of previously created class names for improved performance.</li>
 * </ul>
 *
 * @class ClassNameManager
 * @static
 */

// String constants
var CLASS_NAME_PREFIX = 'classNamePrefix',
	CLASS_NAME_DELIMITER = 'classNameDelimiter',
    CONFIG = Y.config;

// Global config

/**
 * Configuration property indicating the prefix for all CSS class names in this YUI instance.
 *
 * @property classNamePrefix
 * @type {String}
 * @default "yui"
 * @static
 */
CONFIG[CLASS_NAME_PREFIX] = CONFIG[CLASS_NAME_PREFIX] || 'yui3';

/**
 * Configuration property indicating the delimiter used to compose all CSS class names in
 * this YUI instance.
 *
 * @property classNameDelimiter
 * @type {String}
 * @default "-"
 * @static
 */
CONFIG[CLASS_NAME_DELIMITER] = CONFIG[CLASS_NAME_DELIMITER] || '-';

Y.ClassNameManager = function () {

	var sPrefix    = CONFIG[CLASS_NAME_PREFIX],
		sDelimiter = CONFIG[CLASS_NAME_DELIMITER];

	return {

		/**
		 * Returns a class name prefixed with the value of the
		 * <code>Y.config.classNamePrefix</code> attribute + the provided strings.
		 * Uses the <code>Y.config.classNameDelimiter</code> attribute to delimit the
		 * provided strings. E.g. Y.ClassNameManager.getClassName('foo','bar'); // yui-foo-bar
		 *
		 * @method getClassName
		 * @param {String} [classnameSection*] one or more classname sections to be joined
		 * @param {Boolean} skipPrefix If set to true, the classname will not be prefixed with the default Y.config.classNameDelimiter value.
		 */
		getClassName: Y.cached(function () {

            var args = Y.Array(arguments);

            if (args[args.length-1] !== true) {
                args.unshift(sPrefix);
            } else {
                args.pop();
            }

			return args.join(sDelimiter);
		})

	};

}();


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 794783:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('color-base', function (Y, NAME) {

/**
Color provides static methods for color conversion.

    Y.Color.toRGB('f00'); // rgb(255, 0, 0)

    Y.Color.toHex('rgb(255, 255, 0)'); // #ffff00

@module color
@submodule color-base
@class Color
@since 3.8.0
**/

var REGEX_HEX = /^#?([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})(\ufffe)?/,
    REGEX_HEX3 = /^#?([\da-fA-F]{1})([\da-fA-F]{1})([\da-fA-F]{1})(\ufffe)?/,
    REGEX_RGB = /rgba?\(([\d]{1,3}), ?([\d]{1,3}), ?([\d]{1,3}),? ?([.\d]*)?\)/,
    TYPES = { 'HEX': 'hex', 'RGB': 'rgb', 'RGBA': 'rgba' },
    CONVERTS = { 'hex': 'toHex', 'rgb': 'toRGB', 'rgba': 'toRGBA' };


Y.Color = {
    /**
    @static
    @property KEYWORDS
    @type Object
    @since 3.8.0
    **/
    KEYWORDS: {
        'black': '000', 'silver': 'c0c0c0', 'gray': '808080', 'white': 'fff',
        'maroon': '800000', 'red': 'f00', 'purple': '800080', 'fuchsia': 'f0f',
        'green': '008000', 'lime': '0f0', 'olive': '808000', 'yellow': 'ff0',
        'navy': '000080', 'blue': '00f', 'teal': '008080', 'aqua': '0ff'
    },

    /**
        NOTE: `(\ufffe)?` is added to the Regular Expression to carve out a
        place for the alpha channel that is returned from toArray
        without compromising any usage of the Regular Expression

    @static
    @property REGEX_HEX
    @type RegExp
    @default /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})(\ufffe)?/
    @since 3.8.0
    **/
    REGEX_HEX: REGEX_HEX,

    /**
        NOTE: `(\ufffe)?` is added to the Regular Expression to carve out a
        place for the alpha channel that is returned from toArray
        without compromising any usage of the Regular Expression

    @static
    @property REGEX_HEX3
    @type RegExp
    @default /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})(\ufffe)?/
    @since 3.8.0
    **/
    REGEX_HEX3: REGEX_HEX3,

    /**
    @static
    @property REGEX_RGB
    @type RegExp
    @default /rgba?\(([0-9]{1,3}), ?([0-9]{1,3}), ?([0-9]{1,3}),? ?([.0-9]{1,3})?\)/
    @since 3.8.0
    **/
    REGEX_RGB: REGEX_RGB,

    re_RGB: REGEX_RGB,

    re_hex: REGEX_HEX,

    re_hex3: REGEX_HEX3,

    /**
    @static
    @property STR_HEX
    @type String
    @default #{*}{*}{*}
    @since 3.8.0
    **/
    STR_HEX: '#{*}{*}{*}',

    /**
    @static
    @property STR_RGB
    @type String
    @default rgb({*}, {*}, {*})
    @since 3.8.0
    **/
    STR_RGB: 'rgb({*}, {*}, {*})',

    /**
    @static
    @property STR_RGBA
    @type String
    @default rgba({*}, {*}, {*}, {*})
    @since 3.8.0
    **/
    STR_RGBA: 'rgba({*}, {*}, {*}, {*})',

    /**
    @static
    @property TYPES
    @type Object
    @default {'rgb':'rgb', 'rgba':'rgba'}
    @since 3.8.0
    **/
    TYPES: TYPES,

    /**
    @static
    @property CONVERTS
    @type Object
    @default {}
    @since 3.8.0
    **/
    CONVERTS: CONVERTS,

    /**
     Converts the provided string to the provided type.
     You can use the `Y.Color.TYPES` to get a valid `to` type.
     If the color cannot be converted, the original color will be returned.

     @public
     @method convert
     @param {String} str
     @param {String} to
     @return {String}
     @since 3.8.0
     **/
    convert: function (str, to) {
        var convert = Y.Color.CONVERTS[to.toLowerCase()],
            clr = str;

        if (convert && Y.Color[convert]) {
            clr = Y.Color[convert](str);
        }

        return clr;
    },

    /**
    Converts provided color value to a hex value string

    @public
    @method toHex
    @param {String} str Hex or RGB value string
    @return {String} returns array of values or CSS string if options.css is true
    @since 3.8.0
    **/
    toHex: function (str) {
        var clr = Y.Color._convertTo(str, 'hex'),
            isTransparent = clr.toLowerCase() === 'transparent';

        if (clr.charAt(0) !== '#' && !isTransparent) {
            clr = '#' + clr;
        }

        return isTransparent ? clr.toLowerCase() : clr.toUpperCase();
    },

    /**
    Converts provided color value to an RGB value string
    @public
    @method toRGB
    @param {String} str Hex or RGB value string
    @return {String}
    @since 3.8.0
    **/
    toRGB: function (str) {
        var clr = Y.Color._convertTo(str, 'rgb');
        return clr.toLowerCase();
    },

    /**
    Converts provided color value to an RGB value string
    @public
    @method toRGBA
    @param {String} str Hex or RGB value string
    @return {String}
    @since 3.8.0
    **/
    toRGBA: function (str) {
        var clr = Y.Color._convertTo(str, 'rgba' );
        return clr.toLowerCase();
    },

    /**
    Converts the provided color string to an array of values where the
        last value is the alpha value. Will return an empty array if
        the provided string is not able to be parsed.

        NOTE: `(\ufffe)?` is added to `HEX` and `HEX3` Regular Expressions to
        carve out a place for the alpha channel that is returned from
        toArray without compromising any usage of the Regular Expression

        Y.Color.toArray('fff');              // ['ff', 'ff', 'ff', 1]
        Y.Color.toArray('rgb(0, 0, 0)');     // ['0', '0', '0', 1]
        Y.Color.toArray('rgba(0, 0, 0, 0)'); // ['0', '0', '0', 1]



    @public
    @method toArray
    @param {String} str
    @return {Array}
    @since 3.8.0
    **/
    toArray: function(str) {
        // parse with regex and return "matches" array
        var type = Y.Color.findType(str).toUpperCase(),
            regex,
            arr,
            length,
            lastItem;

        if (type === 'HEX' && str.length < 5) {
            type = 'HEX3';
        }

        if (type.charAt(type.length - 1) === 'A') {
            type = type.slice(0, -1);
        }

        regex = Y.Color['REGEX_' + type];

        if (regex) {
            arr = regex.exec(str) || [];
            length = arr.length;

            if (length) {

                arr.shift();
                length--;

                if (type === 'HEX3') {
                    arr[0] += arr[0];
                    arr[1] += arr[1];
                    arr[2] += arr[2];
                }

                lastItem = arr[length - 1];
                if (!lastItem) {
                    arr[length - 1] = 1;
                }
            }
        }

        return arr;

    },

    /**
    Converts the array of values to a string based on the provided template.
    @public
    @method fromArray
    @param {Array} arr
    @param {String} template
    @return {String}
    @since 3.8.0
    **/
    fromArray: function(arr, template) {
        arr = arr.concat();

        if (typeof template === 'undefined') {
            return arr.join(', ');
        }

        var replace = '{*}';

        template = Y.Color['STR_' + template.toUpperCase()];

        if (arr.length === 3 && template.match(/\{\*\}/g).length === 4) {
            arr.push(1);
        }

        while ( template.indexOf(replace) >= 0 && arr.length > 0) {
            template = template.replace(replace, arr.shift());
        }

        return template;
    },

    /**
    Finds the value type based on the str value provided.
    @public
    @method findType
    @param {String} str
    @return {String}
    @since 3.8.0
    **/
    findType: function (str) {
        if (Y.Color.KEYWORDS[str]) {
            return 'keyword';
        }

        var index = str.indexOf('('),
            key;

        if (index > 0) {
            key = str.substr(0, index);
        }

        if (key && Y.Color.TYPES[key.toUpperCase()]) {
            return Y.Color.TYPES[key.toUpperCase()];
        }

        return 'hex';

    }, // return 'keyword', 'hex', 'rgb'

    /**
    Retrives the alpha channel from the provided string. If no alpha
        channel is present, `1` will be returned.
    @protected
    @method _getAlpha
    @param {String} clr
    @return {Number}
    @since 3.8.0
    **/
    _getAlpha: function (clr) {
        var alpha,
            arr = Y.Color.toArray(clr);

        if (arr.length > 3) {
            alpha = arr.pop();
        }

        return +alpha || 1;
    },

    /**
    Returns the hex value string if found in the KEYWORDS object
    @protected
    @method _keywordToHex
    @param {String} clr
    @return {String}
    @since 3.8.0
    **/
    _keywordToHex: function (clr) {
        var keyword = Y.Color.KEYWORDS[clr];

        if (keyword) {
            return keyword;
        }
    },

    /**
    Converts the provided color string to the value type provided as `to`
    @protected
    @method _convertTo
    @param {String} clr
    @param {String} to
    @return {String}
    @since 3.8.0
    **/
    _convertTo: function(clr, to) {

        if (clr === 'transparent') {
            return clr;
        }

        var from = Y.Color.findType(clr),
            originalTo = to,
            needsAlpha,
            alpha,
            method,
            ucTo;

        if (from === 'keyword') {
            clr = Y.Color._keywordToHex(clr);
            from = 'hex';
        }

        if (from === 'hex' && clr.length < 5) {
            if (clr.charAt(0) === '#') {
                clr = clr.substr(1);
            }

            clr = '#' + clr.charAt(0) + clr.charAt(0) +
                        clr.charAt(1) + clr.charAt(1) +
                        clr.charAt(2) + clr.charAt(2);
        }

        if (from === to) {
            return clr;
        }

        if (from.charAt(from.length - 1) === 'a') {
            from = from.slice(0, -1);
        }

        needsAlpha = (to.charAt(to.length - 1) === 'a');
        if (needsAlpha) {
            to = to.slice(0, -1);
            alpha = Y.Color._getAlpha(clr);
        }

        ucTo = to.charAt(0).toUpperCase() + to.substr(1).toLowerCase();
        method = Y.Color['_' + from + 'To' + ucTo ];

        // check to see if need conversion to rgb first
        // check to see if there is a direct conversion method
        // convertions are: hex <-> rgb <-> hsl
        if (!method) {
            if (from !== 'rgb' && to !== 'rgb') {
                clr = Y.Color['_' + from + 'ToRgb'](clr);
                from = 'rgb';
                method = Y.Color['_' + from + 'To' + ucTo ];
            }
        }

        if (method) {
            clr = ((method)(clr, needsAlpha));
        }

        // process clr from arrays to strings after conversions if alpha is needed
        if (needsAlpha) {
            if (!Y.Lang.isArray(clr)) {
                clr = Y.Color.toArray(clr);
            }
            clr.push(alpha);
            clr = Y.Color.fromArray(clr, originalTo.toUpperCase());
        }

        return clr;
    },

    /**
    Processes the hex string into r, g, b values. Will return values as
        an array, or as an rgb string.
    @protected
    @method _hexToRgb
    @param {String} str
    @param {Boolean} [toArray]
    @return {String|Array}
    @since 3.8.0
    **/
    _hexToRgb: function (str, toArray) {
        var r, g, b;

        /*jshint bitwise:false*/
        if (str.charAt(0) === '#') {
            str = str.substr(1);
        }

        str = parseInt(str, 16);

        r = str >> 16;
        g = str >> 8 & 0xFF;
        b = str & 0xFF;

        if (toArray) {
            return [r, g, b];
        }

        return 'rgb(' + r + ', ' + g + ', ' + b + ')';
    },

    /**
    Processes the rgb string into r, g, b values. Will return values as
        an array, or as a hex string.
    @protected
    @method _rgbToHex
    @param {String} str
    @param {Boolean} [toArray]
    @return {String|Array}
    @since 3.8.0
    **/
    _rgbToHex: function (str) {
        /*jshint bitwise:false*/
        var rgb = Y.Color.toArray(str),
            hex = rgb[2] | (rgb[1] << 8) | (rgb[0] << 16);

        hex = (+hex).toString(16);

        while (hex.length < 6) {
            hex = '0' + hex;
        }

        return '#' + hex;
    }

};



}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 975042:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('cookie', function (Y, NAME) {

/**
 * Utilities for cookie management
 * @module cookie
 */

    //shortcuts
    var L       = Y.Lang,
        O       = Y.Object,
        NULL    = null,

        //shortcuts to functions
        isString    = L.isString,
        isObject    = L.isObject,
        isUndefined = L.isUndefined,
        isFunction  = L.isFunction,
        encode      = encodeURIComponent,
        decode      = decodeURIComponent,

        //shortcut to document
        doc         = Y.config.doc;

    /*
     * Throws an error message.
     */
    function error(message){
        throw new TypeError(message);
    }

    /*
     * Checks the validity of a cookie name.
     */
    function validateCookieName(name){
        if (!isString(name) || name === ""){
            error("Cookie name must be a non-empty string.");
        }
    }

    /*
     * Checks the validity of a subcookie name.
     */
    function validateSubcookieName(subName){
        if (!isString(subName) || subName === ""){
            error("Subcookie name must be a non-empty string.");
        }
    }

    /**
     * Cookie utility.
     * @class Cookie
     * @static
     */
    Y.Cookie = {

        //-------------------------------------------------------------------------
        // Private Methods
        //-------------------------------------------------------------------------

        /**
         * Creates a cookie string that can be assigned into document.cookie.
         * @param {String} name The name of the cookie.
         * @param {String} value The value of the cookie.
         * @param {Boolean} encodeValue True to encode the value, false to leave as-is.
         * @param {Object} options (Optional) Options for the cookie.
         * @return {String} The formatted cookie string.
         * @method _createCookieString
         * @private
         * @static
         */
        _createCookieString : function (name /*:String*/, value /*:Variant*/, encodeValue /*:Boolean*/, options /*:Object*/) /*:String*/ {

            options = options || {};

            var text /*:String*/ = encode(name) + "=" + (encodeValue ? encode(value) : value),
                expires = options.expires,
                path    = options.path,
                domain  = options.domain;


            if (isObject(options)){
                //expiration date
                if (expires instanceof Date){
                    text += "; expires=" + expires.toUTCString();
                }

                //path
                if (isString(path) && path !== ""){
                    text += "; path=" + path;
                }

                //domain
                if (isString(domain) && domain !== ""){
                    text += "; domain=" + domain;
                }

                //secure
                if (options.secure === true){
                    text += "; secure";
                }
            }

            return text;
        },

        /**
         * Formats a cookie value for an object containing multiple values.
         * @param {Object} hash An object of key-value pairs to create a string for.
         * @return {String} A string suitable for use as a cookie value.
         * @method _createCookieHashString
         * @private
         * @static
         */
        _createCookieHashString : function (hash /*:Object*/) /*:String*/ {
            if (!isObject(hash)){
                error("Cookie._createCookieHashString(): Argument must be an object.");
            }

            var text /*:Array*/ = [];

            O.each(hash, function(value, key){
                if (!isFunction(value) && !isUndefined(value)){
                    text.push(encode(key) + "=" + encode(String(value)));
                }
            });

            return text.join("&");
        },

        /**
         * Parses a cookie hash string into an object.
         * @param {String} text The cookie hash string to parse (format: n1=v1&n2=v2).
         * @return {Object} An object containing entries for each cookie value.
         * @method _parseCookieHash
         * @private
         * @static
         */
        _parseCookieHash : function (text) {

            var hashParts   = text.split("&"),
                hashPart    = NULL,
                hash        = {};

            if (text.length){
                for (var i=0, len=hashParts.length; i < len; i++){
                    hashPart = hashParts[i].split("=");
                    hash[decode(hashPart[0])] = decode(hashPart[1]);
                }
            }

            return hash;
        },

        /**
         * Parses a cookie string into an object representing all accessible cookies.
         * @param {String} text The cookie string to parse.
         * @param {Boolean} shouldDecode (Optional) Indicates if the cookie values should be decoded or not. Default is true.
         * @param {Object} options (Optional) Contains settings for loading the cookie.
         * @return {Object} An object containing entries for each accessible cookie.
         * @method _parseCookieString
         * @private
         * @static
         */
        _parseCookieString : function (text /*:String*/, shouldDecode /*:Boolean*/, options /*:Object*/) /*:Object*/ {

            var cookies /*:Object*/ = {};

            if (isString(text) && text.length > 0) {

                var decodeValue = (shouldDecode === false ? function(s){return s;} : decode),
                    cookieParts = text.split(/;\s/g),
                    cookieName  = NULL,
                    cookieValue = NULL,
                    cookieNameValue = NULL;

                for (var i=0, len=cookieParts.length; i < len; i++){
                    //check for normally-formatted cookie (name-value)
                    cookieNameValue = cookieParts[i].match(/([^=]+)=/i);
                    if (cookieNameValue instanceof Array){
                        try {
                            cookieName = decode(cookieNameValue[1]);
                            cookieValue = decodeValue(cookieParts[i].substring(cookieNameValue[1].length+1));
                        } catch (ex){
                            //intentionally ignore the cookie - the encoding is wrong
                        }
                    } else {
                        //means the cookie does not have an "=", so treat it as a boolean flag
                        cookieName = decode(cookieParts[i]);
                        cookieValue = "";
                    }
                    // don't overwrite an already loaded cookie if set by option
                    if (!isUndefined(options) && options.reverseCookieLoading) {
                        if (isUndefined(cookies[cookieName])) {
                            cookies[cookieName] = cookieValue;
                        }
                    } else {
                        cookies[cookieName] = cookieValue;
                    }
                }

            }

            return cookies;
        },

        /**
         * Sets the document object that the cookie utility uses for setting
         * cookies. This method is necessary to ensure that the cookie utility
         * unit tests can pass even when run on a domain instead of locally.
         * This method should not be used otherwise; you should use
         * <code>Y.config.doc</code> to change the document that the cookie
         * utility uses for everyday purposes.
         * @param {Object} newDoc The object to use as the document.
         * @method _setDoc
         * @private
         */
        _setDoc: function(newDoc){
            doc = newDoc;
        },

        //-------------------------------------------------------------------------
        // Public Methods
        //-------------------------------------------------------------------------

        /**
         * Determines if the cookie with the given name exists. This is useful for
         * Boolean cookies (those that do not follow the name=value convention).
         * @param {String} name The name of the cookie to check.
         * @return {Boolean} True if the cookie exists, false if not.
         * @method exists
         * @static
         */
        exists: function(name) {

            validateCookieName(name);   //throws error

            var cookies = this._parseCookieString(doc.cookie, true);

            return cookies.hasOwnProperty(name);
        },

        /**
         * Returns the cookie value for the given name.
         * @param {String} name The name of the cookie to retrieve.
         * @param {Function|Object} options (Optional) An object containing one or more
         *      cookie options: raw (true/false), reverseCookieLoading (true/false)
         *      and converter (a function).
         *      The converter function is run on the value before returning it. The
         *      function is not used if the cookie doesn't exist. The function can be
         *      passed instead of the options object for backwards compatibility. When
         *      raw is set to true, the cookie value is not URI decoded.
         * @return {Any} If no converter is specified, returns a string or null if
         *      the cookie doesn't exist. If the converter is specified, returns the value
         *      returned from the converter or null if the cookie doesn't exist.
         * @method get
         * @static
         */
        get : function (name, options) {

            validateCookieName(name);   //throws error

            var cookies,
                cookie,
                converter;

            //if options is a function, then it's the converter
            if (isFunction(options)) {
                converter = options;
                options = {};
            } else if (isObject(options)) {
                converter = options.converter;
            } else {
                options = {};
            }

            cookies = this._parseCookieString(doc.cookie, !options.raw, options);
            cookie = cookies[name];

            //should return null, not undefined if the cookie doesn't exist
            if (isUndefined(cookie)) {
                return NULL;
            }

            if (!isFunction(converter)){
                return cookie;
            } else {
                return converter(cookie);
            }
        },

        /**
         * Returns the value of a subcookie.
         * @param {String} name The name of the cookie to retrieve.
         * @param {String} subName The name of the subcookie to retrieve.
         * @param {Function} converter (Optional) A function to run on the value before returning
         *      it. The function is not used if the cookie doesn't exist.
         * @param {Object} options (Optional) Containing one or more settings for cookie parsing.
         * @return {Any} If the cookie doesn't exist, null is returned. If the subcookie
         *      doesn't exist, null if also returned. If no converter is specified and the
         *      subcookie exists, a string is returned. If a converter is specified and the
         *      subcookie exists, the value returned from the converter is returned.
         * @method getSub
         * @static
         */
        getSub : function (name /*:String*/, subName /*:String*/, converter /*:Function*/, options /*:Object*/) /*:Variant*/ {

            var hash /*:Variant*/ = this.getSubs(name, options);

            if (hash !== NULL) {

                validateSubcookieName(subName);   //throws error

                if (isUndefined(hash[subName])){
                    return NULL;
                }

                if (!isFunction(converter)){
                    return hash[subName];
                } else {
                    return converter(hash[subName]);
                }
            } else {
                return NULL;
            }

        },

        /**
         * Returns an object containing name-value pairs stored in the cookie with the given name.
         * @param {String} name The name of the cookie to retrieve.
         * @param {Object} options (Optional) Containing one or more settings for cookie parsing.
         * @return {Object} An object of name-value pairs if the cookie with the given name
         *      exists, null if it does not.
         * @method getSubs
         * @static
         */
        getSubs : function (name /*:String*/, options /*:Object*/) {

            validateCookieName(name);   //throws error

            var cookies = this._parseCookieString(doc.cookie, false, options);
            if (isString(cookies[name])){
                return this._parseCookieHash(cookies[name]);
            }
            return NULL;
        },

        /**
         * Removes a cookie from the machine by setting its expiration date to
         * sometime in the past.
         * @param {String} name The name of the cookie to remove.
         * @param {Object} options (Optional) An object containing one or more
         *      cookie options: path (a string), domain (a string),
         *      and secure (true/false). The expires option will be overwritten
         *      by the method.
         * @return {String} The created cookie string.
         * @method remove
         * @static
         */
        remove : function (name, options) {

            validateCookieName(name);   //throws error

            //set options
            options = Y.merge(options || {}, {
                expires: new Date(0)
            });

            //set cookie
            return this.set(name, "", options);
        },

        /**
         * Removes a sub cookie with a given name.
         * @param {String} name The name of the cookie in which the subcookie exists.
         * @param {String} subName The name of the subcookie to remove.
         * @param {Object} options (Optional) An object containing one or more
         *      cookie options: path (a string), domain (a string), expires (a Date object),
         *      removeIfEmpty (true/false), and secure (true/false). This must be the same
         *      settings as the original subcookie.
         * @return {String} The created cookie string.
         * @method removeSub
         * @static
         */
        removeSub : function(name, subName, options) {

            validateCookieName(name);   //throws error

            validateSubcookieName(subName);   //throws error

            options = options || {};

            //get all subcookies for this cookie
            var subs = this.getSubs(name);

            //delete the indicated subcookie
            if (isObject(subs) && subs.hasOwnProperty(subName)){
                delete subs[subName];

                if (!options.removeIfEmpty) {
                    //reset the cookie

                    return this.setSubs(name, subs, options);
                } else {
                    //reset the cookie if there are subcookies left, else remove
                    for (var key in subs){
                        if (subs.hasOwnProperty(key) && !isFunction(subs[key]) && !isUndefined(subs[key])){
                            return this.setSubs(name, subs, options);
                        }
                    }

                    return this.remove(name, options);
                }
            } else {
                return "";
            }

        },

        /**
         * Sets a cookie with a given name and value.
         * @param {String} name The name of the cookie to set.
         * @param {Any} value The value to set for the cookie.
         * @param {Object} options (Optional) An object containing one or more
         *      cookie options: path (a string), domain (a string), expires (a Date object),
         *      secure (true/false), and raw (true/false). Setting raw to true indicates
         *      that the cookie should not be URI encoded before being set.
         * @return {String} The created cookie string.
         * @method set
         * @static
         */
        set : function (name, value, options) {

            validateCookieName(name);   //throws error

            if (isUndefined(value)){
                error("Cookie.set(): Value cannot be undefined.");
            }

            options = options || {};

            var text = this._createCookieString(name, value, !options.raw, options);
            doc.cookie = text;
            return text;
        },

        /**
         * Sets a sub cookie with a given name to a particular value.
         * @param {String} name The name of the cookie to set.
         * @param {String} subName The name of the subcookie to set.
         * @param {Any} value The value to set.
         * @param {Object} options (Optional) An object containing one or more
         *      cookie options: path (a string), domain (a string), expires (a Date object),
         *      and secure (true/false).
         * @return {String} The created cookie string.
         * @method setSub
         * @static
         */
        setSub : function (name, subName, value, options) {

            validateCookieName(name);   //throws error

            validateSubcookieName(subName);   //throws error

            if (isUndefined(value)){
                error("Cookie.setSub(): Subcookie value cannot be undefined.");
            }

            var hash = this.getSubs(name);

            if (!isObject(hash)){
                hash = {};
            }

            hash[subName] = value;

            return this.setSubs(name, hash, options);

        },

        /**
         * Sets a cookie with a given name to contain a hash of name-value pairs.
         * @param {String} name The name of the cookie to set.
         * @param {Object} value An object containing name-value pairs.
         * @param {Object} options (Optional) An object containing one or more
         *      cookie options: path (a string), domain (a string), expires (a Date object),
         *      and secure (true/false).
         * @return {String} The created cookie string.
         * @method setSubs
         * @static
         */
        setSubs : function (name, value, options) {

            validateCookieName(name);   //throws error

            if (!isObject(value)){
                error("Cookie.setSubs(): Cookie value must be an object.");
            }

            var text /*:String*/ = this._createCookieString(name, this._createCookieHashString(value), false, options);
            doc.cookie = text;
            return text;
        }

    };


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 95084:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('datatype-xml-parse', function (Y, NAME) {

/**
 * Parse XML submodule.
 *
 * @module datatype-xml
 * @submodule datatype-xml-parse
 * @for XML
 */

Y.mix(Y.namespace("XML"), {
    /**
     * Converts data to type XMLDocument.
     *
     * @method parse
     * @param data {String} Data to convert.
     * @return {XMLDocument} XML Document.
     */
    parse: function(data) {
        var xmlDoc = null, win;
        if (typeof data === "string") {
            win = Y.config.win;
            if (win.ActiveXObject !== undefined) {
                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = false;
                xmlDoc.loadXML(data);            
            } else if (win.DOMParser !== undefined) {
                xmlDoc = new DOMParser().parseFromString(data, "text/xml");            
            } else if (win.Windows !== undefined) {
                xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
                xmlDoc.loadXml(data);            
            }
        }

        if (xmlDoc === null || xmlDoc.documentElement === null || xmlDoc.documentElement.nodeName === "parsererror") {
        }

        return xmlDoc;
    }
});

// Add Parsers shortcut
Y.namespace("Parsers").xml = Y.XML.parse;

Y.namespace("DataType");
Y.DataType.XML = Y.XML;


}, '3.17.2');


/***/ }),

/***/ 134495:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('dom-base', function (Y, NAME) {

/**
* @for DOM
* @module dom
*/
var documentElement = Y.config.doc.documentElement,
    Y_DOM = Y.DOM,
    TAG_NAME = 'tagName',
    OWNER_DOCUMENT = 'ownerDocument',
    EMPTY_STRING = '',
    addFeature = Y.Features.add,
    testFeature = Y.Features.test;

Y.mix(Y_DOM, {
    /**
     * Returns the text content of the HTMLElement.
     * @method getText
     * @param {HTMLElement} element The html element.
     * @return {String} The text content of the element (includes text of any descending elements).
     */
    getText: (documentElement.textContent !== undefined) ?
        function(element) {
            var ret = '';
            if (element) {
                ret = element.textContent;
            }
            return ret || '';
        } : function(element) {
            var ret = '';
            if (element) {
                ret = element.innerText || element.nodeValue; // might be a textNode
            }
            return ret || '';
        },

    /**
     * Sets the text content of the HTMLElement.
     * @method setText
     * @param {HTMLElement} element The html element.
     * @param {String} content The content to add.
     */
    setText: (documentElement.textContent !== undefined) ?
        function(element, content) {
            if (element) {
                element.textContent = content;
            }
        } : function(element, content) {
            if ('innerText' in element) {
                element.innerText = content;
            } else if ('nodeValue' in element) {
                element.nodeValue = content;
            }
    },

    CUSTOM_ATTRIBUTES: (!documentElement.hasAttribute) ? { // IE < 8
        'for': 'htmlFor',
        'class': 'className'
    } : { // w3c
        'htmlFor': 'for',
        'className': 'class'
    },

    /**
     * Provides a normalized attribute interface.
     * @method setAttribute
     * @param {HTMLElement} el The target element for the attribute.
     * @param {String} attr The attribute to set.
     * @param {String} val The value of the attribute.
     */
    setAttribute: function(el, attr, val, ieAttr) {
        if (el && attr && el.setAttribute) {
            attr = Y_DOM.CUSTOM_ATTRIBUTES[attr] || attr;
            el.setAttribute(attr, val, ieAttr);
        }
    },


    /**
     * Provides a normalized attribute interface.
     * @method getAttribute
     * @param {HTMLElement} el The target element for the attribute.
     * @param {String} attr The attribute to get.
     * @return {String} The current value of the attribute.
     */
    getAttribute: function(el, attr, ieAttr) {
        ieAttr = (ieAttr !== undefined) ? ieAttr : 2;
        var ret = '';
        if (el && attr && el.getAttribute) {
            attr = Y_DOM.CUSTOM_ATTRIBUTES[attr] || attr;
            // BUTTON value issue for IE < 8
            ret = (el.tagName === "BUTTON" && attr === 'value') ? Y_DOM.getValue(el) : el.getAttribute(attr, ieAttr);

            if (ret === null) {
                ret = ''; // per DOM spec
            }
        }
        return ret;
    },

    VALUE_SETTERS: {},

    VALUE_GETTERS: {},

    getValue: function(node) {
        var ret = '', // TODO: return null?
            getter;

        if (node && node[TAG_NAME]) {
            getter = Y_DOM.VALUE_GETTERS[node[TAG_NAME].toLowerCase()];

            if (getter) {
                ret = getter(node);
            } else {
                ret = node.value;
            }
        }

        // workaround for IE8 JSON stringify bug
        // which converts empty string values to null
        if (ret === EMPTY_STRING) {
            ret = EMPTY_STRING; // for real
        }

        return (typeof ret === 'string') ? ret : '';
    },

    setValue: function(node, val) {
        var setter;

        if (node && node[TAG_NAME]) {
            setter = Y_DOM.VALUE_SETTERS[node[TAG_NAME].toLowerCase()];
            val = (val === null) ? '' : val;
            if (setter) {
                setter(node, val);
            } else {
                node.value = val;
            }
        }
    },

    creators: {}
});

addFeature('value-set', 'select', {
    test: function() {
        var node = Y.config.doc.createElement('select');
        node.innerHTML = '<option>1</option><option>2</option>';
        node.value = '2';
        return (node.value && node.value === '2');
    }
});

if (!testFeature('value-set', 'select')) {
    Y_DOM.VALUE_SETTERS.select = function(node, val) {
        for (var i = 0, options = node.getElementsByTagName('option'), option;
                option = options[i++];) {
            if (Y_DOM.getValue(option) === val) {
                option.selected = true;
                //Y_DOM.setAttribute(option, 'selected', 'selected');
                break;
            }
        }
    };
}

Y.mix(Y_DOM.VALUE_GETTERS, {
    button: function(node) {
        return (node.attributes && node.attributes.value) ? node.attributes.value.value : '';
    }
});

Y.mix(Y_DOM.VALUE_SETTERS, {
    // IE: node.value changes the button text, which should be handled via innerHTML
    button: function(node, val) {
        var attr = node.attributes.value;
        if (!attr) {
            attr = node[OWNER_DOCUMENT].createAttribute('value');
            node.setAttributeNode(attr);
        }

        attr.value = val;
    }
});


Y.mix(Y_DOM.VALUE_GETTERS, {
    option: function(node) {
        var attrs = node.attributes;
        return (attrs.value && attrs.value.specified) ? node.value : node.text;
    },

    select: function(node) {
        var val = node.value,
            options = node.options;

        if (options && options.length) {
            // TODO: implement multipe select
            if (node.multiple) {
            } else if (node.selectedIndex > -1) {
                val = Y_DOM.getValue(options[node.selectedIndex]);
            }
        }

        return val;
    }
});
var addClass, hasClass, removeClass;

Y.mix(Y.DOM, {
    /**
     * Determines whether a DOM element has the given className.
     * @method hasClass
     * @for DOM
     * @param {HTMLElement} element The DOM element.
     * @param {String} className the class name to search for
     * @return {Boolean} Whether or not the element has the given class.
     */
    hasClass: function(node, className) {
        var re = Y.DOM._getRegExp('(?:^|\\s+)' + className + '(?:\\s+|$)');
        if (node) {
          return re.test(node.className)
        }
        return false;
    },

    /**
     * Adds a class name to a given DOM element.
     * @method addClass
     * @for DOM
     * @param {HTMLElement} element The DOM element.
     * @param {String} className the class name to add to the class attribute
     */
    addClass: function(node, className) {
        if (node && !Y.DOM.hasClass(node, className)) { // skip if already present
            node.className = Y.Lang.trim([node.className, className].join(' '));
        }
    },

    /**
     * Removes a class name from a given element.
     * @method removeClass
     * @for DOM
     * @param {HTMLElement} element The DOM element.
     * @param {String} className the class name to remove from the class attribute
     */
    removeClass: function(node, className) {
        if (className && hasClass(node, className)) {
            node.className = Y.Lang.trim(node.className.replace(Y.DOM._getRegExp('(?:^|\\s+)' +
                            className + '(?:\\s+|$)'), ' '));

            if ( hasClass(node, className) ) { // in case of multiple adjacent
                removeClass(node, className);
            }
        }
    },

    /**
     * Replace a class with another class for a given element.
     * If no oldClassName is present, the newClassName is simply added.
     * @method replaceClass
     * @for DOM
     * @param {HTMLElement} element The DOM element
     * @param {String} oldClassName the class name to be replaced
     * @param {String} newClassName the class name that will be replacing the old class name
     */
    replaceClass: function(node, oldC, newC) {
        removeClass(node, oldC); // remove first in case oldC === newC
        addClass(node, newC);
    },

    /**
     * If the className exists on the node it is removed, if it doesn't exist it is added.
     * @method toggleClass
     * @for DOM
     * @param {HTMLElement} element The DOM element
     * @param {String} className the class name to be toggled
     * @param {Boolean} addClass optional boolean to indicate whether class
     * should be added or removed regardless of current state
     */
    toggleClass: function(node, className, force) {
        var add = (force !== undefined) ? force :
                !(hasClass(node, className));

        if (add) {
            addClass(node, className);
        } else {
            removeClass(node, className);
        }
    }
});

hasClass = Y.DOM.hasClass;
removeClass = Y.DOM.removeClass;
addClass = Y.DOM.addClass;

var re_tag = /<([a-z]+)/i,

    Y_DOM = Y.DOM,

    addFeature = Y.Features.add,
    testFeature = Y.Features.test,

    creators = {},

    createFromDIV = function(html, tag) {
        var div = Y.config.doc.createElement('div'),
            ret = true;

        div.innerHTML = html;
        if (!div.firstChild || div.firstChild.tagName !== tag.toUpperCase()) {
            ret = false;
        }

        return ret;
    },

    re_tbody = /(?:\/(?:thead|tfoot|tbody|caption|col|colgroup)>)+\s*<tbody/,

    TABLE_OPEN = '<table>',
    TABLE_CLOSE = '</table>',

    selectedIndex;

Y.mix(Y.DOM, {
    _fragClones: {},

    _create: function(html, doc, tag) {
        tag = tag || 'div';

        var frag = Y_DOM._fragClones[tag];
        if (frag) {
            frag = frag.cloneNode(false);
        } else {
            frag = Y_DOM._fragClones[tag] = doc.createElement(tag);
        }
        frag.innerHTML = html;
        return frag;
    },

    _children: function(node, tag) {
            var i = 0,
            children = node.children,
            childNodes,
            hasComments,
            child;

        if (children && children.tags) { // use tags filter when possible
            if (tag) {
                children = node.children.tags(tag);
            } else { // IE leaks comments into children
                hasComments = children.tags('!').length;
            }
        }

        if (!children || (!children.tags && tag) || hasComments) {
            childNodes = children || node.childNodes;
            children = [];
            while ((child = childNodes[i++])) {
                if (child.nodeType === 1) {
                    if (!tag || tag === child.tagName) {
                        children.push(child);
                    }
                }
            }
        }

        return children || [];
    },

    /**
     * Creates a new dom node using the provided markup string.
     * @method create
     * @param {String} html The markup used to create the element
     * @param {HTMLDocument} doc An optional document context
     * @return {HTMLElement|DocumentFragment} returns a single HTMLElement
     * when creating one node, and a documentFragment when creating
     * multiple nodes.
     */
    create: function(html, doc) {
        if (typeof html === 'string') {
            html = Y.Lang.trim(html); // match IE which trims whitespace from innerHTML

        }

        doc = doc || Y.config.doc;
        var m = re_tag.exec(html),
            create = Y_DOM._create,
            custom = creators,
            ret = null,
            creator, tag, node, nodes;

        if (html != undefined) { // not undefined or null
            if (m && m[1]) {
                creator = custom[m[1].toLowerCase()];
                if (typeof creator === 'function') {
                    create = creator;
                } else {
                    tag = creator;
                }
            }

            node = create(html, doc, tag);
            nodes = node.childNodes;

            if (nodes.length === 1) { // return single node, breaking parentNode ref from "fragment"
                ret = node.removeChild(nodes[0]);
            } else if (nodes[0] && nodes[0].className === 'yui3-big-dummy') { // using dummy node to preserve some attributes (e.g. OPTION not selected)
                selectedIndex = node.selectedIndex;

                if (nodes.length === 2) {
                    ret = nodes[0].nextSibling;
                } else {
                    node.removeChild(nodes[0]);
                    ret = Y_DOM._nl2frag(nodes, doc);
                }
            } else { // return multiple nodes as a fragment
                 ret = Y_DOM._nl2frag(nodes, doc);
            }

        }

        return ret;
    },

    _nl2frag: function(nodes, doc) {
        var ret = null,
            i, len;

        if (nodes && (nodes.push || nodes.item) && nodes[0]) {
            doc = doc || nodes[0].ownerDocument;
            ret = doc.createDocumentFragment();

            if (nodes.item) { // convert live list to static array
                nodes = Y.Array(nodes, 0, true);
            }

            for (i = 0, len = nodes.length; i < len; i++) {
                ret.appendChild(nodes[i]);
            }
        } // else inline with log for minification
        return ret;
    },

    /**
     * Inserts content in a node at the given location
     * @method addHTML
     * @param {HTMLElement} node The node to insert into
     * @param {HTMLElement | Array | HTMLCollection} content The content to be inserted
     * @param {HTMLElement} where Where to insert the content
     * If no "where" is given, content is appended to the node
     * Possible values for "where"
     * <dl>
     * <dt>HTMLElement</dt>
     * <dd>The element to insert before</dd>
     * <dt>"replace"</dt>
     * <dd>Replaces the existing HTML</dd>
     * <dt>"before"</dt>
     * <dd>Inserts before the existing HTML</dd>
     * <dt>"before"</dt>
     * <dd>Inserts content before the node</dd>
     * <dt>"after"</dt>
     * <dd>Inserts content after the node</dd>
     * </dl>
     */
    addHTML: function(node, content, where) {
        var nodeParent = node.parentNode,
            i = 0,
            item,
            ret = content,
            newNode;


        if (content != undefined) { // not null or undefined (maybe 0)
            if (content.nodeType) { // DOM node, just add it
                newNode = content;
            } else if (typeof content == 'string' || typeof content == 'number') {
                ret = newNode = Y_DOM.create(content);
            } else if (content[0] && content[0].nodeType) { // array or collection
                newNode = Y.config.doc.createDocumentFragment();
                while ((item = content[i++])) {
                    newNode.appendChild(item); // append to fragment for insertion
                }
            }
        }

        if (where) {
            if (newNode && where.parentNode) { // insert regardless of relationship to node
                where.parentNode.insertBefore(newNode, where);
            } else {
                switch (where) {
                    case 'replace':
                        while (node.firstChild) {
                            node.removeChild(node.firstChild);
                        }
                        if (newNode) { // allow empty content to clear node
                            node.appendChild(newNode);
                        }
                        break;
                    case 'before':
                        if (newNode) {
                            nodeParent.insertBefore(newNode, node);
                        }
                        break;
                    case 'after':
                        if (newNode) {
                            if (node.nextSibling) { // IE errors if refNode is null
                                nodeParent.insertBefore(newNode, node.nextSibling);
                            } else {
                                nodeParent.appendChild(newNode);
                            }
                        }
                        break;
                    default:
                        if (newNode) {
                            node.appendChild(newNode);
                        }
                }
            }
        } else if (newNode) {
            node.appendChild(newNode);
        }

        // `select` elements are the only elements with `selectedIndex`.
        // Don't grab the dummy `option` element's `selectedIndex`.
        if (node.nodeName == "SELECT" && selectedIndex > 0) {
            node.selectedIndex = selectedIndex - 1;
        }

        return ret;
    },

    wrap: function(node, html) {
        var parent = (html && html.nodeType) ? html : Y.DOM.create(html),
            nodes = parent.getElementsByTagName('*');

        if (nodes.length) {
            parent = nodes[nodes.length - 1];
        }

        if (node.parentNode) {
            node.parentNode.replaceChild(parent, node);
        }
        parent.appendChild(node);
    },

    unwrap: function(node) {
        var parent = node.parentNode,
            lastChild = parent.lastChild,
            next = node,
            grandparent;

        if (parent) {
            grandparent = parent.parentNode;
            if (grandparent) {
                node = parent.firstChild;
                while (node !== lastChild) {
                    next = node.nextSibling;
                    grandparent.insertBefore(node, parent);
                    node = next;
                }
                grandparent.replaceChild(lastChild, parent);
            } else {
                parent.removeChild(node);
            }
        }
    }
});

addFeature('innerhtml', 'table', {
    test: function() {
        var node = Y.config.doc.createElement('table');
        try {
            node.innerHTML = '<tbody></tbody>';
        } catch(e) {
            return false;
        }
        return (node.firstChild && node.firstChild.nodeName === 'TBODY');
    }
});

addFeature('innerhtml-div', 'tr', {
    test: function() {
        return createFromDIV('<tr></tr>', 'tr');
    }
});

addFeature('innerhtml-div', 'script', {
    test: function() {
        return createFromDIV('<script></script>', 'script');
    }
});

if (!testFeature('innerhtml', 'table')) {
    // TODO: thead/tfoot with nested tbody
        // IE adds TBODY when creating TABLE elements (which may share this impl)
    creators.tbody = function(html, doc) {
        var frag = Y_DOM.create(TABLE_OPEN + html + TABLE_CLOSE, doc),
            tb = Y.DOM._children(frag, 'tbody')[0];

        if (frag.children.length > 1 && tb && !re_tbody.test(html)) {
            tb.parentNode.removeChild(tb); // strip extraneous tbody
        }
        return frag;
    };
}

if (!testFeature('innerhtml-div', 'script')) {
    creators.script = function(html, doc) {
        var frag = doc.createElement('div');

        frag.innerHTML = '-' + html;
        frag.removeChild(frag.firstChild);
        return frag;
    };

    creators.link = creators.style = creators.script;
}

if (!testFeature('innerhtml-div', 'tr')) {
    Y.mix(creators, {
        option: function(html, doc) {
            return Y_DOM.create('<select><option class="yui3-big-dummy" selected></option>' + html + '</select>', doc);
        },

        tr: function(html, doc) {
            return Y_DOM.create('<tbody>' + html + '</tbody>', doc);
        },

        td: function(html, doc) {
            return Y_DOM.create('<tr>' + html + '</tr>', doc);
        },

        col: function(html, doc) {
            return Y_DOM.create('<colgroup>' + html + '</colgroup>', doc);
        },

        tbody: 'table'
    });

    Y.mix(creators, {
        legend: 'fieldset',
        th: creators.td,
        thead: creators.tbody,
        tfoot: creators.tbody,
        caption: creators.tbody,
        colgroup: creators.tbody,
        optgroup: creators.option
    });
}

Y_DOM.creators = creators;
Y.mix(Y.DOM, {
    /**
     * Sets the width of the element to the given size, regardless
     * of box model, border, padding, etc.
     * @method setWidth
     * @param {HTMLElement} element The DOM element.
     * @param {String|Number} size The pixel height to size to
     */

    setWidth: function(node, size) {
        Y.DOM._setSize(node, 'width', size);
    },

    /**
     * Sets the height of the element to the given size, regardless
     * of box model, border, padding, etc.
     * @method setHeight
     * @param {HTMLElement} element The DOM element.
     * @param {String|Number} size The pixel height to size to
     */

    setHeight: function(node, size) {
        Y.DOM._setSize(node, 'height', size);
    },

    _setSize: function(node, prop, val) {
        val = (val > 0) ? val : 0;
        var size = 0;

        node.style[prop] = val + 'px';
        size = (prop === 'height') ? node.offsetHeight : node.offsetWidth;

        if (size > val) {
            val = val - (size - val);

            if (val < 0) {
                val = 0;
            }

            node.style[prop] = val + 'px';
        }
    }
});


}, '3.17.2', {"requires": ["dom-core"]});


/***/ }),

/***/ 239429:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('dom-core', function (Y, NAME) {

var NODE_TYPE = 'nodeType',
    OWNER_DOCUMENT = 'ownerDocument',
    DOCUMENT_ELEMENT = 'documentElement',
    DEFAULT_VIEW = 'defaultView',
    PARENT_WINDOW = 'parentWindow',
    TAG_NAME = 'tagName',
    PARENT_NODE = 'parentNode',
    PREVIOUS_SIBLING = 'previousSibling',
    NEXT_SIBLING = 'nextSibling',
    CONTAINS = 'contains',
    COMPARE_DOCUMENT_POSITION = 'compareDocumentPosition',
    EMPTY_ARRAY = [],

    // IE < 8 throws on node.contains(textNode)
    supportsContainsTextNode = (function() {
        var node = Y.config.doc.createElement('div'),
            textNode = node.appendChild(Y.config.doc.createTextNode('')),
            result = false;

        try {
            result = node.contains(textNode);
        } catch(e) {}

        return result;
    })(),

/**
 * The DOM utility provides a cross-browser abtraction layer
 * normalizing DOM tasks, and adds extra helper functionality
 * for other common tasks.
 * @module dom
 * @main dom
 * @submodule dom-base
 * @for DOM
 *
 */

/**
 * Provides DOM helper methods.
 * @class DOM
 *
 */

Y_DOM = {
    /**
     * Returns the HTMLElement with the given ID (Wrapper for document.getElementById).
     * @method byId
     * @param {String} id the id attribute
     * @param {Object} doc optional The document to search. Defaults to current document
     * @return {HTMLElement | null} The HTMLElement with the id, or null if none found.
     */
    byId: function(id, doc) {
        // handle dupe IDs and IE name collision
        return Y_DOM.allById(id, doc)[0] || null;
    },

    getId: function(node) {
        var id;
        // HTMLElement returned from FORM when INPUT name === "id"
        // IE < 8: HTMLCollection returned when INPUT id === "id"
        // via both getAttribute and form.id
        if (node.id && !node.id.tagName && !node.id.item) {
            id = node.id;
        } else if (node.attributes && node.attributes.id) {
            id = node.attributes.id.value;
        }

        return id;
    },

    setId: function(node, id) {
        if (node.setAttribute) {
            node.setAttribute('id', id);
        } else {
            node.id = id;
        }
    },

    /*
     * Finds the ancestor of the element.
     * @method ancestor
     * @param {HTMLElement} element The html element.
     * @param {Function} fn optional An optional boolean test to apply.
     * The optional function is passed the current DOM node being tested as its only argument.
     * If no function is given, the parentNode is returned.
     * @param {Boolean} testSelf optional Whether or not to include the element in the scan
     * @return {HTMLElement | null} The matching DOM node or null if none found.
     */
    ancestor: function(element, fn, testSelf, stopFn) {
        var ret = null;
        if (testSelf) {
            ret = (!fn || fn(element)) ? element : null;

        }
        return ret || Y_DOM.elementByAxis(element, PARENT_NODE, fn, null, stopFn);
    },

    /*
     * Finds the ancestors of the element.
     * @method ancestors
     * @param {HTMLElement} element The html element.
     * @param {Function} fn optional An optional boolean test to apply.
     * The optional function is passed the current DOM node being tested as its only argument.
     * If no function is given, all ancestors are returned.
     * @param {Boolean} testSelf optional Whether or not to include the element in the scan
     * @return {Array} An array containing all matching DOM nodes.
     */
    ancestors: function(element, fn, testSelf, stopFn) {
        var ancestor = element,
            ret = [];

        while ((ancestor = Y_DOM.ancestor(ancestor, fn, testSelf, stopFn))) {
            testSelf = false;
            if (ancestor) {
                ret.unshift(ancestor);

                if (stopFn && stopFn(ancestor)) {
                    return ret;
                }
            }
        }

        return ret;
    },

    /**
     * Searches the element by the given axis for the first matching element.
     * @method elementByAxis
     * @param {HTMLElement} element The html element.
     * @param {String} axis The axis to search (parentNode, nextSibling, previousSibling).
     * @param {Function} [fn] An optional boolean test to apply.
     * @param {Boolean} [all] Whether text nodes as well as element nodes should be returned, or
     * just element nodes will be returned(default)
     * The optional function is passed the current HTMLElement being tested as its only argument.
     * If no function is given, the first element is returned.
     * @return {HTMLElement | null} The matching element or null if none found.
     */
    elementByAxis: function(element, axis, fn, all, stopAt) {
        while (element && (element = element[axis])) { // NOTE: assignment
                if ( (all || element[TAG_NAME]) && (!fn || fn(element)) ) {
                    return element;
                }

                if (stopAt && stopAt(element)) {
                    return null;
                }
        }
        return null;
    },

    /**
     * Determines whether or not one HTMLElement is or contains another HTMLElement.
     * @method contains
     * @param {HTMLElement} element The containing html element.
     * @param {HTMLElement} needle The html element that may be contained.
     * @return {Boolean} Whether or not the element is or contains the needle.
     */
    contains: function(element, needle) {
        var ret = false;

        if ( !needle || !element || !needle[NODE_TYPE] || !element[NODE_TYPE]) {
            ret = false;
        } else if (element[CONTAINS] &&
                // IE < 8 throws on node.contains(textNode) so fall back to brute.
                // Falling back for other nodeTypes as well.
                (needle[NODE_TYPE] === 1 || supportsContainsTextNode)) {
                ret = element[CONTAINS](needle);
        } else if (element[COMPARE_DOCUMENT_POSITION]) {
            // Match contains behavior (node.contains(node) === true).
            // Needed for Firefox < 4.
            if (element === needle || !!(element[COMPARE_DOCUMENT_POSITION](needle) & 16)) {
                ret = true;
            }
        } else {
            ret = Y_DOM._bruteContains(element, needle);
        }

        return ret;
    },

    /**
     * Determines whether or not the HTMLElement is part of the document.
     * @method inDoc
     * @param {HTMLElement} element The containing html element.
     * @param {HTMLElement} doc optional The document to check.
     * @return {Boolean} Whether or not the element is attached to the document.
     */
    inDoc: function(element, doc) {
        var ret = false,
            rootNode;

        if (element && element.nodeType) {
            (doc) || (doc = element[OWNER_DOCUMENT]);

            rootNode = doc[DOCUMENT_ELEMENT];

            // contains only works with HTML_ELEMENT
            if (rootNode && rootNode.contains && element.tagName) {
                ret = rootNode.contains(element);
            } else {
                ret = Y_DOM.contains(rootNode, element);
            }
        }

        return ret;

    },

   allById: function(id, root) {
        root = root || Y.config.doc;
        var nodes = [],
            ret = [],
            i,
            node;

        if (root.querySelectorAll) {
            ret = root.querySelectorAll('[id="' + id + '"]');
        } else if (root.all) {
            nodes = root.all(id);

            if (nodes) {
                // root.all may return HTMLElement or HTMLCollection.
                // some elements are also HTMLCollection (FORM, SELECT).
                if (nodes.nodeName) {
                    if (nodes.id === id) { // avoid false positive on name
                        ret.push(nodes);
                        nodes = EMPTY_ARRAY; // done, no need to filter
                    } else { //  prep for filtering
                        nodes = [nodes];
                    }
                }

                if (nodes.length) {
                    // filter out matches on node.name
                    // and element.id as reference to element with id === 'id'
                    for (i = 0; node = nodes[i++];) {
                        if (node.id === id  ||
                                (node.attributes && node.attributes.id &&
                                node.attributes.id.value === id)) {
                            ret.push(node);
                        }
                    }
                }
            }
        } else {
            ret = [Y_DOM._getDoc(root).getElementById(id)];
        }

        return ret;
   },


    isWindow: function(obj) {
        return !!(obj && obj.scrollTo && obj.document);
    },

    _removeChildNodes: function(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    },

    siblings: function(node, fn) {
        var nodes = [],
            sibling = node;

        while ((sibling = sibling[PREVIOUS_SIBLING])) {
            if (sibling[TAG_NAME] && (!fn || fn(sibling))) {
                nodes.unshift(sibling);
            }
        }

        sibling = node;
        while ((sibling = sibling[NEXT_SIBLING])) {
            if (sibling[TAG_NAME] && (!fn || fn(sibling))) {
                nodes.push(sibling);
            }
        }

        return nodes;
    },

    /**
     * Brute force version of contains.
     * Used for browsers without contains support for non-HTMLElement Nodes (textNodes, etc).
     * @method _bruteContains
     * @private
     * @param {HTMLElement} element The containing html element.
     * @param {HTMLElement} needle The html element that may be contained.
     * @return {Boolean} Whether or not the element is or contains the needle.
     */
    _bruteContains: function(element, needle) {
        while (needle) {
            if (element === needle) {
                return true;
            }
            needle = needle.parentNode;
        }
        return false;
    },

// TODO: move to Lang?
    /**
     * Memoizes dynamic regular expressions to boost runtime performance.
     * @method _getRegExp
     * @private
     * @param {String} str The string to convert to a regular expression.
     * @param {String} flags optional An optinal string of flags.
     * @return {RegExp} An instance of RegExp
     */
    _getRegExp: function(str, flags) {
        flags = flags || '';
        Y_DOM._regexCache = Y_DOM._regexCache || {};
        if (!Y_DOM._regexCache[str + flags]) {
            Y_DOM._regexCache[str + flags] = new RegExp(str, flags);
        }
        return Y_DOM._regexCache[str + flags];
    },

// TODO: make getDoc/Win true privates?
    /**
     * returns the appropriate document.
     * @method _getDoc
     * @private
     * @param {HTMLElement} element optional Target element.
     * @return {Object} The document for the given element or the default document.
     */
    _getDoc: function(element) {
        var doc = Y.config.doc;
        if (element) {
            doc = (element[NODE_TYPE] === 9) ? element : // element === document
                element[OWNER_DOCUMENT] || // element === DOM node
                element.document || // element === window
                Y.config.doc; // default
        }

        return doc;
    },

    /**
     * returns the appropriate window.
     * @method _getWin
     * @private
     * @param {HTMLElement} element optional Target element.
     * @return {Object} The window for the given element or the default window.
     */
    _getWin: function(element) {
        var doc = Y_DOM._getDoc(element);
        return doc[DEFAULT_VIEW] || doc[PARENT_WINDOW] || Y.config.win;
    },

    _batch: function(nodes, fn, arg1, arg2, arg3, etc) {
        fn = (typeof fn === 'string') ? Y_DOM[fn] : fn;
        var result,
            i = 0,
            node,
            ret;

        if (fn && nodes) {
            while ((node = nodes[i++])) {
                result = result = fn.call(Y_DOM, node, arg1, arg2, arg3, etc);
                if (typeof result !== 'undefined') {
                    (ret) || (ret = []);
                    ret.push(result);
                }
            }
        }

        return (typeof ret !== 'undefined') ? ret : nodes;
    },

    generateID: function(el) {
        var id = el.id;

        if (!id) {
            id = Y.stamp(el);
            el.id = id;
        }

        return id;
    }
};


Y.DOM = Y_DOM;


}, '3.17.2', {"requires": ["oop", "features"]});


/***/ }),

/***/ 353015:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('dom-screen', function (Y, NAME) {

(function(Y) {

/**
 * Adds position and region management functionality to DOM.
 * @module dom
 * @submodule dom-screen
 * @for DOM
 */

var DOCUMENT_ELEMENT = 'documentElement',
    COMPAT_MODE = 'compatMode',
    POSITION = 'position',
    FIXED = 'fixed',
    RELATIVE = 'relative',
    LEFT = 'left',
    TOP = 'top',
    _BACK_COMPAT = 'BackCompat',
    MEDIUM = 'medium',
    BORDER_LEFT_WIDTH = 'borderLeftWidth',
    BORDER_TOP_WIDTH = 'borderTopWidth',
    GET_BOUNDING_CLIENT_RECT = 'getBoundingClientRect',
    GET_COMPUTED_STYLE = 'getComputedStyle',

    Y_DOM = Y.DOM,

    // TODO: how about thead/tbody/tfoot/tr?
    // TODO: does caption matter?
    RE_TABLE = /^t(?:able|d|h)$/i,

    SCROLL_NODE;

if (Y.UA.ie) {
    if (Y.config.doc[COMPAT_MODE] !== 'BackCompat') {
        SCROLL_NODE = DOCUMENT_ELEMENT;
    } else {
        SCROLL_NODE = 'body';
    }
}

Y.mix(Y_DOM, {
    /**
     * Returns the inner height of the viewport (exludes scrollbar).
     * @method winHeight
     * @return {Number} The current height of the viewport.
     */
    winHeight: function(node) {
        var h = Y_DOM._getWinSize(node).height;
        return h;
    },

    /**
     * Returns the inner width of the viewport (exludes scrollbar).
     * @method winWidth
     * @return {Number} The current width of the viewport.
     */
    winWidth: function(node) {
        var w = Y_DOM._getWinSize(node).width;
        return w;
    },

    /**
     * Document height
     * @method docHeight
     * @return {Number} The current height of the document.
     */
    docHeight:  function(node) {
        var h = Y_DOM._getDocSize(node).height;
        return Math.max(h, Y_DOM._getWinSize(node).height);
    },

    /**
     * Document width
     * @method docWidth
     * @return {Number} The current width of the document.
     */
    docWidth:  function(node) {
        var w = Y_DOM._getDocSize(node).width;
        return Math.max(w, Y_DOM._getWinSize(node).width);
    },

    /**
     * Amount page has been scroll horizontally
     * @method docScrollX
     * @return {Number} The current amount the screen is scrolled horizontally.
     */
    docScrollX: function(node, doc) {
        doc = doc || (node) ? Y_DOM._getDoc(node) : Y.config.doc; // perf optimization
        var dv = doc.defaultView,
            pageOffset = (dv) ? dv.pageXOffset : 0;
        return Math.max(doc[DOCUMENT_ELEMENT].scrollLeft, doc.body.scrollLeft, pageOffset);
    },

    /**
     * Amount page has been scroll vertically
     * @method docScrollY
     * @return {Number} The current amount the screen is scrolled vertically.
     */
    docScrollY:  function(node, doc) {
        doc = doc || (node) ? Y_DOM._getDoc(node) : Y.config.doc; // perf optimization
        var dv = doc.defaultView,
            pageOffset = (dv) ? dv.pageYOffset : 0;
        return Math.max(doc[DOCUMENT_ELEMENT].scrollTop, doc.body.scrollTop, pageOffset);
    },

    /**
     * Gets the current position of an element based on page coordinates.
     * Element must be part of the DOM tree to have page coordinates
     * (display:none or elements not appended return false).
     * @method getXY
     * @param element The target element
     * @return {Array} The XY position of the element

     TODO: test inDocument/display?
     */
    getXY: function() {
        if (Y.config.doc[DOCUMENT_ELEMENT][GET_BOUNDING_CLIENT_RECT]) {
            return function(node) {
                var xy = null,
                    scrollLeft,
                    scrollTop,
                    mode,
                    box,
                    offX,
                    offY,
                    doc,
                    win,
                    inDoc,
                    rootNode;

                if (node && node.tagName) {
                    doc = node.ownerDocument;
                    mode = doc[COMPAT_MODE];

                    if (mode !== _BACK_COMPAT) {
                        rootNode = doc[DOCUMENT_ELEMENT];
                    } else {
                        rootNode = doc.body;
                    }

                    // inline inDoc check for perf
                    if (rootNode.contains) {
                        inDoc = rootNode.contains(node);
                    } else {
                        inDoc = Y.DOM.contains(rootNode, node);
                    }

                    if (inDoc) {
                        win = doc.defaultView;

                        // inline scroll calc for perf
                        if (win && 'pageXOffset' in win) {
                            scrollLeft = win.pageXOffset;
                            scrollTop = win.pageYOffset;
                        } else {
                            scrollLeft = (SCROLL_NODE) ? doc[SCROLL_NODE].scrollLeft : Y_DOM.docScrollX(node, doc);
                            scrollTop = (SCROLL_NODE) ? doc[SCROLL_NODE].scrollTop : Y_DOM.docScrollY(node, doc);
                        }

                        if (Y.UA.ie) { // IE < 8, quirks, or compatMode
                            if (!doc.documentMode || doc.documentMode < 8 || mode === _BACK_COMPAT) {
                                offX = rootNode.clientLeft;
                                offY = rootNode.clientTop;
                            }
                        }
                        box = node[GET_BOUNDING_CLIENT_RECT]();
                        xy = [box.left, box.top];

                        if (offX || offY) {
                                xy[0] -= offX;
                                xy[1] -= offY;

                        }
                        if ((scrollTop || scrollLeft)) {
                            if (!Y.UA.ios || (Y.UA.ios >= 4.2)) {
                                xy[0] += scrollLeft;
                                xy[1] += scrollTop;
                            }

                        }
                    } else {
                        xy = Y_DOM._getOffset(node);
                    }
                }
                return xy;
            };
        } else {
            return function(node) { // manually calculate by crawling up offsetParents
                //Calculate the Top and Left border sizes (assumes pixels)
                var xy = null,
                    doc,
                    parentNode,
                    bCheck,
                    scrollTop,
                    scrollLeft;

                if (node) {
                    if (Y_DOM.inDoc(node)) {
                        xy = [node.offsetLeft, node.offsetTop];
                        doc = node.ownerDocument;
                        parentNode = node;
                        // TODO: refactor with !! or just falsey
                        bCheck = ((Y.UA.gecko || Y.UA.webkit > 519) ? true : false);

                        // TODO: worth refactoring for TOP/LEFT only?
                        while ((parentNode = parentNode.offsetParent)) {
                            xy[0] += parentNode.offsetLeft;
                            xy[1] += parentNode.offsetTop;
                            if (bCheck) {
                                xy = Y_DOM._calcBorders(parentNode, xy);
                            }
                        }

                        // account for any scrolled ancestors
                        if (Y_DOM.getStyle(node, POSITION) != FIXED) {
                            parentNode = node;

                            while ((parentNode = parentNode.parentNode)) {
                                scrollTop = parentNode.scrollTop;
                                scrollLeft = parentNode.scrollLeft;

                                //Firefox does something funky with borders when overflow is not visible.
                                if (Y.UA.gecko && (Y_DOM.getStyle(parentNode, 'overflow') !== 'visible')) {
                                        xy = Y_DOM._calcBorders(parentNode, xy);
                                }


                                if (scrollTop || scrollLeft) {
                                    xy[0] -= scrollLeft;
                                    xy[1] -= scrollTop;
                                }
                            }
                            xy[0] += Y_DOM.docScrollX(node, doc);
                            xy[1] += Y_DOM.docScrollY(node, doc);

                        } else {
                            //Fix FIXED position -- add scrollbars
                            xy[0] += Y_DOM.docScrollX(node, doc);
                            xy[1] += Y_DOM.docScrollY(node, doc);
                        }
                    } else {
                        xy = Y_DOM._getOffset(node);
                    }
                }

                return xy;
            };
        }
    }(),// NOTE: Executing for loadtime branching

    /**
    Gets the width of vertical scrollbars on overflowed containers in the body
    content.

    @method getScrollbarWidth
    @return {Number} Pixel width of a scrollbar in the current browser
    **/
    getScrollbarWidth: Y.cached(function () {
        var doc      = Y.config.doc,
            testNode = doc.createElement('div'),
            body     = doc.getElementsByTagName('body')[0],
            // 0.1 because cached doesn't support falsy refetch values
            width    = 0.1;

        if (body) {
            testNode.style.cssText = "position:absolute;visibility:hidden;overflow:scroll;width:20px;";
            testNode.appendChild(doc.createElement('p')).style.height = '1px';
            body.insertBefore(testNode, body.firstChild);
            width = testNode.offsetWidth - testNode.clientWidth;

            body.removeChild(testNode);
        }

        return width;
    }, null, 0.1),

    /**
     * Gets the current X position of an element based on page coordinates.
     * Element must be part of the DOM tree to have page coordinates
     * (display:none or elements not appended return false).
     * @method getX
     * @param element The target element
     * @return {Number} The X position of the element
     */

    getX: function(node) {
        return Y_DOM.getXY(node)[0];
    },

    /**
     * Gets the current Y position of an element based on page coordinates.
     * Element must be part of the DOM tree to have page coordinates
     * (display:none or elements not appended return false).
     * @method getY
     * @param element The target element
     * @return {Number} The Y position of the element
     */

    getY: function(node) {
        return Y_DOM.getXY(node)[1];
    },

    /**
     * Set the position of an html element in page coordinates.
     * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
     * @method setXY
     * @param element The target element
     * @param {Array} xy Contains X & Y values for new position (coordinates are page-based)
     * @param {Boolean} noRetry By default we try and set the position a second time if the first fails
     */
    setXY: function(node, xy, noRetry) {
        var setStyle = Y_DOM.setStyle,
            pos,
            delta,
            newXY,
            currentXY;

        if (node && xy) {
            pos = Y_DOM.getStyle(node, POSITION);

            delta = Y_DOM._getOffset(node);
            if (pos == 'static') { // default to relative
                pos = RELATIVE;
                setStyle(node, POSITION, pos);
            }
            currentXY = Y_DOM.getXY(node);

            if (xy[0] !== null) {
                setStyle(node, LEFT, Math.floor(xy[0] - currentXY[0] + delta[0]) + 'px');
            }

            if (xy[1] !== null) {
                setStyle(node, TOP, Math.floor(xy[1] - currentXY[1] + delta[1]) + 'px');
            }

            if (!noRetry) {
                newXY = Y_DOM.getXY(node);
                if (newXY[0] !== xy[0] || newXY[1] !== xy[1]) {
                    Y_DOM.setXY(node, xy, true);
                }
            }

        } else {
        }
    },

    /**
     * Set the X position of an html element in page coordinates, regardless of how the element is positioned.
     * The element(s) must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
     * @method setX
     * @param element The target element
     * @param {Number} x The X values for new position (coordinates are page-based)
     */
    setX: function(node, x) {
        return Y_DOM.setXY(node, [x, null]);
    },

    /**
     * Set the Y position of an html element in page coordinates, regardless of how the element is positioned.
     * The element(s) must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
     * @method setY
     * @param element The target element
     * @param {Number} y The Y values for new position (coordinates are page-based)
     */
    setY: function(node, y) {
        return Y_DOM.setXY(node, [null, y]);
    },

    /**
     * @method swapXY
     * @description Swap the xy position with another node
     * @param {Node} node The node to swap with
     * @param {Node} otherNode The other node to swap with
     * @return {Node}
     */
    swapXY: function(node, otherNode) {
        var xy = Y_DOM.getXY(node);
        Y_DOM.setXY(node, Y_DOM.getXY(otherNode));
        Y_DOM.setXY(otherNode, xy);
    },

    _calcBorders: function(node, xy2) {
        var t = parseInt(Y_DOM[GET_COMPUTED_STYLE](node, BORDER_TOP_WIDTH), 10) || 0,
            l = parseInt(Y_DOM[GET_COMPUTED_STYLE](node, BORDER_LEFT_WIDTH), 10) || 0;
        if (Y.UA.gecko) {
            if (RE_TABLE.test(node.tagName)) {
                t = 0;
                l = 0;
            }
        }
        xy2[0] += l;
        xy2[1] += t;
        return xy2;
    },

    _getWinSize: function(node, doc) {
        doc  = doc || (node) ? Y_DOM._getDoc(node) : Y.config.doc;
        var win = doc.defaultView || doc.parentWindow,
            mode = doc[COMPAT_MODE],
            h = win.innerHeight,
            w = win.innerWidth,
            root = doc[DOCUMENT_ELEMENT];

        if ( mode && !Y.UA.opera ) { // IE, Gecko
            if (mode != 'CSS1Compat') { // Quirks
                root = doc.body;
            }
            h = root.clientHeight;
            w = root.clientWidth;
        }
        return { height: h, width: w };
    },

    _getDocSize: function(node) {
        var doc = (node) ? Y_DOM._getDoc(node) : Y.config.doc,
            root = doc[DOCUMENT_ELEMENT];

        if (doc[COMPAT_MODE] != 'CSS1Compat') {
            root = doc.body;
        }

        return { height: root.scrollHeight, width: root.scrollWidth };
    }
});

})(Y);
(function(Y) {
var TOP = 'top',
    RIGHT = 'right',
    BOTTOM = 'bottom',
    LEFT = 'left',

    getOffsets = function(r1, r2) {
        var t = Math.max(r1[TOP], r2[TOP]),
            r = Math.min(r1[RIGHT], r2[RIGHT]),
            b = Math.min(r1[BOTTOM], r2[BOTTOM]),
            l = Math.max(r1[LEFT], r2[LEFT]),
            ret = {};

        ret[TOP] = t;
        ret[RIGHT] = r;
        ret[BOTTOM] = b;
        ret[LEFT] = l;
        return ret;
    },

    DOM = Y.DOM;

Y.mix(DOM, {
    /**
     * Returns an Object literal containing the following about this element: (top, right, bottom, left)
     * @for DOM
     * @method region
     * @param {HTMLElement} element The DOM element.
     * @return {Object} Object literal containing the following about this element: (top, right, bottom, left)
     */
    region: function(node) {
        var xy = DOM.getXY(node),
            ret = false;

        if (node && xy) {
            ret = DOM._getRegion(
                xy[1], // top
                xy[0] + node.offsetWidth, // right
                xy[1] + node.offsetHeight, // bottom
                xy[0] // left
            );
        }

        return ret;
    },

    /**
     * Find the intersect information for the passed nodes.
     * @method intersect
     * @for DOM
     * @param {HTMLElement} element The first element
     * @param {HTMLElement | Object} element2 The element or region to check the interect with
     * @param {Object} altRegion An object literal containing the region for the first element if we already have the data (for performance e.g. DragDrop)
     * @return {Object} Object literal containing the following intersection data: (top, right, bottom, left, area, yoff, xoff, inRegion)
     */
    intersect: function(node, node2, altRegion) {
        var r = altRegion || DOM.region(node), region = {},
            n = node2,
            off;

        if (n.tagName) {
            region = DOM.region(n);
        } else if (Y.Lang.isObject(node2)) {
            region = node2;
        } else {
            return false;
        }

        off = getOffsets(region, r);
        return {
            top: off[TOP],
            right: off[RIGHT],
            bottom: off[BOTTOM],
            left: off[LEFT],
            area: ((off[BOTTOM] - off[TOP]) * (off[RIGHT] - off[LEFT])),
            yoff: ((off[BOTTOM] - off[TOP])),
            xoff: (off[RIGHT] - off[LEFT]),
            inRegion: DOM.inRegion(node, node2, false, altRegion)
        };

    },
    /**
     * Check if any part of this node is in the passed region
     * @method inRegion
     * @for DOM
     * @param {Object} node The node to get the region from
     * @param {Object} node2 The second node to get the region from or an Object literal of the region
     * @param {Boolean} all Should all of the node be inside the region
     * @param {Object} altRegion An object literal containing the region for this node if we already have the data (for performance e.g. DragDrop)
     * @return {Boolean} True if in region, false if not.
     */
    inRegion: function(node, node2, all, altRegion) {
        var region = {},
            r = altRegion || DOM.region(node),
            n = node2,
            off;

        if (n.tagName) {
            region = DOM.region(n);
        } else if (Y.Lang.isObject(node2)) {
            region = node2;
        } else {
            return false;
        }

        if (all) {
            return (
                r[LEFT]   >= region[LEFT]   &&
                r[RIGHT]  <= region[RIGHT]  &&
                r[TOP]    >= region[TOP]    &&
                r[BOTTOM] <= region[BOTTOM]  );
        } else {
            off = getOffsets(region, r);
            if (off[BOTTOM] >= off[TOP] && off[RIGHT] >= off[LEFT]) {
                return true;
            } else {
                return false;
            }

        }
    },

    /**
     * Check if any part of this element is in the viewport
     * @method inViewportRegion
     * @for DOM
     * @param {HTMLElement} element The DOM element.
     * @param {Boolean} all Should all of the node be inside the region
     * @param {Object} altRegion An object literal containing the region for this node if we already have the data (for performance e.g. DragDrop)
     * @return {Boolean} True if in region, false if not.
     */
    inViewportRegion: function(node, all, altRegion) {
        return DOM.inRegion(node, DOM.viewportRegion(node), all, altRegion);

    },

    _getRegion: function(t, r, b, l) {
        var region = {};

        region[TOP] = region[1] = t;
        region[LEFT] = region[0] = l;
        region[BOTTOM] = b;
        region[RIGHT] = r;
        region.width = region[RIGHT] - region[LEFT];
        region.height = region[BOTTOM] - region[TOP];

        return region;
    },

    /**
     * Returns an Object literal containing the following about the visible region of viewport: (top, right, bottom, left)
     * @method viewportRegion
     * @for DOM
     * @return {Object} Object literal containing the following about the visible region of the viewport: (top, right, bottom, left)
     */
    viewportRegion: function(node) {
        node = node || Y.config.doc.documentElement;
        var ret = false,
            scrollX,
            scrollY;

        if (node) {
            scrollX = DOM.docScrollX(node);
            scrollY = DOM.docScrollY(node);

            ret = DOM._getRegion(scrollY, // top
                DOM.winWidth(node) + scrollX, // right
                scrollY + DOM.winHeight(node), // bottom
                scrollX); // left
        }

        return ret;
    }
});
})(Y);


}, '3.17.2', {"requires": ["dom-base", "dom-style"]});


/***/ }),

/***/ 819406:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('dom-style-ie', function (Y, NAME) {

var HAS_LAYOUT = 'hasLayout',
    PX = 'px',
    FILTER = 'filter',
    FILTERS = 'filters',
    OPACITY = 'opacity',
    AUTO = 'auto',

    BORDER_WIDTH = 'borderWidth',
    BORDER_TOP_WIDTH = 'borderTopWidth',
    BORDER_RIGHT_WIDTH = 'borderRightWidth',
    BORDER_BOTTOM_WIDTH = 'borderBottomWidth',
    BORDER_LEFT_WIDTH = 'borderLeftWidth',
    WIDTH = 'width',
    HEIGHT = 'height',
    TRANSPARENT = 'transparent',
    VISIBLE = 'visible',
    GET_COMPUTED_STYLE = 'getComputedStyle',
    documentElement = Y.config.doc.documentElement,

    testFeature = Y.Features.test,
    addFeature = Y.Features.add,

    // TODO: unit-less lineHeight (e.g. 1.22)
    re_unit = /^(\d[.\d]*)+(em|ex|px|gd|rem|vw|vh|vm|ch|mm|cm|in|pt|pc|deg|rad|ms|s|hz|khz|%){1}?/i,

    isIE8 = (Y.UA.ie >= 8),

    _getStyleObj = function(node) {
        return node.currentStyle || node.style;
    },

    ComputedStyle = {
        CUSTOM_STYLES: {},

        get: function(el, property) {
            var value = '',
                current;

            if (el) {
                    current = _getStyleObj(el)[property];

                if (property === OPACITY && Y.DOM.CUSTOM_STYLES[OPACITY]) {
                    value = Y.DOM.CUSTOM_STYLES[OPACITY].get(el);
                } else if (!current || (current.indexOf && current.indexOf(PX) > -1)) { // no need to convert
                    value = current;
                } else if (Y.DOM.IE.COMPUTED[property]) { // use compute function
                    value = Y.DOM.IE.COMPUTED[property](el, property);
                } else if (re_unit.test(current)) { // convert to pixel
                    value = ComputedStyle.getPixel(el, property) + PX;
                } else {
                    value = current;
                }
            }

            return value;
        },

        sizeOffsets: {
            width: ['Left', 'Right'],
            height: ['Top', 'Bottom'],
            top: ['Top'],
            bottom: ['Bottom']
        },

        getOffset: function(el, prop) {
            var current = _getStyleObj(el)[prop],                     // value of "width", "top", etc.
                capped = prop.charAt(0).toUpperCase() + prop.substr(1), // "Width", "Top", etc.
                pixel = 'pixel' + capped,                               // "pixelWidth", "pixelTop", etc.
                sizeOffsets = ComputedStyle.sizeOffsets[prop],
                mode = el.ownerDocument.compatMode,
                value = '';

            // IE pixelWidth incorrect for percent
            // manually compute by subtracting padding and border from offset size
            // NOTE: clientWidth/Height (size minus border) is 0 when current === AUTO so offsetHeight is used
            // reverting to auto from auto causes position stacking issues (old impl)
            if (current === AUTO || current.indexOf('%') > -1) {
                value = el['offset' + capped];

                if (mode !== 'BackCompat') {
                    if (sizeOffsets[0]) {
                        value -= ComputedStyle.getPixel(el, 'padding' + sizeOffsets[0]);
                        value -= ComputedStyle.getBorderWidth(el, 'border' + sizeOffsets[0] + 'Width', 1);
                    }

                    if (sizeOffsets[1]) {
                        value -= ComputedStyle.getPixel(el, 'padding' + sizeOffsets[1]);
                        value -= ComputedStyle.getBorderWidth(el, 'border' + sizeOffsets[1] + 'Width', 1);
                    }
                }

            } else { // use style.pixelWidth, etc. to convert to pixels
                // need to map style.width to currentStyle (no currentStyle.pixelWidth)
                if (!el.style[pixel] && !el.style[prop]) {
                    el.style[prop] = current;
                }
                value = el.style[pixel];

            }
            return value + PX;
        },

        borderMap: {
            thin: (isIE8) ? '1px' : '2px',
            medium: (isIE8) ? '3px': '4px',
            thick: (isIE8) ? '5px' : '6px'
        },

        getBorderWidth: function(el, property, omitUnit) {
            var current = el.currentStyle[property];

            if (current.indexOf(PX) < 0) { // look up keywords if a border exists
                if (ComputedStyle.borderMap[current] &&
                        el.currentStyle.borderStyle !== 'none') {
                    current = ComputedStyle.borderMap[current];
                } else { // otherwise no border (default is "medium")
                    current = 0;
                }
            }
            return (omitUnit) ? parseFloat(current) : current;
        },

        getPixel: function(node, att) {
            // use pixelRight to convert to px
            var val = null,
                style = _getStyleObj(node),
                styleRight = style.right,
                current = style[att];

            node.style.right = current;
            val = node.style.pixelRight;
            node.style.right = styleRight; // revert

            return val;
        },

        getMargin: function(node, att) {
            var val,
                style = _getStyleObj(node);

            if (style[att] === AUTO) {
                val = 0;
            } else {
                val = ComputedStyle.getPixel(node, att);
            }
            return val + PX;
        },

        getVisibility: function(node, att) {
            var current;
            while ( (current = node.currentStyle) && current[att] === 'inherit') { // NOTE: assignment in test
                node = node.parentNode;
            }
            return (current) ? current[att] : VISIBLE;
        },

        getColor: function(node, att) {
            var current = _getStyleObj(node)[att];

            if (!current || current === TRANSPARENT) {
                Y.DOM.elementByAxis(node, 'parentNode', null, function(parent) {
                    current = _getStyleObj(parent)[att];
                    if (current && current !== TRANSPARENT) {
                        node = parent;
                        return true;
                    }
                });
            }

            return Y.Color.toRGB(current);
        },

        getBorderColor: function(node, att) {
            var current = _getStyleObj(node),
                val = current[att] || current.color;
            return Y.Color.toRGB(Y.Color.toHex(val));
        }
    },

    //fontSize: getPixelFont,
    IEComputed = {};

addFeature('style', 'computedStyle', {
    test: function() {
        return 'getComputedStyle' in Y.config.win;
    }
});

addFeature('style', 'opacity', {
    test: function() {
        return 'opacity' in documentElement.style;
    }
});

addFeature('style', 'filter', {
    test: function() {
        return 'filters' in documentElement;
    }
});

// use alpha filter for IE opacity
if (!testFeature('style', 'opacity') && testFeature('style', 'filter')) {
    Y.DOM.CUSTOM_STYLES[OPACITY] = {
        get: function(node) {
            var val = 100;
            try { // will error if no DXImageTransform
                val = node[FILTERS]['DXImageTransform.Microsoft.Alpha'][OPACITY];

            } catch(e) {
                try { // make sure its in the document
                    val = node[FILTERS]('alpha')[OPACITY];
                } catch(err) {
                }
            }
            return val / 100;
        },

        set: function(node, val, style) {
            var current,
                styleObj = _getStyleObj(node),
                currentFilter = styleObj[FILTER];

            style = style || node.style;
            if (val === '') { // normalize inline style behavior
                current = (OPACITY in styleObj) ? styleObj[OPACITY] : 1; // revert to original opacity
                val = current;
            }

            if (typeof currentFilter === 'string') { // in case not appended
                style[FILTER] = currentFilter.replace(/alpha([^)]*\))/gi, '') +
                        ((val <= 1) ? 'alpha(' + OPACITY + '=' + val * 100 + ')' : '');

                if (!style[FILTER]) {
                    style.removeAttribute(FILTER);
                }

                if (!styleObj[HAS_LAYOUT]) {
                    style.zoom = 1; // needs layout
                }
            }
        }
    };
}

try {
    Y.config.doc.createElement('div').style.height = '-1px';
} catch(e) { // IE throws error on invalid style set; trap common cases
    Y.DOM.CUSTOM_STYLES.height = {
        set: function(node, val, style) {
            var floatVal = parseFloat(val);
            if (floatVal >= 0 || val === 'auto' || val === '') {
                style.height = val;
            } else {
            }
        }
    };

    Y.DOM.CUSTOM_STYLES.width = {
        set: function(node, val, style) {
            var floatVal = parseFloat(val);
            if (floatVal >= 0 || val === 'auto' || val === '') {
                style.width = val;
            } else {
            }
        }
    };
}

if (!testFeature('style', 'computedStyle')) {
    // TODO: top, right, bottom, left
    IEComputed[WIDTH] = IEComputed[HEIGHT] = ComputedStyle.getOffset;

    IEComputed.color = IEComputed.backgroundColor = ComputedStyle.getColor;

    IEComputed[BORDER_WIDTH] = IEComputed[BORDER_TOP_WIDTH] = IEComputed[BORDER_RIGHT_WIDTH] =
            IEComputed[BORDER_BOTTOM_WIDTH] = IEComputed[BORDER_LEFT_WIDTH] =
            ComputedStyle.getBorderWidth;

    IEComputed.marginTop = IEComputed.marginRight = IEComputed.marginBottom =
            IEComputed.marginLeft = ComputedStyle.getMargin;

    IEComputed.visibility = ComputedStyle.getVisibility;
    IEComputed.borderColor = IEComputed.borderTopColor =
            IEComputed.borderRightColor = IEComputed.borderBottomColor =
            IEComputed.borderLeftColor = ComputedStyle.getBorderColor;

    Y.DOM[GET_COMPUTED_STYLE] = ComputedStyle.get;

    Y.namespace('DOM.IE');
    Y.DOM.IE.COMPUTED = IEComputed;
    Y.DOM.IE.ComputedStyle = ComputedStyle;
}


}, '3.17.2', {"requires": ["dom-style", "color-base"]});


/***/ }),

/***/ 743384:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('dom-style', function (Y, NAME) {

/**
 * Add style management functionality to DOM.
 * @module dom
 * @submodule dom-style
 * @for DOM
 */

var DOCUMENT_ELEMENT = 'documentElement',
    DEFAULT_VIEW = 'defaultView',
    OWNER_DOCUMENT = 'ownerDocument',
    STYLE = 'style',
    FLOAT = 'float',
    CSS_FLOAT = 'cssFloat',
    STYLE_FLOAT = 'styleFloat',
    TRANSPARENT = 'transparent',
    GET_COMPUTED_STYLE = 'getComputedStyle',
    GET_BOUNDING_CLIENT_RECT = 'getBoundingClientRect',

    DOCUMENT = Y.config.doc,

    Y_DOM = Y.DOM,

    TRANSFORM,
    TRANSFORMORIGIN,
    VENDOR_TRANSFORM = [
        'WebkitTransform',
        'MozTransform',
        'OTransform',
        'msTransform',
        'transform'
    ],

    re_unit = /width|height|top|left|right|bottom|margin|padding/i;

Y.Array.each(VENDOR_TRANSFORM, function(val) {
    if (val in DOCUMENT[DOCUMENT_ELEMENT].style) {
        TRANSFORM = val;
        TRANSFORMORIGIN = val + "Origin";
    }
});

Y.mix(Y_DOM, {
    DEFAULT_UNIT: 'px',

    CUSTOM_STYLES: {
    },


    /**
     * Sets a style property for a given element.
     * @method setStyle
     * @param {HTMLElement} node The HTMLElement to apply the style to.
     * @param {String} att The style property to set.
     * @param {String|Number} val The value.
     * @param {Object} [style] The style node. Defaults to `node.style`.
     */
    setStyle: function(node, att, val, style) {
        style = style || node.style;
        var CUSTOM_STYLES = Y_DOM.CUSTOM_STYLES;

        if (style) {
            if (val === null || val === '') { // normalize unsetting
                val = '';
            } else if (!isNaN(Number(val)) && re_unit.test(att)) { // number values may need a unit
                val += Y_DOM.DEFAULT_UNIT;
            }

            if (att in CUSTOM_STYLES) {
                if (CUSTOM_STYLES[att].set) {
                    CUSTOM_STYLES[att].set(node, val, style);
                    return; // NOTE: return
                } else if (typeof CUSTOM_STYLES[att] === 'string') {
                    att = CUSTOM_STYLES[att];
                }
            } else if (att === '') { // unset inline styles
                att = 'cssText';
                val = '';
            }
            style[att] = val;
        }
    },

    /**
     * Returns the current style value for the given property.
     * @method getStyle
     * @param {HTMLElement} node The HTMLElement to get the style from.
     * @param {String} att The style property to get.
     * @param {Object} [style] The style node. Defaults to `node.style`.
     */
    getStyle: function(node, att, style) {
        style = style || node.style;
        var CUSTOM_STYLES = Y_DOM.CUSTOM_STYLES,
            val = '';

        if (style) {
            if (att in CUSTOM_STYLES) {
                if (CUSTOM_STYLES[att].get) {
                    return CUSTOM_STYLES[att].get(node, att, style); // NOTE: return
                } else if (typeof CUSTOM_STYLES[att] === 'string') {
                    att = CUSTOM_STYLES[att];
                }
            }
            val = style[att];
            if (val === '') { // TODO: is empty string sufficient?
                val = Y_DOM[GET_COMPUTED_STYLE](node, att);
            }
        }

        return val;
    },

    /**
     * Sets multiple style properties.
     * @method setStyles
     * @param {HTMLElement} node The HTMLElement to apply the styles to.
     * @param {Object} hash An object literal of property:value pairs.
     */
    setStyles: function(node, hash) {
        var style = node.style;
        Y.each(hash, function(v, n) {
            Y_DOM.setStyle(node, n, v, style);
        }, Y_DOM);
    },

    /**
     * Returns the computed style for the given node.
     * @method getComputedStyle
     * @param {HTMLElement} node The HTMLElement to get the style from.
     * @param {String} att The style property to get.
     * @return {String} The computed value of the style property.
     */
    getComputedStyle: function(node, att) {
        var val = '',
            doc = node[OWNER_DOCUMENT],
            computed;

        if (node[STYLE] && doc[DEFAULT_VIEW] && doc[DEFAULT_VIEW][GET_COMPUTED_STYLE]) {
            computed = doc[DEFAULT_VIEW][GET_COMPUTED_STYLE](node, null);
            if (computed) { // FF may be null in some cases (ticket #2530548)
                val = computed[att];
            }
        }
        return val;
    }
});

// normalize reserved word float alternatives ("cssFloat" or "styleFloat")
if (DOCUMENT[DOCUMENT_ELEMENT][STYLE][CSS_FLOAT] !== undefined) {
    Y_DOM.CUSTOM_STYLES[FLOAT] = CSS_FLOAT;
} else if (DOCUMENT[DOCUMENT_ELEMENT][STYLE][STYLE_FLOAT] !== undefined) {
    Y_DOM.CUSTOM_STYLES[FLOAT] = STYLE_FLOAT;
}

// safari converts transparent to rgba(), others use "transparent"
if (Y.UA.webkit) {
    Y_DOM[GET_COMPUTED_STYLE] = function(node, att) {
        var view = node[OWNER_DOCUMENT][DEFAULT_VIEW],
            val = view[GET_COMPUTED_STYLE](node, '')[att];

        if (val === 'rgba(0, 0, 0, 0)') {
            val = TRANSPARENT;
        }

        return val;
    };

}

Y.DOM._getAttrOffset = function(node, attr) {
    var val = Y.DOM[GET_COMPUTED_STYLE](node, attr),
        offsetParent = node.offsetParent,
        position,
        parentOffset,
        offset;

    if (val === 'auto') {
        position = Y.DOM.getStyle(node, 'position');
        if (position === 'static' || position === 'relative') {
            val = 0;
        } else if (offsetParent && offsetParent[GET_BOUNDING_CLIENT_RECT]) {
            parentOffset = offsetParent[GET_BOUNDING_CLIENT_RECT]()[attr];
            offset = node[GET_BOUNDING_CLIENT_RECT]()[attr];
            if (attr === 'left' || attr === 'top') {
                val = offset - parentOffset;
            } else {
                val = parentOffset - node[GET_BOUNDING_CLIENT_RECT]()[attr];
            }
        }
    }

    return val;
};

Y.DOM._getOffset = function(node) {
    var pos,
        xy = null;

    if (node) {
        pos = Y_DOM.getStyle(node, 'position');
        xy = [
            parseInt(Y_DOM[GET_COMPUTED_STYLE](node, 'left'), 10),
            parseInt(Y_DOM[GET_COMPUTED_STYLE](node, 'top'), 10)
        ];

        if ( isNaN(xy[0]) ) { // in case of 'auto'
            xy[0] = parseInt(Y_DOM.getStyle(node, 'left'), 10); // try inline
            if ( isNaN(xy[0]) ) { // default to offset value
                xy[0] = (pos === 'relative') ? 0 : node.offsetLeft || 0;
            }
        }

        if ( isNaN(xy[1]) ) { // in case of 'auto'
            xy[1] = parseInt(Y_DOM.getStyle(node, 'top'), 10); // try inline
            if ( isNaN(xy[1]) ) { // default to offset value
                xy[1] = (pos === 'relative') ? 0 : node.offsetTop || 0;
            }
        }
    }

    return xy;

};

if (TRANSFORM) {
    Y_DOM.CUSTOM_STYLES.transform = {
        set: function(node, val, style) {
            style[TRANSFORM] = val;
        },

        get: function(node) {
            return Y_DOM[GET_COMPUTED_STYLE](node, TRANSFORM);
        }
    };

    Y_DOM.CUSTOM_STYLES.transformOrigin = {
        set: function(node, val, style) {
            style[TRANSFORMORIGIN] = val;
        },

        get: function(node) {
            return Y_DOM[GET_COMPUTED_STYLE](node, TRANSFORMORIGIN);
        }
    };
}


}, '3.17.2', {"requires": ["dom-base"]});


/***/ }),

/***/ 514054:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('escape', function (Y, NAME) {

/**
Provides utility methods for escaping strings.

@module escape
@class Escape
@static
@since 3.3.0
**/

var HTML_CHARS = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '/': '&#x2F;',
        '`': '&#x60;'
    },

Escape = {
    // -- Public Static Methods ------------------------------------------------

    /**
    Returns a copy of the specified string with special HTML characters
    escaped. The following characters will be converted to their
    corresponding character entities:

        & < > " ' / `

    This implementation is based on the [OWASP HTML escaping
    recommendations][1]. In addition to the characters in the OWASP
    recommendations, we also escape the <code>&#x60;</code> character, since IE
    interprets it as an attribute delimiter.

    If _string_ is not already a string, it will be coerced to a string.

    [1]: http://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet

    @method html
    @param {String} string String to escape.
    @return {String} Escaped string.
    @static
    **/
    html: function (string) {
        return (string + '').replace(/[&<>"'\/`]/g, Escape._htmlReplacer);
    },

    /**
    Returns a copy of the specified string with special regular expression
    characters escaped, allowing the string to be used safely inside a regex.
    The following characters, and all whitespace characters, are escaped:

        - $ ^ * ( ) + [ ] { } | \ , . ?

    If _string_ is not already a string, it will be coerced to a string.

    @method regex
    @param {String} string String to escape.
    @return {String} Escaped string.
    @static
    **/
    regex: function (string) {
        // There's no need to escape !, =, and : since they only have meaning
        // when they follow a parenthesized ?, as in (?:...), and we already
        // escape parens and question marks.
        return (string + '').replace(/[\-$\^*()+\[\]{}|\\,.?\s]/g, '\\$&');
    },

    // -- Protected Static Methods ---------------------------------------------

    /**
     * Regex replacer for HTML escaping.
     *
     * @method _htmlReplacer
     * @param {String} match Matched character (must exist in HTML_CHARS).
     * @return {String} HTML entity.
     * @static
     * @protected
     */
    _htmlReplacer: function (match) {
        return HTML_CHARS[match];
    }
};

Escape.regexp = Escape.regex;

Y.Escape = Escape;


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 245518:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

(function() {

var stateChangeListener,
    GLOBAL_ENV   = YUI.Env,
    config       = YUI.config,
    doc          = config.doc,
    docElement   = doc && doc.documentElement,
    EVENT_NAME   = 'onreadystatechange',
    pollInterval = config.pollInterval || 40;

if (docElement.doScroll && !GLOBAL_ENV._ieready) {
    GLOBAL_ENV._ieready = function() {
        GLOBAL_ENV._ready();
    };

/*! DOMReady: based on work by: Dean Edwards/John Resig/Matthias Miller/Diego Perini */
// Internet Explorer: use the doScroll() method on the root element.
// This isolates what appears to be a safe moment to manipulate the
// DOM prior to when the document's readyState suggests it is safe to do so.
    if (self !== self.top) {
        stateChangeListener = function() {
            if (doc.readyState == 'complete') {
                GLOBAL_ENV.remove(doc, EVENT_NAME, stateChangeListener);
                GLOBAL_ENV.ieready();
            }
        };
        GLOBAL_ENV.add(doc, EVENT_NAME, stateChangeListener);
    } else {
        GLOBAL_ENV._dri = setInterval(function() {
            try {
                docElement.doScroll('left');
                clearInterval(GLOBAL_ENV._dri);
                GLOBAL_ENV._dri = null;
                GLOBAL_ENV._ieready();
            } catch (domNotReady) { }
        }, pollInterval);
    }
}

})();
YUI.add('event-base-ie', function (Y, NAME) {

/*
 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
 * events.
 * @module event
 * @submodule event-base
 */

function IEEventFacade() {
    // IEEventFacade.superclass.constructor.apply(this, arguments);
    Y.DOM2EventFacade.apply(this, arguments);
}

/*
 * (intentially left out of API docs)
 * Alternate Facade implementation that is based on Object.defineProperty, which
 * is partially supported in IE8.  Properties that involve setup work are
 * deferred to temporary getters using the static _define method.
 */
function IELazyFacade(e) {
    var proxy = Y.config.doc.createEventObject(e),
        proto = IELazyFacade.prototype;

    // TODO: necessary?
    proxy.hasOwnProperty = function () { return true; };

    proxy.init = proto.init;
    proxy.halt = proto.halt;
    proxy.preventDefault           = proto.preventDefault;
    proxy.stopPropagation          = proto.stopPropagation;
    proxy.stopImmediatePropagation = proto.stopImmediatePropagation;

    Y.DOM2EventFacade.apply(proxy, arguments);

    return proxy;
}


var imp = Y.config.doc && Y.config.doc.implementation,
    useLazyFacade = Y.config.lazyEventFacade,

    buttonMap = {
        0: 1, // left click
        4: 2, // middle click
        2: 3  // right click
    },
    relatedTargetMap = {
        mouseout: 'toElement',
        mouseover: 'fromElement'
    },

    resolve = Y.DOM2EventFacade.resolve,

    proto = {
        init: function() {

            IEEventFacade.superclass.init.apply(this, arguments);

            var e = this._event,
                x, y, d, b, de, t;

            this.target = resolve(e.srcElement);

            if (('clientX' in e) && (!x) && (0 !== x)) {
                x = e.clientX;
                y = e.clientY;

                d = Y.config.doc;
                b = d.body;
                de = d.documentElement;

                x += (de.scrollLeft || (b && b.scrollLeft) || 0);
                y += (de.scrollTop  || (b && b.scrollTop)  || 0);

                this.pageX = x;
                this.pageY = y;
            }

            if (e.type == "mouseout") {
                t = e.toElement;
            } else if (e.type == "mouseover") {
                t = e.fromElement;
            }

            // fallback to t.relatedTarget to support simulated events.
            // IE doesn't support setting toElement or fromElement on generic
            // events, so Y.Event.simulate sets relatedTarget instead.
            this.relatedTarget = resolve(t || e.relatedTarget);

            // which should contain the unicode key code if this is a key event.
            // For click events, which is normalized for which mouse button was
            // clicked.
            this.which = // chained assignment
            this.button = e.keyCode || buttonMap[e.button] || e.button;
        },

        stopPropagation: function() {
            this._event.cancelBubble = true;
            this._wrapper.stopped = 1;
            this.stopped = 1;
        },

        stopImmediatePropagation: function() {
            this.stopPropagation();
            this._wrapper.stopped = 2;
            this.stopped = 2;
        },

        preventDefault: function(returnValue) {
            this._event.returnValue = returnValue || false;
            this._wrapper.prevented = 1;
            this.prevented = 1;
        }
    };

Y.extend(IEEventFacade, Y.DOM2EventFacade, proto);

Y.extend(IELazyFacade, Y.DOM2EventFacade, proto);
IELazyFacade.prototype.init = function () {
    var e         = this._event,
        overrides = this._wrapper.overrides,
        define    = IELazyFacade._define,
        lazyProperties = IELazyFacade._lazyProperties,
        prop;

    this.altKey   = e.altKey;
    this.ctrlKey  = e.ctrlKey;
    this.metaKey  = e.metaKey;
    this.shiftKey = e.shiftKey;
    this.type     = (overrides && overrides.type) || e.type;
    this.clientX  = e.clientX;
    this.clientY  = e.clientY;
    this.keyCode  = // chained assignment
    this.charCode = e.keyCode;
    this.which    = // chained assignment
    this.button   = e.keyCode || buttonMap[e.button] || e.button;

    for (prop in lazyProperties) {
        if (lazyProperties.hasOwnProperty(prop)) {
            define(this, prop, lazyProperties[prop]);
        }
    }

    if (this._touch) {
        this._touch(e, this._currentTarget, this._wrapper);
    }
};

IELazyFacade._lazyProperties = {
    target: function () {
        return resolve(this._event.srcElement);
    },
    relatedTarget: function () {
        var e = this._event,
            targetProp = relatedTargetMap[e.type] || 'relatedTarget';

        // fallback to t.relatedTarget to support simulated events.
        // IE doesn't support setting toElement or fromElement on generic
        // events, so Y.Event.simulate sets relatedTarget instead.
        return resolve(e[targetProp] || e.relatedTarget);
    },
    currentTarget: function () {
        return resolve(this._currentTarget);
    },

    wheelDelta: function () {
        var e = this._event;

        if (e.type === "mousewheel" || e.type === "DOMMouseScroll") {
            return (e.detail) ?
                (e.detail * -1) :
                // wheelDelta between -80 and 80 result in -1 or 1
                Math.round(e.wheelDelta / 80) || ((e.wheelDelta < 0) ? -1 : 1);
        }
    },

    pageX: function () {
        var e = this._event,
            val = e.pageX,
            doc, bodyScroll, docScroll;

        if (val === undefined) {
            doc = Y.config.doc;
            bodyScroll = doc.body && doc.body.scrollLeft;
            docScroll = doc.documentElement.scrollLeft;

            val = e.clientX + (docScroll || bodyScroll || 0);
        }

        return val;
    },
    pageY: function () {
        var e = this._event,
            val = e.pageY,
            doc, bodyScroll, docScroll;

        if (val === undefined) {
            doc = Y.config.doc;
            bodyScroll = doc.body && doc.body.scrollTop;
            docScroll = doc.documentElement.scrollTop;

            val = e.clientY + (docScroll || bodyScroll || 0);
        }

        return val;
    }
};


/**
 * Wrapper function for Object.defineProperty that creates a property whose
 * value will be calulated only when asked for.  After calculating the value,
 * the getter wll be removed, so it will behave as a normal property beyond that
 * point.  A setter is also assigned so assigning to the property will clear
 * the getter, so foo.prop = 'a'; foo.prop; won't trigger the getter,
 * overwriting value 'a'.
 *
 * Used only by the DOMEventFacades used by IE8 when the YUI configuration
 * <code>lazyEventFacade</code> is set to true.
 *
 * @method _define
 * @param o {DOMObject} A DOM object to add the property to
 * @param prop {String} The name of the new property
 * @param valueFn {Function} The function that will return the initial, default
 *                  value for the property.
 * @static
 * @private
 */
IELazyFacade._define = function (o, prop, valueFn) {
    function val(v) {
        var ret = (arguments.length) ? v : valueFn.call(this);

        delete o[prop];
        Object.defineProperty(o, prop, {
            value: ret,
            configurable: true,
            writable: true
        });
        return ret;
    }
    Object.defineProperty(o, prop, {
        get: val,
        set: val,
        configurable: true
    });
};

if (imp && (!imp.hasFeature('Events', '2.0'))) {
    if (useLazyFacade) {
        // Make sure we can use the lazy facade logic
        try {
            Object.defineProperty(Y.config.doc.createEventObject(), 'z', {});
        } catch (e) {
            useLazyFacade = false;
        }
    }

    Y.DOMEventFacade = (useLazyFacade) ? IELazyFacade : IEEventFacade;
}


}, '3.17.2', {"requires": ["node-base"]});


/***/ }),

/***/ 68367:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-base', function (Y, NAME) {

/*
 * DOM event listener abstraction layer
 * @module event
 * @submodule event-base
 */

/**
 * The domready event fires at the moment the browser's DOM is
 * usable. In most cases, this is before images are fully
 * downloaded, allowing you to provide a more responsive user
 * interface.
 *
 * In YUI 3, domready subscribers will be notified immediately if
 * that moment has already passed when the subscription is created.
 *
 * One exception is if the yui.js file is dynamically injected into
 * the page.  If this is done, you must tell the YUI instance that
 * you did this in order for DOMReady (and window load events) to
 * fire normally.  That configuration option is 'injected' -- set
 * it to true if the yui.js script is not included inline.
 *
 * This method is part of the 'event-ready' module, which is a
 * submodule of 'event'.
 *
 * @event domready
 * @for YUI
 */
Y.publish('domready', {
    fireOnce: true,
    async: true
});

if (YUI.Env.DOMReady) {
    Y.fire('domready');
} else {
    Y.Do.before(function() { Y.fire('domready'); }, YUI.Env, '_ready');
}

/**
 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
 * events.
 * @module event
 * @submodule event-base
 */

/**
 * Wraps a DOM event, properties requiring browser abstraction are
 * fixed here.  Provids a security layer when required.
 * @class DOMEventFacade
 * @param ev {Event} the DOM event
 * @param currentTarget {HTMLElement} the element the listener was attached to
 * @param wrapper {CustomEvent} the custom event wrapper for this DOM event
 */

    var ua = Y.UA,

    EMPTY = {},

    /**
     * webkit key remapping required for Safari < 3.1
     * @property webkitKeymap
     * @private
     */
    webkitKeymap = {
        63232: 38, // up
        63233: 40, // down
        63234: 37, // left
        63235: 39, // right
        63276: 33, // page up
        63277: 34, // page down
        25:     9, // SHIFT-TAB (Safari provides a different key code in
                   // this case, even though the shiftKey modifier is set)
        63272: 46, // delete
        63273: 36, // home
        63275: 35  // end
    },

    /**
     * Returns a wrapped node.  Intended to be used on event targets,
     * so it will return the node's parent if the target is a text
     * node.
     *
     * If accessing a property of the node throws an error, this is
     * probably the anonymous div wrapper Gecko adds inside text
     * nodes.  This likely will only occur when attempting to access
     * the relatedTarget.  In this case, we now return null because
     * the anonymous div is completely useless and we do not know
     * what the related target was because we can't even get to
     * the element's parent node.
     *
     * @method resolve
     * @private
     */
    resolve = function(n) {
        if (!n) {
            return n;
        }
        try {
            if (n && 3 == n.nodeType) {
                n = n.parentNode;
            }
        } catch(e) {
            return null;
        }

        return Y.one(n);
    },

    DOMEventFacade = function(ev, currentTarget, wrapper) {
        this._event = ev;
        this._currentTarget = currentTarget;
        this._wrapper = wrapper || EMPTY;

        // if not lazy init
        this.init();
    };

Y.extend(DOMEventFacade, Object, {

    init: function() {

        var e = this._event,
            overrides = this._wrapper.overrides,
            x = e.pageX,
            y = e.pageY,
            c,
            currentTarget = this._currentTarget;

        this.altKey   = e.altKey;
        this.ctrlKey  = e.ctrlKey;
        this.metaKey  = e.metaKey;
        this.shiftKey = e.shiftKey;
        this.type     = (overrides && overrides.type) || e.type;
        this.clientX  = e.clientX;
        this.clientY  = e.clientY;

        this.pageX = x;
        this.pageY = y;

        // charCode is unknown in keyup, keydown. keyCode is unknown in keypress.
        // FF 3.6 - 8+? pass 0 for keyCode in keypress events.
        // Webkit, FF 3.6-8+?, and IE9+? pass 0 for charCode in keydown, keyup.
        // Webkit and IE9+? duplicate charCode in keyCode.
        // Opera never sets charCode, always keyCode (though with the charCode).
        // IE6-8 don't set charCode or which.
        // All browsers other than IE6-8 set which=keyCode in keydown, keyup, and
        // which=charCode in keypress.
        //
        // Moral of the story: (e.which || e.keyCode) will always return the
        // known code for that key event phase. e.keyCode is often different in
        // keypress from keydown and keyup.
        c = e.keyCode || e.charCode;

        if (ua.webkit && (c in webkitKeymap)) {
            c = webkitKeymap[c];
        }

        this.keyCode = c;
        this.charCode = c;
        // Fill in e.which for IE - implementers should always use this over
        // e.keyCode or e.charCode.
        this.which = e.which || e.charCode || c;
        // this.button = e.button;
        this.button = this.which;

        this.target = resolve(e.target);
        this.currentTarget = resolve(currentTarget);
        this.relatedTarget = resolve(e.relatedTarget);

        if (e.type == "mousewheel" || e.type == "DOMMouseScroll") {
            this.wheelDelta = (e.detail) ? (e.detail * -1) : Math.round(e.wheelDelta / 80) || ((e.wheelDelta < 0) ? -1 : 1);
        }

        if (this._touch) {
            this._touch(e, currentTarget, this._wrapper);
        }
    },

    stopPropagation: function() {
        this._event.stopPropagation();
        this._wrapper.stopped = 1;
        this.stopped = 1;
    },

    stopImmediatePropagation: function() {
        var e = this._event;
        if (e.stopImmediatePropagation) {
            e.stopImmediatePropagation();
        } else {
            this.stopPropagation();
        }
        this._wrapper.stopped = 2;
        this.stopped = 2;
    },

    preventDefault: function(returnValue) {
        var e = this._event;
        e.preventDefault();
        if (returnValue) {
            e.returnValue = returnValue;
        }
        this._wrapper.prevented = 1;
        this.prevented = 1;
    },

    halt: function(immediate) {
        if (immediate) {
            this.stopImmediatePropagation();
        } else {
            this.stopPropagation();
        }

        this.preventDefault();
    }

});

DOMEventFacade.resolve = resolve;
Y.DOM2EventFacade = DOMEventFacade;
Y.DOMEventFacade = DOMEventFacade;

    /**
     * The native event
     * @property _event
     * @type {DOMEvent}
     * @private
     */

    /**
    The name of the event (e.g. "click")

    @property type
    @type {String}
    **/

    /**
    `true` if the "alt" or "option" key is pressed.

    @property altKey
    @type {Boolean}
    **/

    /**
    `true` if the shift key is pressed.

    @property shiftKey
    @type {Boolean}
    **/

    /**
    `true` if the "Windows" key on a Windows keyboard, "command" key on an
    Apple keyboard, or "meta" key on other keyboards is pressed.

    @property metaKey
    @type {Boolean}
    **/

    /**
    `true` if the "Ctrl" or "control" key is pressed.

    @property ctrlKey
    @type {Boolean}
    **/

    /**
     * The X location of the event on the page (including scroll)
     * @property pageX
     * @type {Number}
     */

    /**
     * The Y location of the event on the page (including scroll)
     * @property pageY
     * @type {Number}
     */

    /**
     * The X location of the event in the viewport
     * @property clientX
     * @type {Number}
     */

    /**
     * The Y location of the event in the viewport
     * @property clientY
     * @type {Number}
     */

    /**
     * The keyCode for key events.  Uses charCode if keyCode is not available
     * @property keyCode
     * @type {Number}
     */

    /**
     * The charCode for key events.  Same as keyCode
     * @property charCode
     * @type {Number}
     */

    /**
     * The button that was pushed. 1 for left click, 2 for middle click, 3 for
     * right click.  This is only reliably populated on `mouseup` events.
     * @property button
     * @type {Number}
     */

    /**
     * The button that was pushed.  Same as button.
     * @property which
     * @type {Number}
     */

    /**
     * Node reference for the targeted element
     * @property target
     * @type {Node}
     */

    /**
     * Node reference for the element that the listener was attached to.
     * @property currentTarget
     * @type {Node}
     */

    /**
     * Node reference to the relatedTarget
     * @property relatedTarget
     * @type {Node}
     */

    /**
     * Number representing the direction and velocity of the movement of the mousewheel.
     * Negative is down, the higher the number, the faster.  Applies to the mousewheel event.
     * @property wheelDelta
     * @type {Number}
     */

    /**
     * Stops the propagation to the next bubble target
     * @method stopPropagation
     */

    /**
     * Stops the propagation to the next bubble target and
     * prevents any additional listeners from being exectued
     * on the current target.
     * @method stopImmediatePropagation
     */

    /**
     * Prevents the event's default behavior
     * @method preventDefault
     * @param returnValue {string} sets the returnValue of the event to this value
     * (rather than the default false value).  This can be used to add a customized
     * confirmation query to the beforeunload event).
     */

    /**
     * Stops the event propagation and prevents the default
     * event behavior.
     * @method halt
     * @param immediate {boolean} if true additional listeners
     * on the current target will not be executed
     */
(function() {

/**
 * The event utility provides functions to add and remove event listeners,
 * event cleansing.  It also tries to automatically remove listeners it
 * registers during the unload event.
 * @module event
 * @main event
 * @submodule event-base
 */

/**
 * The event utility provides functions to add and remove event listeners,
 * event cleansing.  It also tries to automatically remove listeners it
 * registers during the unload event.
 *
 * @class Event
 * @static
 */

Y.Env.evt.dom_wrappers = {};
Y.Env.evt.dom_map = {};

var _eventenv = Y.Env.evt,
    config = Y.config,
    win = config.win,
    add = YUI.Env.add,
    remove = YUI.Env.remove,

    onLoad = function() {
        YUI.Env.windowLoaded = true;
        Y.Event._load();
        remove(win, "load", onLoad);
    },

    onUnload = function() {
        Y.Event._unload();
    },

    EVENT_READY = 'domready',

    COMPAT_ARG = '~yui|2|compat~',

    shouldIterate = function(o) {
        try {
            // TODO: See if there's a more performant way to return true early on this, for the common case
            return (o && typeof o !== "string" && Y.Lang.isNumber(o.length) && !o.tagName && !Y.DOM.isWindow(o));
        } catch(ex) {
            return false;
        }
    },

    // aliases to support DOM event subscription clean up when the last
    // subscriber is detached. deleteAndClean overrides the DOM event's wrapper
    // CustomEvent _delete method.
    _ceProtoDelete = Y.CustomEvent.prototype._delete,
    _deleteAndClean = function(s) {
        var ret = _ceProtoDelete.apply(this, arguments);

        if (!this.hasSubs()) {
            Y.Event._clean(this);
        }

        return ret;
    },

Event = function() {

    /**
     * True after the onload event has fired
     * @property _loadComplete
     * @type boolean
     * @static
     * @private
     */
    var _loadComplete =  false,

    /**
     * The number of times to poll after window.onload.  This number is
     * increased if additional late-bound handlers are requested after
     * the page load.
     * @property _retryCount
     * @static
     * @private
     */
    _retryCount = 0,

    /**
     * onAvailable listeners
     * @property _avail
     * @static
     * @private
     */
    _avail = [],

    /**
     * Custom event wrappers for DOM events.  Key is
     * 'event:' + Element uid stamp + event type
     * @property _wrappers
     * @type CustomEvent
     * @static
     * @private
     */
    _wrappers = _eventenv.dom_wrappers,

    _windowLoadKey = null,

    /**
     * Custom event wrapper map DOM events.  Key is
     * Element uid stamp.  Each item is a hash of custom event
     * wrappers as provided in the _wrappers collection.  This
     * provides the infrastructure for getListeners.
     * @property _el_events
     * @static
     * @private
     */
    _el_events = _eventenv.dom_map;

    return {

        /**
         * The number of times we should look for elements that are not
         * in the DOM at the time the event is requested after the document
         * has been loaded.  The default is 1000@amp;40 ms, so it will poll
         * for 40 seconds or until all outstanding handlers are bound
         * (whichever comes first).
         * @property POLL_RETRYS
         * @type int
         * @static
         * @final
         */
        POLL_RETRYS: 1000,

        /**
         * The poll interval in milliseconds
         * @property POLL_INTERVAL
         * @type int
         * @static
         * @final
         */
        POLL_INTERVAL: 40,

        /**
         * addListener/removeListener can throw errors in unexpected scenarios.
         * These errors are suppressed, the method returns false, and this property
         * is set
         * @property lastError
         * @static
         * @type Error
         */
        lastError: null,


        /**
         * poll handle
         * @property _interval
         * @static
         * @private
         */
        _interval: null,

        /**
         * document readystate poll handle
         * @property _dri
         * @static
         * @private
         */
         _dri: null,

        /**
         * True when the document is initially usable
         * @property DOMReady
         * @type boolean
         * @static
         */
        DOMReady: false,

        /**
         * @method startInterval
         * @static
         * @private
         */
        startInterval: function() {
            if (!Event._interval) {
Event._interval = setInterval(Event._poll, Event.POLL_INTERVAL);
            }
        },

        /**
         * Executes the supplied callback when the item with the supplied
         * id is found.  This is meant to be used to execute behavior as
         * soon as possible as the page loads.  If you use this after the
         * initial page load it will poll for a fixed time for the element.
         * The number of times it will poll and the frequency are
         * configurable.  By default it will poll for 10 seconds.
         *
         * <p>The callback is executed with a single parameter:
         * the custom object parameter, if provided.</p>
         *
         * @method onAvailable
         *
         * @param {string||string[]}   id the id of the element, or an array
         * of ids to look for.
         * @param {function} fn what to execute when the element is found.
         * @param {object}   p_obj an optional object to be passed back as
         *                   a parameter to fn.
         * @param {boolean|object}  p_override If set to true, fn will execute
         *                   in the context of p_obj, if set to an object it
         *                   will execute in the context of that object
         * @param checkContent {boolean} check child node readiness (onContentReady)
         * @static
         * @deprecated Use Y.on("available")
         */
        // @TODO fix arguments
        onAvailable: function(id, fn, p_obj, p_override, checkContent, compat) {

            var a = Y.Array(id), i, availHandle;

            for (i=0; i<a.length; i=i+1) {
                _avail.push({
                    id:         a[i],
                    fn:         fn,
                    obj:        p_obj,
                    override:   p_override,
                    checkReady: checkContent,
                    compat:     compat
                });
            }
            _retryCount = this.POLL_RETRYS;

            // We want the first test to be immediate, but async
            Y.config.win.setTimeout(Event._poll, 0);

            availHandle = new Y.EventHandle({

                _delete: function() {
                    // set by the event system for lazy DOM listeners
                    if (availHandle.handle) {
                        availHandle.handle.detach();
                        return;
                    }

                    var i, j;

                    // otherwise try to remove the onAvailable listener(s)
                    for (i = 0; i < a.length; i++) {
                        for (j = 0; j < _avail.length; j++) {
                            if (a[i] === _avail[j].id) {
                                _avail.splice(j, 1);
                            }
                        }
                    }
                }

            });

            return availHandle;
        },

        /**
         * Works the same way as onAvailable, but additionally checks the
         * state of sibling elements to determine if the content of the
         * available element is safe to modify.
         *
         * <p>The callback is executed with a single parameter:
         * the custom object parameter, if provided.</p>
         *
         * @method onContentReady
         *
         * @param {string}   id the id of the element to look for.
         * @param {function} fn what to execute when the element is ready.
         * @param {object}   obj an optional object to be passed back as
         *                   a parameter to fn.
         * @param {boolean|object}  override If set to true, fn will execute
         *                   in the context of p_obj.  If an object, fn will
         *                   exectute in the context of that object
         *
         * @static
         * @deprecated Use Y.on("contentready")
         */
        // @TODO fix arguments
        onContentReady: function(id, fn, obj, override, compat) {
            return Event.onAvailable(id, fn, obj, override, true, compat);
        },

        /**
         * Adds an event listener
         *
         * @method attach
         *
         * @param {String}   type     The type of event to append
         * @param {Function} fn        The method the event invokes
         * @param {String|HTMLElement|Array|NodeList} el An id, an element
         *  reference, or a collection of ids and/or elements to assign the
         *  listener to.
         * @param {Object}   context optional context object
         * @param {Boolean|object}  args 0..n arguments to pass to the callback
         * @return {EventHandle} an object to that can be used to detach the listener
         *
         * @static
         */

        attach: function(type, fn, el, context) {
            return Event._attach(Y.Array(arguments, 0, true));
        },

        _createWrapper: function (el, type, capture, compat, facade) {

            var cewrapper,
                ek  = Y.stamp(el),
                key = 'event:' + ek + type;

            if (false === facade) {
                key += 'native';
            }
            if (capture) {
                key += 'capture';
            }


            cewrapper = _wrappers[key];


            if (!cewrapper) {
                // create CE wrapper
                cewrapper = Y.publish(key, {
                    silent: true,
                    bubbles: false,
                    emitFacade:false,
                    contextFn: function() {
                        if (compat) {
                            return cewrapper.el;
                        } else {
                            cewrapper.nodeRef = cewrapper.nodeRef || Y.one(cewrapper.el);
                            return cewrapper.nodeRef;
                        }
                    }
                });

                cewrapper.overrides = {};

                // for later removeListener calls
                cewrapper.el = el;
                cewrapper.key = key;
                cewrapper.domkey = ek;
                cewrapper.type = type;
                cewrapper.fn = function(e) {
                    cewrapper.fire(Event.getEvent(e, el, (compat || (false === facade))));
                };
                cewrapper.capture = capture;

                if (el == win && type == "load") {
                    // window load happens once
                    cewrapper.fireOnce = true;
                    _windowLoadKey = key;
                }
                cewrapper._delete = _deleteAndClean;

                _wrappers[key] = cewrapper;
                _el_events[ek] = _el_events[ek] || {};
                _el_events[ek][key] = cewrapper;

                add(el, type, cewrapper.fn, capture);
            }

            return cewrapper;

        },

        _attach: function(args, conf) {

            var compat,
                handles, oEl, cewrapper, context,
                fireNow = false, ret,
                type = args[0],
                fn = args[1],
                el = args[2] || win,
                facade = conf && conf.facade,
                capture = conf && conf.capture,
                overrides = conf && conf.overrides;

            if (args[args.length-1] === COMPAT_ARG) {
                compat = true;
            }

            if (!fn || !fn.call) {
                return false;
            }

            // The el argument can be an array of elements or element ids.
            if (shouldIterate(el)) {

                handles=[];

                Y.each(el, function(v, k) {
                    args[2] = v;
                    handles.push(Event._attach(args.slice(), conf));
                });

                // return (handles.length === 1) ? handles[0] : handles;
                return new Y.EventHandle(handles);

            // If the el argument is a string, we assume it is
            // actually the id of the element.  If the page is loaded
            // we convert el to the actual element, otherwise we
            // defer attaching the event until the element is
            // ready
            } else if (Y.Lang.isString(el)) {

                // oEl = (compat) ? Y.DOM.byId(el) : Y.Selector.query(el);

                if (compat) {
                    oEl = Y.DOM.byId(el);
                } else {

                    oEl = Y.Selector.query(el);

                    switch (oEl.length) {
                        case 0:
                            oEl = null;
                            break;
                        case 1:
                            oEl = oEl[0];
                            break;
                        default:
                            args[2] = oEl;
                            return Event._attach(args, conf);
                    }
                }

                if (oEl) {

                    el = oEl;

                // Not found = defer adding the event until the element is available
                } else {

                    ret = Event.onAvailable(el, function() {

                        ret.handle = Event._attach(args, conf);

                    }, Event, true, false, compat);

                    return ret;

                }
            }

            // Element should be an html element or node
            if (!el) {
                return false;
            }

            if (Y.Node && Y.instanceOf(el, Y.Node)) {
                el = Y.Node.getDOMNode(el);
            }

            cewrapper = Event._createWrapper(el, type, capture, compat, facade);
            if (overrides) {
                Y.mix(cewrapper.overrides, overrides);
            }

            if (el == win && type == "load") {

                // if the load is complete, fire immediately.
                // all subscribers, including the current one
                // will be notified.
                if (YUI.Env.windowLoaded) {
                    fireNow = true;
                }
            }

            if (compat) {
                args.pop();
            }

            context = args[3];

            // set context to the Node if not specified
            // ret = cewrapper.on.apply(cewrapper, trimmedArgs);
            ret = cewrapper._on(fn, context, (args.length > 4) ? args.slice(4) : null);

            if (fireNow) {
                cewrapper.fire();
            }

            return ret;

        },

        /**
         * Removes an event listener.  Supports the signature the event was bound
         * with, but the preferred way to remove listeners is using the handle
         * that is returned when using Y.on
         *
         * @method detach
         *
         * @param {String} type the type of event to remove.
         * @param {Function} fn the method the event invokes.  If fn is
         * undefined, then all event handlers for the type of event are
         * removed.
         * @param {String|HTMLElement|Array|NodeList|EventHandle} el An
         * event handle, an id, an element reference, or a collection
         * of ids and/or elements to remove the listener from.
         * @return {boolean} true if the unbind was successful, false otherwise.
         * @static
         */
        detach: function(type, fn, el, obj) {

            var args=Y.Array(arguments, 0, true), compat, l, ok, i,
                id, ce;

            if (args[args.length-1] === COMPAT_ARG) {
                compat = true;
                // args.pop();
            }

            if (type && type.detach) {
                return type.detach();
            }

            // The el argument can be a string
            if (typeof el == "string") {

                // el = (compat) ? Y.DOM.byId(el) : Y.all(el);
                if (compat) {
                    el = Y.DOM.byId(el);
                } else {
                    el = Y.Selector.query(el);
                    l = el.length;
                    if (l < 1) {
                        el = null;
                    } else if (l == 1) {
                        el = el[0];
                    }
                }
                // return Event.detach.apply(Event, args);
            }

            if (!el) {
                return false;
            }

            if (el.detach) {
                args.splice(2, 1);
                return el.detach.apply(el, args);
            // The el argument can be an array of elements or element ids.
            } else if (shouldIterate(el)) {
                ok = true;
                for (i=0, l=el.length; i<l; ++i) {
                    args[2] = el[i];
                    ok = ( Y.Event.detach.apply(Y.Event, args) && ok );
                }

                return ok;
            }

            if (!type || !fn || !fn.call) {
                return Event.purgeElement(el, false, type);
            }

            id = 'event:' + Y.stamp(el) + type;
            ce = _wrappers[id];

            if (ce) {
                return ce.detach(fn);
            } else {
                return false;
            }

        },

        /**
         * Finds the event in the window object, the caller's arguments, or
         * in the arguments of another method in the callstack.  This is
         * executed automatically for events registered through the event
         * manager, so the implementer should not normally need to execute
         * this function at all.
         * @method getEvent
         * @param {Event} e the event parameter from the handler
         * @param {HTMLElement} el the element the listener was attached to
         * @return {Event} the event
         * @static
         */
        getEvent: function(e, el, noFacade) {
            var ev = e || win.event;

            return (noFacade) ? ev :
                new Y.DOMEventFacade(ev, el, _wrappers['event:' + Y.stamp(el) + e.type]);
        },

        /**
         * Generates an unique ID for the element if it does not already
         * have one.
         * @method generateId
         * @param el the element to create the id for
         * @return {string} the resulting id of the element
         * @static
         */
        generateId: function(el) {
            return Y.DOM.generateID(el);
        },

        /**
         * We want to be able to use getElementsByTagName as a collection
         * to attach a group of events to.  Unfortunately, different
         * browsers return different types of collections.  This function
         * tests to determine if the object is array-like.  It will also
         * fail if the object is an array, but is empty.
         * @method _isValidCollection
         * @param o the object to test
         * @return {boolean} true if the object is array-like and populated
         * @deprecated was not meant to be used directly
         * @static
         * @private
         */
        _isValidCollection: shouldIterate,

        /**
         * hook up any deferred listeners
         * @method _load
         * @static
         * @private
         */
        _load: function(e) {
            if (!_loadComplete) {
                _loadComplete = true;

                // Just in case DOMReady did not go off for some reason
                // E._ready();
                if (Y.fire) {
                    Y.fire(EVENT_READY);
                }

                // Available elements may not have been detected before the
                // window load event fires. Try to find them now so that the
                // the user is more likely to get the onAvailable notifications
                // before the window load notification
                Event._poll();
            }
        },

        /**
         * Polling function that runs before the onload event fires,
         * attempting to attach to DOM Nodes as soon as they are
         * available
         * @method _poll
         * @static
         * @private
         */
        _poll: function() {
            if (Event.locked) {
                return;
            }

            if (Y.UA.ie && !YUI.Env.DOMReady) {
                // Hold off if DOMReady has not fired and check current
                // readyState to protect against the IE operation aborted
                // issue.
                Event.startInterval();
                return;
            }

            Event.locked = true;

            // keep trying until after the page is loaded.  We need to
            // check the page load state prior to trying to bind the
            // elements so that we can be certain all elements have been
            // tested appropriately
            var i, len, item, el, notAvail, executeItem,
                tryAgain = !_loadComplete;

            if (!tryAgain) {
                tryAgain = (_retryCount > 0);
            }

            // onAvailable
            notAvail = [];

            executeItem = function (el, item) {
                var context, ov = item.override;
                try {
                    if (item.compat) {
                        if (item.override) {
                            if (ov === true) {
                                context = item.obj;
                            } else {
                                context = ov;
                            }
                        } else {
                            context = el;
                        }
                        item.fn.call(context, item.obj);
                    } else {
                        context = item.obj || Y.one(el);
                        item.fn.apply(context, (Y.Lang.isArray(ov)) ? ov : []);
                    }
                } catch (e) {
                }
            };

            // onAvailable
            for (i=0,len=_avail.length; i<len; ++i) {
                item = _avail[i];
                if (item && !item.checkReady) {

                    // el = (item.compat) ? Y.DOM.byId(item.id) : Y.one(item.id);
                    el = (item.compat) ? Y.DOM.byId(item.id) : Y.Selector.query(item.id, null, true);

                    if (el) {
                        executeItem(el, item);
                        _avail[i] = null;
                    } else {
                        notAvail.push(item);
                    }
                }
            }

            // onContentReady
            for (i=0,len=_avail.length; i<len; ++i) {
                item = _avail[i];
                if (item && item.checkReady) {

                    // el = (item.compat) ? Y.DOM.byId(item.id) : Y.one(item.id);
                    el = (item.compat) ? Y.DOM.byId(item.id) : Y.Selector.query(item.id, null, true);

                    if (el) {
                        // The element is available, but not necessarily ready
                        // @todo should we test parentNode.nextSibling?
                        if (_loadComplete || (el.get && el.get('nextSibling')) || el.nextSibling) {
                            executeItem(el, item);
                            _avail[i] = null;
                        }
                    } else {
                        notAvail.push(item);
                    }
                }
            }

            _retryCount = (notAvail.length === 0) ? 0 : _retryCount - 1;

            if (tryAgain) {
                // we may need to strip the nulled out items here
                Event.startInterval();
            } else {
                clearInterval(Event._interval);
                Event._interval = null;
            }

            Event.locked = false;

            return;

        },

        /**
         * Removes all listeners attached to the given element via addListener.
         * Optionally, the node's children can also be purged.
         * Optionally, you can specify a specific type of event to remove.
         * @method purgeElement
         * @param {HTMLElement} el the element to purge
         * @param {boolean} recurse recursively purge this element's children
         * as well.  Use with caution.
         * @param {string} type optional type of listener to purge. If
         * left out, all listeners will be removed
         * @static
         */
        purgeElement: function(el, recurse, type) {
            // var oEl = (Y.Lang.isString(el)) ? Y.one(el) : el,
            var oEl = (Y.Lang.isString(el)) ?  Y.Selector.query(el, null, true) : el,
                lis = Event.getListeners(oEl, type), i, len, children, child;

            if (recurse && oEl) {
                lis = lis || [];
                children = Y.Selector.query('*', oEl);
                len = children.length;
                for (i = 0; i < len; ++i) {
                    child = Event.getListeners(children[i], type);
                    if (child) {
                        lis = lis.concat(child);
                    }
                }
            }

            if (lis) {
                for (i = 0, len = lis.length; i < len; ++i) {
                    lis[i].detachAll();
                }
            }

        },

        /**
         * Removes all object references and the DOM proxy subscription for
         * a given event for a DOM node.
         *
         * @method _clean
         * @param wrapper {CustomEvent} Custom event proxy for the DOM
         *                  subscription
         * @private
         * @static
         * @since 3.4.0
         */
        _clean: function (wrapper) {
            var key    = wrapper.key,
                domkey = wrapper.domkey;

            remove(wrapper.el, wrapper.type, wrapper.fn, wrapper.capture);
            delete _wrappers[key];
            delete Y._yuievt.events[key];
            if (_el_events[domkey]) {
                delete _el_events[domkey][key];
                if (!Y.Object.size(_el_events[domkey])) {
                    delete _el_events[domkey];
                }
            }
        },

        /**
         * Returns all listeners attached to the given element via addListener.
         * Optionally, you can specify a specific type of event to return.
         * @method getListeners
         * @param el {HTMLElement|string} the element or element id to inspect
         * @param type {string} optional type of listener to return. If
         * left out, all listeners will be returned
         * @return {CustomEvent} the custom event wrapper for the DOM event(s)
         * @static
         */
        getListeners: function(el, type) {
            var ek = Y.stamp(el, true), evts = _el_events[ek],
                results=[] , key = (type) ? 'event:' + ek + type : null,
                adapters = _eventenv.plugins;

            if (!evts) {
                return null;
            }

            if (key) {
                // look for synthetic events
                if (adapters[type] && adapters[type].eventDef) {
                    key += '_synth';
                }

                if (evts[key]) {
                    results.push(evts[key]);
                }

                // get native events as well
                key += 'native';
                if (evts[key]) {
                    results.push(evts[key]);
                }

            } else {
                Y.each(evts, function(v, k) {
                    results.push(v);
                });
            }

            return (results.length) ? results : null;
        },

        /**
         * Removes all listeners registered by pe.event.  Called
         * automatically during the unload event.
         * @method _unload
         * @static
         * @private
         */
        _unload: function(e) {
            Y.each(_wrappers, function(v, k) {
                if (v.type == 'unload') {
                    v.fire(e);
                }
                v.detachAll();
            });
            remove(win, "unload", onUnload);
        },

        /**
         * Adds a DOM event directly without the caching, cleanup, context adj, etc
         *
         * @method nativeAdd
         * @param {HTMLElement} el      the element to bind the handler to
         * @param {string}      type   the type of event handler
         * @param {function}    fn      the callback to invoke
         * @param {Boolean}      capture capture or bubble phase
         * @static
         * @private
         */
        nativeAdd: add,

        /**
         * Basic remove listener
         *
         * @method nativeRemove
         * @param {HTMLElement} el      the element to bind the handler to
         * @param {string}      type   the type of event handler
         * @param {function}    fn      the callback to invoke
         * @param {Boolean}      capture capture or bubble phase
         * @static
         * @private
         */
        nativeRemove: remove
    };

}();

Y.Event = Event;

if (config.injected || YUI.Env.windowLoaded) {
    onLoad();
} else {
    add(win, "load", onLoad);
}

// Process onAvailable/onContentReady items when when the DOM is ready in IE
if (Y.UA.ie) {
    Y.on(EVENT_READY, Event._poll);

    // In IE6 and below, detach event handlers when the page is unloaded in
    // order to try and prevent cross-page memory leaks. This isn't done in
    // other browsers because a) it's not necessary, and b) it breaks the
    // back/forward cache.
    if (Y.UA.ie < 7) {
        try {
            add(win, "unload", onUnload);
        } catch(e) {
        }
    }
}

Event.Custom = Y.CustomEvent;
Event.Subscriber = Y.Subscriber;
Event.Target = Y.EventTarget;
Event.Handle = Y.EventHandle;
Event.Facade = Y.EventFacade;

Event._poll();

}());

/**
 * DOM event listener abstraction layer
 * @module event
 * @submodule event-base
 */

/**
 * Executes the callback as soon as the specified element
 * is detected in the DOM.  This function expects a selector
 * string for the element(s) to detect.  If you already have
 * an element reference, you don't need this event.
 * @event available
 * @param type {string} 'available'
 * @param fn {function} the callback function to execute.
 * @param el {string} an selector for the element(s) to attach
 * @param context optional argument that specifies what 'this' refers to.
 * @param args* 0..n additional arguments to pass on to the callback function.
 * These arguments will be added after the event object.
 * @return {EventHandle} the detach handle
 * @for YUI
 */
Y.Env.evt.plugins.available = {
    on: function(type, fn, id, o) {
        var a = arguments.length > 4 ?  Y.Array(arguments, 4, true) : null;
        return Y.Event.onAvailable.call(Y.Event, id, fn, o, a);
    }
};

/**
 * Executes the callback as soon as the specified element
 * is detected in the DOM with a nextSibling property
 * (indicating that the element's children are available).
 * This function expects a selector
 * string for the element(s) to detect.  If you already have
 * an element reference, you don't need this event.
 * @event contentready
 * @param type {string} 'contentready'
 * @param fn {function} the callback function to execute.
 * @param el {string} an selector for the element(s) to attach.
 * @param context optional argument that specifies what 'this' refers to.
 * @param args* 0..n additional arguments to pass on to the callback function.
 * These arguments will be added after the event object.
 * @return {EventHandle} the detach handle
 * @for YUI
 */
Y.Env.evt.plugins.contentready = {
    on: function(type, fn, id, o) {
        var a = arguments.length > 4 ? Y.Array(arguments, 4, true) : null;
        return Y.Event.onContentReady.call(Y.Event, id, fn, o, a);
    }
};


}, '3.17.2', {"requires": ["event-custom-base"]});


/***/ }),

/***/ 51852:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-custom-base', function (Y, NAME) {

/**
 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
 * events.
 * @module event-custom
 */

Y.Env.evt = {
    handles: {},
    plugins: {}
};

/**
 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
 * events.
 * @module event-custom
 * @submodule event-custom-base
 */

/**
 * Allows for the insertion of methods that are executed before or after
 * a specified method
 * @class Do
 * @static
 */

var DO_BEFORE = 0,
    DO_AFTER = 1,

DO = {

    /**
     * Cache of objects touched by the utility
     * @property objs
     * @static
     * @deprecated Since 3.6.0. The `_yuiaop` property on the AOP'd object
     * replaces the role of this property, but is considered to be private, and
     * is only mentioned to provide a migration path.
     *
     * If you have a use case which warrants migration to the _yuiaop property,
     * please file a ticket to let us know what it's used for and we can see if
     * we need to expose hooks for that functionality more formally.
     */
    objs: null,

    /**
     * <p>Execute the supplied method before the specified function.  Wrapping
     * function may optionally return an instance of the following classes to
     * further alter runtime behavior:</p>
     * <dl>
     *     <dt></code>Y.Do.Halt(message, returnValue)</code></dt>
     *         <dd>Immediatly stop execution and return
     *         <code>returnValue</code>.  No other wrapping functions will be
     *         executed.</dd>
     *     <dt></code>Y.Do.AlterArgs(message, newArgArray)</code></dt>
     *         <dd>Replace the arguments that the original function will be
     *         called with.</dd>
     *     <dt></code>Y.Do.Prevent(message)</code></dt>
     *         <dd>Don't execute the wrapped function.  Other before phase
     *         wrappers will be executed.</dd>
     * </dl>
     *
     * @method before
     * @param fn {Function} the function to execute
     * @param obj the object hosting the method to displace
     * @param sFn {string} the name of the method to displace
     * @param c The execution context for fn
     * @param arg* {mixed} 0..n additional arguments to supply to the subscriber
     * when the event fires.
     * @return {EventHandle} handle for the subscription
     * @static
     */
    before: function(fn, obj, sFn, c) {
        var f = fn, a;
        if (c) {
            a = [fn, c].concat(Y.Array(arguments, 4, true));
            f = Y.rbind.apply(Y, a);
        }

        return this._inject(DO_BEFORE, f, obj, sFn);
    },

    /**
     * <p>Execute the supplied method after the specified function.  Wrapping
     * function may optionally return an instance of the following classes to
     * further alter runtime behavior:</p>
     * <dl>
     *     <dt></code>Y.Do.Halt(message, returnValue)</code></dt>
     *         <dd>Immediatly stop execution and return
     *         <code>returnValue</code>.  No other wrapping functions will be
     *         executed.</dd>
     *     <dt></code>Y.Do.AlterReturn(message, returnValue)</code></dt>
     *         <dd>Return <code>returnValue</code> instead of the wrapped
     *         method's original return value.  This can be further altered by
     *         other after phase wrappers.</dd>
     * </dl>
     *
     * <p>The static properties <code>Y.Do.originalRetVal</code> and
     * <code>Y.Do.currentRetVal</code> will be populated for reference.</p>
     *
     * @method after
     * @param fn {Function} the function to execute
     * @param obj the object hosting the method to displace
     * @param sFn {string} the name of the method to displace
     * @param c The execution context for fn
     * @param arg* {mixed} 0..n additional arguments to supply to the subscriber
     * @return {EventHandle} handle for the subscription
     * @static
     */
    after: function(fn, obj, sFn, c) {
        var f = fn, a;
        if (c) {
            a = [fn, c].concat(Y.Array(arguments, 4, true));
            f = Y.rbind.apply(Y, a);
        }

        return this._inject(DO_AFTER, f, obj, sFn);
    },

    /**
     * Execute the supplied method before or after the specified function.
     * Used by <code>before</code> and <code>after</code>.
     *
     * @method _inject
     * @param when {string} before or after
     * @param fn {Function} the function to execute
     * @param obj the object hosting the method to displace
     * @param sFn {string} the name of the method to displace
     * @param c The execution context for fn
     * @return {EventHandle} handle for the subscription
     * @private
     * @static
     */
    _inject: function(when, fn, obj, sFn) {
        // object id
        var id = Y.stamp(obj), o, sid;

        if (!obj._yuiaop) {
            // create a map entry for the obj if it doesn't exist, to hold overridden methods
            obj._yuiaop = {};
        }

        o = obj._yuiaop;

        if (!o[sFn]) {
            // create a map entry for the method if it doesn't exist
            o[sFn] = new Y.Do.Method(obj, sFn);

            // re-route the method to our wrapper
            obj[sFn] = function() {
                return o[sFn].exec.apply(o[sFn], arguments);
            };
        }

        // subscriber id
        sid = id + Y.stamp(fn) + sFn;

        // register the callback
        o[sFn].register(sid, fn, when);

        return new Y.EventHandle(o[sFn], sid);
    },

    /**
     * Detach a before or after subscription.
     *
     * @method detach
     * @param handle {EventHandle} the subscription handle
     * @static
     */
    detach: function(handle) {
        if (handle.detach) {
            handle.detach();
        }
    }
};

Y.Do = DO;

//////////////////////////////////////////////////////////////////////////

/**
 * Contains the return value from the wrapped method, accessible
 * by 'after' event listeners.
 *
 * @property originalRetVal
 * @static
 * @since 3.2.0
 */

/**
 * Contains the current state of the return value, consumable by
 * 'after' event listeners, and updated if an after subscriber
 * changes the return value generated by the wrapped function.
 *
 * @property currentRetVal
 * @static
 * @since 3.2.0
 */

//////////////////////////////////////////////////////////////////////////

/**
 * Wrapper for a displaced method with aop enabled
 * @class Do.Method
 * @constructor
 * @param obj The object to operate on
 * @param sFn The name of the method to displace
 */
DO.Method = function(obj, sFn) {
    this.obj = obj;
    this.methodName = sFn;
    this.method = obj[sFn];
    this.before = {};
    this.after = {};
};

/**
 * Register a aop subscriber
 * @method register
 * @param sid {string} the subscriber id
 * @param fn {Function} the function to execute
 * @param when {string} when to execute the function
 */
DO.Method.prototype.register = function (sid, fn, when) {
    if (when) {
        this.after[sid] = fn;
    } else {
        this.before[sid] = fn;
    }
};

/**
 * Unregister a aop subscriber
 * @method delete
 * @param sid {string} the subscriber id
 * @param fn {Function} the function to execute
 * @param when {string} when to execute the function
 */
DO.Method.prototype._delete = function (sid) {
    delete this.before[sid];
    delete this.after[sid];
};

/**
 * <p>Execute the wrapped method.  All arguments are passed into the wrapping
 * functions.  If any of the before wrappers return an instance of
 * <code>Y.Do.Halt</code> or <code>Y.Do.Prevent</code>, neither the wrapped
 * function nor any after phase subscribers will be executed.</p>
 *
 * <p>The return value will be the return value of the wrapped function or one
 * provided by a wrapper function via an instance of <code>Y.Do.Halt</code> or
 * <code>Y.Do.AlterReturn</code>.
 *
 * @method exec
 * @param arg* {any} Arguments are passed to the wrapping and wrapped functions
 * @return {any} Return value of wrapped function unless overwritten (see above)
 */
DO.Method.prototype.exec = function () {

    var args = Y.Array(arguments, 0, true),
        i, ret, newRet,
        bf = this.before,
        af = this.after,
        prevented = false;

    // execute before
    for (i in bf) {
        if (bf.hasOwnProperty(i)) {
            ret = bf[i].apply(this.obj, args);
            if (ret) {
                switch (ret.constructor) {
                    case DO.Halt:
                        return ret.retVal;
                    case DO.AlterArgs:
                        args = ret.newArgs;
                        break;
                    case DO.Prevent:
                        prevented = true;
                        break;
                    default:
                }
            }
        }
    }

    // execute method
    if (!prevented) {
        ret = this.method.apply(this.obj, args);
    }

    DO.originalRetVal = ret;
    DO.currentRetVal = ret;

    // execute after methods.
    for (i in af) {
        if (af.hasOwnProperty(i)) {
            newRet = af[i].apply(this.obj, args);
            // Stop processing if a Halt object is returned
            if (newRet && newRet.constructor === DO.Halt) {
                return newRet.retVal;
            // Check for a new return value
            } else if (newRet && newRet.constructor === DO.AlterReturn) {
                ret = newRet.newRetVal;
                // Update the static retval state
                DO.currentRetVal = ret;
            }
        }
    }

    return ret;
};

//////////////////////////////////////////////////////////////////////////

/**
 * Return an AlterArgs object when you want to change the arguments that
 * were passed into the function.  Useful for Do.before subscribers.  An
 * example would be a service that scrubs out illegal characters prior to
 * executing the core business logic.
 * @class Do.AlterArgs
 * @constructor
 * @param msg {String} (optional) Explanation of the altered return value
 * @param newArgs {Array} Call parameters to be used for the original method
 *                        instead of the arguments originally passed in.
 */
DO.AlterArgs = function(msg, newArgs) {
    this.msg = msg;
    this.newArgs = newArgs;
};

/**
 * Return an AlterReturn object when you want to change the result returned
 * from the core method to the caller.  Useful for Do.after subscribers.
 * @class Do.AlterReturn
 * @constructor
 * @param msg {String} (optional) Explanation of the altered return value
 * @param newRetVal {any} Return value passed to code that invoked the wrapped
 *                      function.
 */
DO.AlterReturn = function(msg, newRetVal) {
    this.msg = msg;
    this.newRetVal = newRetVal;
};

/**
 * Return a Halt object when you want to terminate the execution
 * of all subsequent subscribers as well as the wrapped method
 * if it has not exectued yet.  Useful for Do.before subscribers.
 * @class Do.Halt
 * @constructor
 * @param msg {String} (optional) Explanation of why the termination was done
 * @param retVal {any} Return value passed to code that invoked the wrapped
 *                      function.
 */
DO.Halt = function(msg, retVal) {
    this.msg = msg;
    this.retVal = retVal;
};

/**
 * Return a Prevent object when you want to prevent the wrapped function
 * from executing, but want the remaining listeners to execute.  Useful
 * for Do.before subscribers.
 * @class Do.Prevent
 * @constructor
 * @param msg {String} (optional) Explanation of why the termination was done
 */
DO.Prevent = function(msg) {
    this.msg = msg;
};

/**
 * Return an Error object when you want to terminate the execution
 * of all subsequent method calls.
 * @class Do.Error
 * @constructor
 * @param msg {String} (optional) Explanation of the altered return value
 * @param retVal {any} Return value passed to code that invoked the wrapped
 *                      function.
 * @deprecated use Y.Do.Halt or Y.Do.Prevent
 */
DO.Error = DO.Halt;


//////////////////////////////////////////////////////////////////////////

/**
 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
 * events.
 * @module event-custom
 * @submodule event-custom-base
 */


// var onsubscribeType = "_event:onsub",
var YArray = Y.Array,

    AFTER = 'after',
    CONFIGS = [
        'broadcast',
        'monitored',
        'bubbles',
        'context',
        'contextFn',
        'currentTarget',
        'defaultFn',
        'defaultTargetOnly',
        'details',
        'emitFacade',
        'fireOnce',
        'async',
        'host',
        'preventable',
        'preventedFn',
        'queuable',
        'silent',
        'stoppedFn',
        'target',
        'type'
    ],

    CONFIGS_HASH = YArray.hash(CONFIGS),

    nativeSlice = Array.prototype.slice,

    YUI3_SIGNATURE = 9,
    YUI_LOG = 'yui:log',

    mixConfigs = function(r, s, ov) {
        var p;

        for (p in s) {
            if (CONFIGS_HASH[p] && (ov || !(p in r))) {
                r[p] = s[p];
            }
        }

        return r;
    };

/**
 * The CustomEvent class lets you define events for your application
 * that can be subscribed to by one or more independent component.
 *
 * @param {String} type The type of event, which is passed to the callback
 * when the event fires.
 * @param {object} defaults configuration object.
 * @class CustomEvent
 * @constructor
 */

 /**
 * The type of event, returned to subscribers when the event fires
 * @property type
 * @type string
 */

/**
 * By default all custom events are logged in the debug build, set silent
 * to true to disable debug outpu for this event.
 * @property silent
 * @type boolean
 */

Y.CustomEvent = function(type, defaults) {

    this._kds = Y.CustomEvent.keepDeprecatedSubs;

    this.id = Y.guid();

    this.type = type;
    this.silent = this.logSystem = (type === YUI_LOG);

    if (this._kds) {
        /**
         * The subscribers to this event
         * @property subscribers
         * @type Subscriber {}
         * @deprecated
         */

        /**
         * 'After' subscribers
         * @property afters
         * @type Subscriber {}
         * @deprecated
         */
        this.subscribers = {};
        this.afters = {};
    }

    if (defaults) {
        mixConfigs(this, defaults, true);
    }
};

/**
 * Static flag to enable population of the <a href="#property_subscribers">`subscribers`</a>
 * and  <a href="#property_subscribers">`afters`</a> properties held on a `CustomEvent` instance.
 *
 * These properties were changed to private properties (`_subscribers` and `_afters`), and
 * converted from objects to arrays for performance reasons.
 *
 * Setting this property to true will populate the deprecated `subscribers` and `afters`
 * properties for people who may be using them (which is expected to be rare). There will
 * be a performance hit, compared to the new array based implementation.
 *
 * If you are using these deprecated properties for a use case which the public API
 * does not support, please file an enhancement request, and we can provide an alternate
 * public implementation which doesn't have the performance cost required to maintiain the
 * properties as objects.
 *
 * @property keepDeprecatedSubs
 * @static
 * @for CustomEvent
 * @type boolean
 * @default false
 * @deprecated
 */
Y.CustomEvent.keepDeprecatedSubs = false;

Y.CustomEvent.mixConfigs = mixConfigs;

Y.CustomEvent.prototype = {

    constructor: Y.CustomEvent,

    /**
     * Monitor when an event is attached or detached.
     *
     * @property monitored
     * @type boolean
     */

    /**
     * If 0, this event does not broadcast.  If 1, the YUI instance is notified
     * every time this event fires.  If 2, the YUI instance and the YUI global
     * (if event is enabled on the global) are notified every time this event
     * fires.
     * @property broadcast
     * @type int
     */

    /**
     * Specifies whether this event should be queued when the host is actively
     * processing an event.  This will effect exectution order of the callbacks
     * for the various events.
     * @property queuable
     * @type boolean
     * @default false
     */

    /**
     * This event has fired if true
     *
     * @property fired
     * @type boolean
     * @default false;
     */

    /**
     * An array containing the arguments the custom event
     * was last fired with.
     * @property firedWith
     * @type Array
     */

    /**
     * This event should only fire one time if true, and if
     * it has fired, any new subscribers should be notified
     * immediately.
     *
     * @property fireOnce
     * @type boolean
     * @default false;
     */

    /**
     * fireOnce listeners will fire syncronously unless async
     * is set to true
     * @property async
     * @type boolean
     * @default false
     */

    /**
     * Flag for stopPropagation that is modified during fire()
     * 1 means to stop propagation to bubble targets.  2 means
     * to also stop additional subscribers on this target.
     * @property stopped
     * @type int
     */

    /**
     * Flag for preventDefault that is modified during fire().
     * if it is not 0, the default behavior for this event
     * @property prevented
     * @type int
     */

    /**
     * Specifies the host for this custom event.  This is used
     * to enable event bubbling
     * @property host
     * @type EventTarget
     */

    /**
     * The default function to execute after event listeners
     * have fire, but only if the default action was not
     * prevented.
     * @property defaultFn
     * @type Function
     */

    /**
     * Flag for the default function to execute only if the
     * firing event is the current target. This happens only
     * when using custom event delegation and setting the
     * flag to `true` mimics the behavior of event delegation
     * in the DOM.
     *
     * @property defaultTargetOnly
     * @type Boolean
     * @default false
     */

    /**
     * The function to execute if a subscriber calls
     * stopPropagation or stopImmediatePropagation
     * @property stoppedFn
     * @type Function
     */

    /**
     * The function to execute if a subscriber calls
     * preventDefault
     * @property preventedFn
     * @type Function
     */

    /**
     * The subscribers to this event
     * @property _subscribers
     * @type Subscriber []
     * @private
     */

    /**
     * 'After' subscribers
     * @property _afters
     * @type Subscriber []
     * @private
     */

    /**
     * If set to true, the custom event will deliver an EventFacade object
     * that is similar to a DOM event object.
     * @property emitFacade
     * @type boolean
     * @default false
     */

    /**
     * Supports multiple options for listener signatures in order to
     * port YUI 2 apps.
     * @property signature
     * @type int
     * @default 9
     */
    signature : YUI3_SIGNATURE,

    /**
     * The context the the event will fire from by default.  Defaults to the YUI
     * instance.
     * @property context
     * @type object
     */
    context : Y,

    /**
     * Specifies whether or not this event's default function
     * can be cancelled by a subscriber by executing preventDefault()
     * on the event facade
     * @property preventable
     * @type boolean
     * @default true
     */
    preventable : true,

    /**
     * Specifies whether or not a subscriber can stop the event propagation
     * via stopPropagation(), stopImmediatePropagation(), or halt()
     *
     * Events can only bubble if emitFacade is true.
     *
     * @property bubbles
     * @type boolean
     * @default true
     */
    bubbles : true,

    /**
     * Returns the number of subscribers for this event as the sum of the on()
     * subscribers and after() subscribers.
     *
     * @method hasSubs
     * @return Number
     */
    hasSubs: function(when) {
        var s = 0,
            a = 0,
            subs = this._subscribers,
            afters = this._afters,
            sib = this.sibling;

        if (subs) {
            s = subs.length;
        }

        if (afters) {
            a = afters.length;
        }

        if (sib) {
            subs = sib._subscribers;
            afters = sib._afters;

            if (subs) {
                s += subs.length;
            }

            if (afters) {
                a += afters.length;
            }
        }

        if (when) {
            return (when === 'after') ? a : s;
        }

        return (s + a);
    },

    /**
     * Monitor the event state for the subscribed event.  The first parameter
     * is what should be monitored, the rest are the normal parameters when
     * subscribing to an event.
     * @method monitor
     * @param what {string} what to monitor ('detach', 'attach', 'publish').
     * @return {EventHandle} return value from the monitor event subscription.
     */
    monitor: function(what) {
        this.monitored = true;
        var type = this.id + '|' + this.type + '_' + what,
            args = nativeSlice.call(arguments, 0);
        args[0] = type;
        return this.host.on.apply(this.host, args);
    },

    /**
     * Get all of the subscribers to this event and any sibling event
     * @method getSubs
     * @return {Array} first item is the on subscribers, second the after.
     */
    getSubs: function() {

        var sibling = this.sibling,
            subs = this._subscribers,
            afters = this._afters,
            siblingSubs,
            siblingAfters;

        if (sibling) {
            siblingSubs = sibling._subscribers;
            siblingAfters = sibling._afters;
        }

        if (siblingSubs) {
            if (subs) {
                subs = subs.concat(siblingSubs);
            } else {
                subs = siblingSubs.concat();
            }
        } else {
            if (subs) {
                subs = subs.concat();
            } else {
                subs = [];
            }
        }

        if (siblingAfters) {
            if (afters) {
                afters = afters.concat(siblingAfters);
            } else {
                afters = siblingAfters.concat();
            }
        } else {
            if (afters) {
                afters = afters.concat();
            } else {
                afters = [];
            }
        }

        return [subs, afters];
    },

    /**
     * Apply configuration properties.  Only applies the CONFIG whitelist
     * @method applyConfig
     * @param o hash of properties to apply.
     * @param force {boolean} if true, properties that exist on the event
     * will be overwritten.
     */
    applyConfig: function(o, force) {
        mixConfigs(this, o, force);
    },

    /**
     * Create the Subscription for subscribing function, context, and bound
     * arguments.  If this is a fireOnce event, the subscriber is immediately
     * notified.
     *
     * @method _on
     * @param fn {Function} Subscription callback
     * @param [context] {Object} Override `this` in the callback
     * @param [args] {Array} bound arguments that will be passed to the callback after the arguments generated by fire()
     * @param [when] {String} "after" to slot into after subscribers
     * @return {EventHandle}
     * @protected
     */
    _on: function(fn, context, args, when) {


        var s = new Y.Subscriber(fn, context, args, when),
            firedWith;

        if (this.fireOnce && this.fired) {

            firedWith = this.firedWith;

            // It's a little ugly for this to know about facades,
            // but given the current breakup, not much choice without
            // moving a whole lot of stuff around.
            if (this.emitFacade && this._addFacadeToArgs) {
                this._addFacadeToArgs(firedWith);
            }

            if (this.async) {
                Y.config.win.setTimeout(Y.bind(this._notify, this, s, firedWith), 0);
            } else {
                this._notify(s, firedWith);
            }
        }

        if (when === AFTER) {
            if (!this._afters) {
                this._afters = [];
            }
            this._afters.push(s);
        } else {
            if (!this._subscribers) {
                this._subscribers = [];
            }
            this._subscribers.push(s);
        }

        if (this._kds) {
            if (when === AFTER) {
                this.afters[s.id] = s;
            } else {
                this.subscribers[s.id] = s;
            }
        }

        return new Y.EventHandle(this, s);
    },

    /**
     * Listen for this event
     * @method subscribe
     * @param {Function} fn The function to execute.
     * @return {EventHandle} Unsubscribe handle.
     * @deprecated use on.
     */
    subscribe: function(fn, context) {
        var a = (arguments.length > 2) ? nativeSlice.call(arguments, 2) : null;
        return this._on(fn, context, a, true);
    },

    /**
     * Listen for this event
     * @method on
     * @param {Function} fn The function to execute.
     * @param {object} context optional execution context.
     * @param {mixed} arg* 0..n additional arguments to supply to the subscriber
     * when the event fires.
     * @return {EventHandle} An object with a detach method to detch the handler(s).
     */
    on: function(fn, context) {
        var a = (arguments.length > 2) ? nativeSlice.call(arguments, 2) : null;

        if (this.monitored && this.host) {
            this.host._monitor('attach', this, {
                args: arguments
            });
        }
        return this._on(fn, context, a, true);
    },

    /**
     * Listen for this event after the normal subscribers have been notified and
     * the default behavior has been applied.  If a normal subscriber prevents the
     * default behavior, it also prevents after listeners from firing.
     * @method after
     * @param {Function} fn The function to execute.
     * @param {object} context optional execution context.
     * @param {mixed} arg* 0..n additional arguments to supply to the subscriber
     * when the event fires.
     * @return {EventHandle} handle Unsubscribe handle.
     */
    after: function(fn, context) {
        var a = (arguments.length > 2) ? nativeSlice.call(arguments, 2) : null;
        return this._on(fn, context, a, AFTER);
    },

    /**
     * Detach listeners.
     * @method detach
     * @param {Function} fn  The subscribed function to remove, if not supplied
     *                       all will be removed.
     * @param {Object}   context The context object passed to subscribe.
     * @return {Number} returns the number of subscribers unsubscribed.
     */
    detach: function(fn, context) {
        // unsubscribe handle
        if (fn && fn.detach) {
            return fn.detach();
        }

        var i, s,
            found = 0,
            subs = this._subscribers,
            afters = this._afters;

        if (subs) {
            for (i = subs.length; i >= 0; i--) {
                s = subs[i];
                if (s && (!fn || fn === s.fn)) {
                    this._delete(s, subs, i);
                    found++;
                }
            }
        }

        if (afters) {
            for (i = afters.length; i >= 0; i--) {
                s = afters[i];
                if (s && (!fn || fn === s.fn)) {
                    this._delete(s, afters, i);
                    found++;
                }
            }
        }

        return found;
    },

    /**
     * Detach listeners.
     * @method unsubscribe
     * @param {Function} fn  The subscribed function to remove, if not supplied
     *                       all will be removed.
     * @param {Object}   context The context object passed to subscribe.
     * @return {int|undefined} returns the number of subscribers unsubscribed.
     * @deprecated use detach.
     */
    unsubscribe: function() {
        return this.detach.apply(this, arguments);
    },

    /**
     * Notify a single subscriber
     * @method _notify
     * @param {Subscriber} s the subscriber.
     * @param {Array} args the arguments array to apply to the listener.
     * @protected
     */
    _notify: function(s, args, ef) {


        var ret;

        ret = s.notify(args, this);

        if (false === ret || this.stopped > 1) {
            return false;
        }

        return true;
    },

    /**
     * Logger abstraction to centralize the application of the silent flag
     * @method log
     * @param {string} msg message to log.
     * @param {string} cat log category.
     */
    log: function(msg, cat) {
    },

    /**
     * Notifies the subscribers.  The callback functions will be executed
     * from the context specified when the event was created, and with the
     * following parameters:
     *   <ul>
     *   <li>The type of event</li>
     *   <li>All of the arguments fire() was executed with as an array</li>
     *   <li>The custom object (if any) that was passed into the subscribe()
     *       method</li>
     *   </ul>
     * @method fire
     * @param {Object*} arguments an arbitrary set of parameters to pass to
     *                            the handler.
     * @return {boolean} false if one of the subscribers returned false,
     *                   true otherwise.
     *
     */
    fire: function() {

        // push is the fastest way to go from arguments to arrays
        // for most browsers currently
        // http://jsperf.com/push-vs-concat-vs-slice/2

        var args = [];
        args.push.apply(args, arguments);

        return this._fire(args);
    },

    /**
     * Private internal implementation for `fire`, which is can be used directly by
     * `EventTarget` and other event module classes which have already converted from
     * an `arguments` list to an array, to avoid the repeated overhead.
     *
     * @method _fire
     * @private
     * @param {Array} args The array of arguments passed to be passed to handlers.
     * @return {boolean} false if one of the subscribers returned false, true otherwise.
     */
    _fire: function(args) {

        if (this.fireOnce && this.fired) {
            return true;
        } else {

            // this doesn't happen if the event isn't published
            // this.host._monitor('fire', this.type, args);

            this.fired = true;

            if (this.fireOnce) {
                this.firedWith = args;
            }

            if (this.emitFacade) {
                return this.fireComplex(args);
            } else {
                return this.fireSimple(args);
            }
        }
    },

    /**
     * Set up for notifying subscribers of non-emitFacade events.
     *
     * @method fireSimple
     * @param args {Array} Arguments passed to fire()
     * @return Boolean false if a subscriber returned false
     * @protected
     */
    fireSimple: function(args) {
        this.stopped = 0;
        this.prevented = 0;
        if (this.hasSubs()) {
            var subs = this.getSubs();
            this._procSubs(subs[0], args);
            this._procSubs(subs[1], args);
        }
        if (this.broadcast) {
            this._broadcast(args);
        }
        return this.stopped ? false : true;
    },

    // Requires the event-custom-complex module for full funcitonality.
    fireComplex: function(args) {
        args[0] = args[0] || {};
        return this.fireSimple(args);
    },

    /**
     * Notifies a list of subscribers.
     *
     * @method _procSubs
     * @param subs {Array} List of subscribers
     * @param args {Array} Arguments passed to fire()
     * @param ef {}
     * @return Boolean false if a subscriber returns false or stops the event
     *              propagation via e.stopPropagation(),
     *              e.stopImmediatePropagation(), or e.halt()
     * @private
     */
    _procSubs: function(subs, args, ef) {
        var s, i, l;

        for (i = 0, l = subs.length; i < l; i++) {
            s = subs[i];
            if (s && s.fn) {
                if (false === this._notify(s, args, ef)) {
                    this.stopped = 2;
                }
                if (this.stopped === 2) {
                    return false;
                }
            }
        }

        return true;
    },

    /**
     * Notifies the YUI instance if the event is configured with broadcast = 1,
     * and both the YUI instance and Y.Global if configured with broadcast = 2.
     *
     * @method _broadcast
     * @param args {Array} Arguments sent to fire()
     * @private
     */
    _broadcast: function(args) {
        if (!this.stopped && this.broadcast) {

            var a = args.concat();
            a.unshift(this.type);

            if (this.host !== Y) {
                Y.fire.apply(Y, a);
            }

            if (this.broadcast === 2) {
                Y.Global.fire.apply(Y.Global, a);
            }
        }
    },

    /**
     * Removes all listeners
     * @method unsubscribeAll
     * @return {Number} The number of listeners unsubscribed.
     * @deprecated use detachAll.
     */
    unsubscribeAll: function() {
        return this.detachAll.apply(this, arguments);
    },

    /**
     * Removes all listeners
     * @method detachAll
     * @return {Number} The number of listeners unsubscribed.
     */
    detachAll: function() {
        return this.detach();
    },

    /**
     * Deletes the subscriber from the internal store of on() and after()
     * subscribers.
     *
     * @method _delete
     * @param s subscriber object.
     * @param subs (optional) on or after subscriber array
     * @param index (optional) The index found.
     * @private
     */
    _delete: function(s, subs, i) {
        var when = s._when;

        if (!subs) {
            subs = (when === AFTER) ? this._afters : this._subscribers;
        }

        if (subs) {
            i = YArray.indexOf(subs, s, 0);

            if (s && subs[i] === s) {
                subs.splice(i, 1);
            }
        }

        if (this._kds) {
            if (when === AFTER) {
                delete this.afters[s.id];
            } else {
                delete this.subscribers[s.id];
            }
        }

        if (this.monitored && this.host) {
            this.host._monitor('detach', this, {
                ce: this,
                sub: s
            });
        }

        if (s) {
            s.deleted = true;
        }
    }
};
/**
 * Stores the subscriber information to be used when the event fires.
 * @param {Function} fn       The wrapped function to execute.
 * @param {Object}   context  The value of the keyword 'this' in the listener.
 * @param {Array} args*       0..n additional arguments to supply the listener.
 *
 * @class Subscriber
 * @constructor
 */
Y.Subscriber = function(fn, context, args, when) {

    /**
     * The callback that will be execute when the event fires
     * This is wrapped by Y.rbind if obj was supplied.
     * @property fn
     * @type Function
     */
    this.fn = fn;

    /**
     * Optional 'this' keyword for the listener
     * @property context
     * @type Object
     */
    this.context = context;

    /**
     * Unique subscriber id
     * @property id
     * @type String
     */
    this.id = Y.guid();

    /**
     * Additional arguments to propagate to the subscriber
     * @property args
     * @type Array
     */
    this.args = args;

    this._when = when;

    /**
     * Custom events for a given fire transaction.
     * @property events
     * @type {EventTarget}
     */
    // this.events = null;

    /**
     * This listener only reacts to the event once
     * @property once
     */
    // this.once = false;

};

Y.Subscriber.prototype = {
    constructor: Y.Subscriber,

    _notify: function(c, args, ce) {
        if (this.deleted && !this.postponed) {
            if (this.postponed) {
                delete this.fn;
                delete this.context;
            } else {
                delete this.postponed;
                return null;
            }
        }
        var a = this.args, ret;
        switch (ce.signature) {
            case 0:
                ret = this.fn.call(c, ce.type, args, c);
                break;
            case 1:
                ret = this.fn.call(c, args[0] || null, c);
                break;
            default:
                if (a || args) {
                    args = args || [];
                    a = (a) ? args.concat(a) : args;
                    ret = this.fn.apply(c, a);
                } else {
                    ret = this.fn.call(c);
                }
        }

        if (this.once) {
            ce._delete(this);
        }

        return ret;
    },

    /**
     * Executes the subscriber.
     * @method notify
     * @param args {Array} Arguments array for the subscriber.
     * @param ce {CustomEvent} The custom event that sent the notification.
     */
    notify: function(args, ce) {
        var c = this.context,
            ret = true;

        if (!c) {
            c = (ce.contextFn) ? ce.contextFn() : ce.context;
        }

        // only catch errors if we will not re-throw them.
        if (Y.config && Y.config.throwFail) {
            ret = this._notify(c, args, ce);
        } else {
            try {
                ret = this._notify(c, args, ce);
            } catch (e) {
                Y.error(this + ' failed: ' + e.message, e);
            }
        }

        return ret;
    },

    /**
     * Returns true if the fn and obj match this objects properties.
     * Used by the unsubscribe method to match the right subscriber.
     *
     * @method contains
     * @param {Function} fn the function to execute.
     * @param {Object} context optional 'this' keyword for the listener.
     * @return {boolean} true if the supplied arguments match this
     *                   subscriber's signature.
     */
    contains: function(fn, context) {
        if (context) {
            return ((this.fn === fn) && this.context === context);
        } else {
            return (this.fn === fn);
        }
    },

    valueOf : function() {
        return this.id;
    }

};
/**
 * Return value from all subscribe operations
 * @class EventHandle
 * @constructor
 * @param {CustomEvent} evt the custom event.
 * @param {Subscriber} sub the subscriber.
 */
Y.EventHandle = function(evt, sub) {

    /**
     * The custom event
     *
     * @property evt
     * @type CustomEvent
     */
    this.evt = evt;

    /**
     * The subscriber object
     *
     * @property sub
     * @type Subscriber
     */
    this.sub = sub;
};

Y.EventHandle.prototype = {
    batch: function(f, c) {
        f.call(c || this, this);
        if (Y.Lang.isArray(this.evt)) {
            Y.Array.each(this.evt, function(h) {
                h.batch.call(c || h, f);
            });
        }
    },

    /**
     * Detaches this subscriber
     * @method detach
     * @return {Number} the number of detached listeners
     */
    detach: function() {
        var evt = this.evt, detached = 0, i;
        if (evt) {
            if (Y.Lang.isArray(evt)) {
                for (i = 0; i < evt.length; i++) {
                    detached += evt[i].detach();
                }
            } else {
                evt._delete(this.sub);
                detached = 1;
            }

        }

        return detached;
    },

    /**
     * Monitor the event state for the subscribed event.  The first parameter
     * is what should be monitored, the rest are the normal parameters when
     * subscribing to an event.
     * @method monitor
     * @param what {string} what to monitor ('attach', 'detach', 'publish').
     * @return {EventHandle} return value from the monitor event subscription.
     */
    monitor: function(what) {
        return this.evt.monitor.apply(this.evt, arguments);
    }
};

/**
 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
 * events.
 * @module event-custom
 * @submodule event-custom-base
 */

/**
 * EventTarget provides the implementation for any object to
 * publish, subscribe and fire to custom events, and also
 * alows other EventTargets to target the object with events
 * sourced from the other object.
 * EventTarget is designed to be used with Y.augment to wrap
 * EventCustom in an interface that allows events to be listened to
 * and fired by name.  This makes it possible for implementing code to
 * subscribe to an event that either has not been created yet, or will
 * not be created at all.
 * @class EventTarget
 * @param opts a configuration object
 * @config emitFacade {boolean} if true, all events will emit event
 * facade payloads by default (default false)
 * @config prefix {String} the prefix to apply to non-prefixed event names
 */

var L = Y.Lang,
    PREFIX_DELIMITER = ':',
    CATEGORY_DELIMITER = '|',
    AFTER_PREFIX = '~AFTER~',
    WILD_TYPE_RE = /(.*?)(:)(.*?)/,

    _wildType = Y.cached(function(type) {
        return type.replace(WILD_TYPE_RE, "*$2$3");
    }),

    /**
     * If the instance has a prefix attribute and the
     * event type is not prefixed, the instance prefix is
     * applied to the supplied type.
     * @method _getType
     * @private
     */
    _getType = function(type, pre) {

        if (!pre || !type || type.indexOf(PREFIX_DELIMITER) > -1) {
            return type;
        }

        return pre + PREFIX_DELIMITER + type;
    },

    /**
     * Returns an array with the detach key (if provided),
     * and the prefixed event name from _getType
     * Y.on('detachcategory| menu:click', fn)
     * @method _parseType
     * @private
     */
    _parseType = Y.cached(function(type, pre) {

        var t = type, detachcategory, after, i;

        if (!L.isString(t)) {
            return t;
        }

        i = t.indexOf(AFTER_PREFIX);

        if (i > -1) {
            after = true;
            t = t.substr(AFTER_PREFIX.length);
        }

        i = t.indexOf(CATEGORY_DELIMITER);

        if (i > -1) {
            detachcategory = t.substr(0, (i));
            t = t.substr(i+1);
            if (t === '*') {
                t = null;
            }
        }

        // detach category, full type with instance prefix, is this an after listener, short type
        return [detachcategory, (pre) ? _getType(t, pre) : t, after, t];
    }),

    ET = function(opts) {

        var etState = this._yuievt,
            etConfig;

        if (!etState) {
            etState = this._yuievt = {
                events: {},    // PERF: Not much point instantiating lazily. We're bound to have events
                targets: null, // PERF: Instantiate lazily, if user actually adds target,
                config: {
                    host: this,
                    context: this
                },
                chain: Y.config.chain
            };
        }

        etConfig = etState.config;

        if (opts) {
            mixConfigs(etConfig, opts, true);

            if (opts.chain !== undefined) {
                etState.chain = opts.chain;
            }

            if (opts.prefix) {
                etConfig.prefix = opts.prefix;
            }
        }
    };

ET.prototype = {

    constructor: ET,

    /**
     * Listen to a custom event hosted by this object one time.
     * This is the equivalent to <code>on</code> except the
     * listener is immediatelly detached when it is executed.
     * @method once
     * @param {String} type The name of the event
     * @param {Function} fn The callback to execute in response to the event
     * @param {Object} [context] Override `this` object in callback
     * @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
     * @return {EventHandle} A subscription handle capable of detaching the
     *                       subscription
     */
    once: function() {
        var handle = this.on.apply(this, arguments);
        handle.batch(function(hand) {
            if (hand.sub) {
                hand.sub.once = true;
            }
        });
        return handle;
    },

    /**
     * Listen to a custom event hosted by this object one time.
     * This is the equivalent to <code>after</code> except the
     * listener is immediatelly detached when it is executed.
     * @method onceAfter
     * @param {String} type The name of the event
     * @param {Function} fn The callback to execute in response to the event
     * @param {Object} [context] Override `this` object in callback
     * @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
     * @return {EventHandle} A subscription handle capable of detaching that
     *                       subscription
     */
    onceAfter: function() {
        var handle = this.after.apply(this, arguments);
        handle.batch(function(hand) {
            if (hand.sub) {
                hand.sub.once = true;
            }
        });
        return handle;
    },

    /**
     * Takes the type parameter passed to 'on' and parses out the
     * various pieces that could be included in the type.  If the
     * event type is passed without a prefix, it will be expanded
     * to include the prefix one is supplied or the event target
     * is configured with a default prefix.
     * @method parseType
     * @param {String} type the type
     * @param {String} [pre] The prefix. Defaults to this._yuievt.config.prefix
     * @since 3.3.0
     * @return {Array} an array containing:
     *  * the detach category, if supplied,
     *  * the prefixed event type,
     *  * whether or not this is an after listener,
     *  * the supplied event type
     */
    parseType: function(type, pre) {
        return _parseType(type, pre || this._yuievt.config.prefix);
    },

    /**
     * Subscribe a callback function to a custom event fired by this object or
     * from an object that bubbles its events to this object.
     *
     * Callback functions for events published with `emitFacade = true` will
     * receive an `EventFacade` as the first argument (typically named "e").
     * These callbacks can then call `e.preventDefault()` to disable the
     * behavior published to that event's `defaultFn`.  See the `EventFacade`
     * API for all available properties and methods. Subscribers to
     * non-`emitFacade` events will receive the arguments passed to `fire()`
     * after the event name.
     *
     * To subscribe to multiple events at once, pass an object as the first
     * argument, where the key:value pairs correspond to the eventName:callback,
     * or pass an array of event names as the first argument to subscribe to
     * all listed events with the same callback.
     *
     * Returning `false` from a callback is supported as an alternative to
     * calling `e.preventDefault(); e.stopPropagation();`.  However, it is
     * recommended to use the event methods whenever possible.
     *
     * @method on
     * @param {String} type The name of the event
     * @param {Function} fn The callback to execute in response to the event
     * @param {Object} [context] Override `this` object in callback
     * @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
     * @return {EventHandle} A subscription handle capable of detaching that
     *                       subscription
     */
    on: function(type, fn, context) {

        var yuievt = this._yuievt,
            parts = _parseType(type, yuievt.config.prefix), f, c, args, ret, ce,
            detachcategory, handle, store = Y.Env.evt.handles, after, adapt, shorttype,
            Node = Y.Node, n, domevent, isArr;

        // full name, args, detachcategory, after
        this._monitor('attach', parts[1], {
            args: arguments,
            category: parts[0],
            after: parts[2]
        });

        if (L.isObject(type)) {

            if (L.isFunction(type)) {
                return Y.Do.before.apply(Y.Do, arguments);
            }

            f = fn;
            c = context;
            args = nativeSlice.call(arguments, 0);
            ret = [];

            if (L.isArray(type)) {
                isArr = true;
            }

            after = type._after;
            delete type._after;

            Y.each(type, function(v, k) {

                if (L.isObject(v)) {
                    f = v.fn || ((L.isFunction(v)) ? v : f);
                    c = v.context || c;
                }

                var nv = (after) ? AFTER_PREFIX : '';

                args[0] = nv + ((isArr) ? v : k);
                args[1] = f;
                args[2] = c;

                ret.push(this.on.apply(this, args));

            }, this);

            return (yuievt.chain) ? this : new Y.EventHandle(ret);
        }

        detachcategory = parts[0];
        after = parts[2];
        shorttype = parts[3];

        // extra redirection so we catch adaptor events too.  take a look at this.
        if (Node && Y.instanceOf(this, Node) && (shorttype in Node.DOM_EVENTS)) {
            args = nativeSlice.call(arguments, 0);
            args.splice(2, 0, Node.getDOMNode(this));
            return Y.on.apply(Y, args);
        }

        type = parts[1];

        if (Y.instanceOf(this, YUI)) {

            adapt = Y.Env.evt.plugins[type];
            args  = nativeSlice.call(arguments, 0);
            args[0] = shorttype;

            if (Node) {
                n = args[2];

                if (Y.instanceOf(n, Y.NodeList)) {
                    n = Y.NodeList.getDOMNodes(n);
                } else if (Y.instanceOf(n, Node)) {
                    n = Node.getDOMNode(n);
                }

                domevent = (shorttype in Node.DOM_EVENTS);

                // Captures both DOM events and event plugins.
                if (domevent) {
                    args[2] = n;
                }
            }

            // check for the existance of an event adaptor
            if (adapt) {
                handle = adapt.on.apply(Y, args);
            } else if ((!type) || domevent) {
                handle = Y.Event._attach(args);
            }

        }

        if (!handle) {
            ce = yuievt.events[type] || this.publish(type);
            handle = ce._on(fn, context, (arguments.length > 3) ? nativeSlice.call(arguments, 3) : null, (after) ? 'after' : true);

            // TODO: More robust regex, accounting for category
            if (type.indexOf("*:") !== -1) {
                this._hasSiblings = true;
            }
        }

        if (detachcategory) {
            store[detachcategory] = store[detachcategory] || {};
            store[detachcategory][type] = store[detachcategory][type] || [];
            store[detachcategory][type].push(handle);
        }

        return (yuievt.chain) ? this : handle;

    },

    /**
     * subscribe to an event
     * @method subscribe
     * @deprecated use on
     */
    subscribe: function() {
        return this.on.apply(this, arguments);
    },

    /**
     * Detach one or more listeners the from the specified event
     * @method detach
     * @param type {string|Object}   Either the handle to the subscriber or the
     *                        type of event.  If the type
     *                        is not specified, it will attempt to remove
     *                        the listener from all hosted events.
     * @param fn   {Function} The subscribed function to unsubscribe, if not
     *                          supplied, all subscribers will be removed.
     * @param context  {Object}   The custom object passed to subscribe.  This is
     *                        optional, but if supplied will be used to
     *                        disambiguate multiple listeners that are the same
     *                        (e.g., you subscribe many object using a function
     *                        that lives on the prototype)
     * @return {EventTarget} the host
     */
    detach: function(type, fn, context) {

        var evts = this._yuievt.events,
            i,
            Node = Y.Node,
            isNode = Node && (Y.instanceOf(this, Node));

        // detachAll disabled on the Y instance.
        if (!type && (this !== Y)) {
            for (i in evts) {
                if (evts.hasOwnProperty(i)) {
                    evts[i].detach(fn, context);
                }
            }
            if (isNode) {
                Y.Event.purgeElement(Node.getDOMNode(this));
            }

            return this;
        }

        var parts = _parseType(type, this._yuievt.config.prefix),
        detachcategory = L.isArray(parts) ? parts[0] : null,
        shorttype = (parts) ? parts[3] : null,
        adapt, store = Y.Env.evt.handles, detachhost, cat, args,
        ce,

        keyDetacher = function(lcat, ltype, host) {
            var handles = lcat[ltype], ce, i;
            if (handles) {
                for (i = handles.length - 1; i >= 0; --i) {
                    ce = handles[i].evt;
                    if (ce.host === host || ce.el === host) {
                        handles[i].detach();
                    }
                }
            }
        };

        if (detachcategory) {

            cat = store[detachcategory];
            type = parts[1];
            detachhost = (isNode) ? Y.Node.getDOMNode(this) : this;

            if (cat) {
                if (type) {
                    keyDetacher(cat, type, detachhost);
                } else {
                    for (i in cat) {
                        if (cat.hasOwnProperty(i)) {
                            keyDetacher(cat, i, detachhost);
                        }
                    }
                }

                return this;
            }

        // If this is an event handle, use it to detach
        } else if (L.isObject(type) && type.detach) {
            type.detach();
            return this;
        // extra redirection so we catch adaptor events too.  take a look at this.
        } else if (isNode && ((!shorttype) || (shorttype in Node.DOM_EVENTS))) {
            args = nativeSlice.call(arguments, 0);
            args[2] = Node.getDOMNode(this);
            Y.detach.apply(Y, args);
            return this;
        }

        adapt = Y.Env.evt.plugins[shorttype];

        // The YUI instance handles DOM events and adaptors
        if (Y.instanceOf(this, YUI)) {
            args = nativeSlice.call(arguments, 0);
            // use the adaptor specific detach code if
            if (adapt && adapt.detach) {
                adapt.detach.apply(Y, args);
                return this;
            // DOM event fork
            } else if (!type || (!adapt && Node && (type in Node.DOM_EVENTS))) {
                args[0] = type;
                Y.Event.detach.apply(Y.Event, args);
                return this;
            }
        }

        // ce = evts[type];
        ce = evts[parts[1]];
        if (ce) {
            ce.detach(fn, context);
        }

        return this;
    },

    /**
     * detach a listener
     * @method unsubscribe
     * @deprecated use detach
     */
    unsubscribe: function() {
        return this.detach.apply(this, arguments);
    },

    /**
     * Removes all listeners from the specified event.  If the event type
     * is not specified, all listeners from all hosted custom events will
     * be removed.
     * @method detachAll
     * @param type {String}   The type, or name of the event
     */
    detachAll: function(type) {
        return this.detach(type);
    },

    /**
     * Removes all listeners from the specified event.  If the event type
     * is not specified, all listeners from all hosted custom events will
     * be removed.
     * @method unsubscribeAll
     * @param type {String}   The type, or name of the event
     * @deprecated use detachAll
     */
    unsubscribeAll: function() {
        return this.detachAll.apply(this, arguments);
    },

    /**
     * Creates a new custom event of the specified type.  If a custom event
     * by that name already exists, it will not be re-created.  In either
     * case the custom event is returned.
     *
     * @method publish
     *
     * @param type {String} the type, or name of the event
     * @param opts {object} optional config params.  Valid properties are:
     *
     *  <ul>
     *    <li>
     *   'broadcast': whether or not the YUI instance and YUI global are notified when the event is fired (false)
     *    </li>
     *    <li>
     *   'bubbles': whether or not this event bubbles (true)
     *              Events can only bubble if emitFacade is true.
     *    </li>
     *    <li>
     *   'context': the default execution context for the listeners (this)
     *    </li>
     *    <li>
     *   'defaultFn': the default function to execute when this event fires if preventDefault was not called
     *    </li>
     *    <li>
     *   'emitFacade': whether or not this event emits a facade (false)
     *    </li>
     *    <li>
     *   'prefix': the prefix for this targets events, e.g., 'menu' in 'menu:click'
     *    </li>
     *    <li>
     *   'fireOnce': if an event is configured to fire once, new subscribers after
     *   the fire will be notified immediately.
     *    </li>
     *    <li>
     *   'async': fireOnce event listeners will fire synchronously if the event has already
     *    fired unless async is true.
     *    </li>
     *    <li>
     *   'preventable': whether or not preventDefault() has an effect (true)
     *    </li>
     *    <li>
     *   'preventedFn': a function that is executed when preventDefault is called
     *    </li>
     *    <li>
     *   'queuable': whether or not this event can be queued during bubbling (false)
     *    </li>
     *    <li>
     *   'silent': if silent is true, debug messages are not provided for this event.
     *    </li>
     *    <li>
     *   'stoppedFn': a function that is executed when stopPropagation is called
     *    </li>
     *
     *    <li>
     *   'monitored': specifies whether or not this event should send notifications about
     *   when the event has been attached, detached, or published.
     *    </li>
     *    <li>
     *   'type': the event type (valid option if not provided as the first parameter to publish)
     *    </li>
     *  </ul>
     *
     *  @return {CustomEvent} the custom event
     *
     */
    publish: function(type, opts) {

        var ret,
            etState = this._yuievt,
            etConfig = etState.config,
            pre = etConfig.prefix;

        if (typeof type === "string")  {
            if (pre) {
                type = _getType(type, pre);
            }
            ret = this._publish(type, etConfig, opts);
        } else {
            ret = {};

            Y.each(type, function(v, k) {
                if (pre) {
                    k = _getType(k, pre);
                }
                ret[k] = this._publish(k, etConfig, v || opts);
            }, this);

        }

        return ret;
    },

    /**
     * Returns the fully qualified type, given a short type string.
     * That is, returns "foo:bar" when given "bar" if "foo" is the configured prefix.
     *
     * NOTE: This method, unlike _getType, does no checking of the value passed in, and
     * is designed to be used with the low level _publish() method, for critical path
     * implementations which need to fast-track publish for performance reasons.
     *
     * @method _getFullType
     * @private
     * @param {String} type The short type to prefix
     * @return {String} The prefixed type, if a prefix is set, otherwise the type passed in
     */
    _getFullType : function(type) {

        var pre = this._yuievt.config.prefix;

        if (pre) {
            return pre + PREFIX_DELIMITER + type;
        } else {
            return type;
        }
    },

    /**
     * The low level event publish implementation. It expects all the massaging to have been done
     * outside of this method. e.g. the `type` to `fullType` conversion. It's designed to be a fast
     * path publish, which can be used by critical code paths to improve performance.
     *
     * @method _publish
     * @private
     * @param {String} fullType The prefixed type of the event to publish.
     * @param {Object} etOpts The EventTarget specific configuration to mix into the published event.
     * @param {Object} ceOpts The publish specific configuration to mix into the published event.
     * @return {CustomEvent} The published event. If called without `etOpts` or `ceOpts`, this will
     * be the default `CustomEvent` instance, and can be configured independently.
     */
    _publish : function(fullType, etOpts, ceOpts) {

        var ce,
            etState = this._yuievt,
            etConfig = etState.config,
            host = etConfig.host,
            context = etConfig.context,
            events = etState.events;

        ce = events[fullType];

        // PERF: Hate to pull the check out of monitor, but trying to keep critical path tight.
        if ((etConfig.monitored && !ce) || (ce && ce.monitored)) {
            this._monitor('publish', fullType, {
                args: arguments
            });
        }

        if (!ce) {
            // Publish event
            ce = events[fullType] = new Y.CustomEvent(fullType, etOpts);

            if (!etOpts) {
                ce.host = host;
                ce.context = context;
            }
        }

        if (ceOpts) {
            mixConfigs(ce, ceOpts, true);
        }

        return ce;
    },

    /**
     * This is the entry point for the event monitoring system.
     * You can monitor 'attach', 'detach', 'fire', and 'publish'.
     * When configured, these events generate an event.  click ->
     * click_attach, click_detach, click_publish -- these can
     * be subscribed to like other events to monitor the event
     * system.  Inividual published events can have monitoring
     * turned on or off (publish can't be turned off before it
     * it published) by setting the events 'monitor' config.
     *
     * @method _monitor
     * @param what {String} 'attach', 'detach', 'fire', or 'publish'
     * @param eventType {String|CustomEvent} The prefixed name of the event being monitored, or the CustomEvent object.
     * @param o {Object} Information about the event interaction, such as
     *                  fire() args, subscription category, publish config
     * @private
     */
    _monitor: function(what, eventType, o) {
        var monitorevt, ce, type;

        if (eventType) {
            if (typeof eventType === "string") {
                type = eventType;
                ce = this.getEvent(eventType, true);
            } else {
                ce = eventType;
                type = eventType.type;
            }

            if ((this._yuievt.config.monitored && (!ce || ce.monitored)) || (ce && ce.monitored)) {
                monitorevt = type + '_' + what;
                o.monitored = what;
                this.fire.call(this, monitorevt, o);
            }
        }
    },

    /**
     * Fire a custom event by name.  The callback functions will be executed
     * from the context specified when the event was created, and with the
     * following parameters.
     *
     * The first argument is the event type, and any additional arguments are
     * passed to the listeners as parameters.  If the first of these is an
     * object literal, and the event is configured to emit an event facade,
     * that object is mixed into the event facade and the facade is provided
     * in place of the original object.
     *
     * If the custom event object hasn't been created, then the event hasn't
     * been published and it has no subscribers.  For performance sake, we
     * immediate exit in this case.  This means the event won't bubble, so
     * if the intention is that a bubble target be notified, the event must
     * be published on this object first.
     *
     * @method fire
     * @param type {String|Object} The type of the event, or an object that contains
     * a 'type' property.
     * @param arguments {Object*} an arbitrary set of parameters to pass to
     * the handler.  If the first of these is an object literal and the event is
     * configured to emit an event facade, the event facade will replace that
     * parameter after the properties the object literal contains are copied to
     * the event facade.
     * @return {Boolean} True if the whole lifecycle of the event went through,
     * false if at any point the event propagation was halted.
     */
    fire: function(type) {

        var typeIncluded = (typeof type === "string"),
            argCount = arguments.length,
            t = type,
            yuievt = this._yuievt,
            etConfig = yuievt.config,
            pre = etConfig.prefix,
            ret,
            ce,
            ce2,
            args;

        if (typeIncluded && argCount <= 3) {

            // PERF: Try to avoid slice/iteration for the common signatures

            // Most common
            if (argCount === 2) {
                args = [arguments[1]]; // fire("foo", {})
            } else if (argCount === 3) {
                args = [arguments[1], arguments[2]]; // fire("foo", {}, opts)
            } else {
                args = []; // fire("foo")
            }

        } else {
            args = nativeSlice.call(arguments, ((typeIncluded) ? 1 : 0));
        }

        if (!typeIncluded) {
            t = (type && type.type);
        }

        if (pre) {
            t = _getType(t, pre);
        }

        ce = yuievt.events[t];

        if (this._hasSiblings) {
            ce2 = this.getSibling(t, ce);

            if (ce2 && !ce) {
                ce = this.publish(t);
            }
        }

        // PERF: trying to avoid function call, since this is a critical path
        if ((etConfig.monitored && (!ce || ce.monitored)) || (ce && ce.monitored)) {
            this._monitor('fire', (ce || t), {
                args: args
            });
        }

        // this event has not been published or subscribed to
        if (!ce) {
            if (yuievt.hasTargets) {
                return this.bubble({ type: t }, args, this);
            }

            // otherwise there is nothing to be done
            ret = true;
        } else {

            if (ce2) {
                ce.sibling = ce2;
            }

            ret = ce._fire(args);
        }

        return (yuievt.chain) ? this : ret;
    },

    getSibling: function(type, ce) {
        var ce2;

        // delegate to *:type events if there are subscribers
        if (type.indexOf(PREFIX_DELIMITER) > -1) {
            type = _wildType(type);
            ce2 = this.getEvent(type, true);
            if (ce2) {
                ce2.applyConfig(ce);
                ce2.bubbles = false;
                ce2.broadcast = 0;
            }
        }

        return ce2;
    },

    /**
     * Returns the custom event of the provided type has been created, a
     * falsy value otherwise
     * @method getEvent
     * @param type {String} the type, or name of the event
     * @param prefixed {String} if true, the type is prefixed already
     * @return {CustomEvent} the custom event or null
     */
    getEvent: function(type, prefixed) {
        var pre, e;

        if (!prefixed) {
            pre = this._yuievt.config.prefix;
            type = (pre) ? _getType(type, pre) : type;
        }
        e = this._yuievt.events;
        return e[type] || null;
    },

    /**
     * Subscribe to a custom event hosted by this object.  The
     * supplied callback will execute after any listeners add
     * via the subscribe method, and after the default function,
     * if configured for the event, has executed.
     *
     * @method after
     * @param {String} type The name of the event
     * @param {Function} fn The callback to execute in response to the event
     * @param {Object} [context] Override `this` object in callback
     * @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
     * @return {EventHandle} A subscription handle capable of detaching the
     *                       subscription
     */
    after: function(type, fn) {

        var a = nativeSlice.call(arguments, 0);

        switch (L.type(type)) {
            case 'function':
                return Y.Do.after.apply(Y.Do, arguments);
            case 'array':
            //     YArray.each(a[0], function(v) {
            //         v = AFTER_PREFIX + v;
            //     });
            //     break;
            case 'object':
                a[0]._after = true;
                break;
            default:
                a[0] = AFTER_PREFIX + type;
        }

        return this.on.apply(this, a);

    },

    /**
     * Executes the callback before a DOM event, custom event
     * or method.  If the first argument is a function, it
     * is assumed the target is a method.  For DOM and custom
     * events, this is an alias for Y.on.
     *
     * For DOM and custom events:
     * type, callback, context, 0-n arguments
     *
     * For methods:
     * callback, object (method host), methodName, context, 0-n arguments
     *
     * @method before
     * @return detach handle
     */
    before: function() {
        return this.on.apply(this, arguments);
    }

};

Y.EventTarget = ET;

// make Y an event target
Y.mix(Y, ET.prototype);
ET.call(Y, { bubbles: false });

YUI.Env.globalEvents = YUI.Env.globalEvents || new ET();

/**
 * Hosts YUI page level events.  This is where events bubble to
 * when the broadcast config is set to 2.  This property is
 * only available if the custom event module is loaded.
 * @property Global
 * @type EventTarget
 * @for YUI
 */
Y.Global = YUI.Env.globalEvents;

// @TODO implement a global namespace function on Y.Global?

/**
`Y.on()` can do many things:

<ul>
    <li>Subscribe to custom events `publish`ed and `fire`d from Y</li>
    <li>Subscribe to custom events `publish`ed with `broadcast` 1 or 2 and
        `fire`d from any object in the YUI instance sandbox</li>
    <li>Subscribe to DOM events</li>
    <li>Subscribe to the execution of a method on any object, effectively
    treating that method as an event</li>
</ul>

For custom event subscriptions, pass the custom event name as the first argument
and callback as the second. The `this` object in the callback will be `Y` unless
an override is passed as the third argument.

    Y.on('io:complete', function () {
        Y.MyApp.updateStatus('Transaction complete');
    });

To subscribe to DOM events, pass the name of a DOM event as the first argument
and a CSS selector string as the third argument after the callback function.
Alternately, the third argument can be a `Node`, `NodeList`, `HTMLElement`,
array, or simply omitted (the default is the `window` object).

    Y.on('click', function (e) {
        e.preventDefault();

        // proceed with ajax form submission
        var url = this.get('action');
        ...
    }, '#my-form');

The `this` object in DOM event callbacks will be the `Node` targeted by the CSS
selector or other identifier.

`on()` subscribers for DOM events or custom events `publish`ed with a
`defaultFn` can prevent the default behavior with `e.preventDefault()` from the
event object passed as the first parameter to the subscription callback.

To subscribe to the execution of an object method, pass arguments corresponding to the call signature for
<a href="../classes/Do.html#methods_before">`Y.Do.before(...)`</a>.

NOTE: The formal parameter list below is for events, not for function
injection.  See `Y.Do.before` for that signature.

@method on
@param {String} type DOM or custom event name
@param {Function} fn The callback to execute in response to the event
@param {Object} [context] Override `this` object in callback
@param {Any} [arg*] 0..n additional arguments to supply to the subscriber
@return {EventHandle} A subscription handle capable of detaching the
                      subscription
@see Do.before
@for YUI
**/

/**
Listen for an event one time.  Equivalent to `on()`, except that
the listener is immediately detached when executed.

See the <a href="#methods_on">`on()` method</a> for additional subscription
options.

@see on
@method once
@param {String} type DOM or custom event name
@param {Function} fn The callback to execute in response to the event
@param {Object} [context] Override `this` object in callback
@param {Any} [arg*] 0..n additional arguments to supply to the subscriber
@return {EventHandle} A subscription handle capable of detaching the
                      subscription
@for YUI
**/

/**
Listen for an event one time.  Equivalent to `once()`, except, like `after()`,
the subscription callback executes after all `on()` subscribers and the event's
`defaultFn` (if configured) have executed.  Like `after()` if any `on()` phase
subscriber calls `e.preventDefault()`, neither the `defaultFn` nor the `after()`
subscribers will execute.

The listener is immediately detached when executed.

See the <a href="#methods_on">`on()` method</a> for additional subscription
options.

@see once
@method onceAfter
@param {String} type The custom event name
@param {Function} fn The callback to execute in response to the event
@param {Object} [context] Override `this` object in callback
@param {Any} [arg*] 0..n additional arguments to supply to the subscriber
@return {EventHandle} A subscription handle capable of detaching the
                      subscription
@for YUI
**/

/**
Like `on()`, this method creates a subscription to a custom event or to the
execution of a method on an object.

For events, `after()` subscribers are executed after the event's
`defaultFn` unless `e.preventDefault()` was called from an `on()` subscriber.

See the <a href="#methods_on">`on()` method</a> for additional subscription
options.

NOTE: The subscription signature shown is for events, not for function
injection.  See <a href="../classes/Do.html#methods_after">`Y.Do.after`</a>
for that signature.

@see on
@see Do.after
@method after
@param {String} type The custom event name
@param {Function} fn The callback to execute in response to the event
@param {Object} [context] Override `this` object in callback
@param {Any} [args*] 0..n additional arguments to supply to the subscriber
@return {EventHandle} A subscription handle capable of detaching the
                      subscription
@for YUI
**/


}, '3.17.2', {"requires": ["oop"]});


/***/ }),

/***/ 606536:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-custom-complex', function (Y, NAME) {


/**
 * Adds event facades, preventable default behavior, and bubbling.
 * events.
 * @module event-custom
 * @submodule event-custom-complex
 */

var FACADE,
    FACADE_KEYS,
    YObject = Y.Object,
    key,
    EMPTY = {},
    CEProto = Y.CustomEvent.prototype,
    ETProto = Y.EventTarget.prototype,

    mixFacadeProps = function(facade, payload) {
        var p;

        for (p in payload) {
            if (!(FACADE_KEYS.hasOwnProperty(p))) {
                facade[p] = payload[p];
            }
        }
    };

/**
 * Wraps and protects a custom event for use when emitFacade is set to true.
 * Requires the event-custom-complex module
 * @class EventFacade
 * @param e {Event} the custom event
 * @param currentTarget {HTMLElement} the element the listener was attached to
 */

Y.EventFacade = function(e, currentTarget) {

    if (!e) {
        e = EMPTY;
    }

    this._event = e;

    /**
     * The arguments passed to fire
     * @property details
     * @type Array
     */
    this.details = e.details;

    /**
     * The event type, this can be overridden by the fire() payload
     * @property type
     * @type string
     */
    this.type = e.type;

    /**
     * The real event type
     * @property _type
     * @type string
     * @private
     */
    this._type = e.type;

    //////////////////////////////////////////////////////

    /**
     * Node reference for the targeted eventtarget
     * @property target
     * @type Node
     */
    this.target = e.target;

    /**
     * Node reference for the element that the listener was attached to.
     * @property currentTarget
     * @type Node
     */
    this.currentTarget = currentTarget;

    /**
     * Node reference to the relatedTarget
     * @property relatedTarget
     * @type Node
     */
    this.relatedTarget = e.relatedTarget;

};

Y.mix(Y.EventFacade.prototype, {

    /**
     * Stops the propagation to the next bubble target
     * @method stopPropagation
     */
    stopPropagation: function() {
        this._event.stopPropagation();
        this.stopped = 1;
    },

    /**
     * Stops the propagation to the next bubble target and
     * prevents any additional listeners from being exectued
     * on the current target.
     * @method stopImmediatePropagation
     */
    stopImmediatePropagation: function() {
        this._event.stopImmediatePropagation();
        this.stopped = 2;
    },

    /**
     * Prevents the event's default behavior
     * @method preventDefault
     */
    preventDefault: function() {
        this._event.preventDefault();
        this.prevented = 1;
    },

    /**
     * Stops the event propagation and prevents the default
     * event behavior.
     * @method halt
     * @param immediate {boolean} if true additional listeners
     * on the current target will not be executed
     */
    halt: function(immediate) {
        this._event.halt(immediate);
        this.prevented = 1;
        this.stopped = (immediate) ? 2 : 1;
    }

});

CEProto.fireComplex = function(args) {

    var es,
        ef,
        q,
        queue,
        ce,
        ret = true,
        events,
        subs,
        ons,
        afters,
        afterQueue,
        postponed,
        prevented,
        preventedFn,
        defaultFn,
        self = this,
        host = self.host || self,
        next,
        oldbubble,
        stack = self.stack,
        yuievt = host._yuievt,
        hasPotentialSubscribers;

    if (stack) {

        // queue this event if the current item in the queue bubbles
        if (self.queuable && self.type !== stack.next.type) {

            if (!stack.queue) {
                stack.queue = [];
            }
            stack.queue.push([self, args]);

            return true;
        }
    }

    hasPotentialSubscribers = self.hasSubs() || yuievt.hasTargets || self.broadcast;

    self.target = self.target || host;
    self.currentTarget = host;

    self.details = args.concat();

    if (hasPotentialSubscribers) {

        es = stack || {

           id: self.id, // id of the first event in the stack
           next: self,
           silent: self.silent,
           stopped: 0,
           prevented: 0,
           bubbling: null,
           type: self.type,
           // defaultFnQueue: new Y.Queue(),
           defaultTargetOnly: self.defaultTargetOnly

        };

        subs = self.getSubs();
        ons = subs[0];
        afters = subs[1];

        self.stopped = (self.type !== es.type) ? 0 : es.stopped;
        self.prevented = (self.type !== es.type) ? 0 : es.prevented;

        if (self.stoppedFn) {
            // PERF TODO: Can we replace with callback, like preventedFn. Look into history
            events = new Y.EventTarget({
                fireOnce: true,
                context: host
            });
            self.events = events;
            events.on('stopped', self.stoppedFn);
        }


        self._facade = null; // kill facade to eliminate stale properties

        ef = self._createFacade(args);

        if (ons) {
            self._procSubs(ons, args, ef);
        }

        // bubble if this is hosted in an event target and propagation has not been stopped
        if (self.bubbles && host.bubble && !self.stopped) {
            oldbubble = es.bubbling;

            es.bubbling = self.type;

            if (es.type !== self.type) {
                es.stopped = 0;
                es.prevented = 0;
            }

            ret = host.bubble(self, args, null, es);

            self.stopped = Math.max(self.stopped, es.stopped);
            self.prevented = Math.max(self.prevented, es.prevented);

            es.bubbling = oldbubble;
        }

        prevented = self.prevented;

        if (prevented) {
            preventedFn = self.preventedFn;
            if (preventedFn) {
                preventedFn.apply(host, args);
            }
        } else {
            defaultFn = self.defaultFn;

            if (defaultFn && ((!self.defaultTargetOnly && !es.defaultTargetOnly) || host === ef.target)) {
                defaultFn.apply(host, args);
            }
        }

        // broadcast listeners are fired as discreet events on the
        // YUI instance and potentially the YUI global.
        if (self.broadcast) {
            self._broadcast(args);
        }

        if (afters && !self.prevented && self.stopped < 2) {

            // Queue the after
            afterQueue = es.afterQueue;

            if (es.id === self.id || self.type !== yuievt.bubbling) {

                self._procSubs(afters, args, ef);

                if (afterQueue) {
                    while ((next = afterQueue.last())) {
                        next();
                    }
                }
            } else {
                postponed = afters;

                if (es.execDefaultCnt) {
                    postponed = Y.merge(postponed);

                    Y.each(postponed, function(s) {
                        s.postponed = true;
                    });
                }

                if (!afterQueue) {
                    es.afterQueue = new Y.Queue();
                }

                es.afterQueue.add(function() {
                    self._procSubs(postponed, args, ef);
                });
            }

        }

        self.target = null;

        if (es.id === self.id) {

            queue = es.queue;

            if (queue) {
                while (queue.length) {
                    q = queue.pop();
                    ce = q[0];
                    // set up stack to allow the next item to be processed
                    es.next = ce;
                    ce._fire(q[1]);
                }
            }

            self.stack = null;
        }

        ret = !(self.stopped);

        if (self.type !== yuievt.bubbling) {
            es.stopped = 0;
            es.prevented = 0;
            self.stopped = 0;
            self.prevented = 0;
        }

    } else {
        defaultFn = self.defaultFn;

        if(defaultFn) {
            ef = self._createFacade(args);

            if ((!self.defaultTargetOnly) || (host === ef.target)) {
                defaultFn.apply(host, args);
            }
        }
    }

    // Kill the cached facade to free up memory.
    // Otherwise we have the facade from the last fire, sitting around forever.
    self._facade = null;

    return ret;
};

/**
 * @method _hasPotentialSubscribers
 * @for CustomEvent
 * @private
 * @return {boolean} Whether the event has potential subscribers or not
 */
CEProto._hasPotentialSubscribers = function() {
    return this.hasSubs() || this.host._yuievt.hasTargets || this.broadcast;
};

/**
 * Internal utility method to create a new facade instance and
 * insert it into the fire argument list, accounting for any payload
 * merging which needs to happen.
 *
 * This used to be called `_getFacade`, but the name seemed inappropriate
 * when it was used without a need for the return value.
 *
 * @method _createFacade
 * @private
 * @param fireArgs {Array} The arguments passed to "fire", which need to be
 * shifted (and potentially merged) when the facade is added.
 * @return {EventFacade} The event facade created.
 */

// TODO: Remove (private) _getFacade alias, once synthetic.js is updated.
CEProto._createFacade = CEProto._getFacade = function(fireArgs) {

    var userArgs = this.details,
        firstArg = userArgs && userArgs[0],
        firstArgIsObj = (firstArg && (typeof firstArg === "object")),
        ef = this._facade;

    if (!ef) {
        ef = new Y.EventFacade(this, this.currentTarget);
    }

    if (firstArgIsObj) {
        // protect the event facade properties
        mixFacadeProps(ef, firstArg);

        // Allow the event type to be faked http://yuilibrary.com/projects/yui3/ticket/2528376
        if (firstArg.type) {
            ef.type = firstArg.type;
        }

        if (fireArgs) {
            fireArgs[0] = ef;
        }
    } else {
        if (fireArgs) {
            fireArgs.unshift(ef);
        }
    }

    // update the details field with the arguments
    ef.details = this.details;

    // use the original target when the event bubbled to this target
    ef.target = this.originalTarget || this.target;

    ef.currentTarget = this.currentTarget;
    ef.stopped = 0;
    ef.prevented = 0;

    this._facade = ef;

    return this._facade;
};

/**
 * Utility method to manipulate the args array passed in, to add the event facade,
 * if it's not already the first arg.
 *
 * @method _addFacadeToArgs
 * @private
 * @param {Array} The arguments to manipulate
 */
CEProto._addFacadeToArgs = function(args) {
    var e = args[0];

    // Trying not to use instanceof, just to avoid potential cross Y edge case issues.
    if (!(e && e.halt && e.stopImmediatePropagation && e.stopPropagation && e._event)) {
        this._createFacade(args);
    }
};

/**
 * Stop propagation to bubble targets
 * @for CustomEvent
 * @method stopPropagation
 */
CEProto.stopPropagation = function() {
    this.stopped = 1;
    if (this.stack) {
        this.stack.stopped = 1;
    }
    if (this.events) {
        this.events.fire('stopped', this);
    }
};

/**
 * Stops propagation to bubble targets, and prevents any remaining
 * subscribers on the current target from executing.
 * @method stopImmediatePropagation
 */
CEProto.stopImmediatePropagation = function() {
    this.stopped = 2;
    if (this.stack) {
        this.stack.stopped = 2;
    }
    if (this.events) {
        this.events.fire('stopped', this);
    }
};

/**
 * Prevents the execution of this event's defaultFn
 * @method preventDefault
 */
CEProto.preventDefault = function() {
    if (this.preventable) {
        this.prevented = 1;
        if (this.stack) {
            this.stack.prevented = 1;
        }
    }
};

/**
 * Stops the event propagation and prevents the default
 * event behavior.
 * @method halt
 * @param immediate {boolean} if true additional listeners
 * on the current target will not be executed
 */
CEProto.halt = function(immediate) {
    if (immediate) {
        this.stopImmediatePropagation();
    } else {
        this.stopPropagation();
    }
    this.preventDefault();
};

/**
 * Registers another EventTarget as a bubble target.  Bubble order
 * is determined by the order registered.  Multiple targets can
 * be specified.
 *
 * Events can only bubble if emitFacade is true.
 *
 * Included in the event-custom-complex submodule.
 *
 * @method addTarget
 * @chainable
 * @param o {EventTarget} the target to add
 * @for EventTarget
 */
ETProto.addTarget = function(o) {
    var etState = this._yuievt;

    if (!etState.targets) {
        etState.targets = {};
    }

    etState.targets[Y.stamp(o)] = o;
    etState.hasTargets = true;

    return this;
};

/**
 * Returns an array of bubble targets for this object.
 * @method getTargets
 * @return EventTarget[]
 */
ETProto.getTargets = function() {
    var targets = this._yuievt.targets;
    return targets ? YObject.values(targets) : [];
};

/**
 * Removes a bubble target
 * @method removeTarget
 * @chainable
 * @param o {EventTarget} the target to remove
 * @for EventTarget
 */
ETProto.removeTarget = function(o) {
    var targets = this._yuievt.targets;

    if (targets) {
        delete targets[Y.stamp(o, true)];

        if (YObject.size(targets) === 0) {
            this._yuievt.hasTargets = false;
        }
    }

    return this;
};

/**
 * Propagate an event.  Requires the event-custom-complex module.
 * @method bubble
 * @param evt {CustomEvent} the custom event to propagate
 * @return {boolean} the aggregated return value from Event.Custom.fire
 * @for EventTarget
 */
ETProto.bubble = function(evt, args, target, es) {

    var targs = this._yuievt.targets,
        ret = true,
        t,
        ce,
        i,
        bc,
        ce2,
        type = evt && evt.type,
        originalTarget = target || (evt && evt.target) || this,
        oldbubble;

    if (!evt || ((!evt.stopped) && targs)) {

        for (i in targs) {
            if (targs.hasOwnProperty(i)) {

                t = targs[i];

                ce = t._yuievt.events[type];

                if (t._hasSiblings) {
                    ce2 = t.getSibling(type, ce);
                }

                if (ce2 && !ce) {
                    ce = t.publish(type);
                }

                oldbubble = t._yuievt.bubbling;
                t._yuievt.bubbling = type;

                // if this event was not published on the bubble target,
                // continue propagating the event.
                if (!ce) {
                    if (t._yuievt.hasTargets) {
                        t.bubble(evt, args, originalTarget, es);
                    }
                } else {

                    if (ce2) {
                        ce.sibling = ce2;
                    }

                    // set the original target to that the target payload on the facade is correct.
                    ce.target = originalTarget;
                    ce.originalTarget = originalTarget;
                    ce.currentTarget = t;
                    bc = ce.broadcast;
                    ce.broadcast = false;

                    // default publish may not have emitFacade true -- that
                    // shouldn't be what the implementer meant to do
                    ce.emitFacade = true;

                    ce.stack = es;

                    // TODO: See what's getting in the way of changing this to use
                    // the more performant ce._fire(args || evt.details || []).

                    // Something in Widget Parent/Child tests is not happy if we
                    // change it - maybe evt.details related?
                    ret = ret && ce.fire.apply(ce, args || evt.details || []);

                    ce.broadcast = bc;
                    ce.originalTarget = null;

                    // stopPropagation() was called
                    if (ce.stopped) {
                        break;
                    }
                }

                t._yuievt.bubbling = oldbubble;
            }
        }
    }

    return ret;
};

/**
 * @method _hasPotentialSubscribers
 * @for EventTarget
 * @private
 * @param {String} fullType The fully prefixed type name
 * @return {boolean} Whether the event has potential subscribers or not
 */
ETProto._hasPotentialSubscribers = function(fullType) {

    var etState = this._yuievt,
        e = etState.events[fullType];

    if (e) {
        return e.hasSubs() || etState.hasTargets  || e.broadcast;
    } else {
        return false;
    }
};

FACADE = new Y.EventFacade();
FACADE_KEYS = {};

// Flatten whitelist
for (key in FACADE) {
    FACADE_KEYS[key] = true;
}


}, '3.17.2', {"requires": ["event-custom-base"]});


/***/ }),

/***/ 33146:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-delegate', function (Y, NAME) {

/**
 * Adds event delegation support to the library.
 *
 * @module event
 * @submodule event-delegate
 */

var toArray          = Y.Array,
    YLang            = Y.Lang,
    isString         = YLang.isString,
    isObject         = YLang.isObject,
    isArray          = YLang.isArray,
    selectorTest     = Y.Selector.test,
    detachCategories = Y.Env.evt.handles;

/**
 * <p>Sets up event delegation on a container element.  The delegated event
 * will use a supplied selector or filtering function to test if the event
 * references at least one node that should trigger the subscription
 * callback.</p>
 *
 * <p>Selector string filters will trigger the callback if the event originated
 * from a node that matches it or is contained in a node that matches it.
 * Function filters are called for each Node up the parent axis to the
 * subscribing container node, and receive at each level the Node and the event
 * object.  The function should return true (or a truthy value) if that Node
 * should trigger the subscription callback.  Note, it is possible for filters
 * to match multiple Nodes for a single event.  In this case, the delegate
 * callback will be executed for each matching Node.</p>
 *
 * <p>For each matching Node, the callback will be executed with its 'this'
 * object set to the Node matched by the filter (unless a specific context was
 * provided during subscription), and the provided event's
 * <code>currentTarget</code> will also be set to the matching Node.  The
 * containing Node from which the subscription was originally made can be
 * referenced as <code>e.container</code>.
 *
 * @method delegate
 * @param type {String} the event type to delegate
 * @param fn {Function} the callback function to execute.  This function
 *              will be provided the event object for the delegated event.
 * @param el {String|node} the element that is the delegation container
 * @param filter {string|Function} a selector that must match the target of the
 *              event or a function to test target and its parents for a match
 * @param context optional argument that specifies what 'this' refers to.
 * @param args* 0..n additional arguments to pass on to the callback function.
 *              These arguments will be added after the event object.
 * @return {EventHandle} the detach handle
 * @static
 * @for Event
 */
function delegate(type, fn, el, filter) {
    var args     = toArray(arguments, 0, true),
        query    = isString(el) ? el : null,
        typeBits, synth, container, categories, cat, i, len, handles, handle;

    // Support Y.delegate({ click: fnA, key: fnB }, el, filter, ...);
    // and Y.delegate(['click', 'key'], fn, el, filter, ...);
    if (isObject(type)) {
        handles = [];

        if (isArray(type)) {
            for (i = 0, len = type.length; i < len; ++i) {
                args[0] = type[i];
                handles.push(Y.delegate.apply(Y, args));
            }
        } else {
            // Y.delegate({'click', fn}, el, filter) =>
            // Y.delegate('click', fn, el, filter)
            args.unshift(null); // one arg becomes two; need to make space

            for (i in type) {
                if (type.hasOwnProperty(i)) {
                    args[0] = i;
                    args[1] = type[i];
                    handles.push(Y.delegate.apply(Y, args));
                }
            }
        }

        return new Y.EventHandle(handles);
    }

    typeBits = type.split(/\|/);

    if (typeBits.length > 1) {
        cat  = typeBits.shift();
        args[0] = type = typeBits.shift();
    }

    synth = Y.Node.DOM_EVENTS[type];

    if (isObject(synth) && synth.delegate) {
        handle = synth.delegate.apply(synth, arguments);
    }

    if (!handle) {
        if (!type || !fn || !el || !filter) {
            return;
        }

        container = (query) ? Y.Selector.query(query, null, true) : el;

        if (!container && isString(el)) {
            handle = Y.on('available', function () {
                Y.mix(handle, Y.delegate.apply(Y, args), true);
            }, el);
        }

        if (!handle && container) {
            args.splice(2, 2, container); // remove the filter

            handle = Y.Event._attach(args, { facade: false });
            handle.sub.filter  = filter;
            handle.sub._notify = delegate.notifySub;
        }
    }

    if (handle && cat) {
        categories = detachCategories[cat]  || (detachCategories[cat] = {});
        categories = categories[type] || (categories[type] = []);
        categories.push(handle);
    }

    return handle;
}

/**
Overrides the <code>_notify</code> method on the normal DOM subscription to
inject the filtering logic and only proceed in the case of a match.

This method is hosted as a private property of the `delegate` method
(e.g. `Y.delegate.notifySub`)

@method notifySub
@param thisObj {Object} default 'this' object for the callback
@param args {Array} arguments passed to the event's <code>fire()</code>
@param ce {CustomEvent} the custom event managing the DOM subscriptions for
             the subscribed event on the subscribing node.
@return {Boolean} false if the event was stopped
@private
@static
@since 3.2.0
**/
delegate.notifySub = function (thisObj, args, ce) {
    // Preserve args for other subscribers
    args = args.slice();
    if (this.args) {
        args.push.apply(args, this.args);
    }

    // Only notify subs if the event occurred on a targeted element
    var currentTarget = delegate._applyFilter(this.filter, args, ce),
        //container     = e.currentTarget,
        e, i, len, ret;

    if (currentTarget) {
        // Support multiple matches up the the container subtree
        currentTarget = toArray(currentTarget);

        // The second arg is the currentTarget, but we'll be reusing this
        // facade, replacing the currentTarget for each use, so it doesn't
        // matter what element we seed it with.
        e = args[0] = new Y.DOMEventFacade(args[0], ce.el, ce);

        e.container = Y.one(ce.el);

        for (i = 0, len = currentTarget.length; i < len && !e.stopped; ++i) {
            e.currentTarget = Y.one(currentTarget[i]);

            ret = this.fn.apply(this.context || e.currentTarget, args);

            if (ret === false) { // stop further notifications
                break;
            }
        }

        return ret;
    }
};

/**
Compiles a selector string into a filter function to identify whether
Nodes along the parent axis of an event's target should trigger event
notification.

This function is memoized, so previously compiled filter functions are
returned if the same selector string is provided.

This function may be useful when defining synthetic events for delegate
handling.

Hosted as a property of the `delegate` method (e.g. `Y.delegate.compileFilter`).

@method compileFilter
@param selector {String} the selector string to base the filtration on
@return {Function}
@since 3.2.0
@static
**/
delegate.compileFilter = Y.cached(function (selector) {
    return function (target, e) {
        return selectorTest(target._node, selector,
            (e.currentTarget === e.target) ? null : e.currentTarget._node);
    };
});

/**
Regex to test for disabled elements during filtering. This is only relevant to
IE to normalize behavior with other browsers, which swallow events that occur
to disabled elements. IE fires the event from the parent element instead of the
original target, though it does preserve `event.srcElement` as the disabled
element. IE also supports disabled on `<a>`, but the event still bubbles, so it
acts more like `e.preventDefault()` plus styling. That issue is not handled here
because other browsers fire the event on the `<a>`, so delegate is supported in
both cases.

@property _disabledRE
@type {RegExp}
@protected
@since 3.8.1
**/
delegate._disabledRE = /^(?:button|input|select|textarea)$/i;

/**
Walks up the parent axis of an event's target, and tests each element
against a supplied filter function.  If any Nodes, including the container,
satisfy the filter, the delegated callback will be triggered for each.

Hosted as a protected property of the `delegate` method (e.g.
`Y.delegate._applyFilter`).

@method _applyFilter
@param filter {Function} boolean function to test for inclusion in event
                 notification
@param args {Array} the arguments that would be passed to subscribers
@param ce   {CustomEvent} the DOM event wrapper
@return {Node|Node[]|undefined} The Node or Nodes that satisfy the filter
@protected
**/
delegate._applyFilter = function (filter, args, ce) {
    var e         = args[0],
        container = ce.el, // facadeless events in IE, have no e.currentTarget
        target    = e.target || e.srcElement,
        match     = [],
        isContainer = false;

    // safari svg element fix -bc
    if (typeof SVGElementInstance !== 'undefined') {
        if (!target.nodeType && target.correspondingElement) {
            target = target.correspondingUseElement || target.correspondingElement;
        }
    }

    // Resolve text nodes to their containing element
    if (target.nodeType === 3) {
        target = target.parentNode;
    }

    // For IE. IE propagates events from the parent element of disabled
    // elements, where other browsers swallow the event entirely. To normalize
    // this in IE, filtering for matching elements should abort if the target
    // is a disabled form control.
    if (target.disabled && delegate._disabledRE.test(target.nodeName)) {
        return match;
    }

    // passing target as the first arg rather than leaving well enough alone
    // making 'this' in the filter function refer to the target.  This is to
    // support bound filter functions.
    args.unshift(target);

    if (isString(filter)) {
        while (target) {
            isContainer = (target === container);
            if (selectorTest(target, filter, (isContainer ? null: container))) {
                match.push(target);
            }

            if (isContainer) {
                break;
            }

            target = target.parentNode;
        }
    } else {
        // filter functions are implementer code and should receive wrappers
        args[0] = Y.one(target);
        args[1] = new Y.DOMEventFacade(e, container, ce);

        while (target) {
            // filter(target, e, extra args...) - this === target
            if (filter.apply(args[0], args)) {
                match.push(target);
            }

            if (target === container) {
                break;
            }

            target = target.parentNode;
            args[0] = Y.one(target);
        }
        args[1] = e; // restore the raw DOM event
    }

    if (match.length <= 1) {
        match = match[0]; // single match or undefined
    }

    // remove the target
    args.shift();

    return match;
};

/**
 * Sets up event delegation on a container element.  The delegated event
 * will use a supplied filter to test if the callback should be executed.
 * This filter can be either a selector string or a function that returns
 * a Node to use as the currentTarget for the event.
 *
 * The event object for the delegated event is supplied to the callback
 * function.  It is modified slightly in order to support all properties
 * that may be needed for event delegation.  'currentTarget' is set to
 * the element that matched the selector string filter or the Node returned
 * from the filter function.  'container' is set to the element that the
 * listener is delegated from (this normally would be the 'currentTarget').
 *
 * Filter functions will be called with the arguments that would be passed to
 * the callback function, including the event object as the first parameter.
 * The function should return false (or a falsey value) if the success criteria
 * aren't met, and the Node to use as the event's currentTarget and 'this'
 * object if they are.
 *
 * @method delegate
 * @param type {string} the event type to delegate
 * @param fn {function} the callback function to execute.  This function
 * will be provided the event object for the delegated event.
 * @param el {string|node} the element that is the delegation container
 * @param filter {string|function} a selector that must match the target of the
 * event or a function that returns a Node or false.
 * @param context optional argument that specifies what 'this' refers to.
 * @param args* 0..n additional arguments to pass on to the callback function.
 * These arguments will be added after the event object.
 * @return {EventHandle} the detach handle
 * @for YUI
 */
Y.delegate = Y.Event.delegate = delegate;


}, '3.17.2', {"requires": ["node-base"]});


/***/ }),

/***/ 773452:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-flick', function (Y, NAME) {

/**
 * The gestures module provides gesture events such as "flick", which normalize user interactions
 * across touch and mouse or pointer based input devices. This layer can be used by application developers
 * to build input device agnostic components which behave the same in response to either touch or mouse based
 * interaction.
 *
 * <p>Documentation for events added by this module can be found in the event document for the <a href="../classes/YUI.html#events">YUI</a> global.</p>
 *
 *
 @example

     YUI().use('event-flick', function (Y) {
         Y.one('#myNode').on('flick', function (e) {
         });
     });

 *
 * @module event-gestures
 */

/**
 * Adds support for a "flick" event, which is fired at the end of a touch or mouse based flick gesture, and provides
 * velocity of the flick, along with distance and time information.
 *
 * <p>Documentation for the flick event can be found on the <a href="../classes/YUI.html#event_flick">YUI</a> global,
 * along with the other supported events.</p>
 *
 * @module event-gestures
 * @submodule event-flick
 */
var GESTURE_MAP = Y.Event._GESTURE_MAP,
    EVENT = {
        start: GESTURE_MAP.start,
        end: GESTURE_MAP.end,
        move: GESTURE_MAP.move
    },
    START = "start",
    END = "end",
    MOVE = "move",

    OWNER_DOCUMENT = "ownerDocument",
    MIN_VELOCITY = "minVelocity",
    MIN_DISTANCE = "minDistance",
    PREVENT_DEFAULT = "preventDefault",

    _FLICK_START = "_fs",
    _FLICK_START_HANDLE = "_fsh",
    _FLICK_END_HANDLE = "_feh",
    _FLICK_MOVE_HANDLE = "_fmh",

    NODE_TYPE = "nodeType";

/**
 * Sets up a "flick" event, that is fired whenever the user initiates a flick gesture on the node
 * where the listener is attached. The subscriber can specify a minimum distance or velocity for
 * which the event is to be fired. The subscriber can also specify if there is a particular axis which
 * they are interested in - "x" or "y". If no axis is specified, the axis along which there was most distance
 * covered is used.
 *
 * <p>It is recommended that you use Y.bind to set up context and additional arguments for your event handler,
 * however if you want to pass the context and arguments as additional signature arguments to "on",
 * you need to provide a null value for the configuration object, e.g: <code>node.on("flick", fn, null, context, arg1, arg2, arg3)</code></p>
 *
 * @event flick
 * @for YUI
 * @param type {string} "flick"
 * @param fn {function} The method the event invokes. It receives an event facade with an e.flick object containing the flick related properties: e.flick.time, e.flick.distance, e.flick.velocity and e.flick.axis, e.flick.start.
 * @param cfg {Object} Optional. An object which specifies any of the following:
 * <dl>
 * <dt>minDistance (in pixels, defaults to 10)</dt>
 * <dd>The minimum distance between start and end points, which would qualify the gesture as a flick.</dd>
 * <dt>minVelocity (in pixels/ms, defaults to 0)</dt>
 * <dd>The minimum velocity which would qualify the gesture as a flick.</dd>
 * <dt>preventDefault (defaults to false)</dt>
 * <dd>Can be set to true/false to prevent default behavior as soon as the touchstart/touchend or mousedown/mouseup is received so that things like scrolling or text selection can be
 * prevented. This property can also be set to a function, which returns true or false, based on the event facade passed to it.</dd>
 * <dt>axis (no default)</dt>
 * <dd>Can be set to "x" or "y" if you want to constrain the flick velocity and distance to a single axis. If not
 * defined, the axis along which the maximum distance was covered is used.</dd>
 * </dl>
 * @return {EventHandle} the detach handle
 */

Y.Event.define('flick', {

    on: function (node, subscriber, ce) {

        var startHandle = node.on(EVENT[START],
            this._onStart,
            this,
            node,
            subscriber,
            ce);

        subscriber[_FLICK_START_HANDLE] = startHandle;
    },

    detach: function (node, subscriber, ce) {

        var startHandle = subscriber[_FLICK_START_HANDLE],
            endHandle = subscriber[_FLICK_END_HANDLE];

        if (startHandle) {
            startHandle.detach();
            subscriber[_FLICK_START_HANDLE] = null;
        }

        if (endHandle) {
            endHandle.detach();
            subscriber[_FLICK_END_HANDLE] = null;
        }
    },

    processArgs: function(args) {
        var params = (args.length > 3) ? Y.merge(args.splice(3, 1)[0]) : {};

        if (!(MIN_VELOCITY in params)) {
            params[MIN_VELOCITY] = this.MIN_VELOCITY;
        }

        if (!(MIN_DISTANCE in params)) {
            params[MIN_DISTANCE] = this.MIN_DISTANCE;
        }

        if (!(PREVENT_DEFAULT in params)) {
            params[PREVENT_DEFAULT] = this.PREVENT_DEFAULT;
        }

        return params;
    },

    _onStart: function(e, node, subscriber, ce) {

        var start = true, // always true for mouse
            endHandle,
            moveHandle,
            doc,
            preventDefault = subscriber._extra.preventDefault,
            origE = e;

        if (e.touches) {
            start = (e.touches.length === 1);
            e = e.touches[0];
        }

        if (start) {

            if (preventDefault) {
                // preventDefault is a boolean or function
                if (!preventDefault.call || preventDefault(e)) {
                    origE.preventDefault();
                }
            }

            e.flick = {
                time : new Date().getTime()
            };

            subscriber[_FLICK_START] = e;

            endHandle = subscriber[_FLICK_END_HANDLE];

            doc = (node.get(NODE_TYPE) === 9) ? node : node.get(OWNER_DOCUMENT);
            if (!endHandle) {
                endHandle = doc.on(EVENT[END], Y.bind(this._onEnd, this), null, node, subscriber, ce);
                subscriber[_FLICK_END_HANDLE] = endHandle;
            }

            subscriber[_FLICK_MOVE_HANDLE] = doc.once(EVENT[MOVE], Y.bind(this._onMove, this), null, node, subscriber, ce);
        }
    },

    _onMove: function(e, node, subscriber, ce) {
        var start = subscriber[_FLICK_START];

        // Start timing from first move.
        if (start && start.flick) {
            start.flick.time = new Date().getTime();
        }
    },

    _onEnd: function(e, node, subscriber, ce) {

        var endTime = new Date().getTime(),
            start = subscriber[_FLICK_START],
            valid = !!start,
            endEvent = e,
            startTime,
            time,
            preventDefault,
            params,
            xyDistance,
            distance,
            velocity,
            axis,
            moveHandle = subscriber[_FLICK_MOVE_HANDLE];

        if (moveHandle) {
            moveHandle.detach();
            delete subscriber[_FLICK_MOVE_HANDLE];
        }

        if (valid) {

            if (e.changedTouches) {
                if (e.changedTouches.length === 1 && e.touches.length === 0) {
                    endEvent = e.changedTouches[0];
                } else {
                    valid = false;
                }
            }

            if (valid) {

                params = subscriber._extra;
                preventDefault = params[PREVENT_DEFAULT];

                if (preventDefault) {
                    // preventDefault is a boolean or function
                    if (!preventDefault.call || preventDefault(e)) {
                        e.preventDefault();
                    }
                }

                startTime = start.flick.time;
                endTime = new Date().getTime();
                time = endTime - startTime;

                xyDistance = [
                    endEvent.pageX - start.pageX,
                    endEvent.pageY - start.pageY
                ];

                if (params.axis) {
                    axis = params.axis;
                } else {
                    axis = (Math.abs(xyDistance[0]) >= Math.abs(xyDistance[1])) ? 'x' : 'y';
                }

                distance = xyDistance[(axis === 'x') ? 0 : 1];
                velocity = (time !== 0) ? distance/time : 0;

                if (isFinite(velocity) && (Math.abs(distance) >= params[MIN_DISTANCE]) && (Math.abs(velocity)  >= params[MIN_VELOCITY])) {

                    e.type = "flick";
                    e.flick = {
                        time:time,
                        distance: distance,
                        velocity:velocity,
                        axis: axis,
                        start : start
                    };

                    ce.fire(e);

                }

                subscriber[_FLICK_START] = null;
            }
        }
    },

    MIN_VELOCITY : 0,
    MIN_DISTANCE : 0,
    PREVENT_DEFAULT : false
});


}, '3.17.2', {"requires": ["node-base", "event-touch", "event-synthetic"]});


/***/ }),

/***/ 950122:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-focus', function (Y, NAME) {

/**
 * Adds bubbling and delegation support to DOM events focus and blur.
 *
 * @module event
 * @submodule event-focus
 */
var Event    = Y.Event,

    YLang    = Y.Lang,

    isString = YLang.isString,

    arrayIndex = Y.Array.indexOf,

    useActivate = (function() {

        // Changing the structure of this test, so that it doesn't use inline JS in HTML,
        // which throws an exception in Win8 packaged apps, due to additional security restrictions:
        // http://msdn.microsoft.com/en-us/library/windows/apps/hh465380.aspx#differences

        var supported = false,
            doc = Y.config.doc,
            p;

        if (doc) {

            p = doc.createElement("p");
            p.setAttribute("onbeforeactivate", ";");

            // onbeforeactivate is a function in IE8+.
            // onbeforeactivate is a string in IE6,7 (unfortunate, otherwise we could have just checked for function below).
            // onbeforeactivate is a function in IE10, in a Win8 App environment (no exception running the test).

            // onbeforeactivate is undefined in Webkit/Gecko.
            // onbeforeactivate is a function in Webkit/Gecko if it's a supported event (e.g. onclick).

            supported = (p.onbeforeactivate !== undefined);
        }

        return supported;
    }());

function define(type, proxy, directEvent) {
    var nodeDataKey = '_' + type + 'Notifiers';

    Y.Event.define(type, {

        _useActivate : useActivate,

        _attach: function (el, notifier, delegate) {
            if (Y.DOM.isWindow(el)) {
                return Event._attach([type, function (e) {
                    notifier.fire(e);
                }, el]);
            } else {
                return Event._attach(
                    [proxy, this._proxy, el, this, notifier, delegate],
                    { capture: true });
            }
        },

        _proxy: function (e, notifier, delegate) {
            var target        = e.target,
                currentTarget = e.currentTarget,
                notifiers     = target.getData(nodeDataKey),
                yuid          = Y.stamp(currentTarget._node),
                defer         = (useActivate || target !== currentTarget),
                directSub;

            notifier.currentTarget = (delegate) ? target : currentTarget;
            notifier.container     = (delegate) ? currentTarget : null;

            // Maintain a list to handle subscriptions from nested
            // containers div#a>div#b>input #a.on(focus..) #b.on(focus..),
            // use one focus or blur subscription that fires notifiers from
            // #b then #a to emulate bubble sequence.
            if (!notifiers) {
                notifiers = {};
                target.setData(nodeDataKey, notifiers);

                // only subscribe to the element's focus if the target is
                // not the current target (
                if (defer) {
                    directSub = Event._attach(
                        [directEvent, this._notify, target._node]).sub;
                    directSub.once = true;
                }
            } else {
                // In old IE, defer is always true.  In capture-phase browsers,
                // The delegate subscriptions will be encountered first, which
                // will establish the notifiers data and direct subscription
                // on the node.  If there is also a direct subscription to the
                // node's focus/blur, it should not call _notify because the
                // direct subscription from the delegate sub(s) exists, which
                // will call _notify.  So this avoids _notify being called
                // twice, unnecessarily.
                defer = true;
            }

            if (!notifiers[yuid]) {
                notifiers[yuid] = [];
            }

            notifiers[yuid].push(notifier);

            if (!defer) {
                this._notify(e);
            }
        },

        _notify: function (e, container) {
            var currentTarget = e.currentTarget,
                notifierData  = currentTarget.getData(nodeDataKey),
                axisNodes     = currentTarget.ancestors(),
                doc           = currentTarget.get('ownerDocument'),
                delegates     = [],
                                // Used to escape loops when there are no more
                                // notifiers to consider
                count         = notifierData ?
                                    Y.Object.keys(notifierData).length :
                                    0,
                target, notifiers, notifier, yuid, match, tmp, i, len, sub, ret;

            // clear the notifications list (mainly for delegation)
            currentTarget.clearData(nodeDataKey);

            // Order the delegate subs by their placement in the parent axis
            axisNodes.push(currentTarget);
            // document.get('ownerDocument') returns null
            // which we'll use to prevent having duplicate Nodes in the list
            if (doc) {
                axisNodes.unshift(doc);
            }

            // ancestors() returns the Nodes from top to bottom
            axisNodes._nodes.reverse();

            if (count) {
                // Store the count for step 2
                tmp = count;
                axisNodes.some(function (node) {
                    var yuid      = Y.stamp(node),
                        notifiers = notifierData[yuid],
                        i, len;

                    if (notifiers) {
                        count--;
                        for (i = 0, len = notifiers.length; i < len; ++i) {
                            if (notifiers[i].handle.sub.filter) {
                                delegates.push(notifiers[i]);
                            }
                        }
                    }

                    return !count;
                });
                count = tmp;
            }

            // Walk up the parent axis, notifying direct subscriptions and
            // testing delegate filters.
            while (count && (target = axisNodes.shift())) {
                yuid = Y.stamp(target);

                notifiers = notifierData[yuid];

                if (notifiers) {
                    for (i = 0, len = notifiers.length; i < len; ++i) {
                        notifier = notifiers[i];
                        sub      = notifier.handle.sub;
                        match    = true;

                        e.currentTarget = target;

                        if (sub.filter) {
                            match = sub.filter.apply(target,
                                [target, e].concat(sub.args || []));

                            // No longer necessary to test against this
                            // delegate subscription for the nodes along
                            // the parent axis.
                            delegates.splice(
                                arrayIndex(delegates, notifier), 1);
                        }

                        if (match) {
                            // undefined for direct subs
                            e.container = notifier.container;
                            ret = notifier.fire(e);
                        }

                        if (ret === false || e.stopped === 2) {
                            break;
                        }
                    }

                    delete notifiers[yuid];
                    count--;
                }

                if (e.stopped !== 2) {
                    // delegates come after subs targeting this specific node
                    // because they would not normally report until they'd
                    // bubbled to the container node.
                    for (i = 0, len = delegates.length; i < len; ++i) {
                        notifier = delegates[i];
                        sub = notifier.handle.sub;

                        if (sub.filter.apply(target,
                            [target, e].concat(sub.args || []))) {

                            e.container = notifier.container;
                            e.currentTarget = target;
                            ret = notifier.fire(e);
                        }

                        if (ret === false || e.stopped === 2 ||
                            // If e.stopPropagation() is called, notify any
                            // delegate subs from the same container, but break
                            // once the container changes. This emulates
                            // delegate() behavior for events like 'click' which
                            // won't notify delegates higher up the parent axis.
                            (e.stopped && delegates[i+1] &&
                             delegates[i+1].container !== notifier.container)) {
                            break;
                        }
                    }
                }

                if (e.stopped) {
                    break;
                }
            }
        },

        on: function (node, sub, notifier) {
            sub.handle = this._attach(node._node, notifier);
        },

        detach: function (node, sub) {
            sub.handle.detach();
        },

        delegate: function (node, sub, notifier, filter) {
            if (isString(filter)) {
                sub.filter = function (target) {
                    return Y.Selector.test(target._node, filter,
                        node === target ? null : node._node);
                };
            }

            sub.handle = this._attach(node._node, notifier, true);
        },

        detachDelegate: function (node, sub) {
            sub.handle.detach();
        }
    }, true);
}

// For IE, we need to defer to focusin rather than focus because
// `el.focus(); doSomething();` executes el.onbeforeactivate, el.onactivate,
// el.onfocusin, doSomething, then el.onfocus.  All others support capture
// phase focus, which executes before doSomething.  To guarantee consistent
// behavior for this use case, IE's direct subscriptions are made against
// focusin so subscribers will be notified before js following el.focus() is
// executed.
if (useActivate) {
    //     name     capture phase       direct subscription
    define("focus", "beforeactivate",   "focusin");
    define("blur",  "beforedeactivate", "focusout");
} else {
    define("focus", "focus", "focus");
    define("blur",  "blur",  "blur");
}


}, '3.17.2', {"requires": ["event-synthetic"]});


/***/ }),

/***/ 105495:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-hover', function (Y, NAME) {

/**
 * Adds support for a "hover" event.  The event provides a convenience wrapper
 * for subscribing separately to mouseenter and mouseleave.  The signature for
 * subscribing to the event is</p>
 *
 * <pre><code>node.on("hover", overFn, outFn);
 * node.delegate("hover", overFn, outFn, ".filterSelector");
 * Y.on("hover", overFn, outFn, ".targetSelector");
 * Y.delegate("hover", overFn, outFn, "#container", ".filterSelector");
 * </code></pre>
 *
 * <p>Additionally, for compatibility with a more typical subscription
 * signature, the following are also supported:</p>
 *
 * <pre><code>Y.on("hover", overFn, ".targetSelector", outFn);
 * Y.delegate("hover", overFn, "#container", outFn, ".filterSelector");
 * </code></pre>
 *
 * @module event
 * @submodule event-hover
 */
var isFunction = Y.Lang.isFunction,
    noop = function () {},
    conf = {
        processArgs: function (args) {
            // Y.delegate('hover', over, out, '#container', '.filter')
            // comes in as ['hover', over, out, '#container', '.filter'], but
            // node.delegate('hover', over, out, '.filter')
            // comes in as ['hover', over, containerEl, out, '.filter']
            var i = isFunction(args[2]) ? 2 : 3;

            return (isFunction(args[i])) ? args.splice(i,1)[0] : noop;
        },

        on: function (node, sub, notifier, filter) {
            var args = (sub.args) ? sub.args.slice() : [];

            args.unshift(null);

            sub._detach = node[(filter) ? "delegate" : "on"]({
                mouseenter: function (e) {
                    e.phase = 'over';
                    notifier.fire(e);
                },
                mouseleave: function (e) {
                    var thisObj = sub.context || this;

                    args[0] = e;

                    e.type = 'hover';
                    e.phase = 'out';
                    sub._extra.apply(thisObj, args);
                }
            }, filter);
        },

        detach: function (node, sub, notifier) {
            sub._detach.detach();
        }
    };

conf.delegate = conf.on;
conf.detachDelegate = conf.detach;

Y.Event.define("hover", conf);


}, '3.17.2', {"requires": ["event-mouseenter"]});


/***/ }),

/***/ 425851:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-key', function (Y, NAME) {

/**
 * Functionality to listen for one or more specific key combinations.
 * @module event
 * @submodule event-key
 */

var ALT      = "+alt",
    CTRL     = "+ctrl",
    META     = "+meta",
    SHIFT    = "+shift",

    trim     = Y.Lang.trim,

    eventDef = {
        KEY_MAP: {
            enter    : 13,
            space    : 32,
            esc      : 27,
            backspace: 8,
            tab      : 9,
            pageup   : 33,
            pagedown : 34
        },

        _typeRE: /^(up|down|press):/,
        _keysRE: /^(?:up|down|press):|\+(alt|ctrl|meta|shift)/g,

        processArgs: function (args) {
            var spec = args.splice(3,1)[0],
                mods = Y.Array.hash(spec.match(/\+(?:alt|ctrl|meta|shift)\b/g) || []),
                config = {
                    type: this._typeRE.test(spec) ? RegExp.$1 : null,
                    mods: mods,
                    keys: null
                },
                // strip type and modifiers from spec, leaving only keyCodes
                bits = spec.replace(this._keysRE, ''),
                chr, uc, lc, i;

            if (bits) {
                bits = bits.split(',');

                config.keys = {};

                // FIXME: need to support '65,esc' => keypress, keydown
                for (i = bits.length - 1; i >= 0; --i) {
                    chr = trim(bits[i]);

                    // catch sloppy filters, trailing commas, etc 'a,,'
                    if (!chr) {
                        continue;
                    }

                    // non-numerics are single characters or key names
                    if (+chr == chr) {
                        config.keys[chr] = mods;
                    } else {
                        lc = chr.toLowerCase();

                        if (this.KEY_MAP[lc]) {
                            config.keys[this.KEY_MAP[lc]] = mods;
                            // FIXME: '65,enter' defaults keydown for both
                            if (!config.type) {
                                config.type = "down"; // safest
                            }
                        } else {
                            // FIXME: Character mapping only works for keypress
                            // events. Otherwise, it uses String.fromCharCode()
                            // from the keyCode, which is wrong.
                            chr = chr.charAt(0);
                            uc  = chr.toUpperCase();

                            if (mods["+shift"]) {
                                chr = uc;
                            }

                            // FIXME: stupid assumption that
                            // the keycode of the lower case == the
                            // charCode of the upper case
                            // a (key:65,char:97), A (key:65,char:65)
                            config.keys[chr.charCodeAt(0)] =
                                (chr === uc) ?
                                    // upper case chars get +shift free
                                    Y.merge(mods, { "+shift": true }) :
                                    mods;
                        }
                    }
                }
            }

            if (!config.type) {
                config.type = "press";
            }

            return config;
        },

        on: function (node, sub, notifier, filter) {
            var spec   = sub._extra,
                type   = "key" + spec.type,
                keys   = spec.keys,
                method = (filter) ? "delegate" : "on";

            // Note: without specifying any keyCodes, this becomes a
            // horribly inefficient alias for 'keydown' (et al), but I
            // can't abort this subscription for a simple
            // Y.on('keypress', ...);
            // Please use keyCodes or just subscribe directly to keydown,
            // keyup, or keypress
            sub._detach = node[method](type, function (e) {
                var key = keys ? keys[e.which] : spec.mods;

                if (key &&
                    (!key[ALT]   || (key[ALT]   && e.altKey)) &&
                    (!key[CTRL]  || (key[CTRL]  && e.ctrlKey)) &&
                    (!key[META]  || (key[META]  && e.metaKey)) &&
                    (!key[SHIFT] || (key[SHIFT] && e.shiftKey)))
                {
                    notifier.fire(e);
                }
            }, filter);
        },

        detach: function (node, sub, notifier) {
            sub._detach.detach();
        }
    };

eventDef.delegate = eventDef.on;
eventDef.detachDelegate = eventDef.detach;

/**
 * <p>Add a key listener.  The listener will only be notified if the
 * keystroke detected meets the supplied specification.  The
 * specification is a string that is defined as:</p>
 *
 * <dl>
 *   <dt>spec</dt>
 *   <dd><code>[{type}:]{code}[,{code}]*</code></dd>
 *   <dt>type</dt>
 *   <dd><code>"down", "up", or "press"</code></dd>
 *   <dt>code</dt>
 *   <dd><code>{keyCode|character|keyName}[+{modifier}]*</code></dd>
 *   <dt>modifier</dt>
 *   <dd><code>"shift", "ctrl", "alt", or "meta"</code></dd>
 *   <dt>keyName</dt>
 *   <dd><code>"enter", "space", "backspace", "esc", "tab", "pageup", or "pagedown"</code></dd>
 * </dl>
 *
 * <p>Examples:</p>
 * <ul>
 *   <li><code>Y.on("key", callback, "press:12,65+shift+ctrl", "#my-input");</code></li>
 *   <li><code>Y.delegate("key", preventSubmit, "#forms", "enter", "input[type=text]");</code></li>
 *   <li><code>Y.one("doc").on("key", viNav, "j,k,l,;");</code></li>
 * </ul>
 *
 * @event key
 * @for YUI
 * @param type {string} 'key'
 * @param fn {function} the function to execute
 * @param id {string|HTMLElement|collection} the element(s) to bind
 * @param spec {string} the keyCode and modifier specification
 * @param o optional context object
 * @param args 0..n additional arguments to provide to the listener.
 * @return {Event.Handle} the detach handle
 */
Y.Event.define('key', eventDef, true);


}, '3.17.2', {"requires": ["event-synthetic"]});


/***/ }),

/***/ 125057:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-mouseenter', function (Y, NAME) {

/**
 * <p>Adds subscription and delegation support for mouseenter and mouseleave
 * events.  Unlike mouseover and mouseout, these events aren't fired from child
 * elements of a subscribed node.</p>
 *
 * <p>This avoids receiving three mouseover notifications from a setup like</p>
 *
 * <pre><code>div#container > p > a[href]</code></pre>
 *
 * <p>where</p>
 *
 * <pre><code>Y.one('#container').on('mouseover', callback)</code></pre>
 *
 * <p>When the mouse moves over the link, one mouseover event is fired from
 * #container, then when the mouse moves over the p, another mouseover event is
 * fired and bubbles to #container, causing a second notification, and finally
 * when the mouse moves over the link, a third mouseover event is fired and
 * bubbles to #container for a third notification.</p>
 *
 * <p>By contrast, using mouseenter instead of mouseover, the callback would be
 * executed only once when the mouse moves over #container.</p>
 *
 * @module event
 * @submodule event-mouseenter
 */

var domEventProxies = Y.Env.evt.dom_wrappers,
    contains = Y.DOM.contains,
    toArray = Y.Array,
    noop = function () {},

    config = {
        proxyType: "mouseover",
        relProperty: "fromElement",

        _notify: function (e, property, notifier) {
            var el = this._node,
                related = e.relatedTarget || e[property];

            if (el !== related && !contains(el, related)) {
                notifier.fire(new Y.DOMEventFacade(e, el,
                    domEventProxies['event:' + Y.stamp(el) + e.type]));
            }
        },

        on: function (node, sub, notifier) {
            var el = Y.Node.getDOMNode(node),
                args = [
                    this.proxyType,
                    this._notify,
                    el,
                    null,
                    this.relProperty,
                    notifier];

            sub.handle = Y.Event._attach(args, { facade: false });
            // node.on(this.proxyType, notify, null, notifier);
        },

        detach: function (node, sub) {
            sub.handle.detach();
        },

        delegate: function (node, sub, notifier, filter) {
            var el = Y.Node.getDOMNode(node),
                args = [
                    this.proxyType,
                    noop,
                    el,
                    null,
                    notifier
                ];

            sub.handle = Y.Event._attach(args, { facade: false });
            sub.handle.sub.filter = filter;
            sub.handle.sub.relProperty = this.relProperty;
            sub.handle.sub._notify = this._filterNotify;
        },

        _filterNotify: function (thisObj, args, ce) {
            args = args.slice();
            if (this.args) {
                args.push.apply(args, this.args);
            }

            var currentTarget = Y.delegate._applyFilter(this.filter, args, ce),
                related = args[0].relatedTarget || args[0][this.relProperty],
                e, i, len, ret, ct;

            if (currentTarget) {
                currentTarget = toArray(currentTarget);

                for (i = 0, len = currentTarget.length && (!e || !e.stopped); i < len; ++i) {
                    ct = currentTarget[0];
                    if (!contains(ct, related)) {
                        if (!e) {
                            e = new Y.DOMEventFacade(args[0], ct, ce);
                            e.container = Y.one(ce.el);
                        }
                        e.currentTarget = Y.one(ct);

                        // TODO: where is notifier? args? this.notifier?
                        ret = args[1].fire(e);

                        if (ret === false) {
                            break;
                        }
                    }
                }
            }

            return ret;
        },

        detachDelegate: function (node, sub) {
            sub.handle.detach();
        }
    };

Y.Event.define("mouseenter", config, true);
Y.Event.define("mouseleave", Y.merge(config, {
    proxyType: "mouseout",
    relProperty: "toElement"
}), true);


}, '3.17.2', {"requires": ["event-synthetic"]});


/***/ }),

/***/ 481133:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-mousewheel', function (Y, NAME) {

/**
 * Adds mousewheel event support
 * @module event
 * @submodule event-mousewheel
 */
var DOM_MOUSE_SCROLL = 'DOMMouseScroll',
    fixArgs = function(args) {
        var a = Y.Array(args, 0, true), target;
        if (Y.UA.gecko) {
            a[0] = DOM_MOUSE_SCROLL;
            target = Y.config.win;
        } else {
            target = Y.config.doc;
        }

        if (a.length < 3) {
            a[2] = target;
        } else {
            a.splice(2, 0, target);
        }

        return a;
    };

/**
 * Mousewheel event.  This listener is automatically attached to the
 * correct target, so one should not be supplied.  Mouse wheel
 * direction and velocity is stored in the 'wheelDelta' field.
 * @event mousewheel
 * @param type {string} 'mousewheel'
 * @param fn {function} the callback to execute
 * @param context optional context object
 * @param args 0..n additional arguments to provide to the listener.
 * @return {EventHandle} the detach handle
 * @for YUI
 */
Y.Env.evt.plugins.mousewheel = {
    on: function() {
        return Y.Event._attach(fixArgs(arguments));
    },

    detach: function() {
        return Y.Event.detach.apply(Y.Event, fixArgs(arguments));
    }
};


}, '3.17.2', {"requires": ["node-base"]});


/***/ }),

/***/ 192312:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-move', function (Y, NAME) {

/**
 * Adds lower level support for "gesturemovestart", "gesturemove" and "gesturemoveend" events, which can be used to create drag/drop
 * interactions which work across touch and mouse input devices. They correspond to "touchstart", "touchmove" and "touchend" on a touch input
 * device, and "mousedown", "mousemove", "mouseup" on a mouse based input device.
 *
 * <p>Documentation for the gesturemove triplet of events can be found on the <a href="../classes/YUI.html#event_gesturemove">YUI</a> global,
 * along with the other supported events.</p>

 @example

     YUI().use('event-move', function (Y) {
         Y.one('#myNode').on('gesturemovestart', function (e) {
         });
         Y.one('#myNode').on('gesturemove', function (e) {
         });
         Y.one('#myNode').on('gesturemoveend', function (e) {
         });
     });

 * @module event-gestures
 * @submodule event-move
 */


 var GESTURE_MAP = Y.Event._GESTURE_MAP,
     EVENT = {
         start: GESTURE_MAP.start,
         end: GESTURE_MAP.end,
         move: GESTURE_MAP.move
     },
    START = "start",
    MOVE = "move",
    END = "end",

    GESTURE_MOVE = "gesture" + MOVE,
    GESTURE_MOVE_END = GESTURE_MOVE + END,
    GESTURE_MOVE_START = GESTURE_MOVE + START,

    _MOVE_START_HANDLE = "_msh",
    _MOVE_HANDLE = "_mh",
    _MOVE_END_HANDLE = "_meh",

    _DEL_MOVE_START_HANDLE = "_dmsh",
    _DEL_MOVE_HANDLE = "_dmh",
    _DEL_MOVE_END_HANDLE = "_dmeh",

    _MOVE_START = "_ms",
    _MOVE = "_m",

    MIN_TIME = "minTime",
    MIN_DISTANCE = "minDistance",
    PREVENT_DEFAULT = "preventDefault",
    BUTTON = "button",
    OWNER_DOCUMENT = "ownerDocument",

    CURRENT_TARGET = "currentTarget",
    TARGET = "target",

    NODE_TYPE = "nodeType",
    SUPPORTS_POINTER = Y.config.win && ("msPointerEnabled" in Y.config.win.navigator),
    MS_TOUCH_ACTION_COUNT = 'msTouchActionCount',
    MS_INIT_TOUCH_ACTION = 'msInitTouchAction',

    _defArgsProcessor = function(se, args, delegate) {
        var iConfig = (delegate) ? 4 : 3,
            config = (args.length > iConfig) ? Y.merge(args.splice(iConfig,1)[0]) : {};

        if (!(PREVENT_DEFAULT in config)) {
            config[PREVENT_DEFAULT] = se.PREVENT_DEFAULT;
        }

        return config;
    },

    _getRoot = function(node, subscriber) {
        return subscriber._extra.root || (node.get(NODE_TYPE) === 9) ? node : node.get(OWNER_DOCUMENT);
    },

    //Checks to see if the node is the document, and if it is, returns the documentElement.
    _checkDocumentElem = function(node) {
        var elem = node.getDOMNode();
        if (node.compareTo(Y.config.doc) && elem.documentElement) {
            return elem.documentElement;
        }
        else {
            return false;
        }
    },

    _normTouchFacade = function(touchFacade, touch, params) {
        touchFacade.pageX = touch.pageX;
        touchFacade.pageY = touch.pageY;
        touchFacade.screenX = touch.screenX;
        touchFacade.screenY = touch.screenY;
        touchFacade.clientX = touch.clientX;
        touchFacade.clientY = touch.clientY;
        touchFacade[TARGET] = touchFacade[TARGET] || touch[TARGET];
        touchFacade[CURRENT_TARGET] = touchFacade[CURRENT_TARGET] || touch[CURRENT_TARGET];

        touchFacade[BUTTON] = (params && params[BUTTON]) || 1; // default to left (left as per vendors, not W3C which is 0)
    },

    /*
    In IE10 touch mode, gestures will not work properly unless the -ms-touch-action CSS property is set to something other than 'auto'. Read http://msdn.microsoft.com/en-us/library/windows/apps/hh767313.aspx for more info. To get around this, we set -ms-touch-action: none which is the same as e.preventDefault() on touch environments. This tells the browser to fire DOM events for all touch events, and not perform any default behavior.

    The user can over-ride this by setting a more lenient -ms-touch-action property on a node (such as pan-x, pan-y, etc.) via CSS when subscribing to the 'gesturemovestart' event.
    */
    _setTouchActions = function (node) {
        var elem = _checkDocumentElem(node) || node.getDOMNode(),
            num = node.getData(MS_TOUCH_ACTION_COUNT);

        //Checks to see if msTouchAction is supported.
        if (SUPPORTS_POINTER) {
            if (!num) {
                num = 0;
                node.setData(MS_INIT_TOUCH_ACTION, elem.style.msTouchAction);
            }
            elem.style.msTouchAction = Y.Event._DEFAULT_TOUCH_ACTION;
            num++;
            node.setData(MS_TOUCH_ACTION_COUNT, num);
        }
    },

    /*
    Resets the element's -ms-touch-action property back to the original value, This is called on detach() and detachDelegate().
    */
    _unsetTouchActions = function (node) {
        var elem = _checkDocumentElem(node) || node.getDOMNode(),
            num = node.getData(MS_TOUCH_ACTION_COUNT),
            initTouchAction = node.getData(MS_INIT_TOUCH_ACTION);

        if (SUPPORTS_POINTER) {
            num--;
            node.setData(MS_TOUCH_ACTION_COUNT, num);
            if (num === 0 && elem.style.msTouchAction !== initTouchAction) {
                elem.style.msTouchAction = initTouchAction;
            }
        }
    },

    _prevent = function(e, preventDefault) {
        if (preventDefault) {
            // preventDefault is a boolean or a function
            if (!preventDefault.call || preventDefault(e)) {
                e.preventDefault();
            }
        }
    },

    define = Y.Event.define;
    Y.Event._DEFAULT_TOUCH_ACTION = 'none';

/**
 * Sets up a "gesturemovestart" event, that is fired on touch devices in response to a single finger "touchstart",
 * and on mouse based devices in response to a "mousedown". The subscriber can specify the minimum time
 * and distance thresholds which should be crossed before the "gesturemovestart" is fired and for the mouse,
 * which button should initiate a "gesturemovestart". This event can also be listened for using node.delegate().
 *
 * <p>It is recommended that you use Y.bind to set up context and additional arguments for your event handler,
 * however if you want to pass the context and arguments as additional signature arguments to on/delegate,
 * you need to provide a null value for the configuration object, e.g: <code>node.on("gesturemovestart", fn, null, context, arg1, arg2, arg3)</code></p>
 *
 * @event gesturemovestart
 * @for YUI
 * @param type {string} "gesturemovestart"
 * @param fn {function} The method the event invokes. It receives the event facade of the underlying DOM event (mousedown or touchstart.touches[0]) which contains position co-ordinates.
 * @param cfg {Object} Optional. An object which specifies:
 *
 * <dl>
 * <dt>minDistance (defaults to 0)</dt>
 * <dd>The minimum distance threshold which should be crossed before the gesturemovestart is fired</dd>
 * <dt>minTime (defaults to 0)</dt>
 * <dd>The minimum time threshold for which the finger/mouse should be help down before the gesturemovestart is fired</dd>
 * <dt>button (no default)</dt>
 * <dd>In the case of a mouse input device, if the event should only be fired for a specific mouse button.</dd>
 * <dt>preventDefault (defaults to false)</dt>
 * <dd>Can be set to true/false to prevent default behavior as soon as the touchstart or mousedown is received (that is before minTime or minDistance thresholds are crossed, and so before the gesturemovestart listener is notified) so that things like text selection and context popups (on touch devices) can be
 * prevented. This property can also be set to a function, which returns true or false, based on the event facade passed to it (for example, DragDrop can determine if the target is a valid handle or not before preventing default).</dd>
 * </dl>
 *
 * @return {EventHandle} the detach handle
 */

define(GESTURE_MOVE_START, {

    on: function (node, subscriber, ce) {

        //Set -ms-touch-action on IE10 and set preventDefault to true
        _setTouchActions(node);

        subscriber[_MOVE_START_HANDLE] = node.on(EVENT[START],
            this._onStart,
            this,
            node,
            subscriber,
            ce);
    },

    delegate : function(node, subscriber, ce, filter) {

        var se = this;

        subscriber[_DEL_MOVE_START_HANDLE] = node.delegate(EVENT[START],
            function(e) {
                se._onStart(e, node, subscriber, ce, true);
            },
            filter);
    },

    detachDelegate : function(node, subscriber, ce, filter) {
        var handle = subscriber[_DEL_MOVE_START_HANDLE];

        if (handle) {
            handle.detach();
            subscriber[_DEL_MOVE_START_HANDLE] = null;
        }

        _unsetTouchActions(node);
    },

    detach: function (node, subscriber, ce) {
        var startHandle = subscriber[_MOVE_START_HANDLE];

        if (startHandle) {
            startHandle.detach();
            subscriber[_MOVE_START_HANDLE] = null;
        }

        _unsetTouchActions(node);
    },

    processArgs : function(args, delegate) {
        var params = _defArgsProcessor(this, args, delegate);

        if (!(MIN_TIME in params)) {
            params[MIN_TIME] = this.MIN_TIME;
        }

        if (!(MIN_DISTANCE in params)) {
            params[MIN_DISTANCE] = this.MIN_DISTANCE;
        }

        return params;
    },

    _onStart : function(e, node, subscriber, ce, delegate) {

        if (delegate) {
            node = e[CURRENT_TARGET];
        }

        var params = subscriber._extra,
            fireStart = true,
            minTime = params[MIN_TIME],
            minDistance = params[MIN_DISTANCE],
            button = params.button,
            preventDefault = params[PREVENT_DEFAULT],
            root = _getRoot(node, subscriber),
            startXY;

        if (e.touches) {
            if (e.touches.length === 1) {
                _normTouchFacade(e, e.touches[0], params);
            } else {
                fireStart = false;
            }
        } else {
            fireStart = (button === undefined) || (button === e.button);
        }


        if (fireStart) {

            _prevent(e, preventDefault);

            if (minTime === 0 || minDistance === 0) {
                this._start(e, node, ce, params);

            } else {

                startXY = [e.pageX, e.pageY];

                if (minTime > 0) {


                    params._ht = Y.later(minTime, this, this._start, [e, node, ce, params]);

                    params._hme = root.on(EVENT[END], Y.bind(function() {
                        this._cancel(params);
                    }, this));
                }

                if (minDistance > 0) {


                    params._hm = root.on(EVENT[MOVE], Y.bind(function(em) {
                        if (Math.abs(em.pageX - startXY[0]) > minDistance || Math.abs(em.pageY - startXY[1]) > minDistance) {
                            this._start(e, node, ce, params);
                        }
                    }, this));
                }
            }
        }
    },

    _cancel : function(params) {
        if (params._ht) {
            params._ht.cancel();
            params._ht = null;
        }
        if (params._hme) {
            params._hme.detach();
            params._hme = null;
        }
        if (params._hm) {
            params._hm.detach();
            params._hm = null;
        }
    },

    _start : function(e, node, ce, params) {

        if (params) {
            this._cancel(params);
        }

        e.type = GESTURE_MOVE_START;


        node.setData(_MOVE_START, e);
        ce.fire(e);
    },

    MIN_TIME : 0,
    MIN_DISTANCE : 0,
    PREVENT_DEFAULT : false
});

/**
 * Sets up a "gesturemove" event, that is fired on touch devices in response to a single finger "touchmove",
 * and on mouse based devices in response to a "mousemove".
 *
 * <p>By default this event is only fired when the same node
 * has received a "gesturemovestart" event. The subscriber can set standAlone to true, in the configuration properties,
 * if they want to listen for this event without an initial "gesturemovestart".</p>
 *
 * <p>By default this event sets up it's internal "touchmove" and "mousemove" DOM listeners on the document element. The subscriber
 * can set the root configuration property, to specify which node to attach DOM listeners to, if different from the document.</p>
 *
 * <p>This event can also be listened for using node.delegate().</p>
 *
 * <p>It is recommended that you use Y.bind to set up context and additional arguments for your event handler,
 * however if you want to pass the context and arguments as additional signature arguments to on/delegate,
 * you need to provide a null value for the configuration object, e.g: <code>node.on("gesturemove", fn, null, context, arg1, arg2, arg3)</code></p>
 *
 * @event gesturemove
 * @for YUI
 * @param type {string} "gesturemove"
 * @param fn {function} The method the event invokes. It receives the event facade of the underlying DOM event (mousemove or touchmove.touches[0]) which contains position co-ordinates.
 * @param cfg {Object} Optional. An object which specifies:
 * <dl>
 * <dt>standAlone (defaults to false)</dt>
 * <dd>true, if the subscriber should be notified even if a "gesturemovestart" has not occured on the same node.</dd>
 * <dt>root (defaults to document)</dt>
 * <dd>The node to which the internal DOM listeners should be attached.</dd>
 * <dt>preventDefault (defaults to false)</dt>
 * <dd>Can be set to true/false to prevent default behavior as soon as the touchmove or mousemove is received. As with gesturemovestart, can also be set to function which returns true/false based on the event facade passed to it.</dd>
 * </dl>
 *
 * @return {EventHandle} the detach handle
 */
define(GESTURE_MOVE, {

    on : function (node, subscriber, ce) {

        _setTouchActions(node);
        var root = _getRoot(node, subscriber, EVENT[MOVE]),

            moveHandle = root.on(EVENT[MOVE],
                this._onMove,
                this,
                node,
                subscriber,
                ce);

        subscriber[_MOVE_HANDLE] = moveHandle;

    },

    delegate : function(node, subscriber, ce, filter) {

        var se = this;

        subscriber[_DEL_MOVE_HANDLE] = node.delegate(EVENT[MOVE],
            function(e) {
                se._onMove(e, node, subscriber, ce, true);
            },
            filter);
    },

    detach : function (node, subscriber, ce) {
        var moveHandle = subscriber[_MOVE_HANDLE];

        if (moveHandle) {
            moveHandle.detach();
            subscriber[_MOVE_HANDLE] = null;
        }

        _unsetTouchActions(node);
    },

    detachDelegate : function(node, subscriber, ce, filter) {
        var handle = subscriber[_DEL_MOVE_HANDLE];

        if (handle) {
            handle.detach();
            subscriber[_DEL_MOVE_HANDLE] = null;
        }

        _unsetTouchActions(node);

    },

    processArgs : function(args, delegate) {
        return _defArgsProcessor(this, args, delegate);
    },

    _onMove : function(e, node, subscriber, ce, delegate) {

        if (delegate) {
            node = e[CURRENT_TARGET];
        }

        var fireMove = subscriber._extra.standAlone || node.getData(_MOVE_START),
            preventDefault = subscriber._extra.preventDefault;


        if (fireMove) {

            if (e.touches) {
                if (e.touches.length === 1) {
                    _normTouchFacade(e, e.touches[0]);
                } else {
                    fireMove = false;
                }
            }

            if (fireMove) {

                _prevent(e, preventDefault);


                e.type = GESTURE_MOVE;
                ce.fire(e);
            }
        }
    },

    PREVENT_DEFAULT : false
});

/**
 * Sets up a "gesturemoveend" event, that is fired on touch devices in response to a single finger "touchend",
 * and on mouse based devices in response to a "mouseup".
 *
 * <p>By default this event is only fired when the same node
 * has received a "gesturemove" or "gesturemovestart" event. The subscriber can set standAlone to true, in the configuration properties,
 * if they want to listen for this event without a preceding "gesturemovestart" or "gesturemove".</p>
 *
 * <p>By default this event sets up it's internal "touchend" and "mouseup" DOM listeners on the document element. The subscriber
 * can set the root configuration property, to specify which node to attach DOM listeners to, if different from the document.</p>
 *
 * <p>This event can also be listened for using node.delegate().</p>
 *
 * <p>It is recommended that you use Y.bind to set up context and additional arguments for your event handler,
 * however if you want to pass the context and arguments as additional signature arguments to on/delegate,
 * you need to provide a null value for the configuration object, e.g: <code>node.on("gesturemoveend", fn, null, context, arg1, arg2, arg3)</code></p>
 *
 *
 * @event gesturemoveend
 * @for YUI
 * @param type {string} "gesturemoveend"
 * @param fn {function} The method the event invokes. It receives the event facade of the underlying DOM event (mouseup or touchend.changedTouches[0]).
 * @param cfg {Object} Optional. An object which specifies:
 * <dl>
 * <dt>standAlone (defaults to false)</dt>
 * <dd>true, if the subscriber should be notified even if a "gesturemovestart" or "gesturemove" has not occured on the same node.</dd>
 * <dt>root (defaults to document)</dt>
 * <dd>The node to which the internal DOM listeners should be attached.</dd>
 * <dt>preventDefault (defaults to false)</dt>
 * <dd>Can be set to true/false to prevent default behavior as soon as the touchend or mouseup is received. As with gesturemovestart, can also be set to function which returns true/false based on the event facade passed to it.</dd>
 * </dl>
 *
 * @return {EventHandle} the detach handle
 */
define(GESTURE_MOVE_END, {

    on : function (node, subscriber, ce) {
        _setTouchActions(node);
        var root = _getRoot(node, subscriber),

            endHandle = root.on(EVENT[END],
                this._onEnd,
                this,
                node,
                subscriber,
                ce);

        subscriber[_MOVE_END_HANDLE] = endHandle;
    },

    delegate : function(node, subscriber, ce, filter) {

        var se = this;

        subscriber[_DEL_MOVE_END_HANDLE] = node.delegate(EVENT[END],
            function(e) {
                se._onEnd(e, node, subscriber, ce, true);
            },
            filter);
    },

    detachDelegate : function(node, subscriber, ce, filter) {
        var handle = subscriber[_DEL_MOVE_END_HANDLE];

        if (handle) {
            handle.detach();
            subscriber[_DEL_MOVE_END_HANDLE] = null;
        }

        _unsetTouchActions(node);

    },

    detach : function (node, subscriber, ce) {
        var endHandle = subscriber[_MOVE_END_HANDLE];

        if (endHandle) {
            endHandle.detach();
            subscriber[_MOVE_END_HANDLE] = null;
        }

        _unsetTouchActions(node);
    },

    processArgs : function(args, delegate) {
        return _defArgsProcessor(this, args, delegate);
    },

    _onEnd : function(e, node, subscriber, ce, delegate) {

        if (delegate) {
            node = e[CURRENT_TARGET];
        }

        var fireMoveEnd = subscriber._extra.standAlone || node.getData(_MOVE) || node.getData(_MOVE_START),
            preventDefault = subscriber._extra.preventDefault;

        if (fireMoveEnd) {

            if (e.changedTouches) {
                if (e.changedTouches.length === 1) {
                    _normTouchFacade(e, e.changedTouches[0]);
                } else {
                    fireMoveEnd = false;
                }
            }

            if (fireMoveEnd) {

                _prevent(e, preventDefault);

                e.type = GESTURE_MOVE_END;
                ce.fire(e);

                node.clearData(_MOVE_START);
                node.clearData(_MOVE);
            }
        }
    },

    PREVENT_DEFAULT : false
});


}, '3.17.2', {"requires": ["node-base", "event-touch", "event-synthetic"]});


/***/ }),

/***/ 540856:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-outside', function (Y, NAME) {

/**
 * Outside events are synthetic DOM events that fire when a corresponding native
 * or synthetic DOM event occurs outside a bound element.
 *
 * The following outside events are pre-defined by this module:
 * <ul>
 *   <li>blur</li>
 *   <li>change</li>
 *   <li>click</li>
 *   <li>dblclick</li>
 *   <li>focus</li>
 *   <li>keydown</li>
 *   <li>keypress</li>
 *   <li>keyup</li>
 *   <li>mousedown</li>
 *   <li>mousemove</li>
 *   <li>mouseout</li>
 *   <li>mouseover</li>
 *   <li>mouseup</li>
 *   <li>select</li>
 *   <li>submit</li>
 * </ul>
 *
 * Define new outside events with
 * <code>Y.Event.defineOutside(eventType);</code>.
 * By default, the created synthetic event name will be the name of the event
 * with "outside" appended (e.g. "click" becomes "clickoutside"). If you want
 * a different name for the created Event, pass it as a second argument like so:
 * <code>Y.Event.defineOutside(eventType, "yonderclick")</code>.
 *
 * This module was contributed by Brett Stimmerman, promoted from his
 * gallery-outside-events module at
 * http://yuilibrary.com/gallery/show/outside-events
 *
 * @module event
 * @submodule event-outside
 * @author brettstimmerman
 * @since 3.4.0
 */

// Outside events are pre-defined for each of these native DOM events
var nativeEvents = [
        'blur', 'change', 'click', 'dblclick', 'focus', 'keydown', 'keypress',
        'keyup', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup',
        'select', 'submit'
    ];

/**
 * Defines a new outside event to correspond with the given DOM event.
 *
 * By default, the created synthetic event name will be the name of the event
 * with "outside" appended (e.g. "click" becomes "clickoutside"). If you want
 * a different name for the created Event, pass it as a second argument like so:
 * <code>Y.Event.defineOutside(eventType, "yonderclick")</code>.
 *
 * @method defineOutside
 * @param {String} event DOM event
 * @param {String} name (optional) custom outside event name
 * @static
 * @for Event
 */
Y.Event.defineOutside = function (event, name) {
    name = name || (event + 'outside');

    var config = {

        on: function (node, sub, notifier) {
            sub.handle = Y.one('doc').on(event, function(e) {
                if (this.isOutside(node, e.target)) {
                    e.currentTarget = node;
                    notifier.fire(e);
                }
            }, this);
        },

        detach: function (node, sub, notifier) {
            sub.handle.detach();
        },

        delegate: function (node, sub, notifier, filter) {
            sub.handle = Y.one('doc').delegate(event, function (e) {
                if (this.isOutside(node, e.target)) {
                    notifier.fire(e);
                }
            }, filter, this);
        },

        isOutside: function (node, target) {
            return target !== node && !target.ancestor(function (p) {
                    return p === node;
                });
        }
    };
    config.detachDelegate = config.detach;

    Y.Event.define(name, config);
};

// Define outside events for some common native DOM events
Y.Array.each(nativeEvents, function (event) {
    Y.Event.defineOutside(event);
});


}, '3.17.2', {"requires": ["event-synthetic"]});


/***/ }),

/***/ 130110:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-resize', function (Y, NAME) {

/**
 * Adds a window resize event that has its behavior normalized to fire at the
 * end of the resize rather than constantly during the resize.
 * @module event
 * @submodule event-resize
 */


/**
 * Old firefox fires the window resize event once when the resize action
 * finishes, other browsers fire the event periodically during the
 * resize.  This code uses timeout logic to simulate the Firefox
 * behavior in other browsers.
 * @event windowresize
 * @for YUI
 */
Y.Event.define('windowresize', {

    on: (Y.UA.gecko && Y.UA.gecko < 1.91) ?
        function (node, sub, notifier) {
            sub._handle = Y.Event.attach('resize', function (e) {
                notifier.fire(e);
            });
        } :
        function (node, sub, notifier) {
            // interval bumped from 40 to 100ms as of 3.4.1
            var delay = Y.config.windowResizeDelay || 100;

            sub._handle = Y.Event.attach('resize', function (e) {
                if (sub._timer) {
                    sub._timer.cancel();
                }

                sub._timer = Y.later(delay, Y, function () {
                    notifier.fire(e);
                });
            });
        },

    detach: function (node, sub) {
        if (sub._timer) {
            sub._timer.cancel();
        }
        sub._handle.detach();
    }
    // delegate methods not defined because this only works for window
    // subscriptions, so...yeah.
});


}, '3.17.2', {"requires": ["node-base", "event-synthetic"]});


/***/ }),

/***/ 489565:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-simulate', function (Y, NAME) {

(function() {
/**
 * Simulate user interaction by generating native DOM events.
 *
 * @module event-simulate
 * @requires event
 */

//shortcuts
var L   = Y.Lang,
    win = Y.config.win,
    isFunction  = L.isFunction,
    isString    = L.isString,
    isBoolean   = L.isBoolean,
    isObject    = L.isObject,
    isNumber    = L.isNumber,

    //mouse events supported
    mouseEvents = {
        click:      1,
        dblclick:   1,
        mouseover:  1,
        mouseout:   1,
        mousedown:  1,
        mouseup:    1,
        mousemove:  1,
        contextmenu:1
    },

    pointerEvents = (win && win.PointerEvent) ? {
        pointerover:  1,
        pointerout:   1,
        pointerdown:  1,
        pointerup:    1,
        pointermove:  1
    } : {
        MSPointerOver:  1,
        MSPointerOut:   1,
        MSPointerDown:  1,
        MSPointerUp:    1,
        MSPointerMove:  1
    },

    //key events supported
    keyEvents   = {
        keydown:    1,
        keyup:      1,
        keypress:   1
    },

    //HTML events supported
    uiEvents  = {
        submit:     1,
        blur:       1,
        change:     1,
        focus:      1,
        resize:     1,
        scroll:     1,
        select:     1
    },

    //events that bubble by default
    bubbleEvents = {
        scroll:     1,
        resize:     1,
        reset:      1,
        submit:     1,
        change:     1,
        select:     1,
        error:      1,
        abort:      1
    },

    //touch events supported
    touchEvents = {
        touchstart: 1,
        touchmove: 1,
        touchend: 1,
        touchcancel: 1
    },

    gestureEvents = {
        gesturestart: 1,
        gesturechange: 1,
        gestureend: 1
    };

//all key, mouse and touch events bubble
Y.mix(bubbleEvents, mouseEvents);
Y.mix(bubbleEvents, keyEvents);
Y.mix(bubbleEvents, touchEvents);

/*
 * Note: Intentionally not for YUIDoc generation.
 * Simulates a key event using the given event information to populate
 * the generated event object. This method does browser-equalizing
 * calculations to account for differences in the DOM and IE event models
 * as well as different browser quirks. Note: keydown causes Safari 2.x to
 * crash.
 * @method simulateKeyEvent
 * @private
 * @static
 * @param {HTMLElement} target The target of the given event.
 * @param {String} type The type of event to fire. This can be any one of
 *      the following: keyup, keydown, and keypress.
 * @param {Boolean} [bubbles=true] Indicates if the event can be
 *      bubbled up. DOM Level 3 specifies that all key events bubble by
 *      default.
 * @param {Boolean} [cancelable=true] Indicates if the event can be
 *      canceled using preventDefault(). DOM Level 3 specifies that all
 *      key events can be cancelled.
 * @param {Window} [view=window] The view containing the target. This is
 *      typically the window object.
 * @param {Boolean} [ctrlKey=false] Indicates if one of the CTRL keys
 *      is pressed while the event is firing.
 * @param {Boolean} [altKey=false] Indicates if one of the ALT keys
 *      is pressed while the event is firing.
 * @param {Boolean} [shiftKey=false] Indicates if one of the SHIFT keys
 *      is pressed while the event is firing.
 * @param {Boolean} [metaKey=false] Indicates if one of the META keys
 *      is pressed while the event is firing.
 * @param {Number} [keyCode=0] The code for the key that is in use.
 * @param {Number} [charCode=0] The Unicode code for the character
 *      associated with the key being used.
 */
function simulateKeyEvent(target /*:HTMLElement*/, type /*:String*/,
                             bubbles /*:Boolean*/,  cancelable /*:Boolean*/,
                             view /*:Window*/,
                             ctrlKey /*:Boolean*/,    altKey /*:Boolean*/,
                             shiftKey /*:Boolean*/,   metaKey /*:Boolean*/,
                             keyCode /*:int*/,        charCode /*:int*/) /*:Void*/
{
    //check target
    if (!target){
        Y.error("simulateKeyEvent(): Invalid target.");
    }

    //check event type
    if (isString(type)){
        type = type.toLowerCase();
        switch(type){
            case "textevent": //DOM Level 3
                type = "keypress";
                break;
            case "keyup":
            case "keydown":
            case "keypress":
                break;
            default:
                Y.error("simulateKeyEvent(): Event type '" + type + "' not supported.");
        }
    } else {
        Y.error("simulateKeyEvent(): Event type must be a string.");
    }

    //setup default values
    if (!isBoolean(bubbles)){
        bubbles = true; //all key events bubble
    }
    if (!isBoolean(cancelable)){
        cancelable = true; //all key events can be cancelled
    }
    if (!isObject(view)){
        view = Y.config.win; //view is typically window
    }
    if (!isBoolean(ctrlKey)){
        ctrlKey = false;
    }
    if (!isBoolean(altKey)){
        altKey = false;
    }
    if (!isBoolean(shiftKey)){
        shiftKey = false;
    }
    if (!isBoolean(metaKey)){
        metaKey = false;
    }
    if (!isNumber(keyCode)){
        keyCode = 0;
    }
    if (!isNumber(charCode)){
        charCode = 0;
    }

    //try to create a mouse event
    var customEvent /*:MouseEvent*/ = null;

    //check for DOM-compliant browsers first
    if (isFunction(Y.config.doc.createEvent)){

        try {

            //try to create key event
            customEvent = Y.config.doc.createEvent("KeyEvents");

            /*
             * Interesting problem: Firefox implemented a non-standard
             * version of initKeyEvent() based on DOM Level 2 specs.
             * Key event was removed from DOM Level 2 and re-introduced
             * in DOM Level 3 with a different interface. Firefox is the
             * only browser with any implementation of Key Events, so for
             * now, assume it's Firefox if the above line doesn't error.
             */
            // @TODO: Decipher between Firefox's implementation and a correct one.
            customEvent.initKeyEvent(type, bubbles, cancelable, view, ctrlKey,
                altKey, shiftKey, metaKey, keyCode, charCode);

        } catch (ex /*:Error*/){

            /*
             * If it got here, that means key events aren't officially supported.
             * Safari/WebKit is a real problem now. WebKit 522 won't let you
             * set keyCode, charCode, or other properties if you use a
             * UIEvent, so we first must try to create a generic event. The
             * fun part is that this will throw an error on Safari 2.x. The
             * end result is that we need another try...catch statement just to
             * deal with this mess.
             */
            try {

                //try to create generic event - will fail in Safari 2.x
                customEvent = Y.config.doc.createEvent("Events");

            } catch (uierror /*:Error*/){

                //the above failed, so create a UIEvent for Safari 2.x
                customEvent = Y.config.doc.createEvent("UIEvents");

            } finally {

                customEvent.initEvent(type, bubbles, cancelable);

                //initialize
                customEvent.view = view;
                customEvent.altKey = altKey;
                customEvent.ctrlKey = ctrlKey;
                customEvent.shiftKey = shiftKey;
                customEvent.metaKey = metaKey;
                customEvent.keyCode = keyCode;
                customEvent.charCode = charCode;

            }

        }

        //fire the event
        target.dispatchEvent(customEvent);

    } else if (isObject(Y.config.doc.createEventObject)){ //IE

        //create an IE event object
        customEvent = Y.config.doc.createEventObject();

        //assign available properties
        customEvent.bubbles = bubbles;
        customEvent.cancelable = cancelable;
        customEvent.view = view;
        customEvent.ctrlKey = ctrlKey;
        customEvent.altKey = altKey;
        customEvent.shiftKey = shiftKey;
        customEvent.metaKey = metaKey;

        /*
         * IE doesn't support charCode explicitly. CharCode should
         * take precedence over any keyCode value for accurate
         * representation.
         */
        customEvent.keyCode = (charCode > 0) ? charCode : keyCode;

        //fire the event
        target.fireEvent("on" + type, customEvent);

    } else {
        Y.error("simulateKeyEvent(): No event simulation framework present.");
    }
}

/*
 * Note: Intentionally not for YUIDoc generation.
 * Simulates a mouse event using the given event information to populate
 * the generated event object. This method does browser-equalizing
 * calculations to account for differences in the DOM and IE event models
 * as well as different browser quirks.
 * @method simulateMouseEvent
 * @private
 * @static
 * @param {HTMLElement} target The target of the given event.
 * @param {String} type The type of event to fire. This can be any one of
 *      the following: click, dblclick, mousedown, mouseup, mouseout,
 *      mouseover, and mousemove.
 * @param {Boolean} bubbles (Optional) Indicates if the event can be
 *      bubbled up. DOM Level 2 specifies that all mouse events bubble by
 *      default. The default is true.
 * @param {Boolean} cancelable (Optional) Indicates if the event can be
 *      canceled using preventDefault(). DOM Level 2 specifies that all
 *      mouse events except mousemove can be cancelled. The default
 *      is true for all events except mousemove, for which the default
 *      is false.
 * @param {Window} view (Optional) The view containing the target. This is
 *      typically the window object. The default is window.
 * @param {Number} detail (Optional) The number of times the mouse button has
 *      been used. The default value is 1.
 * @param {Number} screenX (Optional) The x-coordinate on the screen at which
 *      point the event occured. The default is 0.
 * @param {Number} screenY (Optional) The y-coordinate on the screen at which
 *      point the event occured. The default is 0.
 * @param {Number} clientX (Optional) The x-coordinate on the client at which
 *      point the event occured. The default is 0.
 * @param {Number} clientY (Optional) The y-coordinate on the client at which
 *      point the event occured. The default is 0.
 * @param {Boolean} ctrlKey (Optional) Indicates if one of the CTRL keys
 *      is pressed while the event is firing. The default is false.
 * @param {Boolean} altKey (Optional) Indicates if one of the ALT keys
 *      is pressed while the event is firing. The default is false.
 * @param {Boolean} shiftKey (Optional) Indicates if one of the SHIFT keys
 *      is pressed while the event is firing. The default is false.
 * @param {Boolean} metaKey (Optional) Indicates if one of the META keys
 *      is pressed while the event is firing. The default is false.
 * @param {Number} button (Optional) The button being pressed while the event
 *      is executing. The value should be 0 for the primary mouse button
 *      (typically the left button), 1 for the terciary mouse button
 *      (typically the middle button), and 2 for the secondary mouse button
 *      (typically the right button). The default is 0.
 * @param {HTMLElement} relatedTarget (Optional) For mouseout events,
 *      this is the element that the mouse has moved to. For mouseover
 *      events, this is the element that the mouse has moved from. This
 *      argument is ignored for all other events. The default is null.
 */
function simulateMouseEvent(target /*:HTMLElement*/, type /*:String*/,
                               bubbles /*:Boolean*/,  cancelable /*:Boolean*/,
                               view /*:Window*/,        detail /*:int*/,
                               screenX /*:int*/,        screenY /*:int*/,
                               clientX /*:int*/,        clientY /*:int*/,
                               ctrlKey /*:Boolean*/,    altKey /*:Boolean*/,
                               shiftKey /*:Boolean*/,   metaKey /*:Boolean*/,
                               button /*:int*/,         relatedTarget /*:HTMLElement*/) /*:Void*/
{
    //check target
    if (!target){
        Y.error("simulateMouseEvent(): Invalid target.");
    }


    if (isString(type)){

        //make sure it's a supported mouse event or an msPointerEvent.
        if (!mouseEvents[type.toLowerCase()] && !pointerEvents[type]){
            Y.error("simulateMouseEvent(): Event type '" + type + "' not supported.");
        }
    }
    else {
        Y.error("simulateMouseEvent(): Event type must be a string.");
    }

    //setup default values
    if (!isBoolean(bubbles)){
        bubbles = true; //all mouse events bubble
    }
    if (!isBoolean(cancelable)){
        cancelable = (type !== "mousemove"); //mousemove is the only one that can't be cancelled
    }
    if (!isObject(view)){
        view = Y.config.win; //view is typically window
    }
    if (!isNumber(detail)){
        detail = 1;  //number of mouse clicks must be at least one
    }
    if (!isNumber(screenX)){
        screenX = 0;
    }
    if (!isNumber(screenY)){
        screenY = 0;
    }
    if (!isNumber(clientX)){
        clientX = 0;
    }
    if (!isNumber(clientY)){
        clientY = 0;
    }
    if (!isBoolean(ctrlKey)){
        ctrlKey = false;
    }
    if (!isBoolean(altKey)){
        altKey = false;
    }
    if (!isBoolean(shiftKey)){
        shiftKey = false;
    }
    if (!isBoolean(metaKey)){
        metaKey = false;
    }
    if (!isNumber(button)){
        button = 0;
    }

    relatedTarget = relatedTarget || null;

    //try to create a mouse event
    var customEvent /*:MouseEvent*/ = null;

    //check for DOM-compliant browsers first
    if (isFunction(Y.config.doc.createEvent)){

        customEvent = Y.config.doc.createEvent("MouseEvents");

        //Safari 2.x (WebKit 418) still doesn't implement initMouseEvent()
        if (customEvent.initMouseEvent){
            customEvent.initMouseEvent(type, bubbles, cancelable, view, detail,
                                 screenX, screenY, clientX, clientY,
                                 ctrlKey, altKey, shiftKey, metaKey,
                                 button, relatedTarget);
        } else { //Safari

            //the closest thing available in Safari 2.x is UIEvents
            customEvent = Y.config.doc.createEvent("UIEvents");
            customEvent.initEvent(type, bubbles, cancelable);
            customEvent.view = view;
            customEvent.detail = detail;
            customEvent.screenX = screenX;
            customEvent.screenY = screenY;
            customEvent.clientX = clientX;
            customEvent.clientY = clientY;
            customEvent.ctrlKey = ctrlKey;
            customEvent.altKey = altKey;
            customEvent.metaKey = metaKey;
            customEvent.shiftKey = shiftKey;
            customEvent.button = button;
            customEvent.relatedTarget = relatedTarget;
        }

        /*
         * Check to see if relatedTarget has been assigned. Firefox
         * versions less than 2.0 don't allow it to be assigned via
         * initMouseEvent() and the property is readonly after event
         * creation, so in order to keep YAHOO.util.getRelatedTarget()
         * working, assign to the IE proprietary toElement property
         * for mouseout event and fromElement property for mouseover
         * event.
         */
        if (relatedTarget && !customEvent.relatedTarget){
            if (type === "mouseout"){
                customEvent.toElement = relatedTarget;
            } else if (type === "mouseover"){
                customEvent.fromElement = relatedTarget;
            }
        }

        //fire the event
        target.dispatchEvent(customEvent);

    } else if (isObject(Y.config.doc.createEventObject)){ //IE

        //create an IE event object
        customEvent = Y.config.doc.createEventObject();

        //assign available properties
        customEvent.bubbles = bubbles;
        customEvent.cancelable = cancelable;
        customEvent.view = view;
        customEvent.detail = detail;
        customEvent.screenX = screenX;
        customEvent.screenY = screenY;
        customEvent.clientX = clientX;
        customEvent.clientY = clientY;
        customEvent.ctrlKey = ctrlKey;
        customEvent.altKey = altKey;
        customEvent.metaKey = metaKey;
        customEvent.shiftKey = shiftKey;

        //fix button property for IE's wacky implementation
        switch(button){
            case 0:
                customEvent.button = 1;
                break;
            case 1:
                customEvent.button = 4;
                break;
            case 2:
                //leave as is
                break;
            default:
                customEvent.button = 0;
        }

        /*
         * Have to use relatedTarget because IE won't allow assignment
         * to toElement or fromElement on generic events. This keeps
         * YAHOO.util.customEvent.getRelatedTarget() functional.
         */
        customEvent.relatedTarget = relatedTarget;

        //fire the event
        target.fireEvent("on" + type, customEvent);

    } else {
        Y.error("simulateMouseEvent(): No event simulation framework present.");
    }
}

/*
 * Note: Intentionally not for YUIDoc generation.
 * Simulates a UI event using the given event information to populate
 * the generated event object. This method does browser-equalizing
 * calculations to account for differences in the DOM and IE event models
 * as well as different browser quirks.
 * @method simulateHTMLEvent
 * @private
 * @static
 * @param {HTMLElement} target The target of the given event.
 * @param {String} type The type of event to fire. This can be any one of
 *      the following: click, dblclick, mousedown, mouseup, mouseout,
 *      mouseover, and mousemove.
 * @param {Boolean} bubbles (Optional) Indicates if the event can be
 *      bubbled up. DOM Level 2 specifies that all mouse events bubble by
 *      default. The default is true.
 * @param {Boolean} cancelable (Optional) Indicates if the event can be
 *      canceled using preventDefault(). DOM Level 2 specifies that all
 *      mouse events except mousemove can be cancelled. The default
 *      is true for all events except mousemove, for which the default
 *      is false.
 * @param {Window} view (Optional) The view containing the target. This is
 *      typically the window object. The default is window.
 * @param {Number} detail (Optional) The number of times the mouse button has
 *      been used. The default value is 1.
 */
function simulateUIEvent(target /*:HTMLElement*/, type /*:String*/,
                               bubbles /*:Boolean*/,  cancelable /*:Boolean*/,
                               view /*:Window*/,        detail /*:int*/) /*:Void*/
{

    //check target
    if (!target){
        Y.error("simulateUIEvent(): Invalid target.");
    }

    //check event type
    if (isString(type)){
        type = type.toLowerCase();

        //make sure it's a supported mouse event
        if (!uiEvents[type]){
            Y.error("simulateUIEvent(): Event type '" + type + "' not supported.");
        }
    } else {
        Y.error("simulateUIEvent(): Event type must be a string.");
    }

    //try to create a mouse event
    var customEvent = null;


    //setup default values
    if (!isBoolean(bubbles)){
        bubbles = (type in bubbleEvents);  //not all events bubble
    }
    if (!isBoolean(cancelable)){
        cancelable = (type === "submit"); //submit is the only one that can be cancelled
    }
    if (!isObject(view)){
        view = Y.config.win; //view is typically window
    }
    if (!isNumber(detail)){
        detail = 1;  //usually not used but defaulted to this
    }

    //check for DOM-compliant browsers first
    if (isFunction(Y.config.doc.createEvent)){

        //just a generic UI Event object is needed
        customEvent = Y.config.doc.createEvent("UIEvents");
        customEvent.initUIEvent(type, bubbles, cancelable, view, detail);

        //fire the event
        target.dispatchEvent(customEvent);

    } else if (isObject(Y.config.doc.createEventObject)){ //IE

        //create an IE event object
        customEvent = Y.config.doc.createEventObject();

        //assign available properties
        customEvent.bubbles = bubbles;
        customEvent.cancelable = cancelable;
        customEvent.view = view;
        customEvent.detail = detail;

        //fire the event
        target.fireEvent("on" + type, customEvent);

    } else {
        Y.error("simulateUIEvent(): No event simulation framework present.");
    }
}

/*
 * (iOS only) This is for creating native DOM gesture events which only iOS
 * v2.0+ is supporting.
 *
 * @method simulateGestureEvent
 * @private
 * @param {HTMLElement} target The target of the given event.
 * @param {String} type The type of event to fire. This can be any one of
 *      the following: touchstart, touchmove, touchend, touchcancel.
 * @param {Boolean} bubbles (Optional) Indicates if the event can be
 *      bubbled up. DOM Level 2 specifies that all mouse events bubble by
 *      default. The default is true.
 * @param {Boolean} cancelable (Optional) Indicates if the event can be
 *      canceled using preventDefault(). DOM Level 2 specifies that all
 *      touch events except touchcancel can be cancelled. The default
 *      is true for all events except touchcancel, for which the default
 *      is false.
 * @param {Window} view (Optional) The view containing the target. This is
 *      typically the window object. The default is window.
 * @param {Number} detail (Optional) Specifies some detail information about
 *      the event depending on the type of event.
 * @param {Number} screenX (Optional) The x-coordinate on the screen at which
 *      point the event occured. The default is 0.
 * @param {Number} screenY (Optional) The y-coordinate on the screen at which
 *      point the event occured. The default is 0.
 * @param {Number} clientX (Optional) The x-coordinate on the client at which
 *      point the event occured. The default is 0.
 * @param {Number} clientY (Optional) The y-coordinate on the client at which
 *      point the event occured. The default is 0.
 * @param {Boolean} ctrlKey (Optional) Indicates if one of the CTRL keys
 *      is pressed while the event is firing. The default is false.
 * @param {Boolean} altKey (Optional) Indicates if one of the ALT keys
 *      is pressed while the event is firing. The default is false.
 * @param {Boolean} shiftKey (Optional) Indicates if one of the SHIFT keys
 *      is pressed while the event is firing. The default is false.
 * @param {Boolean} metaKey (Optional) Indicates if one of the META keys
 *      is pressed while the event is firing. The default is false.
 * @param {Number} scale (iOS v2+ only) The distance between two fingers
 *      since the start of an event as a multiplier of the initial distance.
 *      The default value is 1.0.
 * @param {Number} rotation (iOS v2+ only) The delta rotation since the start
 *      of an event, in degrees, where clockwise is positive and
 *      counter-clockwise is negative. The default value is 0.0.
 */
function simulateGestureEvent(target, type,
    bubbles,            // boolean
    cancelable,         // boolean
    view,               // DOMWindow
    detail,             // long
    screenX, screenY,   // long
    clientX, clientY,   // long
    ctrlKey, altKey, shiftKey, metaKey, // boolean
    scale,              // float
    rotation            // float
) {
    var customEvent;

    if(!Y.UA.ios || Y.UA.ios<2.0) {
        Y.error("simulateGestureEvent(): Native gesture DOM eventframe is not available in this platform.");
    }

    // check taget
    if (!target){
        Y.error("simulateGestureEvent(): Invalid target.");
    }

    //check event type
    if (Y.Lang.isString(type)) {
        type = type.toLowerCase();

        //make sure it's a supported touch event
        if (!gestureEvents[type]){
            Y.error("simulateTouchEvent(): Event type '" + type + "' not supported.");
        }
    } else {
        Y.error("simulateGestureEvent(): Event type must be a string.");
    }

    // setup default values
    if (!Y.Lang.isBoolean(bubbles)) { bubbles = true; } // bubble by default
    if (!Y.Lang.isBoolean(cancelable)) { cancelable = true; }
    if (!Y.Lang.isObject(view))     { view = Y.config.win; }
    if (!Y.Lang.isNumber(detail))   { detail = 2; }     // usually not used.
    if (!Y.Lang.isNumber(screenX))  { screenX = 0; }
    if (!Y.Lang.isNumber(screenY))  { screenY = 0; }
    if (!Y.Lang.isNumber(clientX))  { clientX = 0; }
    if (!Y.Lang.isNumber(clientY))  { clientY = 0; }
    if (!Y.Lang.isBoolean(ctrlKey)) { ctrlKey = false; }
    if (!Y.Lang.isBoolean(altKey))  { altKey = false; }
    if (!Y.Lang.isBoolean(shiftKey)){ shiftKey = false; }
    if (!Y.Lang.isBoolean(metaKey)) { metaKey = false; }

    if (!Y.Lang.isNumber(scale)){ scale = 1.0; }
    if (!Y.Lang.isNumber(rotation)){ rotation = 0.0; }

    customEvent = Y.config.doc.createEvent("GestureEvent");

    customEvent.initGestureEvent(type, bubbles, cancelable, view, detail,
        screenX, screenY, clientX, clientY,
        ctrlKey, altKey, shiftKey, metaKey,
        target, scale, rotation);

    target.dispatchEvent(customEvent);
}


/*
 * @method simulateTouchEvent
 * @private
 * @param {HTMLElement} target The target of the given event.
 * @param {String} type The type of event to fire. This can be any one of
 *      the following: touchstart, touchmove, touchend, touchcancel.
 * @param {Boolean} bubbles (Optional) Indicates if the event can be
 *      bubbled up. DOM Level 2 specifies that all mouse events bubble by
 *      default. The default is true.
 * @param {Boolean} cancelable (Optional) Indicates if the event can be
 *      canceled using preventDefault(). DOM Level 2 specifies that all
 *      touch events except touchcancel can be cancelled. The default
 *      is true for all events except touchcancel, for which the default
 *      is false.
 * @param {Window} view (Optional) The view containing the target. This is
 *      typically the window object. The default is window.
 * @param {Number} detail (Optional) Specifies some detail information about
 *      the event depending on the type of event.
 * @param {Number} screenX (Optional) The x-coordinate on the screen at which
 *      point the event occured. The default is 0.
 * @param {Number} screenY (Optional) The y-coordinate on the screen at which
 *      point the event occured. The default is 0.
 * @param {Number} clientX (Optional) The x-coordinate on the client at which
 *      point the event occured. The default is 0.
 * @param {Number} clientY (Optional) The y-coordinate on the client at which
 *      point the event occured. The default is 0.
 * @param {Boolean} ctrlKey (Optional) Indicates if one of the CTRL keys
 *      is pressed while the event is firing. The default is false.
 * @param {Boolean} altKey (Optional) Indicates if one of the ALT keys
 *      is pressed while the event is firing. The default is false.
 * @param {Boolean} shiftKey (Optional) Indicates if one of the SHIFT keys
 *      is pressed while the event is firing. The default is false.
 * @param {Boolean} metaKey (Optional) Indicates if one of the META keys
 *      is pressed while the event is firing. The default is false.
 * @param {TouchList} touches A collection of Touch objects representing
 *      all touches associated with this event.
 * @param {TouchList} targetTouches A collection of Touch objects
 *      representing all touches associated with this target.
 * @param {TouchList} changedTouches A collection of Touch objects
 *      representing all touches that changed in this event.
 * @param {Number} scale (iOS v2+ only) The distance between two fingers
 *      since the start of an event as a multiplier of the initial distance.
 *      The default value is 1.0.
 * @param {Number} rotation (iOS v2+ only) The delta rotation since the start
 *      of an event, in degrees, where clockwise is positive and
 *      counter-clockwise is negative. The default value is 0.0.
 */
function simulateTouchEvent(target, type,
    bubbles,            // boolean
    cancelable,         // boolean
    view,               // DOMWindow
    detail,             // long
    screenX, screenY,   // long
    clientX, clientY,   // long
    ctrlKey, altKey, shiftKey, metaKey, // boolean
    touches,            // TouchList
    targetTouches,      // TouchList
    changedTouches,     // TouchList
    scale,              // float
    rotation            // float
) {

    var customEvent;

    // check taget
    if (!target){
        Y.error("simulateTouchEvent(): Invalid target.");
    }

    //check event type
    if (Y.Lang.isString(type)) {
        type = type.toLowerCase();

        //make sure it's a supported touch event
        if (!touchEvents[type]){
            Y.error("simulateTouchEvent(): Event type '" + type + "' not supported.");
        }
    } else {
        Y.error("simulateTouchEvent(): Event type must be a string.");
    }

    // note that the caller is responsible to pass appropriate touch objects.
    // check touch objects
    // Android(even 4.0) doesn't define TouchList yet
    /*if(type === 'touchstart' || type === 'touchmove') {
        if(!touches instanceof TouchList) {
            Y.error('simulateTouchEvent(): Invalid touches. It must be a TouchList');
        } else {
            if(touches.length === 0) {
                Y.error('simulateTouchEvent(): No touch object found.');
            }
        }
    } else if(type === 'touchend') {
        if(!changedTouches instanceof TouchList) {
            Y.error('simulateTouchEvent(): Invalid touches. It must be a TouchList');
        } else {
            if(changedTouches.length === 0) {
                Y.error('simulateTouchEvent(): No touch object found.');
            }
        }
    }*/

    if(type === 'touchstart' || type === 'touchmove') {
        if(touches.length === 0) {
            Y.error('simulateTouchEvent(): No touch object in touches');
        }
    } else if(type === 'touchend') {
        if(changedTouches.length === 0) {
            Y.error('simulateTouchEvent(): No touch object in changedTouches');
        }
    }

    // setup default values
    if (!Y.Lang.isBoolean(bubbles)) { bubbles = true; } // bubble by default.
    if (!Y.Lang.isBoolean(cancelable)) {
        cancelable = (type !== "touchcancel"); // touchcancel is not cancelled
    }
    if (!Y.Lang.isObject(view))     { view = Y.config.win; }
    if (!Y.Lang.isNumber(detail))   { detail = 1; } // usually not used. defaulted to # of touch objects.
    if (!Y.Lang.isNumber(screenX))  { screenX = 0; }
    if (!Y.Lang.isNumber(screenY))  { screenY = 0; }
    if (!Y.Lang.isNumber(clientX))  { clientX = 0; }
    if (!Y.Lang.isNumber(clientY))  { clientY = 0; }
    if (!Y.Lang.isBoolean(ctrlKey)) { ctrlKey = false; }
    if (!Y.Lang.isBoolean(altKey))  { altKey = false; }
    if (!Y.Lang.isBoolean(shiftKey)){ shiftKey = false; }
    if (!Y.Lang.isBoolean(metaKey)) { metaKey = false; }
    if (!Y.Lang.isNumber(scale))    { scale = 1.0; }
    if (!Y.Lang.isNumber(rotation)) { rotation = 0.0; }


    //check for DOM-compliant browsers first
    if (Y.Lang.isFunction(Y.config.doc.createEvent)) {
        if (Y.UA.android) {
            /*
                * Couldn't find android start version that supports touch event.
                * Assumed supported(btw APIs broken till icecream sandwitch)
                * from the beginning.
            */
            if(Y.UA.android < 4.0) {
                /*
                    * Touch APIs are broken in androids older than 4.0. We will use
                    * simulated touch apis for these versions.
                    * App developer still can listen for touch events. This events
                    * will be dispatched with touch event types.
                    *
                    * (Note) Used target for the relatedTarget. Need to verify if
                    * it has a side effect.
                */
                customEvent = Y.config.doc.createEvent("MouseEvents");
                customEvent.initMouseEvent(type, bubbles, cancelable, view, detail,
                    screenX, screenY, clientX, clientY,
                    ctrlKey, altKey, shiftKey, metaKey,
                    0, target);

                customEvent.touches = touches;
                customEvent.targetTouches = targetTouches;
                customEvent.changedTouches = changedTouches;
            } else {
                customEvent = Y.config.doc.createEvent("TouchEvent");

                // Andoroid isn't compliant W3C initTouchEvent method signature.
                customEvent.initTouchEvent(touches, targetTouches, changedTouches,
                    type, view,
                    screenX, screenY, clientX, clientY,
                    ctrlKey, altKey, shiftKey, metaKey);
            }
        } else if (Y.UA.ios) {
            if(Y.UA.ios >= 2.0) {
                customEvent = Y.config.doc.createEvent("TouchEvent");

                // Available iOS 2.0 and later
                customEvent.initTouchEvent(type, bubbles, cancelable, view, detail,
                    screenX, screenY, clientX, clientY,
                    ctrlKey, altKey, shiftKey, metaKey,
                    touches, targetTouches, changedTouches,
                    scale, rotation);
            } else {
                Y.error('simulateTouchEvent(): No touch event simulation framework present for iOS, '+Y.UA.ios+'.');
            }
        } else {
            Y.error('simulateTouchEvent(): Not supported agent yet, '+Y.UA.userAgent);
        }

        //fire the event
        target.dispatchEvent(customEvent);
    //} else if (Y.Lang.isObject(doc.createEventObject)){ // Windows Mobile/IE, support later
    } else {
        Y.error('simulateTouchEvent(): No event simulation framework present.');
    }
}

/**
 * Simulates the event or gesture with the given name on a target.
 * @param {HTMLElement} target The DOM element that's the target of the event.
 * @param {String} type The type of event or name of the supported gesture to simulate
 *      (i.e., "click", "doubletap", "flick").
 * @param {Object} options (Optional) Extra options to copy onto the event object.
 *      For gestures, options are used to refine the gesture behavior.
 * @for Event
 * @method simulate
 * @static
 */
Y.Event.simulate = function(target, type, options){

    options = options || {};

    if (mouseEvents[type] || pointerEvents[type]){
        simulateMouseEvent(target, type, options.bubbles,
            options.cancelable, options.view, options.detail, options.screenX,
            options.screenY, options.clientX, options.clientY, options.ctrlKey,
            options.altKey, options.shiftKey, options.metaKey, options.button,
            options.relatedTarget);
    } else if (keyEvents[type]){
        simulateKeyEvent(target, type, options.bubbles,
            options.cancelable, options.view, options.ctrlKey,
            options.altKey, options.shiftKey, options.metaKey,
            options.keyCode, options.charCode);
    } else if (uiEvents[type]){
        simulateUIEvent(target, type, options.bubbles,
            options.cancelable, options.view, options.detail);

    // touch low-level event simulation
    } else if (touchEvents[type]) {
        if((Y.config.win && ("ontouchstart" in Y.config.win)) && !(Y.UA.phantomjs) && !(Y.UA.chrome && Y.UA.chrome < 6)) {
            simulateTouchEvent(target, type,
                options.bubbles, options.cancelable, options.view, options.detail,
                options.screenX, options.screenY, options.clientX, options.clientY,
                options.ctrlKey, options.altKey, options.shiftKey, options.metaKey,
                options.touches, options.targetTouches, options.changedTouches,
                options.scale, options.rotation);
        } else {
            Y.error("simulate(): Event '" + type + "' can't be simulated. Use gesture-simulate module instead.");
        }

    // ios gesture low-level event simulation (iOS v2+ only)
    } else if(Y.UA.ios && Y.UA.ios >= 2.0 && gestureEvents[type]) {
        simulateGestureEvent(target, type,
            options.bubbles, options.cancelable, options.view, options.detail,
            options.screenX, options.screenY, options.clientX, options.clientY,
            options.ctrlKey, options.altKey, options.shiftKey, options.metaKey,
            options.scale, options.rotation);

    // anything else
    } else {
        Y.error("simulate(): Event '" + type + "' can't be simulated.");
    }
};


})();



}, '3.17.2', {"requires": ["event-base"]});


/***/ }),

/***/ 989746:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-synthetic', function (Y, NAME) {

/**
 * Define new DOM events that can be subscribed to from Nodes.
 *
 * @module event
 * @submodule event-synthetic
 */
var CustomEvent = Y.CustomEvent,
    DOMMap   = Y.Env.evt.dom_map,
    toArray  = Y.Array,
    YLang    = Y.Lang,
    isObject = YLang.isObject,
    isString = YLang.isString,
    isArray  = YLang.isArray,
    query    = Y.Selector.query,
    noop     = function () {};

/**
 * <p>The triggering mechanism used by SyntheticEvents.</p>
 *
 * <p>Implementers should not instantiate these directly.  Use the Notifier
 * provided to the event's implemented <code>on(node, sub, notifier)</code> or
 * <code>delegate(node, sub, notifier, filter)</code> methods.</p>
 *
 * @class SyntheticEvent.Notifier
 * @constructor
 * @param handle {EventHandle} the detach handle for the subscription to an
 *              internal custom event used to execute the callback passed to
 *              on(..) or delegate(..)
 * @param emitFacade {Boolean} take steps to ensure the first arg received by
 *              the subscription callback is an event facade
 * @private
 * @since 3.2.0
 */
function Notifier(handle, emitFacade) {
    this.handle     = handle;
    this.emitFacade = emitFacade;
}

/**
 * <p>Executes the subscription callback, passing the firing arguments as the
 * first parameters to that callback. For events that are configured with
 * emitFacade=true, it is common practice to pass the triggering DOMEventFacade
 * as the first parameter.  Barring a proper DOMEventFacade or EventFacade
 * (from a CustomEvent), a new EventFacade will be generated.  In that case, if
 * fire() is called with a simple object, it will be mixed into the facade.
 * Otherwise, the facade will be prepended to the callback parameters.</p>
 *
 * <p>For notifiers provided to delegate logic, the first argument should be an
 * object with a &quot;currentTarget&quot; property to identify what object to
 * default as 'this' in the callback.  Typically this is gleaned from the
 * DOMEventFacade or EventFacade, but if configured with emitFacade=false, an
 * object must be provided.  In that case, the object will be removed from the
 * callback parameters.</p>
 *
 * <p>Additional arguments passed during event subscription will be
 * automatically added after those passed to fire().</p>
 *
 * @method fire
 * @param {EventFacade|DOMEventFacade|any} e (see description)
 * @param {any[]} [arg*] additional arguments received by all subscriptions
 * @private
 */
Notifier.prototype.fire = function (e) {
    // first arg to delegate notifier should be an object with currentTarget
    var args     = toArray(arguments, 0, true),
        handle   = this.handle,
        ce       = handle.evt,
        sub      = handle.sub,
        thisObj  = sub.context,
        delegate = sub.filter,
        event    = e || {},
        ret;

    if (this.emitFacade) {
        if (!e || !e.preventDefault) {
            event = ce._getFacade();

            if (isObject(e) && !e.preventDefault) {
                Y.mix(event, e, true);
                args[0] = event;
            } else {
                args.unshift(event);
            }
        }

        event.type    = ce.type;
        event.details = args.slice();

        if (delegate) {
            event.container = ce.host;
        }
    } else if (delegate && isObject(e) && e.currentTarget) {
        args.shift();
    }

    sub.context = thisObj || event.currentTarget || ce.host;
    ret = ce.fire.apply(ce, args);

    // have to handle preventedFn and stoppedFn manually because
    // Notifier CustomEvents are forced to emitFacade=false
    if (e.prevented && ce.preventedFn) {
        ce.preventedFn.apply(ce, args);
    }

    if (e.stopped && ce.stoppedFn) {
        ce.stoppedFn.apply(ce, args);
    }

    sub.context = thisObj; // reset for future firing

    // to capture callbacks that return false to stopPropagation.
    // Useful for delegate implementations
    return ret;
};

/**
 * Manager object for synthetic event subscriptions to aggregate multiple synths on the
 * same node without colliding with actual DOM subscription entries in the global map of
 * DOM subscriptions.  Also facilitates proper cleanup on page unload.
 *
 * @class SynthRegistry
 * @constructor
 * @param el {HTMLElement} the DOM element
 * @param yuid {String} the yuid stamp for the element
 * @param key {String} the generated id token used to identify an event type +
 *                     element in the global DOM subscription map.
 * @private
 */
function SynthRegistry(el, yuid, key) {
    this.handles = [];
    this.el      = el;
    this.key     = key;
    this.domkey  = yuid;
}

SynthRegistry.prototype = {
    constructor: SynthRegistry,

    // A few object properties to fake the CustomEvent interface for page
    // unload cleanup.  DON'T TOUCH!
    type      : '_synth',
    fn        : noop,
    capture   : false,

    /**
     * Adds a subscription from the Notifier registry.
     *
     * @method register
     * @param handle {EventHandle} the subscription
     * @since 3.4.0
     */
    register: function (handle) {
        handle.evt.registry = this;
        this.handles.push(handle);
    },

    /**
     * Removes the subscription from the Notifier registry.
     *
     * @method _unregisterSub
     * @param sub {Subscription} the subscription
     * @since 3.4.0
     */
    unregister: function (sub) {
        var handles = this.handles,
            events = DOMMap[this.domkey],
            i;

        for (i = handles.length - 1; i >= 0; --i) {
            if (handles[i].sub === sub) {
                handles.splice(i, 1);
                break;
            }
        }

        // Clean up left over objects when there are no more subscribers.
        if (!handles.length) {
            delete events[this.key];
            if (!Y.Object.size(events)) {
                delete DOMMap[this.domkey];
            }
        }
    },

    /**
     * Used by the event system's unload cleanup process.  When navigating
     * away from the page, the event system iterates the global map of element
     * subscriptions and detaches everything using detachAll().  Normally,
     * the map is populated with custom events, so this object needs to
     * at least support the detachAll method to duck type its way to
     * cleanliness.
     *
     * @method detachAll
     * @private
     * @since 3.4.0
     */
    detachAll : function () {
        var handles = this.handles,
            i = handles.length;

        while (--i >= 0) {
            handles[i].detach();
        }
    }
};

/**
 * <p>Wrapper class for the integration of new events into the YUI event
 * infrastructure.  Don't instantiate this object directly, use
 * <code>Y.Event.define(type, config)</code>.  See that method for details.</p>
 *
 * <p>Properties that MAY or SHOULD be specified in the configuration are noted
 * below and in the description of <code>Y.Event.define</code>.</p>
 *
 * @class SyntheticEvent
 * @constructor
 * @param cfg {Object} Implementation pieces and configuration
 * @since 3.1.0
 * @in event-synthetic
 */
function SyntheticEvent() {
    this._init.apply(this, arguments);
}

Y.mix(SyntheticEvent, {
    Notifier: Notifier,
    SynthRegistry: SynthRegistry,

    /**
     * Returns the array of subscription handles for a node for the given event
     * type.  Passing true as the third argument will create a registry entry
     * in the event system's DOM map to host the array if one doesn't yet exist.
     *
     * @method getRegistry
     * @param node {Node} the node
     * @param type {String} the event
     * @param create {Boolean} create a registration entry to host a new array
     *                  if one doesn't exist.
     * @return {Array}
     * @static
     * @protected
     * @since 3.2.0
     */
    getRegistry: function (node, type, create) {
        var el     = node._node,
            yuid   = Y.stamp(el),
            key    = 'event:' + yuid + type + '_synth',
            events = DOMMap[yuid];

        if (create) {
            if (!events) {
                events = DOMMap[yuid] = {};
            }
            if (!events[key]) {
                events[key] = new SynthRegistry(el, yuid, key);
            }
        }

        return (events && events[key]) || null;
    },

    /**
     * Alternate <code>_delete()</code> method for the CustomEvent object
     * created to manage SyntheticEvent subscriptions.
     *
     * @method _deleteSub
     * @param sub {Subscription} the subscription to clean up
     * @private
     * @since 3.2.0
     */
    _deleteSub: function (sub) {
        if (sub && sub.fn) {
            var synth = this.eventDef,
                method = (sub.filter) ? 'detachDelegate' : 'detach';

            this._subscribers = [];

            if (CustomEvent.keepDeprecatedSubs) {
                this.subscribers = {};
            }

            synth[method](sub.node, sub, this.notifier, sub.filter);
            this.registry.unregister(sub);

            delete sub.fn;
            delete sub.node;
            delete sub.context;
        }
    },

    prototype: {
        constructor: SyntheticEvent,

        /**
         * Construction logic for the event.
         *
         * @method _init
         * @protected
         */
        _init: function () {
            var config = this.publishConfig || (this.publishConfig = {});

            // The notification mechanism handles facade creation
            this.emitFacade = ('emitFacade' in config) ?
                                config.emitFacade :
                                true;
            config.emitFacade  = false;
        },

        /**
         * <p>Implementers MAY provide this method definition.</p>
         *
         * <p>Implement this function if the event supports a different
         * subscription signature.  This function is used by both
         * <code>on()</code> and <code>delegate()</code>.  The second parameter
         * indicates that the event is being subscribed via
         * <code>delegate()</code>.</p>
         *
         * <p>Implementations must remove extra arguments from the args list
         * before returning.  The required args for <code>on()</code>
         * subscriptions are</p>
         * <pre><code>[type, callback, target, context, argN...]</code></pre>
         *
         * <p>The required args for <code>delegate()</code>
         * subscriptions are</p>
         *
         * <pre><code>[type, callback, target, filter, context, argN...]</code></pre>
         *
         * <p>The return value from this function will be stored on the
         * subscription in the '_extra' property for reference elsewhere.</p>
         *
         * @method processArgs
         * @param args {Array} parmeters passed to Y.on(..) or Y.delegate(..)
         * @param delegate {Boolean} true if the subscription is from Y.delegate
         * @return {any}
         */
        processArgs: noop,

        /**
         * <p>Implementers MAY override this property.</p>
         *
         * <p>Whether to prevent multiple subscriptions to this event that are
         * classified as being the same.  By default, this means the subscribed
         * callback is the same function.  See the <code>subMatch</code>
         * method.  Setting this to true will impact performance for high volume
         * events.</p>
         *
         * @property preventDups
         * @type {Boolean}
         * @default false
         */
        //preventDups  : false,

        /**
         * <p>Implementers SHOULD provide this method definition.</p>
         *
         * Implementation logic for subscriptions done via <code>node.on(type,
         * fn)</code> or <code>Y.on(type, fn, target)</code>.  This
         * function should set up the monitor(s) that will eventually fire the
         * event.  Typically this involves subscribing to at least one DOM
         * event.  It is recommended to store detach handles from any DOM
         * subscriptions to make for easy cleanup in the <code>detach</code>
         * method.  Typically these handles are added to the <code>sub</code>
         * object.  Also for SyntheticEvents that leverage a single DOM
         * subscription under the hood, it is recommended to pass the DOM event
         * object to <code>notifier.fire(e)</code>.  (The event name on the
         * object will be updated).
         *
         * @method on
         * @param node {Node} the node the subscription is being applied to
         * @param sub {Subscription} the object to track this subscription
         * @param notifier {SyntheticEvent.Notifier} call notifier.fire(..) to
         *              trigger the execution of the subscribers
         */
        on: noop,

        /**
         * <p>Implementers SHOULD provide this method definition.</p>
         *
         * <p>Implementation logic for detaching subscriptions done via
         * <code>node.on(type, fn)</code>.  This function should clean up any
         * subscriptions made in the <code>on()</code> phase.</p>
         *
         * @method detach
         * @param node {Node} the node the subscription was applied to
         * @param sub {Subscription} the object tracking this subscription
         * @param notifier {SyntheticEvent.Notifier} the Notifier used to
         *              trigger the execution of the subscribers
         */
        detach: noop,

        /**
         * <p>Implementers SHOULD provide this method definition.</p>
         *
         * <p>Implementation logic for subscriptions done via
         * <code>node.delegate(type, fn, filter)</code> or
         * <code>Y.delegate(type, fn, container, filter)</code>.  Like with
         * <code>on()</code> above, this function should monitor the environment
         * for the event being fired, and trigger subscription execution by
         * calling <code>notifier.fire(e)</code>.</p>
         *
         * <p>This function receives a fourth argument, which is the filter
         * used to identify which Node's are of interest to the subscription.
         * The filter will be either a boolean function that accepts a target
         * Node for each hierarchy level as the event bubbles, or a selector
         * string.  To translate selector strings into filter functions, use
         * <code>Y.delegate.compileFilter(filter)</code>.</p>
         *
         * @method delegate
         * @param node {Node} the node the subscription is being applied to
         * @param sub {Subscription} the object to track this subscription
         * @param notifier {SyntheticEvent.Notifier} call notifier.fire(..) to
         *              trigger the execution of the subscribers
         * @param filter {String|Function} Selector string or function that
         *              accepts an event object and returns null, a Node, or an
         *              array of Nodes matching the criteria for processing.
         * @since 3.2.0
         */
        delegate       : noop,

        /**
         * <p>Implementers SHOULD provide this method definition.</p>
         *
         * <p>Implementation logic for detaching subscriptions done via
         * <code>node.delegate(type, fn, filter)</code> or
         * <code>Y.delegate(type, fn, container, filter)</code>.  This function
         * should clean up any subscriptions made in the
         * <code>delegate()</code> phase.</p>
         *
         * @method detachDelegate
         * @param node {Node} the node the subscription was applied to
         * @param sub {Subscription} the object tracking this subscription
         * @param notifier {SyntheticEvent.Notifier} the Notifier used to
         *              trigger the execution of the subscribers
         * @param filter {String|Function} Selector string or function that
         *              accepts an event object and returns null, a Node, or an
         *              array of Nodes matching the criteria for processing.
         * @since 3.2.0
         */
        detachDelegate : noop,

        /**
         * Sets up the boilerplate for detaching the event and facilitating the
         * execution of subscriber callbacks.
         *
         * @method _on
         * @param args {Array} array of arguments passed to
         *              <code>Y.on(...)</code> or <code>Y.delegate(...)</code>
         * @param delegate {Boolean} true if called from
         * <code>Y.delegate(...)</code>
         * @return {EventHandle} the detach handle for this subscription
         * @private
         * since 3.2.0
         */
        _on: function (args, delegate) {
            var handles  = [],
                originalArgs = args.slice(),
                extra    = this.processArgs(args, delegate),
                selector = args[2],
                method   = delegate ? 'delegate' : 'on',
                nodes, handle;

            // Can't just use Y.all because it doesn't support window (yet?)
            nodes = (isString(selector)) ?
                query(selector) :
                toArray(selector || Y.one(Y.config.win));

            if (!nodes.length && isString(selector)) {
                handle = Y.on('available', function () {
                    Y.mix(handle, Y[method].apply(Y, originalArgs), true);
                }, selector);

                return handle;
            }

            Y.Array.each(nodes, function (node) {
                var subArgs = args.slice(),
                    filter;

                node = Y.one(node);

                if (node) {
                    if (delegate) {
                        filter = subArgs.splice(3, 1)[0];
                    }

                    // (type, fn, el, thisObj, ...) => (fn, thisObj, ...)
                    subArgs.splice(0, 4, subArgs[1], subArgs[3]);

                    if (!this.preventDups ||
                        !this.getSubs(node, args, null, true))
                    {
                        handles.push(this._subscribe(node, method, subArgs, extra, filter));
                    }
                }
            }, this);

            return (handles.length === 1) ?
                handles[0] :
                new Y.EventHandle(handles);
        },

        /**
         * Creates a new Notifier object for use by this event's
         * <code>on(...)</code> or <code>delegate(...)</code> implementation
         * and register the custom event proxy in the DOM system for cleanup.
         *
         * @method _subscribe
         * @param node {Node} the Node hosting the event
         * @param method {String} "on" or "delegate"
         * @param args {Array} the subscription arguments passed to either
         *              <code>Y.on(...)</code> or <code>Y.delegate(...)</code>
         *              after running through <code>processArgs(args)</code> to
         *              normalize the argument signature
         * @param extra {any} Extra data parsed from
         *              <code>processArgs(args)</code>
         * @param filter {String|Function} the selector string or function
         *              filter passed to <code>Y.delegate(...)</code> (not
         *              present when called from <code>Y.on(...)</code>)
         * @return {EventHandle}
         * @private
         * @since 3.2.0
         */
        _subscribe: function (node, method, args, extra, filter) {
            var dispatcher = new Y.CustomEvent(this.type, this.publishConfig),
                handle     = dispatcher.on.apply(dispatcher, args),
                notifier   = new Notifier(handle, this.emitFacade),
                registry   = SyntheticEvent.getRegistry(node, this.type, true),
                sub        = handle.sub;

            sub.node   = node;
            sub.filter = filter;
            if (extra) {
                this.applyArgExtras(extra, sub);
            }

            Y.mix(dispatcher, {
                eventDef     : this,
                notifier     : notifier,
                host         : node,       // I forget what this is for
                currentTarget: node,       // for generating facades
                target       : node,       // for generating facades
                el           : node._node, // For category detach

                _delete      : SyntheticEvent._deleteSub
            }, true);

            handle.notifier = notifier;

            registry.register(handle);

            // Call the implementation's "on" or "delegate" method
            this[method](node, sub, notifier, filter);

            return handle;
        },

        /**
         * <p>Implementers MAY provide this method definition.</p>
         *
         * <p>Implement this function if you want extra data extracted during
         * processArgs to be propagated to subscriptions on a per-node basis.
         * That is to say, if you call <code>Y.on('xyz', fn, xtra, 'div')</code>
         * the data returned from processArgs will be shared
         * across the subscription objects for all the divs.  If you want each
         * subscription to receive unique information, do that processing
         * here.</p>
         *
         * <p>The default implementation adds the data extracted by processArgs
         * to the subscription object as <code>sub._extra</code>.</p>
         *
         * @method applyArgExtras
         * @param extra {any} Any extra data extracted from processArgs
         * @param sub {Subscription} the individual subscription
         */
        applyArgExtras: function (extra, sub) {
            sub._extra = extra;
        },

        /**
         * Removes the subscription(s) from the internal subscription dispatch
         * mechanism.  See <code>SyntheticEvent._deleteSub</code>.
         *
         * @method _detach
         * @param args {Array} The arguments passed to
         *                  <code>node.detach(...)</code>
         * @private
         * @since 3.2.0
         */
        _detach: function (args) {
            // Can't use Y.all because it doesn't support window (yet?)
            // TODO: Does Y.all support window now?
            var target = args[2],
                els    = (isString(target)) ?
                            query(target) : toArray(target),
                node, i, len, handles, j;

            // (type, fn, el, context, filter?) => (type, fn, context, filter?)
            args.splice(2, 1);

            for (i = 0, len = els.length; i < len; ++i) {
                node = Y.one(els[i]);

                if (node) {
                    handles = this.getSubs(node, args);

                    if (handles) {
                        for (j = handles.length - 1; j >= 0; --j) {
                            handles[j].detach();
                        }
                    }
                }
            }
        },

        /**
         * Returns the detach handles of subscriptions on a node that satisfy a
         * search/filter function.  By default, the filter used is the
         * <code>subMatch</code> method.
         *
         * @method getSubs
         * @param node {Node} the node hosting the event
         * @param args {Array} the array of original subscription args passed
         *              to <code>Y.on(...)</code> (before
         *              <code>processArgs</code>
         * @param filter {Function} function used to identify a subscription
         *              for inclusion in the returned array
         * @param first {Boolean} stop after the first match (used to check for
         *              duplicate subscriptions)
         * @return {EventHandle[]} detach handles for the matching subscriptions
         */
        getSubs: function (node, args, filter, first) {
            var registry = SyntheticEvent.getRegistry(node, this.type),
                handles  = [],
                allHandles, i, len, handle;

            if (registry) {
                allHandles = registry.handles;

                if (!filter) {
                    filter = this.subMatch;
                }

                for (i = 0, len = allHandles.length; i < len; ++i) {
                    handle = allHandles[i];
                    if (filter.call(this, handle.sub, args)) {
                        if (first) {
                            return handle;
                        } else {
                            handles.push(allHandles[i]);
                        }
                    }
                }
            }

            return handles.length && handles;
        },

        /**
         * <p>Implementers MAY override this to define what constitutes a
         * &quot;same&quot; subscription.  Override implementations should
         * consider the lack of a comparator as a match, so calling
         * <code>getSubs()</code> with no arguments will return all subs.</p>
         *
         * <p>Compares a set of subscription arguments against a Subscription
         * object to determine if they match.  The default implementation
         * compares the callback function against the second argument passed to
         * <code>Y.on(...)</code> or <code>node.detach(...)</code> etc.</p>
         *
         * @method subMatch
         * @param sub {Subscription} the existing subscription
         * @param args {Array} the calling arguments passed to
         *                  <code>Y.on(...)</code> etc.
         * @return {Boolean} true if the sub can be described by the args
         *                  present
         * @since 3.2.0
         */
        subMatch: function (sub, args) {
            // Default detach cares only about the callback matching
            return !args[1] || sub.fn === args[1];
        }
    }
}, true);

Y.SyntheticEvent = SyntheticEvent;

/**
 * <p>Defines a new event in the DOM event system.  Implementers are
 * responsible for monitoring for a scenario whereby the event is fired.  A
 * notifier object is provided to the functions identified below.  When the
 * criteria defining the event are met, call notifier.fire( [args] ); to
 * execute event subscribers.</p>
 *
 * <p>The first parameter is the name of the event.  The second parameter is a
 * configuration object which define the behavior of the event system when the
 * new event is subscribed to or detached from.  The methods that should be
 * defined in this configuration object are <code>on</code>,
 * <code>detach</code>, <code>delegate</code>, and <code>detachDelegate</code>.
 * You are free to define any other methods or properties needed to define your
 * event.  Be aware, however, that since the object is used to subclass
 * SyntheticEvent, you should avoid method names used by SyntheticEvent unless
 * your intention is to override the default behavior.</p>
 *
 * <p>This is a list of properties and methods that you can or should specify
 * in the configuration object:</p>
 *
 * <dl>
 *   <dt><code>on</code></dt>
 *       <dd><code>function (node, subscription, notifier)</code> The
 *       implementation logic for subscription.  Any special setup you need to
 *       do to create the environment for the event being fired--E.g. native
 *       DOM event subscriptions.  Store subscription related objects and
 *       state on the <code>subscription</code> object.  When the
 *       criteria have been met to fire the synthetic event, call
 *       <code>notifier.fire(e)</code>.  See Notifier's <code>fire()</code>
 *       method for details about what to pass as parameters.</dd>
 *
 *   <dt><code>detach</code></dt>
 *       <dd><code>function (node, subscription, notifier)</code> The
 *       implementation logic for cleaning up a detached subscription. E.g.
 *       detach any DOM subscriptions added in <code>on</code>.</dd>
 *
 *   <dt><code>delegate</code></dt>
 *       <dd><code>function (node, subscription, notifier, filter)</code> The
 *       implementation logic for subscription via <code>Y.delegate</code> or
 *       <code>node.delegate</code>.  The filter is typically either a selector
 *       string or a function.  You can use
 *       <code>Y.delegate.compileFilter(selectorString)</code> to create a
 *       filter function from a selector string if needed.  The filter function
 *       expects an event object as input and should output either null, a
 *       matching Node, or an array of matching Nodes.  Otherwise, this acts
 *       like <code>on</code> DOM event subscriptions.  Store subscription
 *       related objects and information on the <code>subscription</code>
 *       object.  When the criteria have been met to fire the synthetic event,
 *       call <code>notifier.fire(e)</code> as noted above.</dd>
 *
 *   <dt><code>detachDelegate</code></dt>
 *       <dd><code>function (node, subscription, notifier)</code> The
 *       implementation logic for cleaning up a detached delegate subscription.
 *       E.g. detach any DOM delegate subscriptions added in
 *       <code>delegate</code>.</dd>
 *
 *   <dt><code>publishConfig</code></dt>
 *       <dd>(Object) The configuration object that will be used to instantiate
 *       the underlying CustomEvent. See Notifier's <code>fire</code> method
 *       for details.</dd>
 *
 *   <dt><code>processArgs</code></dt
 *       <dd>
 *          <p><code>function (argArray, fromDelegate)</code> Optional method
 *          to extract any additional arguments from the subscription
 *          signature.  Using this allows <code>on</code> or
 *          <code>delegate</code> signatures like
 *          <code>node.on(&quot;hover&quot;, overCallback,
 *          outCallback)</code>.</p>
 *          <p>When processing an atypical argument signature, make sure the
 *          args array is returned to the normal signature before returning
 *          from the function.  For example, in the &quot;hover&quot; example
 *          above, the <code>outCallback</code> needs to be <code>splice</code>d
 *          out of the array.  The expected signature of the args array for
 *          <code>on()</code> subscriptions is:</p>
 *          <pre>
 *              <code>[type, callback, target, contextOverride, argN...]</code>
 *          </pre>
 *          <p>And for <code>delegate()</code>:</p>
 *          <pre>
 *              <code>[type, callback, target, filter, contextOverride, argN...]</code>
 *          </pre>
 *          <p>where <code>target</code> is the node the event is being
 *          subscribed for.  You can see these signatures documented for
 *          <code>Y.on()</code> and <code>Y.delegate()</code> respectively.</p>
 *          <p>Whatever gets returned from the function will be stored on the
 *          <code>subscription</code> object under
 *          <code>subscription._extra</code>.</p></dd>
 *   <dt><code>subMatch</code></dt>
 *       <dd>
 *           <p><code>function (sub, args)</code>  Compares a set of
 *           subscription arguments against a Subscription object to determine
 *           if they match.  The default implementation compares the callback
 *           function against the second argument passed to
 *           <code>Y.on(...)</code> or <code>node.detach(...)</code> etc.</p>
 *       </dd>
 * </dl>
 *
 * @method define
 * @param type {String} the name of the event
 * @param config {Object} the prototype definition for the new event (see above)
 * @param force {Boolean} override an existing event (use with caution)
 * @return {SyntheticEvent} the subclass implementation instance created to
 *              handle event subscriptions of this type
 * @static
 * @for Event
 * @since 3.1.0
 * @in event-synthetic
 */
Y.Event.define = function (type, config, force) {
    var eventDef, Impl, synth;

    if (type && type.type) {
        eventDef = type;
        force = config;
    } else if (config) {
        eventDef = Y.merge({ type: type }, config);
    }

    if (eventDef) {
        if (force || !Y.Node.DOM_EVENTS[eventDef.type]) {
            Impl = function () {
                SyntheticEvent.apply(this, arguments);
            };
            Y.extend(Impl, SyntheticEvent, eventDef);
            synth = new Impl();

            type = synth.type;

            Y.Node.DOM_EVENTS[type] = Y.Env.evt.plugins[type] = {
                eventDef: synth,

                on: function () {
                    return synth._on(toArray(arguments));
                },

                delegate: function () {
                    return synth._on(toArray(arguments), true);
                },

                detach: function () {
                    return synth._detach(toArray(arguments));
                }
            };

        }
    } else if (isString(type) || isArray(type)) {
        Y.Array.each(toArray(type), function (t) {
            Y.Node.DOM_EVENTS[t] = 1;
        });
    }

    return synth;
};


}, '3.17.2', {"requires": ["node-base", "event-custom-complex"]});


/***/ }),

/***/ 931619:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-tap', function (Y, NAME) {

/**
The tap module provides a gesture events, "tap", which normalizes user interactions
across touch and mouse or pointer based input devices.  This can be used by application developers
to build input device agnostic components which behave the same in response to either touch or mouse based
interaction.

'tap' is like a touchscreen 'click', only it requires much less finger-down time since it listens to touch events,
but reverts to mouse events if touch is not supported.

@example

    YUI().use('event-tap', function (Y) {
        Y.one('#my-button').on('tap', function (e) {
        });
    });

@module event
@submodule event-tap
@author Andres Garza, matuzak and tilo mitra
@since 3.7.0

*/
var doc = Y.config.doc,
    GESTURE_MAP = Y.Event._GESTURE_MAP,
    EVT_START = GESTURE_MAP.start,
    EVT_TAP = 'tap',
    POINTER_EVENT_TEST = /pointer/i,

    HANDLES = {
        START: 'Y_TAP_ON_START_HANDLE',
        END: 'Y_TAP_ON_END_HANDLE',
        CANCEL: 'Y_TAP_ON_CANCEL_HANDLE'
    };

function detachHandles(subscription, handles) {
    handles = handles || Y.Object.values(HANDLES);

    Y.Array.each(handles, function (item) {
        var handle = subscription[item];
        if (handle) {
            handle.detach();
            subscription[item] = null;
        }
    });

}


/**
Sets up a "tap" event, that is fired on touch devices in response to a tap event (finger down, finder up).
This event can be used instead of listening for click events which have a 500ms delay on most touch devices.
This event can also be listened for using node.delegate().

@event tap
@param type {string} "tap"
@param fn {function} The method the event invokes. It receives the event facade of the underlying DOM event.
@for Event
@return {EventHandle} the detach handle
*/
Y.Event.define(EVT_TAP, {
    publishConfig: {
        preventedFn: function (e) {
            var sub = e.target.once('click', function (click) {
                click.preventDefault();
            });

            // Make sure to detach the subscription during the next event loop
            // so this doesn't `preventDefault()` on the wrong click event.
            setTimeout(function () {
                sub.detach();
            //Setting this to `0` causes the detachment to occur before the click
            //comes in on Android 4.0.3-4.0.4. 100ms seems to be a reliable number here
            //that works across the board.
            }, 100);
        }
    },

    processArgs: function (args, isDelegate) {

        //if we return for the delegate use case, then the `filter` argument
        //returns undefined, and we have to get the filter from sub._extra[0] (ugly)

        if (!isDelegate) {
            var extra = args[3];
            // remove the extra arguments from the array as specified by
            // http://yuilibrary.com/yui/docs/event/synths.html
            args.splice(3,1);
            return extra;
        }
    },
    /**
    This function should set up the node that will eventually fire the event.

    Usage:

        node.on('tap', function (e) {
        });

    @method on
    @param {Node} node
    @param {Array} subscription
    @param {Boolean} notifier
    @public
    @static
    **/
    on: function (node, subscription, notifier) {
        subscription[HANDLES.START] = node.on(EVT_START, this._start, this, node, subscription, notifier);
    },

    /**
    Detaches all event subscriptions set up by the event-tap module

    @method detach
    @param {Node} node
    @param {Array} subscription
    @param {Boolean} notifier
    @public
    @static
    **/
    detach: function (node, subscription, notifier) {
        detachHandles(subscription);
    },

    /**
    Event delegation for the 'tap' event. The delegated event will use a
    supplied selector or filtering function to test if the event references at least one
    node that should trigger the subscription callback.

    Usage:

        node.delegate('tap', function (e) {
        }, 'li a');

    @method delegate
    @param {Node} node
    @param {Array} subscription
    @param {Boolean} notifier
    @param {String | Function} filter
    @public
    @static
    **/
    delegate: function (node, subscription, notifier, filter) {
        subscription[HANDLES.START] = Y.delegate(EVT_START, function (e) {
            this._start(e, node, subscription, notifier, true);
        }, node, filter, this);
    },

    /**
    Detaches the delegated event subscriptions set up by the event-tap module.
    Only used if you use node.delegate(...) instead of node.on(...);

    @method detachDelegate
    @param {Node} node
    @param {Array} subscription
    @param {Boolean} notifier
    @public
    @static
    **/
    detachDelegate: function (node, subscription, notifier) {
        detachHandles(subscription);
    },

    /**
    Called when the monitor(s) are tapped on, either through touchstart or mousedown.

    @method _start
    @param {DOMEventFacade} event
    @param {Node} node
    @param {Array} subscription
    @param {Boolean} notifier
    @param {Boolean} delegate
    @protected
    @static
    **/
    _start: function (event, node, subscription, notifier, delegate) {

        var context = {
                canceled: false,
                eventType: event.type
            },
            preventMouse = subscription.preventMouse || false;

        //move ways to quit early to the top.
        // no right clicks
        if (event.button && event.button === 3) {
            return;
        }

        // for now just support a 1 finger count (later enhance via config)
        if (event.touches && event.touches.length !== 1) {
            return;
        }

        context.node = delegate ? event.currentTarget : node;

        //There is a double check in here to support event simulation tests, in which
        //event.touches can be undefined when simulating 'touchstart' on touch devices.
        if (event.touches) {
          context.startXY = [ event.touches[0].pageX, event.touches[0].pageY ];
        }
        else {
          context.startXY = [ event.pageX, event.pageY ];
        }

        //If `onTouchStart()` was called by a touch event, set up touch event subscriptions.
        //Otherwise, set up mouse/pointer event event subscriptions.
        if (event.touches) {

            subscription[HANDLES.END] = node.once('touchend', this._end, this, node, subscription, notifier, delegate, context);
            subscription[HANDLES.CANCEL] = node.once('touchcancel', this.detach, this, node, subscription, notifier, delegate, context);

            //Since this is a touch* event, there will be corresponding mouse events
            //that will be fired. We don't want these events to get picked up and fire
            //another `tap` event, so we'll set this variable to `true`.
            subscription.preventMouse = true;
        }

        //Only add these listeners if preventMouse is `false`
        //ie: not when touch events have already been subscribed to
        else if (context.eventType.indexOf('mouse') !== -1 && !preventMouse) {
            subscription[HANDLES.END] = node.once('mouseup', this._end, this, node, subscription, notifier, delegate, context);
            subscription[HANDLES.CANCEL] = node.once('mousecancel', this.detach, this, node, subscription, notifier, delegate, context);
        }

        //If a mouse event comes in after a touch event, it will go in here and
        //reset preventMouse to `true`.
        //If a mouse event comes in without a prior touch event, preventMouse will be
        //false in any case, so this block doesn't do anything.
        else if (context.eventType.indexOf('mouse') !== -1 && preventMouse) {
            subscription.preventMouse = false;
        }

        else if (POINTER_EVENT_TEST.test(context.eventType)) {
            subscription[HANDLES.END] = node.once(GESTURE_MAP.end, this._end, this, node, subscription, notifier, delegate, context);
            subscription[HANDLES.CANCEL] = node.once(GESTURE_MAP.cancel, this.detach, this, node, subscription, notifier, delegate, context);
        }

    },


    /**
    Called when the monitor(s) fires a touchend event (or the mouse equivalent).
    This method fires the 'tap' event if certain requirements are met.

    @method _end
    @param {DOMEventFacade} event
    @param {Node} node
    @param {Array} subscription
    @param {Boolean} notifier
    @param {Boolean} delegate
    @param {Object} context
    @protected
    @static
    **/
    _end: function (event, node, subscription, notifier, delegate, context) {
        var startXY = context.startXY,
            endXY,
            clientXY,
            sensitivity = 15;

        if (subscription._extra && subscription._extra.sensitivity >= 0) {
            sensitivity = subscription._extra.sensitivity;
        }

        //There is a double check in here to support event simulation tests, in which
        //event.touches can be undefined when simulating 'touchstart' on touch devices.
        if (event.changedTouches) {
          endXY = [ event.changedTouches[0].pageX, event.changedTouches[0].pageY ];
          clientXY = [event.changedTouches[0].clientX, event.changedTouches[0].clientY];
        }
        else {
          endXY = [ event.pageX, event.pageY ];
          clientXY = [event.clientX, event.clientY];
        }

        // make sure mouse didn't move
        if (Math.abs(endXY[0] - startXY[0]) <= sensitivity && Math.abs(endXY[1] - startXY[1]) <= sensitivity) {

            event.type = EVT_TAP;
            event.pageX = endXY[0];
            event.pageY = endXY[1];
            event.clientX = clientXY[0];
            event.clientY = clientXY[1];
            event.currentTarget = context.node;

            notifier.fire(event);
        }

        detachHandles(subscription, [HANDLES.END, HANDLES.CANCEL]);
    }
});


}, '3.17.2', {"requires": ["node-base", "event-base", "event-touch", "event-synthetic"]});


/***/ }),

/***/ 559747:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-touch', function (Y, NAME) {

/**
Adds touch event facade normalization properties (touches, changedTouches, targetTouches etc.) to the DOM event facade. Adds
touch events to the DOM events whitelist.

@example
    YUI().use('event-touch', function (Y) {
        Y.one('#myDiv').on('touchstart', function(e) {
            ...
        });
    });
@module event
@submodule event-touch
 */
var SCALE = "scale",
    ROTATION = "rotation",
    IDENTIFIER = "identifier",
    win = Y.config.win,
    GESTURE_MAP = {};

/**
 * Adds touch event facade normalization properties to the DOM event facade
 *
 * @method _touch
 * @for DOMEventFacade
 * @private
 * @param ev {Event} the DOM event
 * @param currentTarget {HTMLElement} the element the listener was attached to
 * @param wrapper {CustomEvent} the custom event wrapper for this DOM event
 */
Y.DOMEventFacade.prototype._touch = function(e, currentTarget, wrapper) {

    var i,l, etCached, et,touchCache;


    if (e.touches) {

        /**
         * Array of individual touch events for touch points that are still in
         * contact with the touch surface.
         *
         * @property touches
         * @type {DOMEventFacade[]}
         */
        this.touches = [];
        touchCache = {};

        for (i = 0, l = e.touches.length; i < l; ++i) {
            et = e.touches[i];
            touchCache[Y.stamp(et)] = this.touches[i] = new Y.DOMEventFacade(et, currentTarget, wrapper);
        }
    }

    if (e.targetTouches) {

        /**
         * Array of individual touch events still in contact with the touch
         * surface and whose `touchstart` event occurred inside the same taregt
         * element as the current target element.
         *
         * @property targetTouches
         * @type {DOMEventFacade[]}
         */
        this.targetTouches = [];

        for (i = 0, l = e.targetTouches.length; i < l; ++i) {
            et = e.targetTouches[i];
            etCached = touchCache && touchCache[Y.stamp(et, true)];

            this.targetTouches[i] = etCached || new Y.DOMEventFacade(et, currentTarget, wrapper);

        }
    }

    if (e.changedTouches) {

        /**
        An array of event-specific touch events.

        For `touchstart`, the touch points that became active with the current
        event.

        For `touchmove`, the touch points that have changed since the last
        event.

        For `touchend`, the touch points that have been removed from the touch
        surface.

        @property changedTouches
        @type {DOMEventFacade[]}
        **/
        this.changedTouches = [];

        for (i = 0, l = e.changedTouches.length; i < l; ++i) {
            et = e.changedTouches[i];
            etCached = touchCache && touchCache[Y.stamp(et, true)];

            this.changedTouches[i] = etCached || new Y.DOMEventFacade(et, currentTarget, wrapper);

        }
    }

    if (SCALE in e) {
        this[SCALE] = e[SCALE];
    }

    if (ROTATION in e) {
        this[ROTATION] = e[ROTATION];
    }

    if (IDENTIFIER in e) {
        this[IDENTIFIER] = e[IDENTIFIER];
    }
};

//Adding MSPointer events to whitelisted DOM Events. MSPointer event payloads
//have the same properties as mouse events.
if (Y.Node.DOM_EVENTS) {
    Y.mix(Y.Node.DOM_EVENTS, {
        touchstart:1,
        touchmove:1,
        touchend:1,
        touchcancel:1,
        gesturestart:1,
        gesturechange:1,
        gestureend:1,
        MSPointerDown:1,
        MSPointerUp:1,
        MSPointerMove:1,
        MSPointerCancel:1,
        pointerdown:1,
        pointerup:1,
        pointermove:1,
        pointercancel:1
    });
}

//Add properties to Y.EVENT.GESTURE_MAP based on feature detection.
  /**
   *
   * This is to fix a bug:
   * Most mobile browsers calls touch events and mouse events separately.
   * (fires touch events first, and then mouse events according to the touch behavior)
   * But YUI's DDM uses gesture events, which results in DD events getting mixed up,
   * with non-existent mouse positions and life-cycles getting messed up.
   *
   * This will ensure DD is wired to only one set of gesture events for touch devices.  -bc
   *
   * - Update 2/11/14:
   * No double events for any touch device.
   * Also adding support for pointer events since mobile chrome and firefox are
   * planning to implement pointer events in near future. -bc
   *
   */
  if (win && win.PointerEvent) {
    GESTURE_MAP.start = "pointerdown";
    GESTURE_MAP.end = "pointerup";
    GESTURE_MAP.move = "pointermove";
    GESTURE_MAP.cancel = "pointercancel";
  }

  else if ((win && ("ontouchstart" in win)) && !(Y.UA.chrome && Y.UA.chrome < 6)) {
    GESTURE_MAP.start = "touchstart";
    GESTURE_MAP.end = "touchend";
    GESTURE_MAP.move = "touchmove";
    GESTURE_MAP.cancel = "touchcancel";
}

else if (win && ("msPointerEnabled" in win.navigator)) {
    GESTURE_MAP.start = "MSPointerDown";
    GESTURE_MAP.end = "MSPointerUp";
    GESTURE_MAP.move = "MSPointerMove";
    GESTURE_MAP.cancel = "MSPointerCancel";
}

else {
    GESTURE_MAP.start = "mousedown";
    GESTURE_MAP.end = "mouseup";
    GESTURE_MAP.move = "mousemove";
    GESTURE_MAP.cancel = "mousecancel";
}

/**
 * A object literal with keys "start", "end", and "move". The value for each key is a
 * string representing the event for that environment. For touch environments, the respective
 * values are "touchstart", "touchend" and "touchmove". Mouse and MSPointer environments are also
 * supported via feature detection.
 *
 * @property _GESTURE_MAP
 * @type Object
 * @static
 */
Y.Event._GESTURE_MAP = GESTURE_MAP;


}, '3.17.2', {"requires": ["node-base"]});


/***/ }),

/***/ 924999:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('event-valuechange', function (Y, NAME) {

/**
Adds a synthetic `valuechange` event that fires when the `value` property of an
`<input>`, `<textarea>`, `<select>`, or `[contenteditable="true"]` node changes
as a result of a keystroke, mouse operation, or input method editor (IME)
input event.

Usage:

    YUI().use('event-valuechange', function (Y) {
        Y.one('#my-input').on('valuechange', function (e) {
        });
    });

@module event-valuechange
**/

/**
Provides the implementation for the synthetic `valuechange` event. This class
isn't meant to be used directly, but is public to make monkeypatching possible.

Usage:

    YUI().use('event-valuechange', function (Y) {
        Y.one('#my-input').on('valuechange', function (e) {
        });
    });

@class ValueChange
@static
*/

var DATA_KEY = '_valuechange',
    VALUE    = 'value',
    NODE_NAME = 'nodeName',

    config, // defined at the end of this file

// Just a simple namespace to make methods overridable.
VC = {
    // -- Static Constants -----------------------------------------------------

    /**
    Interval (in milliseconds) at which to poll for changes to the value of an
    element with one or more `valuechange` subscribers when the user is likely
    to be interacting with it.

    @property POLL_INTERVAL
    @type Number
    @default 50
    @static
    **/
    POLL_INTERVAL: 50,

    /**
    Timeout (in milliseconds) after which to stop polling when there hasn't been
    any new activity (keypresses, mouse clicks, etc.) on an element.

    @property TIMEOUT
    @type Number
    @default 10000
    @static
    **/
    TIMEOUT: 10000,

    // -- Protected Static Methods ---------------------------------------------

    /**
    Called at an interval to poll for changes to the value of the specified
    node.

    @method _poll
    @param {Node} node Node to poll.

    @param {Object} options Options object.
        @param {EventFacade} [options.e] Event facade of the event that
            initiated the polling.

    @protected
    @static
    **/
    _poll: function (node, options) {
        var domNode  = node._node, // performance cheat; getValue() is a big hit when polling
            event    = options.e,
            vcData   = node._data && node._data[DATA_KEY], // another perf cheat
            stopped  = 0,
            facade, prevVal, newVal, nodeName, selectedOption, stopElement;

        if (!(domNode && vcData)) {
            VC._stopPolling(node);
            return;
        }

        prevVal = vcData.prevVal;
        nodeName  = vcData.nodeName;

        if (vcData.isEditable) {
            // Use innerHTML for performance
            newVal = domNode.innerHTML;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            // Use value property for performance
            newVal = domNode.value;
        } else if (nodeName === 'select') {
            // Back-compatibility with IE6 <select> element values.
            // Huge performance cheat to get past node.get('value').
            selectedOption = domNode.options[domNode.selectedIndex];
            newVal = selectedOption.value || selectedOption.text;
        }

        if (newVal !== prevVal) {
            vcData.prevVal = newVal;

            facade = {
                _event       : event,
                currentTarget: (event && event.currentTarget) || node,
                newVal       : newVal,
                prevVal      : prevVal,
                target       : (event && event.target) || node
            };

            Y.Object.some(vcData.notifiers, function (notifier) {
                var evt = notifier.handle.evt,
                    newStopped;

                // support e.stopPropagation()
                if (stopped !== 1) {
                    notifier.fire(facade);
                } else if (evt.el === stopElement) {
                    notifier.fire(facade);
                }

                newStopped = evt && evt._facade ? evt._facade.stopped : 0;

                // need to consider the condition in which there are two
                // listeners on the same element:
                // listener 1 calls e.stopPropagation()
                // listener 2 calls e.stopImmediatePropagation()
                if (newStopped > stopped) {
                    stopped = newStopped;

                    if (stopped === 1) {
                        stopElement = evt.el;
                    }
                }

                // support e.stopImmediatePropagation()
                if (stopped === 2) {
                    return true;
                }
            });

            VC._refreshTimeout(node);
        }
    },

    /**
    Restarts the inactivity timeout for the specified node.

    @method _refreshTimeout
    @param {Node} node Node to refresh.
    @param {SyntheticEvent.Notifier} notifier
    @protected
    @static
    **/
    _refreshTimeout: function (node, notifier) {
        // The node may have been destroyed, so check that it still exists
        // before trying to get its data. Otherwise an error will occur.
        if (!node._node) {
            return;
        }

        var vcData = node.getData(DATA_KEY);

        VC._stopTimeout(node); // avoid dupes

        // If we don't see any changes within the timeout period (10 seconds by
        // default), stop polling.
        vcData.timeout = setTimeout(function () {
            VC._stopPolling(node, notifier);
        }, VC.TIMEOUT);

    },

    /**
    Begins polling for changes to the `value` property of the specified node. If
    polling is already underway for the specified node, it will not be restarted
    unless the `force` option is `true`

    @method _startPolling
    @param {Node} node Node to watch.
    @param {SyntheticEvent.Notifier} notifier

    @param {Object} options Options object.
        @param {EventFacade} [options.e] Event facade of the event that
            initiated the polling.
        @param {Boolean} [options.force=false] If `true`, polling will be
            restarted even if we're already polling this node.

    @protected
    @static
    **/
    _startPolling: function (node, notifier, options) {
        var vcData, isEditable;

        if (!node.test('input,textarea,select') && !(isEditable = VC._isEditable(node))) {
            return;
        }

        vcData = node.getData(DATA_KEY);

        if (!vcData) {
            vcData = {
                nodeName   : node.get(NODE_NAME).toLowerCase(),
                isEditable : isEditable,
                prevVal    : isEditable ? node.getDOMNode().innerHTML : node.get(VALUE)
            };

            node.setData(DATA_KEY, vcData);
        }

        vcData.notifiers || (vcData.notifiers = {});

        // Don't bother continuing if we're already polling this node, unless
        // `options.force` is true.
        if (vcData.interval) {
            if (options.force) {
                VC._stopPolling(node, notifier); // restart polling, but avoid dupe polls
            } else {
                vcData.notifiers[Y.stamp(notifier)] = notifier;
                return;
            }
        }

        // Poll for changes to the node's value. We can't rely on keyboard
        // events for this, since the value may change due to a mouse-initiated
        // paste event, an IME input event, or for some other reason that
        // doesn't trigger a key event.
        vcData.notifiers[Y.stamp(notifier)] = notifier;

        vcData.interval = setInterval(function () {
            VC._poll(node, options);
        }, VC.POLL_INTERVAL);


        VC._refreshTimeout(node, notifier);
    },

    /**
    Stops polling for changes to the specified node's `value` attribute.

    @method _stopPolling
    @param {Node} node Node to stop polling on.
    @param {SyntheticEvent.Notifier} [notifier] Notifier to remove from the
        node. If not specified, all notifiers will be removed.
    @protected
    @static
    **/
    _stopPolling: function (node, notifier) {
        // The node may have been destroyed, so check that it still exists
        // before trying to get its data. Otherwise an error will occur.
        if (!node._node) {
            return;
        }

        var vcData = node.getData(DATA_KEY) || {};

        clearInterval(vcData.interval);
        delete vcData.interval;

        VC._stopTimeout(node);

        if (notifier) {
            vcData.notifiers && delete vcData.notifiers[Y.stamp(notifier)];
        } else {
            vcData.notifiers = {};
        }

    },

    /**
    Clears the inactivity timeout for the specified node, if any.

    @method _stopTimeout
    @param {Node} node
    @protected
    @static
    **/
    _stopTimeout: function (node) {
        var vcData = node.getData(DATA_KEY) || {};

        clearTimeout(vcData.timeout);
        delete vcData.timeout;
    },

    /**
    Check to see if a node has editable content or not.

    TODO: Add additional checks to get it to work for child nodes
    that inherit "contenteditable" from parent nodes. This may be
    too computationally intensive to be placed inside of the `_poll`
    loop, however.

    @method _isEditable
    @param {Node} node
    @protected
    @static
    **/
    _isEditable: function (node) {
        // Performance cheat because this is used inside `_poll`
        var domNode = node._node;
        return domNode.contentEditable === 'true' ||
               domNode.contentEditable === '';
    },



    // -- Protected Static Event Handlers --------------------------------------

    /**
    Stops polling when a node's blur event fires.

    @method _onBlur
    @param {EventFacade} e
    @param {SyntheticEvent.Notifier} notifier
    @protected
    @static
    **/
    _onBlur: function (e, notifier) {
        VC._stopPolling(e.currentTarget, notifier);
    },

    /**
    Resets a node's history and starts polling when a focus event occurs.

    @method _onFocus
    @param {EventFacade} e
    @param {SyntheticEvent.Notifier} notifier
    @protected
    @static
    **/
    _onFocus: function (e, notifier) {
        var node       = e.currentTarget,
            vcData     = node.getData(DATA_KEY);

        if (!vcData) {
            vcData = {
                isEditable : VC._isEditable(node),
                nodeName   : node.get(NODE_NAME).toLowerCase()
            };
            node.setData(DATA_KEY, vcData);
        }

        vcData.prevVal = vcData.isEditable ? node.getDOMNode().innerHTML : node.get(VALUE);

        VC._startPolling(node, notifier, {e: e});
    },

    /**
    Starts polling when a node receives a keyDown event.

    @method _onKeyDown
    @param {EventFacade} e
    @param {SyntheticEvent.Notifier} notifier
    @protected
    @static
    **/
    _onKeyDown: function (e, notifier) {
        VC._startPolling(e.currentTarget, notifier, {e: e});
    },

    /**
    Starts polling when an IME-related keyUp event occurs on a node.

    @method _onKeyUp
    @param {EventFacade} e
    @param {SyntheticEvent.Notifier} notifier
    @protected
    @static
    **/
    _onKeyUp: function (e, notifier) {
        // These charCodes indicate that an IME has started. We'll restart
        // polling and give the IME up to 10 seconds (by default) to finish.
        if (e.charCode === 229 || e.charCode === 197) {
            VC._startPolling(e.currentTarget, notifier, {
                e    : e,
                force: true
            });
        }
    },

    /**
    Starts polling when a node receives a mouseDown event.

    @method _onMouseDown
    @param {EventFacade} e
    @param {SyntheticEvent.Notifier} notifier
    @protected
    @static
    **/
    _onMouseDown: function (e, notifier) {
        VC._startPolling(e.currentTarget, notifier, {e: e});
    },

    /**
    Called when the `valuechange` event receives a new subscriber.

    Child nodes that aren't initially available when this subscription is
    called will still fire the `valuechange` event after their data is
    collected when the delegated `focus` event is captured. This includes
    elements that haven't been inserted into the DOM yet, as well as
    elements that aren't initially `contenteditable`.

    @method _onSubscribe
    @param {Node} node
    @param {Subscription} sub
    @param {SyntheticEvent.Notifier} notifier
    @param {Function|String} [filter] Filter function or selector string. Only
        provided for delegate subscriptions.
    @protected
    @static
    **/
    _onSubscribe: function (node, sub, notifier, filter) {
        var _valuechange, callbacks, isEditable, inputNodes, editableNodes;

        callbacks = {
            blur     : VC._onBlur,
            focus    : VC._onFocus,
            keydown  : VC._onKeyDown,
            keyup    : VC._onKeyUp,
            mousedown: VC._onMouseDown
        };

        // Store a utility object on the notifier to hold stuff that needs to be
        // passed around to trigger event handlers, polling handlers, etc.
        _valuechange = notifier._valuechange = {};

        if (filter) {
            // If a filter is provided, then this is a delegated subscription.
            _valuechange.delegated = true;

            // Add a function to the notifier that we can use to find all
            // nodes that pass the delegate filter.
            _valuechange.getNodes = function () {
                inputNodes    = node.all('input,textarea,select').filter(filter);
                editableNodes = node.all('[contenteditable="true"],[contenteditable=""]').filter(filter);

                return inputNodes.concat(editableNodes);
            };

            // Store the initial values for each descendant of the container
            // node that passes the delegate filter.
            _valuechange.getNodes().each(function (child) {
                if (!child.getData(DATA_KEY)) {
                    child.setData(DATA_KEY, {
                        nodeName   : child.get(NODE_NAME).toLowerCase(),
                        isEditable : VC._isEditable(child),
                        prevVal    : isEditable ? child.getDOMNode().innerHTML : child.get(VALUE)
                    });
                }
            });

            notifier._handles = Y.delegate(callbacks, node, filter, null,
                notifier);
        } else {
            isEditable = VC._isEditable(node);
            // This is a normal (non-delegated) event subscription.
            if (!node.test('input,textarea,select') && !isEditable) {
                return;
            }

            if (!node.getData(DATA_KEY)) {
                node.setData(DATA_KEY, {
                    nodeName   : node.get(NODE_NAME).toLowerCase(),
                    isEditable : isEditable,
                    prevVal    : isEditable ? node.getDOMNode().innerHTML : node.get(VALUE)
                });
            }

            notifier._handles = node.on(callbacks, null, null, notifier);
        }
    },

    /**
    Called when the `valuechange` event loses a subscriber.

    @method _onUnsubscribe
    @param {Node} node
    @param {Subscription} subscription
    @param {SyntheticEvent.Notifier} notifier
    @protected
    @static
    **/
    _onUnsubscribe: function (node, subscription, notifier) {
        var _valuechange = notifier._valuechange;

        notifier._handles && notifier._handles.detach();

        if (_valuechange.delegated) {
            _valuechange.getNodes().each(function (child) {
                VC._stopPolling(child, notifier);
            });
        } else {
            VC._stopPolling(node, notifier);
        }
    }
};

/**
Synthetic event that fires when the `value` property of an `<input>`,
`<textarea>`, `<select>`, or `[contenteditable="true"]` node changes as a
result of a user-initiated keystroke, mouse operation, or input method
editor (IME) input event.

Unlike the `onchange` event, this event fires when the value actually changes
and not when the element loses focus. This event also reports IME and
multi-stroke input more reliably than `oninput` or the various key events across
browsers.

For performance reasons, only focused nodes are monitored for changes, so
programmatic value changes on nodes that don't have focus won't be detected.

@example

    YUI().use('event-valuechange', function (Y) {
        Y.one('#my-input').on('valuechange', function (e) {
        });
    });

@event valuechange
@param {String} prevVal Previous value prior to the latest change.
@param {String} newVal New value after the latest change.
@for YUI
**/

config = {
    detach: VC._onUnsubscribe,
    on    : VC._onSubscribe,

    delegate      : VC._onSubscribe,
    detachDelegate: VC._onUnsubscribe,

    publishConfig: {
        emitFacade: true
    }
};

Y.Event.define('valuechange', config);
Y.Event.define('valueChange', config); // deprecated, but supported for backcompat

Y.ValueChange = VC;


}, '3.17.2', {"requires": ["event-focus", "event-synthetic"]});


/***/ }),

/***/ 599302:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('gesture-simulate', function (Y, NAME) {

/**
 * Simulate high-level user gestures by generating a set of native DOM events.
 *
 * @module gesture-simulate
 * @requires event-simulate, async-queue, node-screen
 */

var NAME = "gesture-simulate",

    // phantomjs check may be temporary, until we determine if it really support touch all the way through, like it claims to (http://code.google.com/p/phantomjs/issues/detail?id=375)
    SUPPORTS_TOUCH = ((Y.config.win && ("ontouchstart" in Y.config.win)) && !(Y.UA.phantomjs) && !(Y.UA.chrome && Y.UA.chrome < 6)),

    gestureNames = {
        tap: 1,
        doubletap: 1,
        press: 1,
        move: 1,
        flick: 1,
        pinch: 1,
        rotate: 1
    },

    touchEvents = {
        touchstart: 1,
        touchmove: 1,
        touchend: 1,
        touchcancel: 1
    },

    document = Y.config.doc,
    emptyTouchList,

    EVENT_INTERVAL = 20,        // 20ms
    START_PAGEX,                // will be adjusted to the node element center
    START_PAGEY,                // will be adjusted to the node element center

    // defaults that user can override.
    DEFAULTS = {
        // tap gestures
        HOLD_TAP: 10,           // 10ms
        DELAY_TAP: 10,          // 10ms

        // press gesture
        HOLD_PRESS: 3000,       // 3sec
        MIN_HOLD_PRESS: 1000,   // 1sec
        MAX_HOLD_PRESS: 60000,  // 1min

        // move gesture
        DISTANCE_MOVE: 200,     // 200 pixels
        DURATION_MOVE: 1000,    // 1sec
        MAX_DURATION_MOVE: 5000,// 5sec

        // flick gesture
        MIN_VELOCITY_FLICK: 1.3,
        DISTANCE_FLICK: 200,     // 200 pixels
        DURATION_FLICK: 1000,    // 1sec
        MAX_DURATION_FLICK: 5000,// 5sec

        // pinch/rotation
        DURATION_PINCH: 1000     // 1sec
    },

    TOUCH_START = 'touchstart',
    TOUCH_MOVE = 'touchmove',
    TOUCH_END = 'touchend',

    GESTURE_START = 'gesturestart',
    GESTURE_CHANGE = 'gesturechange',
    GESTURE_END = 'gestureend',

    MOUSE_UP    = 'mouseup',
    MOUSE_MOVE  = 'mousemove',
    MOUSE_DOWN  = 'mousedown',
    MOUSE_CLICK = 'click',
    MOUSE_DBLCLICK = 'dblclick',

    X_AXIS = 'x',
    Y_AXIS = 'y';


function Simulations(node) {
    if(!node) {
        Y.error(NAME+': invalid target node');
    }
    this.node = node;
    this.target = Y.Node.getDOMNode(node);

    var startXY = this.node.getXY(),
        dims = this._getDims();

    START_PAGEX = startXY[0] + (dims[0])/2;
    START_PAGEY = startXY[1] + (dims[1])/2;
}

Simulations.prototype = {

    /**
     * Helper method to convert a degree to a radian.
     *
     * @method _toRadian
     * @private
     * @param {Number} deg A degree to be converted to a radian.
     * @return {Number} The degree in radian.
     */
    _toRadian: function(deg) {
        return deg * (Math.PI/180);
    },

    /**
     * Helper method to get height/width while accounting for
     * rotation/scale transforms where possible by using the
     * bounding client rectangle height/width instead of the
     * offsetWidth/Height which region uses.
     * @method _getDims
     * @private
     * @return {Array} Array with [height, width]
     */
    _getDims : function() {
        var region,
            width,
            height;

        // Ideally, this should be in DOM somewhere.
        if (this.target.getBoundingClientRect) {
            region = this.target.getBoundingClientRect();

            if ("height" in region) {
                height = region.height;
            } else {
                // IE7,8 has getBCR, but no height.
                height = Math.abs(region.bottom - region.top);
            }

            if ("width" in region) {
                width = region.width;
            } else {
                // IE7,8 has getBCR, but no width.
                width = Math.abs(region.right - region.left);
            }
        } else {
            region = this.node.get("region");
            width = region.width;
            height = region.height;
        }

        return [width, height];
    },

    /**
     * Helper method to convert a point relative to the node element into
     * the point in the page coordination.
     *
     * @method _calculateDefaultPoint
     * @private
     * @param {Array} point A point relative to the node element.
     * @return {Array} The same point in the page coordination.
     */
    _calculateDefaultPoint: function(point) {

        var height;

        if(!Y.Lang.isArray(point) || point.length === 0) {
            point = [START_PAGEX, START_PAGEY];
        } else {
            if(point.length == 1) {
                height = this._getDims[1];
                point[1] = height/2;
            }
            // convert to page(viewport) coordination
            point[0] = this.node.getX() + point[0];
            point[1] = this.node.getY() + point[1];
        }

        return point;
    },

    /**
     * The "rotate" and "pinch" methods are essencially same with the exact same
     * arguments. Only difference is the required parameters. The rotate method
     * requires "rotation" parameter while the pinch method requires "startRadius"
     * and "endRadius" parameters.
     *
     * @method rotate
     * @param {Function} cb The callback to execute when the gesture simulation
     *      is completed.
     * @param {Array} center A center point where the pinch gesture of two fingers
     *      should happen. It is relative to the top left corner of the target
     *      node element.
     * @param {Number} startRadius A radius of start circle where 2 fingers are
     *      on when the gesture starts. This is optional. The default is a fourth of
     *      either target node width or height whichever is smaller.
     * @param {Number} endRadius A radius of end circle where 2 fingers will be on when
     *      the pinch or spread gestures are completed. This is optional.
     *      The default is a fourth of either target node width or height whichever is less.
     * @param {Number} duration A duration of the gesture in millisecond.
     * @param {Number} start A start angle(0 degree at 12 o'clock) where the
     *      gesture should start. Default is 0.
     * @param {Number} rotation A rotation in degree. It is required.
     */
    rotate: function(cb, center, startRadius, endRadius, duration, start, rotation) {
        var radius,
            r1 = startRadius,   // optional
            r2 = endRadius;     // optional

        if(!Y.Lang.isNumber(r1) || !Y.Lang.isNumber(r2) || r1<0 || r2<0) {
            radius = (this.target.offsetWidth < this.target.offsetHeight)?
                this.target.offsetWidth/4 : this.target.offsetHeight/4;
            r1 = radius;
            r2 = radius;
        }

        // required
        if(!Y.Lang.isNumber(rotation)) {
            Y.error(NAME+'Invalid rotation detected.');
        }

        this.pinch(cb, center, r1, r2, duration, start, rotation);
    },

    /**
     * The "rotate" and "pinch" methods are essencially same with the exact same
     * arguments. Only difference is the required parameters. The rotate method
     * requires "rotation" parameter while the pinch method requires "startRadius"
     * and "endRadius" parameters.
     *
     * The "pinch" gesture can simulate various 2 finger gestures such as pinch,
     * spread and/or rotation. The "startRadius" and "endRadius" are required.
     * If endRadius is larger than startRadius, it becomes a spread gesture
     * otherwise a pinch gesture.
     *
     * @method pinch
     * @param {Function} cb The callback to execute when the gesture simulation
     *      is completed.
     * @param {Array} center A center point where the pinch gesture of two fingers
     *      should happen. It is relative to the top left corner of the target
     *      node element.
     * @param {Number} startRadius A radius of start circle where 2 fingers are
     *      on when the gesture starts. This paramenter is required.
     * @param {Number} endRadius A radius of end circle where 2 fingers will be on when
     *      the pinch or spread gestures are completed. This parameter is required.
     * @param {Number} duration A duration of the gesture in millisecond.
     * @param {Number} start A start angle(0 degree at 12 o'clock) where the
     *      gesture should start. Default is 0.
     * @param {Number} rotation If rotation is desired during the pinch or
     *      spread gestures, this parameter can be used. Default is 0 degree.
     */
    pinch: function(cb, center, startRadius, endRadius, duration, start, rotation) {
        var eventQueue,
            i,
            interval = EVENT_INTERVAL,
            touches,
            id = 0,
            r1 = startRadius,   // required
            r2 = endRadius,     // required
            radiusPerStep,
            centerX, centerY,
            startScale, endScale, scalePerStep,
            startRot, endRot, rotPerStep,
            path1 = {start: [], end: []}, // paths for 1st and 2nd fingers.
            path2 = {start: [], end: []},
            steps,
            touchMove;

        center = this._calculateDefaultPoint(center);

        if(!Y.Lang.isNumber(r1) || !Y.Lang.isNumber(r2) || r1<0 || r2<0) {
            Y.error(NAME+'Invalid startRadius and endRadius detected.');
        }

        if(!Y.Lang.isNumber(duration) || duration <= 0) {
            duration = DEFAULTS.DURATION_PINCH;
        }

        if(!Y.Lang.isNumber(start)) {
            start = 0.0;
        } else {
            start = start%360;
            while(start < 0) {
                start += 360;
            }
        }

        if(!Y.Lang.isNumber(rotation)) {
            rotation = 0.0;
        }

        Y.AsyncQueue.defaults.timeout = interval;
        eventQueue = new Y.AsyncQueue();

        // range determination
        centerX = center[0];
        centerY = center[1];

        startRot = start;
        endRot = start + rotation;

        // 1st finger path
        path1.start = [
            centerX + r1*Math.sin(this._toRadian(startRot)),
            centerY - r1*Math.cos(this._toRadian(startRot))
        ];
        path1.end   = [
            centerX + r2*Math.sin(this._toRadian(endRot)),
            centerY - r2*Math.cos(this._toRadian(endRot))
        ];

        // 2nd finger path
        path2.start = [
            centerX - r1*Math.sin(this._toRadian(startRot)),
            centerY + r1*Math.cos(this._toRadian(startRot))
        ];
        path2.end   = [
            centerX - r2*Math.sin(this._toRadian(endRot)),
            centerY + r2*Math.cos(this._toRadian(endRot))
        ];

        startScale = 1.0;
        endScale = endRadius/startRadius;

        // touch/gesture start
        eventQueue.add({
            fn: function() {
                var coord1, coord2, coord, touches;

                // coordinate for each touch object.
                coord1 = {
                    pageX: path1.start[0],
                    pageY: path1.start[1],
                    clientX: path1.start[0],
                    clientY: path1.start[1]
                };
                coord2 = {
                    pageX: path2.start[0],
                    pageY: path2.start[1],
                    clientX: path2.start[0],
                    clientY: path2.start[1]
                };
                touches = this._createTouchList([Y.merge({
                    identifier: (id++)
                }, coord1), Y.merge({
                    identifier: (id++)
                }, coord2)]);

                // coordinate for top level event
                coord = {
                    pageX: (path1.start[0] + path2.start[0])/2,
                    pageY: (path1.start[0] + path2.start[1])/2,
                    clientX: (path1.start[0] + path2.start[0])/2,
                    clientY: (path1.start[0] + path2.start[1])/2
                };

                this._simulateEvent(this.target, TOUCH_START, Y.merge({
                    touches: touches,
                    targetTouches: touches,
                    changedTouches: touches,
                    scale: startScale,
                    rotation: startRot
                }, coord));

                if(Y.UA.ios >= 2.0) {
                    /* gesture starts when the 2nd finger touch starts.
                    * The implementation will fire 1 touch start event for both fingers,
                    * simulating 2 fingers touched on the screen at the same time.
                    */
                    this._simulateEvent(this.target, GESTURE_START, Y.merge({
                        scale: startScale,
                        rotation: startRot
                    }, coord));
                }
            },
            timeout: 0,
            context: this
        });

        // gesture change
        steps = Math.floor(duration/interval);
        radiusPerStep = (r2 - r1)/steps;
        scalePerStep = (endScale - startScale)/steps;
        rotPerStep = (endRot - startRot)/steps;

        touchMove = function(step) {
            var radius = r1 + (radiusPerStep)*step,
                px1 = centerX + radius*Math.sin(this._toRadian(startRot + rotPerStep*step)),
                py1 = centerY - radius*Math.cos(this._toRadian(startRot + rotPerStep*step)),
                px2 = centerX - radius*Math.sin(this._toRadian(startRot + rotPerStep*step)),
                py2 = centerY + radius*Math.cos(this._toRadian(startRot + rotPerStep*step)),
                px = (px1+px2)/2,
                py = (py1+py2)/2,
                coord1, coord2, coord, touches;

            // coordinate for each touch object.
            coord1 = {
                pageX: px1,
                pageY: py1,
                clientX: px1,
                clientY: py1
            };
            coord2 = {
                pageX: px2,
                pageY: py2,
                clientX: px2,
                clientY: py2
            };
            touches = this._createTouchList([Y.merge({
                identifier: (id++)
            }, coord1), Y.merge({
                identifier: (id++)
            }, coord2)]);

            // coordinate for top level event
            coord = {
                pageX: px,
                pageY: py,
                clientX: px,
                clientY: py
            };

            this._simulateEvent(this.target, TOUCH_MOVE, Y.merge({
                touches: touches,
                targetTouches: touches,
                changedTouches: touches,
                scale: startScale + scalePerStep*step,
                rotation: startRot + rotPerStep*step
            }, coord));

            if(Y.UA.ios >= 2.0) {
                this._simulateEvent(this.target, GESTURE_CHANGE, Y.merge({
                    scale: startScale + scalePerStep*step,
                    rotation: startRot + rotPerStep*step
                }, coord));
            }
        };

        for (i=0; i < steps; i++) {
            eventQueue.add({
                fn: touchMove,
                args: [i],
                context: this
            });
        }

        // gesture end
        eventQueue.add({
            fn: function() {
                var emptyTouchList = this._getEmptyTouchList(),
                    coord1, coord2, coord, touches;

                // coordinate for each touch object.
                coord1 = {
                    pageX: path1.end[0],
                    pageY: path1.end[1],
                    clientX: path1.end[0],
                    clientY: path1.end[1]
                };
                coord2 = {
                    pageX: path2.end[0],
                    pageY: path2.end[1],
                    clientX: path2.end[0],
                    clientY: path2.end[1]
                };
                touches = this._createTouchList([Y.merge({
                    identifier: (id++)
                }, coord1), Y.merge({
                    identifier: (id++)
                }, coord2)]);

                // coordinate for top level event
                coord = {
                    pageX: (path1.end[0] + path2.end[0])/2,
                    pageY: (path1.end[0] + path2.end[1])/2,
                    clientX: (path1.end[0] + path2.end[0])/2,
                    clientY: (path1.end[0] + path2.end[1])/2
                };

                if(Y.UA.ios >= 2.0) {
                    this._simulateEvent(this.target, GESTURE_END, Y.merge({
                        scale: endScale,
                        rotation: endRot
                    }, coord));
                }

                this._simulateEvent(this.target, TOUCH_END, Y.merge({
                    touches: emptyTouchList,
                    targetTouches: emptyTouchList,
                    changedTouches: touches,
                    scale: endScale,
                    rotation: endRot
                }, coord));
            },
            context: this
        });

        if(cb && Y.Lang.isFunction(cb)) {
            eventQueue.add({
                fn: cb,

                // by default, the callback runs the node context where
                // simulateGesture method is called.
                context: this.node

                //TODO: Use args to pass error object as 1st param if there is an error.
                //args:
            });
        }

        eventQueue.run();
    },

    /**
     * The "tap" gesture can be used for various single touch point gestures
     * such as single tap, N number of taps, long press. The default is a single
     * tap.
     *
     * @method tap
     * @param {Function} cb The callback to execute when the gesture simulation
     *      is completed.
     * @param {Array} point A point(relative to the top left corner of the
     *      target node element) where the tap gesture should start. The default
     *      is the center of the taget node.
     * @param {Number} times The number of taps. Default is 1.
     * @param {Number} hold The hold time in milliseconds between "touchstart" and
     *      "touchend" event generation. Default is 10ms.
     * @param {Number} delay The time gap in millisecond between taps if this
     *      gesture has more than 1 tap. Default is 10ms.
     */
    tap: function(cb, point, times, hold, delay) {
        var eventQueue = new Y.AsyncQueue(),
            emptyTouchList = this._getEmptyTouchList(),
            touches,
            coord,
            i,
            touchStart,
            touchEnd;

        point = this._calculateDefaultPoint(point);

        if(!Y.Lang.isNumber(times) || times < 1) {
            times = 1;
        }

        if(!Y.Lang.isNumber(hold)) {
            hold = DEFAULTS.HOLD_TAP;
        }

        if(!Y.Lang.isNumber(delay)) {
            delay = DEFAULTS.DELAY_TAP;
        }

        coord = {
            pageX: point[0],
            pageY: point[1],
            clientX: point[0],
            clientY: point[1]
        };

        touches = this._createTouchList([Y.merge({identifier: 0}, coord)]);

        touchStart = function() {
            this._simulateEvent(this.target, TOUCH_START, Y.merge({
                touches: touches,
                targetTouches: touches,
                changedTouches: touches
            }, coord));
        };

        touchEnd = function() {
            this._simulateEvent(this.target, TOUCH_END, Y.merge({
                touches: emptyTouchList,
                targetTouches: emptyTouchList,
                changedTouches: touches
            }, coord));
        };

        for (i=0; i < times; i++) {
            eventQueue.add({
                fn: touchStart,
                context: this,
                timeout: (i === 0)? 0 : delay
            });

            eventQueue.add({
                fn: touchEnd,
                context: this,
                timeout: hold
            });
        }

        if(times > 1 && !SUPPORTS_TOUCH) {
            eventQueue.add({
                fn: function() {
                    this._simulateEvent(this.target, MOUSE_DBLCLICK, coord);
                },
                context: this
            });
        }

        if(cb && Y.Lang.isFunction(cb)) {
            eventQueue.add({
                fn: cb,

                // by default, the callback runs the node context where
                // simulateGesture method is called.
                context: this.node

                //TODO: Use args to pass error object as 1st param if there is an error.
                //args:
            });
        }

        eventQueue.run();
    },

    /**
     * The "flick" gesture is a specialized "move" that has some velocity
     * and the movement always runs either x or y axis. The velocity is calculated
     * with "distance" and "duration" arguments. If the calculated velocity is
     * below than the minimum velocity, the given duration will be ignored and
     * new duration will be created to make a valid flick gesture.
     *
     * @method flick
     * @param {Function} cb The callback to execute when the gesture simulation
     *      is completed.
     * @param {Array} point A point(relative to the top left corner of the
     *      target node element) where the flick gesture should start. The default
     *      is the center of the taget node.
     * @param {String} axis Either "x" or "y".
     * @param {Number} distance A distance in pixels to flick.
     * @param {Number} duration A duration of the gesture in millisecond.
     *
     */
    flick: function(cb, point, axis, distance, duration) {
        var path;

        point = this._calculateDefaultPoint(point);

        if(!Y.Lang.isString(axis)) {
            axis = X_AXIS;
        } else {
            axis = axis.toLowerCase();
            if(axis !== X_AXIS && axis !== Y_AXIS) {
                Y.error(NAME+'(flick): Only x or y axis allowed');
            }
        }

        if(!Y.Lang.isNumber(distance)) {
            distance = DEFAULTS.DISTANCE_FLICK;
        }

        if(!Y.Lang.isNumber(duration)){
            duration = DEFAULTS.DURATION_FLICK; // ms
        } else {
            if(duration > DEFAULTS.MAX_DURATION_FLICK) {
                duration = DEFAULTS.MAX_DURATION_FLICK;
            }
        }

        /*
         * Check if too slow for a flick.
         * Adjust duration if the calculated velocity is less than
         * the minimum velcocity to be claimed as a flick.
         */
        if(Math.abs(distance)/duration < DEFAULTS.MIN_VELOCITY_FLICK) {
            duration = Math.abs(distance)/DEFAULTS.MIN_VELOCITY_FLICK;
        }

        path = {
            start: Y.clone(point),
            end: [
                (axis === X_AXIS) ? point[0]+distance : point[0],
                (axis === Y_AXIS) ? point[1]+distance : point[1]
            ]
        };

        this._move(cb, path, duration);
    },

    /**
     * The "move" gesture simulate the movement of any direction between
     * the straight line of start and end point for the given duration.
     * The path argument is an object with "point", "xdist" and "ydist" properties.
     * The "point" property is an array with x and y coordinations(relative to the
     * top left corner of the target node element) while "xdist" and "ydist"
     * properties are used for the distance along the x and y axis. A negative
     * distance number can be used to drag either left or up direction.
     *
     * If no arguments are given, it will simulate the default move, which
     * is moving 200 pixels from the center of the element to the positive X-axis
     * direction for 1 sec.
     *
     * @method move
     * @param {Function} cb The callback to execute when the gesture simulation
     *      is completed.
     * @param {Object} path An object with "point", "xdist" and "ydist".
     * @param {Number} duration A duration of the gesture in millisecond.
     */
    move: function(cb, path, duration) {
        var convertedPath;

        if(!Y.Lang.isObject(path)) {
            path = {
                point: this._calculateDefaultPoint([]),
                xdist: DEFAULTS.DISTANCE_MOVE,
                ydist: 0
            };
        } else {
            // convert to the page coordination
            if(!Y.Lang.isArray(path.point)) {
                path.point = this._calculateDefaultPoint([]);
            } else {
                path.point = this._calculateDefaultPoint(path.point);
            }

            if(!Y.Lang.isNumber(path.xdist)) {
                path.xdist = DEFAULTS.DISTANCE_MOVE;
            }

            if(!Y.Lang.isNumber(path.ydist)) {
                path.ydist = 0;
            }
        }

        if(!Y.Lang.isNumber(duration)){
            duration = DEFAULTS.DURATION_MOVE; // ms
        } else {
            if(duration > DEFAULTS.MAX_DURATION_MOVE) {
                duration = DEFAULTS.MAX_DURATION_MOVE;
            }
        }

        convertedPath = {
            start: Y.clone(path.point),
            end: [path.point[0]+path.xdist, path.point[1]+path.ydist]
        };

        this._move(cb, convertedPath, duration);
    },

    /**
     * A base method on top of "move" and "flick" methods. The method takes
     * the path with start/end properties and duration to generate a set of
     * touch events for the movement gesture.
     *
     * @method _move
     * @private
     * @param {Function} cb The callback to execute when the gesture simulation
     *      is completed.
     * @param {Object} path An object with "start" and "end" properties. Each
     *      property should be an array with x and y coordination (e.g. start: [100, 50])
     * @param {Number} duration A duration of the gesture in millisecond.
     */
    _move: function(cb, path, duration) {
        var eventQueue,
            i,
            interval = EVENT_INTERVAL,
            steps, stepX, stepY,
            id = 0,
            touchMove;

        if(!Y.Lang.isNumber(duration)){
            duration = DEFAULTS.DURATION_MOVE; // ms
        } else {
            if(duration > DEFAULTS.MAX_DURATION_MOVE) {
                duration = DEFAULTS.MAX_DURATION_MOVE;
            }
        }

        if(!Y.Lang.isObject(path)) {
            path = {
                start: [
                    START_PAGEX,
                    START_PAGEY
                ],
                end: [
                    START_PAGEX + DEFAULTS.DISTANCE_MOVE,
                    START_PAGEY
                ]
            };
        } else {
            if(!Y.Lang.isArray(path.start)) {
                path.start = [
                    START_PAGEX,
                    START_PAGEY
                ];
            }
            if(!Y.Lang.isArray(path.end)) {
                path.end = [
                    START_PAGEX + DEFAULTS.DISTANCE_MOVE,
                    START_PAGEY
                ];
            }
        }

        Y.AsyncQueue.defaults.timeout = interval;
        eventQueue = new Y.AsyncQueue();

        // start
        eventQueue.add({
            fn: function() {
                var coord = {
                        pageX: path.start[0],
                        pageY: path.start[1],
                        clientX: path.start[0],
                        clientY: path.start[1]
                    },
                    touches = this._createTouchList([
                        Y.merge({identifier: (id++)}, coord)
                    ]);

                this._simulateEvent(this.target, TOUCH_START, Y.merge({
                    touches: touches,
                    targetTouches: touches,
                    changedTouches: touches
                }, coord));
            },
            timeout: 0,
            context: this
        });

        // move
        steps = Math.floor(duration/interval);
        stepX = (path.end[0] - path.start[0])/steps;
        stepY = (path.end[1] - path.start[1])/steps;

        touchMove = function(step) {
            var px = path.start[0]+(stepX * step),
                py = path.start[1]+(stepY * step),
                coord = {
                    pageX: px,
                    pageY: py,
                    clientX: px,
                    clientY: py
                },
                touches = this._createTouchList([
                    Y.merge({identifier: (id++)}, coord)
                ]);

            this._simulateEvent(this.target, TOUCH_MOVE, Y.merge({
                touches: touches,
                targetTouches: touches,
                changedTouches: touches
            }, coord));
        };

        for (i=0; i < steps; i++) {
            eventQueue.add({
                fn: touchMove,
                args: [i],
                context: this
            });
        }

        // last move
        eventQueue.add({
            fn: function() {
                var coord = {
                        pageX: path.end[0],
                        pageY: path.end[1],
                        clientX: path.end[0],
                        clientY: path.end[1]
                    },
                    touches = this._createTouchList([
                        Y.merge({identifier: id}, coord)
                    ]);

                this._simulateEvent(this.target, TOUCH_MOVE, Y.merge({
                    touches: touches,
                    targetTouches: touches,
                    changedTouches: touches
                }, coord));
            },
            timeout: 0,
            context: this
        });

        // end
        eventQueue.add({
            fn: function() {
                var coord = {
                    pageX: path.end[0],
                    pageY: path.end[1],
                    clientX: path.end[0],
                    clientY: path.end[1]
                },
                emptyTouchList = this._getEmptyTouchList(),
                touches = this._createTouchList([
                    Y.merge({identifier: id}, coord)
                ]);

                this._simulateEvent(this.target, TOUCH_END, Y.merge({
                    touches: emptyTouchList,
                    targetTouches: emptyTouchList,
                    changedTouches: touches
                }, coord));
            },
            context: this
        });

        if(cb && Y.Lang.isFunction(cb)) {
            eventQueue.add({
                fn: cb,

                // by default, the callback runs the node context where
                // simulateGesture method is called.
                context: this.node

                //TODO: Use args to pass error object as 1st param if there is an error.
                //args:
            });
        }

        eventQueue.run();
    },

    /**
     * Helper method to return a singleton instance of empty touch list.
     *
     * @method _getEmptyTouchList
     * @private
     * @return {TouchList | Array} An empty touch list object.
     */
    _getEmptyTouchList: function() {
        if(!emptyTouchList) {
            emptyTouchList = this._createTouchList([]);
        }

        return emptyTouchList;
    },

    /**
     * Helper method to convert an array with touch points to TouchList object as
     * defined in http://www.w3.org/TR/touch-events/
     *
     * @method _createTouchList
     * @private
     * @param {Array} touchPoints
     * @return {TouchList | Array} If underlaying platform support creating touch list
     *      a TouchList object will be returned otherwise a fake Array object
     *      will be returned.
     */
    _createTouchList: function(touchPoints) {
        /*
        * Android 4.0.3 emulator:
        * Native touch api supported starting in version 4.0 (Ice Cream Sandwich).
        * However the support seems limited. In Android 4.0.3 emulator, I got
        * "TouchList is not defined".
        */
        var touches = [],
            touchList,
            self = this;

        if(!!touchPoints && Y.Lang.isArray(touchPoints)) {
            if(Y.UA.android && Y.UA.android >= 4.0 || Y.UA.ios && Y.UA.ios >= 2.0) {
                Y.each(touchPoints, function(point) {
                    if(!point.identifier) {point.identifier = 0;}
                    if(!point.pageX) {point.pageX = 0;}
                    if(!point.pageY) {point.pageY = 0;}
                    if(!point.screenX) {point.screenX = 0;}
                    if(!point.screenY) {point.screenY = 0;}

                    touches.push(document.createTouch(Y.config.win,
                        self.target,
                        point.identifier,
                        point.pageX, point.pageY,
                        point.screenX, point.screenY));
                });

                touchList = document.createTouchList.apply(document, touches);
            } else if(Y.UA.ios && Y.UA.ios < 2.0) {
                Y.error(NAME+': No touch event simulation framework present.');
            } else {
                // this will inclide android(Y.UA.android && Y.UA.android < 4.0)
                // and desktops among all others.

                /*
                 * Touch APIs are broken in androids older than 4.0. We will use
                 * simulated touch apis for these versions.
                 */
                touchList = [];
                Y.each(touchPoints, function(point) {
                    if(!point.identifier) {point.identifier = 0;}
                    if(!point.clientX)  {point.clientX = 0;}
                    if(!point.clientY)  {point.clientY = 0;}
                    if(!point.pageX)    {point.pageX = 0;}
                    if(!point.pageY)    {point.pageY = 0;}
                    if(!point.screenX)  {point.screenX = 0;}
                    if(!point.screenY)  {point.screenY = 0;}

                    touchList.push({
                        target: self.target,
                        identifier: point.identifier,
                        clientX: point.clientX,
                        clientY: point.clientY,
                        pageX: point.pageX,
                        pageY: point.pageY,
                        screenX: point.screenX,
                        screenY: point.screenY
                    });
                });

                touchList.item = function(i) {
                    return touchList[i];
                };
            }
        } else {
            Y.error(NAME+': Invalid touchPoints passed');
        }

        return touchList;
    },

    /**
     * @method _simulateEvent
     * @private
     * @param {HTMLElement} target The DOM element that's the target of the event.
     * @param {String} type The type of event or name of the supported gesture to simulate
     *      (i.e., "click", "doubletap", "flick").
     * @param {Object} options (Optional) Extra options to copy onto the event object.
     *      For gestures, options are used to refine the gesture behavior.
     */
    _simulateEvent: function(target, type, options) {
        var touches;

        if (touchEvents[type]) {
            if(SUPPORTS_TOUCH) {
                Y.Event.simulate(target, type, options);
            } else {
                // simulate using mouse events if touch is not applicable on this platform.
                // but only single touch event can be simulated.
                if(this._isSingleTouch(options.touches, options.targetTouches, options.changedTouches)) {
                    type = {
                        touchstart: MOUSE_DOWN,
                        touchmove: MOUSE_MOVE,
                        touchend: MOUSE_UP
                    }[type];

                    options.button = 0;
                    options.relatedTarget = null; // since we are not using mouseover event.

                    // touchend has none in options.touches.
                    touches = (type === MOUSE_UP)? options.changedTouches : options.touches;

                    options = Y.mix(options, {
                        screenX: touches.item(0).screenX,
                        screenY: touches.item(0).screenY,
                        clientX: touches.item(0).clientX,
                        clientY: touches.item(0).clientY
                    }, true);

                    Y.Event.simulate(target, type, options);

                    if(type == MOUSE_UP) {
                        Y.Event.simulate(target, MOUSE_CLICK, options);
                    }
                } else {
                    Y.error("_simulateEvent(): Event '" + type + "' has multi touch objects that can't be simulated in your platform.");
                }
            }
        } else {
            // pass thru for all non touch events
            Y.Event.simulate(target, type, options);
        }
    },

    /**
     * Helper method to check the single touch.
     * @method _isSingleTouch
     * @private
     * @param {TouchList} touches
     * @param {TouchList} targetTouches
     * @param {TouchList} changedTouches
     */
    _isSingleTouch: function(touches, targetTouches, changedTouches) {
        return (touches && (touches.length <= 1)) &&
            (targetTouches && (targetTouches.length <= 1)) &&
            (changedTouches && (changedTouches.length <= 1));
    }
};

/*
 * A gesture simulation class.
 */
Y.GestureSimulation = Simulations;

/*
 * Various simulation default behavior properties. If user override
 * Y.GestureSimulation.defaults, overriden values will be used and this
 * should be done before the gesture simulation.
 */
Y.GestureSimulation.defaults = DEFAULTS;

/*
 * The high level gesture names that YUI knows how to simulate.
 */
Y.GestureSimulation.GESTURES = gestureNames;

/**
 * Simulates the higher user level gesture of the given name on a target.
 * This method generates a set of low level touch events(Apple specific gesture
 * events as well for the iOS platforms) asynchronously. Note that gesture
 * simulation is relying on `Y.Event.simulate()` method to generate
 * the touch events under the hood. The `Y.Event.simulate()` method
 * itself is a synchronous method.
 *
 * Users are suggested to use `Node.simulateGesture()` method which
 * basically calls this method internally. Supported gestures are `tap`,
 * `doubletap`, `press`, `move`, `flick`, `pinch` and `rotate`.
 *
 * The `pinch` gesture is used to simulate the pinching and spreading of two
 * fingers. During a pinch simulation, rotation is also possible. Essentially
 * `pinch` and `rotate` simulations share the same base implementation to allow
 * both pinching and rotation at the same time. The only difference is `pinch`
 * requires `start` and `end` option properties while `rotate` requires `rotation`
 * option property.
 *
 * The `pinch` and `rotate` gestures can be described as placing 2 fingers along a
 * circle. Pinching and spreading can be described by start and end circles while
 * rotation occurs on a single circle. If the radius of the start circle is greater
 * than the end circle, the gesture becomes a pinch, otherwise it is a spread spread.
 *
 * @example
 *
 *     var node = Y.one("#target");
 *
 *     // double tap example
 *     node.simulateGesture("doubletap", function() {
 *         // my callback function
 *     });
 *
 *     // flick example from the center of the node, move 50 pixels down for 50ms)
 *     node.simulateGesture("flick", {
 *         axis: y,
 *         distance: -100
 *         duration: 50
 *     }, function() {
 *         // my callback function
 *     });
 *
 *     // simulate rotating a node 75 degrees counter-clockwise
 *     node.simulateGesture("rotate", {
 *         rotation: -75
 *     });
 *
 *     // simulate a pinch and a rotation at the same time.
 *     // fingers start on a circle of radius 100 px, placed at top/bottom
 *     // fingers end on a circle of radius 50px, placed at right/left
 *     node.simulateGesture("pinch", {
 *         r1: 100,
 *         r2: 50,
 *         start: 0
 *         rotation: 90
 *     });
 *
 * @method simulateGesture
 * @param {HTMLElement|Node} node The YUI node or HTML element that's the target
 *      of the event.
 * @param {String} name The name of the supported gesture to simulate. The
 *      supported gesture name is one of "tap", "doubletap", "press", "move",
 *      "flick", "pinch" and "rotate".
 * @param {Object} [options] Extra options used to define the gesture behavior:
 *
 *      Valid options properties for the `tap` gesture:
 *
 *      @param {Array} [options.point] (Optional) Indicates the [x,y] coordinates
 *        where the tap should be simulated. Default is the center of the node
 *        element.
 *      @param {Number} [options.hold=10] (Optional) The hold time in milliseconds.
 *        This is the time between `touchstart` and `touchend` event generation.
 *      @param {Number} [options.times=1] (Optional) Indicates the number of taps.
 *      @param {Number} [options.delay=10] (Optional) The number of milliseconds
 *        before the next tap simulation happens. This is valid only when `times`
 *        is more than 1.
 *
 *      Valid options properties for the `doubletap` gesture:
 *
 *      @param {Array} [options.point] (Optional) Indicates the [x,y] coordinates
 *        where the doubletap should be simulated. Default is the center of the
 *        node element.
 *
 *      Valid options properties for the `press` gesture:
 *
 *      @param {Array} [options.point] (Optional) Indicates the [x,y] coordinates
 *        where the press should be simulated. Default is the center of the node
 *        element.
 *      @param {Number} [options.hold=3000] (Optional) The hold time in milliseconds.
 *        This is the time between `touchstart` and `touchend` event generation.
 *        Default is 3000ms (3 seconds).
 *
 *      Valid options properties for the `move` gesture:
 *
 *      @param {Object} [options.path] (Optional) Indicates the path of the finger
 *        movement. It's an object with three optional properties: `point`,
 *        `xdist` and  `ydist`.
 *        @param {Array} [options.path.point] A starting point of the gesture.
 *          Default is the center of the node element.
 *        @param {Number} [options.path.xdist=200] A distance to move in pixels
 *          along the X axis. A negative distance value indicates moving left.
 *        @param {Number} [options.path.ydist=0] A distance to move in pixels
 *          along the Y axis. A negative distance value indicates moving up.
 *      @param {Number} [options.duration=1000] (Optional) The duration of the
 *        gesture in milliseconds.
 *
 *      Valid options properties for the `flick` gesture:
 *
 *      @param {Array} [options.point] (Optional) Indicates the [x, y] coordinates
 *        where the flick should be simulated. Default is the center of the
 *        node element.
 *      @param {String} [options.axis='x'] (Optional) Valid values are either
 *        "x" or "y". Indicates axis to move along. The flick can move to one of
 *        4 directions(left, right, up and down).
 *      @param {Number} [options.distance=200] (Optional) Distance to move in pixels
 *      @param {Number} [options.duration=1000] (Optional) The duration of the
 *        gesture in milliseconds. User given value could be automatically
 *        adjusted by the framework if it is below the minimum velocity to be
 *        a flick gesture.
 *
 *      Valid options properties for the `pinch` gesture:
 *
 *      @param {Array} [options.center] (Optional) The center of the circle where
 *        two fingers are placed. Default is the center of the node element.
 *      @param {Number} [options.r1] (Required) Pixel radius of the start circle
 *        where 2 fingers will be on when the gesture starts. The circles are
 *        centered at the center of the element.
 *      @param {Number} [options.r2] (Required) Pixel radius of the end circle
 *        when this gesture ends.
 *      @param {Number} [options.duration=1000] (Optional) The duration of the
 *        gesture in milliseconds.
 *      @param {Number} [options.start=0] (Optional) Starting degree of the first
 *        finger. The value is relative to the path of the north. Default is 0
 *        (i.e., 12:00 on a clock).
 *      @param {Number} [options.rotation=0] (Optional) Degrees to rotate from
 *        the starting degree. A negative value means rotation to the
 *        counter-clockwise direction.
 *
 *      Valid options properties for the `rotate` gesture:
 *
 *      @param {Array} [options.center] (Optional) The center of the circle where
 *        two fingers are placed. Default is the center of the node element.
 *      @param {Number} [options.r1] (Optional) Pixel radius of the start circle
 *        where 2 fingers will be on when the gesture starts. The circles are
 *        centered at the center of the element. Default is a fourth of the node
 *        element width or height, whichever is smaller.
 *      @param {Number} [options.r2] (Optional) Pixel radius of the end circle
 *        when this gesture ends. Default is a fourth of the node element width or
 *        height, whichever is smaller.
 *      @param {Number} [options.duration=1000] (Optional) The duration of the
 *        gesture in milliseconds.
 *      @param {Number} [options.start=0] (Optional) Starting degree of the first
 *        finger. The value is relative to the path of the north. Default is 0
 *        (i.e., 12:00 on a clock).
 *      @param {Number} [options.rotation] (Required) Degrees to rotate from
 *        the starting degree. A negative value means rotation to the
 *        counter-clockwise direction.
 *
 * @param {Function} [cb] The callback to execute when the asynchronouse gesture
 *      simulation is completed.
 *      @param {Error} cb.err An error object if the simulation is failed.
 * @for Event
 * @static
 */
Y.Event.simulateGesture = function(node, name, options, cb) {

    node = Y.one(node);

    var sim = new Y.GestureSimulation(node);
    name = name.toLowerCase();

    if(!cb && Y.Lang.isFunction(options)) {
        cb = options;
        options = {};
    }

    options = options || {};

    if (gestureNames[name]) {
        switch(name) {
            // single-touch: point gestures
            case 'tap':
                sim.tap(cb, options.point, options.times, options.hold, options.delay);
                break;
            case 'doubletap':
                sim.tap(cb, options.point, 2);
                break;
            case 'press':
                if(!Y.Lang.isNumber(options.hold)) {
                    options.hold = DEFAULTS.HOLD_PRESS;
                } else if(options.hold < DEFAULTS.MIN_HOLD_PRESS) {
                    options.hold = DEFAULTS.MIN_HOLD_PRESS;
                } else if(options.hold > DEFAULTS.MAX_HOLD_PRESS) {
                    options.hold = DEFAULTS.MAX_HOLD_PRESS;
                }
                sim.tap(cb, options.point, 1, options.hold);
                break;

            // single-touch: move gestures
            case 'move':
                sim.move(cb, options.path, options.duration);
                break;
            case 'flick':
                sim.flick(cb, options.point, options.axis, options.distance,
                    options.duration);
                break;

            // multi-touch: pinch/rotation gestures
            case 'pinch':
                sim.pinch(cb, options.center, options.r1, options.r2,
                    options.duration, options.start, options.rotation);
                break;
            case 'rotate':
                sim.rotate(cb, options.center, options.r1, options.r2,
                    options.duration, options.start, options.rotation);
                break;
        }
    } else {
        Y.error(NAME+': Not a supported gesture simulation: '+name);
    }
};


}, '3.17.2', {"requires": ["async-queue", "event-simulate", "node-screen"]});


/***/ }),

/***/ 163562:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('history-base', function (Y, NAME) {

/**
 * Provides browser history management functionality using a simple
 * add/replace/get paradigm. This can be used to ensure that the browser's back
 * and forward buttons work as the user expects and to provide bookmarkable URLs
 * that return the user to the current application state, even in an Ajax
 * application that doesn't perform full-page refreshes.
 *
 * @module history
 * @main history
 * @since 3.2.0
 */

/**
 * Provides global state management backed by an object, but with no browser
 * history integration. For actual browser history integration and back/forward
 * support, use the history-html5 or history-hash modules.
 *
 * @module history
 * @submodule history-base
 * @class HistoryBase
 * @uses EventTarget
 * @constructor
 * @param {Object} config (optional) configuration object, which may contain
 *   zero or more of the following properties:
 *
 * <dl>
 *   <dt>force (Boolean)</dt>
 *   <dd>
 *     If `true`, a `history:change` event will be fired whenever the URL
 *     changes, even if there is no associated state change. Default is `false`.
 *   </dd>
 *
 *   <dt>initialState (Object)</dt>
 *   <dd>
 *     Initial state to set, as an object hash of key/value pairs. This will be
 *     merged into the current global state.
 *   </dd>
 * </dl>
 */

var Lang      = Y.Lang,
    Obj       = Y.Object,
    GlobalEnv = YUI.namespace('Env.History'),
    YArray    = Y.Array,

    doc       = Y.config.doc,
    docMode   = doc.documentMode,
    win       = Y.config.win,

    DEFAULT_OPTIONS = {merge: true},
    EVT_CHANGE      = 'change',
    SRC_ADD         = 'add',
    SRC_REPLACE     = 'replace';

function HistoryBase() {
    this._init.apply(this, arguments);
}

Y.augment(HistoryBase, Y.EventTarget, null, null, {
    emitFacade : true,
    prefix     : 'history',
    preventable: false,
    queueable  : true
});

if (!GlobalEnv._state) {
    GlobalEnv._state = {};
}

// -- Private Methods ----------------------------------------------------------

/**
 * Returns <code>true</code> if <i>value</i> is a simple object and not a
 * function or an array.
 *
 * @method _isSimpleObject
 * @param {mixed} value
 * @return {Boolean}
 * @private
 */
function _isSimpleObject(value) {
    return Lang.type(value) === 'object';
}

// -- Public Static Properties -------------------------------------------------

/**
 * Name of this component.
 *
 * @property NAME
 * @type String
 * @static
 */
HistoryBase.NAME = 'historyBase';

/**
 * Constant used to identify state changes originating from the
 * <code>add()</code> method.
 *
 * @property SRC_ADD
 * @type String
 * @static
 * @final
 */
HistoryBase.SRC_ADD = SRC_ADD;

/**
 * Constant used to identify state changes originating from the
 * <code>replace()</code> method.
 *
 * @property SRC_REPLACE
 * @type String
 * @static
 * @final
 */
HistoryBase.SRC_REPLACE = SRC_REPLACE;

/**
 * Whether or not this browser supports the HTML5 History API.
 *
 * @property html5
 * @type Boolean
 * @static
 */

// All HTML5-capable browsers except Gecko 2+ (Firefox 4+) correctly return
// true for 'onpopstate' in win. In order to support Gecko 2, we fall back to a
// UA sniff for now. (current as of Firefox 4.0b2)
HistoryBase.html5 = !!(win.history && win.history.pushState &&
        win.history.replaceState && ('onpopstate' in win || Y.UA.gecko >= 2) &&
        (!Y.UA.android || Y.UA.android >= 2.4));

/**
 * Whether or not this browser supports the <code>window.onhashchange</code>
 * event natively. Note that even if this is <code>true</code>, you may
 * still want to use HistoryHash's synthetic <code>hashchange</code> event
 * since it normalizes implementation differences and fixes spec violations
 * across various browsers.
 *
 * @property nativeHashChange
 * @type Boolean
 * @static
 */

// Most browsers that support hashchange expose it on the window. Opera 10.6+
// exposes it on the document (but you can still attach to it on the window).
//
// IE8 supports the hashchange event, but only in IE8 Standards
// Mode. However, IE8 in IE7 compatibility mode still defines the
// event but never fires it, so we can't just detect the event. We also can't
// just UA sniff for IE8, since other browsers support this event as well.
HistoryBase.nativeHashChange = ('onhashchange' in win || 'onhashchange' in doc) &&
        (!docMode || docMode > 7);

Y.mix(HistoryBase.prototype, {
    // -- Initialization -------------------------------------------------------

    /**
     * Initializes this HistoryBase instance. This method is called by the
     * constructor.
     *
     * @method _init
     * @param {Object} config configuration object
     * @protected
     */
    _init: function (config) {
        var initialState;

        /**
         * Configuration object provided by the user on instantiation, or an
         * empty object if one wasn't provided.
         *
         * @property _config
         * @type Object
         * @default {}
         * @protected
         */
        config = this._config = config || {};

        /**
         * If `true`, a `history:change` event will be fired whenever the URL
         * changes, even if there is no associated state change.
         *
         * @property force
         * @type Boolean
         * @default false
         */
         this.force = !!config.force;

        /**
         * Resolved initial state: a merge of the user-supplied initial state
         * (if any) and any initial state provided by a subclass. This may
         * differ from <code>_config.initialState</code>. If neither the config
         * nor a subclass supplies an initial state, this property will be
         * <code>null</code>.
         *
         * @property _initialState
         * @type Object|null
         * @default {}
         * @protected
         */
        initialState = this._initialState = this._initialState ||
                config.initialState || null;

        /**
         * Fired when the state changes. To be notified of all state changes
         * regardless of the History or YUI instance that generated them,
         * subscribe to this event on <code>Y.Global</code>. If you would rather
         * be notified only about changes generated by this specific History
         * instance, subscribe to this event on the instance.
         *
         * @event history:change
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *
         * <dl>
         *   <dt>changed (Object)</dt>
         *   <dd>
         *     Object hash of state items that have been added or changed. The
         *     key is the item key, and the value is an object containing
         *     <code>newVal</code> and <code>prevVal</code> properties
         *     representing the values of the item both before and after the
         *     change. If the item was newly added, <code>prevVal</code> will be
         *     <code>undefined</code>.
         *   </dd>
         *
         *   <dt>newVal (Object)</dt>
         *   <dd>
         *     Object hash of key/value pairs of all state items after the
         *     change.
         *   </dd>
         *
         *   <dt>prevVal (Object)</dt>
         *   <dd>
         *     Object hash of key/value pairs of all state items before the
         *     change.
         *   </dd>
         *
         *   <dt>removed (Object)</dt>
         *   <dd>
         *     Object hash of key/value pairs of state items that have been
         *     removed. Values are the old values prior to removal.
         *   </dd>
         *
         *   <dt>src (String)</dt>
         *   <dd>
         *     The source of the event. This can be used to selectively ignore
         *     events generated by certain sources.
         *   </dd>
         * </dl>
         */
        this.publish(EVT_CHANGE, {
            broadcast: 2,
            defaultFn: this._defChangeFn
        });

        // If initialState was provided, merge it into the current state.
        if (initialState) {
            this.replace(initialState);
        }
    },

    // -- Public Methods -------------------------------------------------------

    /**
     * Adds a state entry with new values for the specified keys. By default,
     * the new state will be merged into the existing state, and new values will
     * override existing values. Specifying a <code>null</code> or
     * <code>undefined</code> value will cause that key to be removed from the
     * new state entry.
     *
     * @method add
     * @param {Object} state Object hash of key/value pairs.
     * @param {Object} options (optional) Zero or more of the following options:
     *   <dl>
     *     <dt>merge (Boolean)</dt>
     *     <dd>
     *       <p>
     *       If <code>true</code> (the default), the new state will be merged
     *       into the existing state. New values will override existing values,
     *       and <code>null</code> or <code>undefined</code> values will be
     *       removed from the state.
     *       </p>
     *
     *       <p>
     *       If <code>false</code>, the existing state will be discarded as a
     *       whole and the new state will take its place.
     *       </p>
     *     </dd>
     *   </dl>
     * @chainable
     */
    add: function () {
        var args = YArray(arguments, 0, true);
        args.unshift(SRC_ADD);
        return this._change.apply(this, args);
    },

    /**
     * Adds a state entry with a new value for a single key. By default, the new
     * value will be merged into the existing state values, and will override an
     * existing value with the same key if there is one. Specifying a
     * <code>null</code> or <code>undefined</code> value will cause the key to
     * be removed from the new state entry.
     *
     * @method addValue
     * @param {String} key State parameter key.
     * @param {String} value New value.
     * @param {Object} options (optional) Zero or more options. See
     *   <code>add()</code> for a list of supported options.
     * @chainable
     */
    addValue: function (key, value, options) {
        var state = {};
        state[key] = value;
        return this._change(SRC_ADD, state, options);
    },

    /**
     * Returns the current value of the state parameter specified by <i>key</i>,
     * or an object hash of key/value pairs for all current state parameters if
     * no key is specified.
     *
     * @method get
     * @param {String} key (optional) State parameter key.
     * @return {Object|String} Value of the specified state parameter, or an
     *   object hash of key/value pairs for all current state parameters.
     */
    get: function (key) {
        var state    = GlobalEnv._state,
            isObject = _isSimpleObject(state);

        if (key) {
            return isObject && Obj.owns(state, key) ? state[key] : undefined;
        } else {
            return isObject ? Y.mix({}, state, true) : state; // mix provides a fast shallow clone.
        }
    },

    /**
     * Same as <code>add()</code> except that a new browser history entry will
     * not be created. Instead, the current history entry will be replaced with
     * the new state.
     *
     * @method replace
     * @param {Object} state Object hash of key/value pairs.
     * @param {Object} options (optional) Zero or more options. See
     *   <code>add()</code> for a list of supported options.
     * @chainable
     */
    replace: function () {
        var args = YArray(arguments, 0, true);
        args.unshift(SRC_REPLACE);
        return this._change.apply(this, args);
    },

    /**
     * Same as <code>addValue()</code> except that a new browser history entry
     * will not be created. Instead, the current history entry will be replaced
     * with the new state.
     *
     * @method replaceValue
     * @param {String} key State parameter key.
     * @param {String} value New value.
     * @param {Object} options (optional) Zero or more options. See
     *   <code>add()</code> for a list of supported options.
     * @chainable
     */
    replaceValue: function (key, value, options) {
        var state = {};
        state[key] = value;
        return this._change(SRC_REPLACE, state, options);
    },

    // -- Protected Methods ----------------------------------------------------

    /**
     * Changes the state. This method provides a common implementation shared by
     * the public methods for changing state.
     *
     * @method _change
     * @param {String} src Source of the change, for inclusion in event facades
     *   to facilitate filtering.
     * @param {Object} state Object hash of key/value pairs.
     * @param {Object} options (optional) Zero or more options. See
     *   <code>add()</code> for a list of supported options.
     * @protected
     * @chainable
     */
    _change: function (src, state, options) {
        options = options ? Y.merge(DEFAULT_OPTIONS, options) : DEFAULT_OPTIONS;

        if (options.merge && _isSimpleObject(state) &&
                _isSimpleObject(GlobalEnv._state)) {
            state = Y.merge(GlobalEnv._state, state);
        }

        this._resolveChanges(src, state, options);
        return this;
    },

    /**
     * Called by _resolveChanges() when the state has changed. This method takes
     * care of actually firing the necessary events.
     *
     * @method _fireEvents
     * @param {String} src Source of the changes, for inclusion in event facades
     *   to facilitate filtering.
     * @param {Object} changes Resolved changes.
     * @param {Object} options Zero or more options. See <code>add()</code> for
     *   a list of supported options.
     * @protected
     */
    _fireEvents: function (src, changes, options) {
        // Fire the global change event.
        this.fire(EVT_CHANGE, {
            _options: options,
            changed : changes.changed,
            newVal  : changes.newState,
            prevVal : changes.prevState,
            removed : changes.removed,
            src     : src
        });

        // Fire change/remove events for individual items.
        Obj.each(changes.changed, function (value, key) {
            this._fireChangeEvent(src, key, value);
        }, this);

        Obj.each(changes.removed, function (value, key) {
            this._fireRemoveEvent(src, key, value);
        }, this);
    },

    /**
     * Fires a dynamic "[key]Change" event.
     *
     * @method _fireChangeEvent
     * @param {String} src source of the change, for inclusion in event facades
     *   to facilitate filtering
     * @param {String} key key of the item that was changed
     * @param {Object} value object hash containing <i>newVal</i> and
     *   <i>prevVal</i> properties for the changed item
     * @protected
     */
    _fireChangeEvent: function (src, key, value) {
        /**
         * <p>
         * Dynamic event fired when an individual history item is added or
         * changed. The name of this event depends on the name of the key that
         * changed. To listen to change events for a key named "foo", subscribe
         * to the <code>fooChange</code> event; for a key named "bar", subscribe
         * to <code>barChange</code>, etc.
         * </p>
         *
         * <p>
         * Key-specific events are only fired for instance-level changes; that
         * is, changes that were made via the same History instance on which the
         * event is subscribed. To be notified of changes made by other History
         * instances, subscribe to the global <code>history:change</code> event.
         * </p>
         *
         * @event [key]Change
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *
         * <dl>
         *   <dt>newVal (mixed)</dt>
         *   <dd>
         *     The new value of the item after the change.
         *   </dd>
         *
         *   <dt>prevVal (mixed)</dt>
         *   <dd>
         *     The previous value of the item before the change, or
         *     <code>undefined</code> if the item was just added and has no
         *     previous value.
         *   </dd>
         *
         *   <dt>src (String)</dt>
         *   <dd>
         *     The source of the event. This can be used to selectively ignore
         *     events generated by certain sources.
         *   </dd>
         * </dl>
         */
        this.fire(key + 'Change', {
            newVal : value.newVal,
            prevVal: value.prevVal,
            src    : src
        });
    },

    /**
     * Fires a dynamic "[key]Remove" event.
     *
     * @method _fireRemoveEvent
     * @param {String} src source of the change, for inclusion in event facades
     *   to facilitate filtering
     * @param {String} key key of the item that was removed
     * @param {mixed} value value of the item prior to its removal
     * @protected
     */
    _fireRemoveEvent: function (src, key, value) {
        /**
         * <p>
         * Dynamic event fired when an individual history item is removed. The
         * name of this event depends on the name of the key that was removed.
         * To listen to remove events for a key named "foo", subscribe to the
         * <code>fooRemove</code> event; for a key named "bar", subscribe to
         * <code>barRemove</code>, etc.
         * </p>
         *
         * <p>
         * Key-specific events are only fired for instance-level changes; that
         * is, changes that were made via the same History instance on which the
         * event is subscribed. To be notified of changes made by other History
         * instances, subscribe to the global <code>history:change</code> event.
         * </p>
         *
         * @event [key]Remove
         * @param {EventFacade} e Event facade with the following additional
         *   properties:
         *
         * <dl>
         *   <dt>prevVal (mixed)</dt>
         *   <dd>
         *     The value of the item before it was removed.
         *   </dd>
         *
         *   <dt>src (String)</dt>
         *   <dd>
         *     The source of the event. This can be used to selectively ignore
         *     events generated by certain sources.
         *   </dd>
         * </dl>
         */
        this.fire(key + 'Remove', {
            prevVal: value,
            src    : src
        });
    },

    /**
     * Resolves the changes (if any) between <i>newState</i> and the current
     * state and fires appropriate events if things have changed.
     *
     * @method _resolveChanges
     * @param {String} src source of the changes, for inclusion in event facades
     *   to facilitate filtering
     * @param {Object} newState object hash of key/value pairs representing the
     *   new state
     * @param {Object} options Zero or more options. See <code>add()</code> for
     *   a list of supported options.
     * @protected
     */
    _resolveChanges: function (src, newState, options) {
        var changed   = {},
            isChanged,
            prevState = GlobalEnv._state,
            removed   = {};

        newState || (newState = {});
        options  || (options  = {});

        if (_isSimpleObject(newState) && _isSimpleObject(prevState)) {
            // Figure out what was added or changed.
            Obj.each(newState, function (newVal, key) {
                var prevVal = prevState[key];

                if (newVal !== prevVal) {
                    changed[key] = {
                        newVal : newVal,
                        prevVal: prevVal
                    };

                    isChanged = true;
                }
            }, this);

            // Figure out what was removed.
            Obj.each(prevState, function (prevVal, key) {
                if (!Obj.owns(newState, key) || newState[key] === null) {
                    delete newState[key];
                    removed[key] = prevVal;
                    isChanged = true;
                }
            }, this);
        } else {
            isChanged = newState !== prevState;
        }

        if (isChanged || this.force) {
            this._fireEvents(src, {
                changed  : changed,
                newState : newState,
                prevState: prevState,
                removed  : removed
            }, options);
        }
    },

    /**
     * Stores the specified state. Don't call this method directly; go through
     * _resolveChanges() to ensure that changes are resolved and all events are
     * fired properly.
     *
     * @method _storeState
     * @param {String} src source of the changes
     * @param {Object} newState new state to store
     * @param {Object} options Zero or more options. See <code>add()</code> for
     *   a list of supported options.
     * @protected
     */
    _storeState: function (src, newState) {
        // Note: the src and options params aren't used here, but they are used
        // by subclasses.
        GlobalEnv._state = newState || {};
    },

    // -- Protected Event Handlers ---------------------------------------------

    /**
     * Default <code>history:change</code> event handler.
     *
     * @method _defChangeFn
     * @param {EventFacade} e state change event facade
     * @protected
     */
    _defChangeFn: function (e) {
        this._storeState(e.src, e.newVal, e._options);
    }
}, true);

Y.HistoryBase = HistoryBase;


}, '3.17.2', {"requires": ["event-custom-complex"]});


/***/ }),

/***/ 827476:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('history-hash-ie', function (Y, NAME) {

/**
 * Improves IE6/7 support in history-hash by using a hidden iframe to create
 * entries in IE's browser history. This module is only needed if IE6/7 support
 * is necessary; it's not needed for any other browser.
 *
 * @module history
 * @submodule history-hash-ie
 * @since 3.2.0
 */

// Combination of a UA sniff to ensure this is IE (or a browser that wants us to
// treat it like IE) and feature detection for native hashchange support (false
// for IE < 8 or IE8/9 in IE7 mode).
if (Y.UA.ie && !Y.HistoryBase.nativeHashChange) {
    var Do          = Y.Do,
        GlobalEnv   = YUI.namespace('Env.HistoryHash'),
        HistoryHash = Y.HistoryHash,

        iframe = GlobalEnv._iframe,
        win    = Y.config.win;

    /**
     * Gets the raw (not decoded) current location hash from the IE iframe,
     * minus the preceding '#' character and the hashPrefix (if one is set).
     *
     * @method getIframeHash
     * @return {String} current iframe hash
     * @static
     */
    HistoryHash.getIframeHash = function () {
        if (!iframe || !iframe.contentWindow) {
            return '';
        }

        var prefix = HistoryHash.hashPrefix,
            hash   = iframe.contentWindow.location.hash.substr(1);

        return prefix && hash.indexOf(prefix) === 0 ?
                    hash.replace(prefix, '') : hash;
    };

    /**
     * Updates the history iframe with the specified hash.
     *
     * @method _updateIframe
     * @param {String} hash location hash
     * @param {Boolean} replace (optional) if <code>true</code>, the current
     *   history state will be replaced without adding a new history entry
     * @protected
     * @static
     * @for HistoryHash
     */
    HistoryHash._updateIframe = function (hash, replace) {
        var iframeDoc      = iframe && iframe.contentWindow && iframe.contentWindow.document,
            iframeLocation = iframeDoc && iframeDoc.location;

        if (!iframeDoc || !iframeLocation) {
            return;
        }


        if (replace) {
            iframeLocation.replace(hash.charAt(0) === '#' ? hash : '#' + hash);
        } else {
            iframeDoc.open().close();
            iframeLocation.hash = hash;
        }
    };

    Do.before(HistoryHash._updateIframe, HistoryHash, 'replaceHash', HistoryHash, true);

    if (!iframe) {
        Y.on('domready', function () {
            var lastUrlHash = HistoryHash.getHash();

            // Create a hidden iframe to store history state, following the
            // iframe-hiding recommendations from
            // http://www.paciellogroup.com/blog/?p=604.
            //
            // This iframe will allow history navigation within the current page
            // context. After navigating to another page, all but the most
            // recent history state will be lost.
            //
            // Earlier versions of the YUI History Utility attempted to work
            // around this limitation by having the iframe load a static
            // resource. This workaround was extremely fragile and tended to
            // break frequently (and silently) since it was entirely dependent
            // on IE's inconsistent handling of iframe history.
            //
            // Since this workaround didn't work much of the time anyway and
            // added significant complexity, it has been removed, and IE6 and 7
            // now get slightly degraded history support.

            iframe = GlobalEnv._iframe = Y.Node.getDOMNode(Y.Node.create(
                '<iframe src="javascript:0" style="display:none" height="0" width="0" tabindex="-1" title="empty"/>'
            ));

            // Append the iframe to the documentElement rather than the body.
            // Keeping it outside the body prevents scrolling on the initial
            // page load (hat tip to Ben Alman and jQuery BBQ for this
            // technique).
            Y.config.doc.documentElement.appendChild(iframe);

            // Update the iframe with the initial location hash, if any. This
            // will create an initial history entry that the user can return to
            // after the state has changed.
            HistoryHash._updateIframe(lastUrlHash || '#');

            // Listen for hashchange events and keep the iframe's hash in sync
            // with the parent frame's hash.
            Y.on('hashchange', function (e) {
                lastUrlHash = e.newHash;

                if (HistoryHash.getIframeHash() !== lastUrlHash) {
                    HistoryHash._updateIframe(lastUrlHash);
                }
            }, win);

            // Watch the iframe hash in order to detect back/forward navigation.
            Y.later(50, null, function () {
                var iframeHash = HistoryHash.getIframeHash();

                if (iframeHash !== lastUrlHash) {
                    HistoryHash.setHash(iframeHash);
                }
            }, null, true);
        });
    }
}


}, '3.17.2', {"requires": ["history-hash", "node-base"]});


/***/ }),

/***/ 213978:
/***/ (function() {

// /*
// YUI 3.17.2 (build 9c3c78e)
// Copyright 2014 Yahoo! Inc. All rights reserved.
// Licensed under the BSD License.
// http://yuilibrary.com/license/
// */
// 
// YUI.add('history-hash', function (Y, NAME) {
// 
// /**
//  * Provides browser history management backed by
//  * <code>window.location.hash</code>, as well as convenience methods for working
//  * with the location hash and a synthetic <code>hashchange</code> event that
//  * normalizes differences across browsers.
//  *
//  * @module history
//  * @submodule history-hash
//  * @since 3.2.0
//  * @class HistoryHash
//  * @extends HistoryBase
//  * @constructor
//  * @param {Object} config (optional) Configuration object. See the HistoryBase
//  *   documentation for details.
//  */
// 
// var HistoryBase = Y.HistoryBase,
//     Lang        = Y.Lang,
//     YArray      = Y.Array,
//     YObject     = Y.Object,
//     GlobalEnv   = YUI.namespace('Env.HistoryHash'),
// 
//     SRC_HASH    = 'hash',
// 
//     hashNotifiers,
//     oldHash,
//     oldUrl,
//     win             = Y.config.win,
//     useHistoryHTML5 = Y.config.useHistoryHTML5;
// 
// function HistoryHash() {
//     HistoryHash.superclass.constructor.apply(this, arguments);
// }
// 
// Y.extend(HistoryHash, HistoryBase, {
//     // -- Initialization -------------------------------------------------------
//     _init: function (config) {
//         var bookmarkedState = HistoryHash.parseHash();
// 
//         // If an initialState was provided, merge the bookmarked state into it
//         // (the bookmarked state wins).
//         config = config || {};
// 
//         this._initialState = config.initialState ?
//                 Y.merge(config.initialState, bookmarkedState) : bookmarkedState;
// 
//         // Subscribe to the synthetic hashchange event (defined below) to handle
//         // changes.
//         Y.after('hashchange', Y.bind(this._afterHashChange, this), win);
// 
//         HistoryHash.superclass._init.apply(this, arguments);
//     },
// 
//     // -- Protected Methods ----------------------------------------------------
//     _change: function (src, state, options) {
//         // Stringify all values to ensure that comparisons don't fail after
//         // they're coerced to strings in the location hash.
//         YObject.each(state, function (value, key) {
//             if (Lang.isValue(value)) {
//                 state[key] = value.toString();
//             }
//         });
// 
//         return HistoryHash.superclass._change.call(this, src, state, options);
//     },
// 
//     _storeState: function (src, newState) {
//         var decode  = HistoryHash.decode,
//             newHash = HistoryHash.createHash(newState);
// 
//         HistoryHash.superclass._storeState.apply(this, arguments);
// 
//         // Update the location hash with the changes, but only if the new hash
//         // actually differs from the current hash (this avoids creating multiple
//         // history entries for a single state).
//         //
//         // We always compare decoded hashes, since it's possible that the hash
//         // could be set incorrectly to a non-encoded value outside of
//         // HistoryHash.
//         if (src !== SRC_HASH && decode(HistoryHash.getHash()) !== decode(newHash)) {
//             HistoryHash[src === HistoryBase.SRC_REPLACE ? 'replaceHash' : 'setHash'](newHash);
//         }
//     },
// 
//     // -- Protected Event Handlers ---------------------------------------------
// 
//     /**
//      * Handler for hashchange events.
//      *
//      * @method _afterHashChange
//      * @param {Event} e
//      * @protected
//      */
//     _afterHashChange: function (e) {
//         this._resolveChanges(SRC_HASH, HistoryHash.parseHash(e.newHash), {});
//     }
// }, {
//     // -- Public Static Properties ---------------------------------------------
//     NAME: 'historyHash',
// 
//     /**
//      * Constant used to identify state changes originating from
//      * <code>hashchange</code> events.
//      *
//      * @property SRC_HASH
//      * @type String
//      * @static
//      * @final
//      */
//     SRC_HASH: SRC_HASH,
// 
//     /**
//      * <p>
//      * Prefix to prepend when setting the hash fragment. For example, if the
//      * prefix is <code>!</code> and the hash fragment is set to
//      * <code>#foo=bar&baz=quux</code>, the final hash fragment in the URL will
//      * become <code>#!foo=bar&baz=quux</code>. This can be used to help make an
//      * Ajax application crawlable in accordance with Google's guidelines at
//      * <a href="http://code.google.com/web/ajaxcrawling/">http://code.google.com/web/ajaxcrawling/</a>.
//      * </p>
//      *
//      * <p>
//      * Note that this prefix applies to all HistoryHash instances. It's not
//      * possible for individual instances to use their own prefixes since they
//      * all operate on the same URL.
//      * </p>
//      *
//      * @property hashPrefix
//      * @type String
//      * @default ''
//      * @static
//      */
//     hashPrefix: '',
// 
//     // -- Protected Static Properties ------------------------------------------
// 
//     /**
//      * Regular expression used to parse location hash/query strings.
//      *
//      * @property _REGEX_HASH
//      * @type RegExp
//      * @protected
//      * @static
//      * @final
//      */
//     _REGEX_HASH: /([^\?#&=]+)=?([^&=]*)/g,
// 
//     // -- Public Static Methods ------------------------------------------------
// 
//     /**
//      * Creates a location hash string from the specified object of key/value
//      * pairs.
//      *
//      * @method createHash
//      * @param {Object} params object of key/value parameter pairs
//      * @return {String} location hash string
//      * @static
//      */
//     createHash: function (params) {
//         var encode = HistoryHash.encode,
//             hash   = [];
// 
//         YObject.each(params, function (value, key) {
//             if (Lang.isValue(value)) {
//                 hash.push(encode(key) + '=' + encode(value));
//             }
//         });
// 
//         return hash.join('&');
//     },
// 
//     /**
//      * Wrapper around <code>decodeURIComponent()</code> that also converts +
//      * chars into spaces.
//      *
//      * @method decode
//      * @param {String} string string to decode
//      * @return {String} decoded string
//      * @static
//      */
//     decode: function (string) {
//         return decodeURIComponent(string.replace(/\+/g, ' '));
//     },
// 
//     /**
//      * Wrapper around <code>encodeURIComponent()</code> that converts spaces to
//      * + chars.
//      *
//      * @method encode
//      * @param {String} string string to encode
//      * @return {String} encoded string
//      * @static
//      */
//     encode: function (string) {
//         return encodeURIComponent(string).replace(/%20/g, '+');
//     },
// 
//     /**
//      * Gets the raw (not decoded) current location hash, minus the preceding '#'
//      * character and the hashPrefix (if one is set).
//      *
//      * @method getHash
//      * @return {String} current location hash
//      * @static
//      */
//     getHash: (Y.UA.gecko ? function () {
//         // Gecko's window.location.hash returns a decoded string and we want all
//         // encoding untouched, so we need to get the hash value from
//         // window.location.href instead. We have to use UA sniffing rather than
//         // feature detection, since the only way to detect this would be to
//         // actually change the hash.
//         var location = Y.getLocation(),
//             matches  = /#(.*)$/.exec(location.href),
//             hash     = matches && matches[1] || '',
//             prefix   = HistoryHash.hashPrefix;
// 
//         return prefix && hash.indexOf(prefix) === 0 ?
//                     hash.replace(prefix, '') : hash;
//     } : function () {
//         var location = Y.getLocation(),
//             hash     = location.hash.substring(1),
//             prefix   = HistoryHash.hashPrefix;
// 
//         // Slight code duplication here, but execution speed is of the essence
//         // since getHash() is called every 50ms to poll for changes in browsers
//         // that don't support native onhashchange. An additional function call
//         // would add unnecessary overhead.
//         return prefix && hash.indexOf(prefix) === 0 ?
//                     hash.replace(prefix, '') : hash;
//     }),
// 
//     /**
//      * Gets the current bookmarkable URL.
//      *
//      * @method getUrl
//      * @return {String} current bookmarkable URL
//      * @static
//      */
//     getUrl: function () {
//         return location.href;
//     },
// 
//     /**
//      * Parses a location hash string into an object of key/value parameter
//      * pairs. If <i>hash</i> is not specified, the current location hash will
//      * be used.
//      *
//      * @method parseHash
//      * @param {String} hash (optional) location hash string
//      * @return {Object} object of parsed key/value parameter pairs
//      * @static
//      */
//     parseHash: function (hash) {
//         var decode = HistoryHash.decode,
//             i,
//             len,
//             match,
//             matches,
//             param,
//             params = {},
//             prefix = HistoryHash.hashPrefix,
//             prefixIndex;
// 
//         hash = Lang.isValue(hash) ? hash : HistoryHash.getHash();
// 
//         if (prefix) {
//             prefixIndex = hash.indexOf(prefix);
// 
//             if (prefixIndex === 0 || (prefixIndex === 1 && hash.charAt(0) === '#')) {
//                 hash = hash.replace(prefix, '');
//             }
//         }
// 
//         matches = hash.match(HistoryHash._REGEX_HASH) || [];
// 
//         for (i = 0, len = matches.length; i < len; ++i) {
//             match = matches[i];
// 
//             param = match.split('=');
// 
//             if (param.length > 1) {
//                 params[decode(param[0])] = decode(param[1]);
//             } else {
//                 params[decode(match)] = '';
//             }
//         }
// 
//         return params;
//     },
// 
//     /**
//      * Replaces the browser's current location hash with the specified hash
//      * and removes all forward navigation states, without creating a new browser
//      * history entry. Automatically prepends the <code>hashPrefix</code> if one
//      * is set.
//      *
//      * @method replaceHash
//      * @param {String} hash new location hash
//      * @static
//      */
//     replaceHash: function (hash) {
//         var location = Y.getLocation(),
//             base     = location.href.replace(/#.*$/, '');
// 
//         if (hash.charAt(0) === '#') {
//             hash = hash.substring(1);
//         }
// 
//         location.replace(base + '#' + (HistoryHash.hashPrefix || '') + hash);
//     },
// 
//     /**
//      * Sets the browser's location hash to the specified string. Automatically
//      * prepends the <code>hashPrefix</code> if one is set.
//      *
//      * @method setHash
//      * @param {String} hash new location hash
//      * @static
//      */
//     setHash: function (hash) {
//         var location = Y.getLocation();
// 
//         if (hash.charAt(0) === '#') {
//             hash = hash.substring(1);
//         }
// 
//         location.hash = (HistoryHash.hashPrefix || '') + hash;
//     }
// });
// 
// // -- Synthetic hashchange Event -----------------------------------------------
// 
// // TODO: YUIDoc currently doesn't provide a good way to document synthetic DOM
// // events. For now, we're just documenting the hashchange event on the YUI
// // object, which is about the best we can do until enhancements are made to
// // YUIDoc.
// 
// /**
// Synthetic <code>window.onhashchange</code> event that normalizes differences
// across browsers and provides support for browsers that don't natively support
// <code>onhashchange</code>.
// 
// This event is provided by the <code>history-hash</code> module.
// 
// @example
// 
//     YUI().use('history-hash', function (Y) {
//       Y.on('hashchange', function (e) {
//         // Handle hashchange events on the current window.
//       }, Y.config.win);
//     });
// 
// @event hashchange
// @param {EventFacade} e Event facade with the following additional
//   properties:
// 
// <dl>
//   <dt>oldHash</dt>
//   <dd>
//     Previous hash fragment value before the change.
//   </dd>
// 
//   <dt>oldUrl</dt>
//   <dd>
//     Previous URL (including the hash fragment) before the change.
//   </dd>
// 
//   <dt>newHash</dt>
//   <dd>
//     New hash fragment value after the change.
//   </dd>
// 
//   <dt>newUrl</dt>
//   <dd>
//     New URL (including the hash fragment) after the change.
//   </dd>
// </dl>
// @for YUI
// @since 3.2.0
// **/
// 
// hashNotifiers = GlobalEnv._notifiers;
// 
// if (!hashNotifiers) {
//     hashNotifiers = GlobalEnv._notifiers = [];
// }
// 
// Y.Event.define('hashchange', {
//     on: function (node, subscriber, notifier) {
//         // Ignore this subscription if the node is anything other than the
//         // window or document body, since those are the only elements that
//         // should support the hashchange event. Note that the body could also be
//         // a frameset, but that's okay since framesets support hashchange too.
//         if (node.compareTo(win) || node.compareTo(Y.config.doc.body)) {
//             hashNotifiers.push(notifier);
//         }
//     },
// 
//     detach: function (node, subscriber, notifier) {
//         var index = YArray.indexOf(hashNotifiers, notifier);
// 
//         if (index !== -1) {
//             hashNotifiers.splice(index, 1);
//         }
//     }
// });
// 
// oldHash = HistoryHash.getHash();
// oldUrl  = HistoryHash.getUrl();
// 
// if (HistoryBase.nativeHashChange) {
//     // Wrap the browser's native hashchange event if there's not already a
//     // global listener.
//     if (!GlobalEnv._hashHandle) {
//         GlobalEnv._hashHandle = Y.Event.attach('hashchange', function (e) {
//             var newHash = HistoryHash.getHash(),
//                 newUrl  = HistoryHash.getUrl();
// 
//             // Iterate over a copy of the hashNotifiers array since a subscriber
//             // could detach during iteration and cause the array to be re-indexed.
//             YArray.each(hashNotifiers.concat(), function (notifier) {
//                 notifier.fire({
//                     _event : e,
//                     oldHash: oldHash,
//                     oldUrl : oldUrl,
//                     newHash: newHash,
//                     newUrl : newUrl
//                 });
//             });
// 
//             oldHash = newHash;
//             oldUrl  = newUrl;
//         }, win);
//     }
// } else {
//     // Begin polling for location hash changes if there's not already a global
//     // poll running.
//     if (!GlobalEnv._hashPoll) {
//         GlobalEnv._hashPoll = Y.later(50, null, function () {
//             var newHash = HistoryHash.getHash(),
//                 facade, newUrl;
// 
//             if (oldHash !== newHash) {
//                 newUrl = HistoryHash.getUrl();
// 
//                 facade = {
//                     oldHash: oldHash,
//                     oldUrl : oldUrl,
//                     newHash: newHash,
//                     newUrl : newUrl
//                 };
// 
//                 oldHash = newHash;
//                 oldUrl  = newUrl;
// 
//                 YArray.each(hashNotifiers.concat(), function (notifier) {
//                     notifier.fire(facade);
//                 });
//             }
//         }, null, true);
//     }
// }
// 
// Y.HistoryHash = HistoryHash;
// 
// // HistoryHash will never win over HistoryHTML5 unless useHistoryHTML5 is false.
// if (useHistoryHTML5 === false || (!Y.History && useHistoryHTML5 !== true &&
//         (!HistoryBase.html5 || !Y.HistoryHTML5))) {
//     Y.History = HistoryHash;
// }
// 
// 
// }, '3.17.2', {"requires": ["event-synthetic", "history-base", "yui-later"]});
YUI.add('squarespace-history-hash', function (Y, NAME) {

}, '1.0', {
  requires: [
    'squarespace-beforeunload'
  ]
});


/*  __   __  _______  ___      ___      _______  __
// |  | |  ||       ||   |    |   |    |       ||  |
// |  |_|  ||    ___||   |    |   |    |   _   ||  |
// |       ||   |___ |   |    |   |    |  | |  ||  |
// |       ||    ___||   |___ |   |___ |  |_|  ||__|
// |   _   ||   |___ |       ||       ||       | __
// |__| |__||_______||_______||_______||_______||__|
*/

/**
 * This file is an override for YUI's history-hash. Because we use multiple
 * frames in our environment, we need to change a couple assumptions that YUI
 * has about environments.
 *
 * The guts of what changed can be seen at the `Synthetic hashchange Event` section
 * of this file.
 *
 * We attach an event to the window if it doesn't exist already, and use that
 * to notify everyone that listens for a hashchange event.
 *
 * We also bring in the `squarespace-beforeunload` module, so that we can unbind the listener
 * once a window gets "destroyed".
 */

(function(YUI) {

    var DEBUG = false;

// the reason this is an `exports` and not YUI.add('history-hash')
// is because we don't want create-rollups to pick up on the fact
// that history-hash is in here.

YUI.add('history-hash', function(Y) {


    /**
     * Provides browser history management backed by
     * <code>window.location.hash</code>, as well as convenience methods for working
     * with the location hash and a synthetic <code>hashchange</code> event that
     * normalizes differences across browsers.
     *
     * @module history
     * @submodule history-hash
     * @since 3.2.0
     * @class HistoryHash
     * @extends HistoryBase
     * @constructor
     * @param {Object} config (optional) Configuration object. See the HistoryBase
     *   documentation for details.
     */

    var HistoryBase = Y.HistoryBase,
        Lang        = Y.Lang,
        YArray      = Y.Array,
        YObject     = Y.Object,
        GlobalEnv   = YUI.namespace('Env.HistoryHash'),

        SRC_HASH    = 'hash',

        globalHashNotifiersByWindow,
        hashNotifiersForWindow,
        oldHash,
        oldUrl,
        win             = Y.config.win,
        useHistoryHTML5 = Y.config.useHistoryHTML5;

    function HistoryHash() {
        HistoryHash.superclass.constructor.apply(this, arguments);
    }

    Y.extend(HistoryHash, HistoryBase, {
        // -- Initialization -------------------------------------------------------
        _init: function (config) {
            var bookmarkedState = HistoryHash.parseHash();

            // If an initialState was provided, merge the bookmarked state into it
            // (the bookmarked state wins).
            config = config || {};

            this._initialState = config.initialState ?
                    Y.merge(config.initialState, bookmarkedState) : bookmarkedState;

            // Subscribe to the synthetic hashchange event (defined below) to handle
            // changes.
            Y.after('hashchange', Y.bind(this._afterHashChange, this), win);

            HistoryHash.superclass._init.apply(this, arguments);
        },

        // -- Protected Methods ----------------------------------------------------
        _change: function (src, state, options) {
            // Stringify all values to ensure that comparisons don't fail after
            // they're coerced to strings in the location hash.
            YObject.each(state, function (value, key) {
                if (Lang.isValue(value)) {
                    state[key] = value.toString();
                }
            });

            return HistoryHash.superclass._change.call(this, src, state, options);
        },

        _storeState: function (src, newState) {
            var decode  = HistoryHash.decode,
                newHash = HistoryHash.createHash(newState);

            HistoryHash.superclass._storeState.apply(this, arguments);

            // Update the location hash with the changes, but only if the new hash
            // actually differs from the current hash (this avoids creating multiple
            // history entries for a single state).
            //
            // We always compare decoded hashes, since it's possible that the hash
            // could be set incorrectly to a non-encoded value outside of
            // HistoryHash.
            if (src !== SRC_HASH && decode(HistoryHash.getHash()) !== decode(newHash)) {
                HistoryHash[src === HistoryBase.SRC_REPLACE ? 'replaceHash' : 'setHash'](newHash);
            }
        },

        // -- Protected Event Handlers ---------------------------------------------

        /**
         * Handler for hashchange events.
         *
         * @method _afterHashChange
         * @param {Event} e
         * @protected
         */
        _afterHashChange: function (e) {
            this._resolveChanges(SRC_HASH, HistoryHash.parseHash(e.newHash), {});
        }
    }, {
        // -- Public Static Properties ---------------------------------------------
        NAME: 'historyHash',

        /**
         * Constant used to identify state changes originating from
         * <code>hashchange</code> events.
         *
         * @property SRC_HASH
         * @type String
         * @static
         * @final
         */
        SRC_HASH: SRC_HASH,

        /**
         * <p>
         * Prefix to prepend when setting the hash fragment. For example, if the
         * prefix is <code>!</code> and the hash fragment is set to
         * <code>#foo=bar&baz=quux</code>, the final hash fragment in the URL will
         * become <code>#!foo=bar&baz=quux</code>. This can be used to help make an
         * Ajax application crawlable in accordance with Google's guidelines at
         * <a href="http://code.google.com/web/ajaxcrawling/">http://code.google.com/web/ajaxcrawling/</a>.
         * </p>
         *
         * <p>
         * Note that this prefix applies to all HistoryHash instances. It's not
         * possible for individual instances to use their own prefixes since they
         * all operate on the same URL.
         * </p>
         *
         * @property hashPrefix
         * @type String
         * @default ''
         * @static
         */
        hashPrefix: '',

        // -- Protected Static Properties ------------------------------------------

        /**
         * Regular expression used to parse location hash/query strings.
         *
         * @property _REGEX_HASH
         * @type RegExp
         * @protected
         * @static
         * @final
         */
        _REGEX_HASH: /([^\?#&=]+)=?([^&=]*)/g,

        // -- Public Static Methods ------------------------------------------------

        /**
         * Creates a location hash string from the specified object of key/value
         * pairs.
         *
         * @method createHash
         * @param {Object} params object of key/value parameter pairs
         * @return {String} location hash string
         * @static
         */
        createHash: function (params) {
            var encode = HistoryHash.encode,
                hash   = [];

            YObject.each(params, function (value, key) {
                if (Lang.isValue(value)) {
                    hash.push(encode(key) + '=' + encode(value));
                }
            });

            return hash.join('&');
        },

        /**
         * Wrapper around <code>decodeURIComponent()</code> that also converts +
         * chars into spaces.
         *
         * @method decode
         * @param {String} string string to decode
         * @return {String} decoded string
         * @static
         */
        decode: function (string) {
            return decodeURIComponent(string.replace(/\+/g, ' '));
        },

        /**
         * Wrapper around <code>encodeURIComponent()</code> that converts spaces to
         * + chars.
         *
         * @method encode
         * @param {String} string string to encode
         * @return {String} encoded string
         * @static
         */
        encode: function (string) {
            return encodeURIComponent(string).replace(/%20/g, '+');
        },

        /**
         * Gets the raw (not decoded) current location hash, minus the preceding '#'
         * character and the hashPrefix (if one is set).
         *
         * @method getHash
         * @return {String} current location hash
         * @static
         */
        getHash: (Y.UA.gecko ? function () {
            // Gecko's window.location.hash returns a decoded string and we want all
            // encoding untouched, so we need to get the hash value from
            // window.location.href instead. We have to use UA sniffing rather than
            // feature detection, since the only way to detect this would be to
            // actually change the hash.
            var location = Y.getLocation(),
                matches  = /#(.*)$/.exec(location.href),
                hash     = matches && matches[1] || '',
                prefix   = HistoryHash.hashPrefix;

            return prefix && hash.indexOf(prefix) === 0 ?
                        hash.replace(prefix, '') : hash;
        } : function () {
            var location = Y.getLocation(),
                hash     = location.hash.substring(1),
                prefix   = HistoryHash.hashPrefix;

            // Slight code duplication here, but execution speed is of the essence
            // since getHash() is called every 50ms to poll for changes in browsers
            // that don't support native onhashchange. An additional function call
            // would add unnecessary overhead.
            return prefix && hash.indexOf(prefix) === 0 ?
                        hash.replace(prefix, '') : hash;
        }),

        /**
         * Gets the current bookmarkable URL.
         *
         * @method getUrl
         * @return {String} current bookmarkable URL
         * @static
         */
        getUrl: function () {
            return location.href;
        },

        /**
         * Parses a location hash string into an object of key/value parameter
         * pairs. If <i>hash</i> is not specified, the current location hash will
         * be used.
         *
         * @method parseHash
         * @param {String} hash (optional) location hash string
         * @return {Object} object of parsed key/value parameter pairs
         * @static
         */
        parseHash: function (hash) {
            var decode = HistoryHash.decode,
                i,
                len,
                match,
                matches,
                param,
                params = {},
                prefix = HistoryHash.hashPrefix,
                prefixIndex;

            hash = Lang.isValue(hash) ? hash : HistoryHash.getHash();

            if (prefix) {
                prefixIndex = hash.indexOf(prefix);

                if (prefixIndex === 0 || (prefixIndex === 1 && hash.charAt(0) === '#')) {
                    hash = hash.replace(prefix, '');
                }
            }

            matches = hash.match(HistoryHash._REGEX_HASH) || [];

            for (i = 0, len = matches.length; i < len; ++i) {
                match = matches[i];

                param = match.split('=');

                if (param.length > 1) {
                    params[decode(param[0])] = decode(param[1]);
                } else {
                    params[decode(match)] = '';
                }
            }

            return params;
        },

        /**
         * Replaces the browser's current location hash with the specified hash
         * and removes all forward navigation states, without creating a new browser
         * history entry. Automatically prepends the <code>hashPrefix</code> if one
         * is set.
         *
         * @method replaceHash
         * @param {String} hash new location hash
         * @static
         */
        replaceHash: function (hash) {
            var location = Y.getLocation(),
                base     = location.href.replace(/#.*$/, '');

            if (hash.charAt(0) === '#') {
                hash = hash.substring(1);
            }

            location.replace(base + '#' + (HistoryHash.hashPrefix || '') + hash);
        },

        /**
         * Sets the browser's location hash to the specified string. Automatically
         * prepends the <code>hashPrefix</code> if one is set.
         *
         * @method setHash
         * @param {String} hash new location hash
         * @static
         */
        setHash: function (hash) {
            var location = Y.getLocation();

            if (hash.charAt(0) === '#') {
                hash = hash.substring(1);
            }

            location.hash = (HistoryHash.hashPrefix || '') + hash;
        }
    });

    // -- Synthetic hashchange Event -----------------------------------------------

    // TODO: YUIDoc currently doesn't provide a good way to document synthetic DOM
    // events. For now, we're just documenting the hashchange event on the YUI
    // object, which is about the best we can do until enhancements are made to
    // YUIDoc.

    /**
    Synthetic <code>window.onhashchange</code> event that normalizes differences
    across browsers and provides support for browsers that don't natively support
    <code>onhashchange</code>.

    This event is provided by the <code>history-hash</code> module.

    @example

        YUI().use('history-hash', function (Y) {
          Y.on('hashchange', function (e) {
            // Handle hashchange events on the current window.
          }, Y.config.win);
        });

    @event hashchange
    @param {EventFacade} e Event facade with the following additional
      properties:

    <dl>
      <dt>oldHash</dt>
      <dd>
        Previous hash fragment value before the change.
      </dd>

      <dt>oldUrl</dt>
      <dd>
        Previous URL (including the hash fragment) before the change.
      </dd>

      <dt>newHash</dt>
      <dd>
        New hash fragment value after the change.
      </dd>

      <dt>newUrl</dt>
      <dd>
        New URL (including the hash fragment) after the change.
      </dd>
    </dl>
    @for YUI
    @since 3.2.0
    **/

    var _historyHashEnvId = Y.config.win._YUI_HISTORY_HASH_ENVIRONMENT_ID;
    if (!_historyHashEnvId) {
        _historyHashEnvId = Y.guid();
        Y.config.win._YUI_HISTORY_HASH_ENVIRONMENT_ID = _historyHashEnvId;

        if (DEBUG) {
            console.log('Created the hash', _historyHashEnvId, ' for window', Y.config.win);
        }
    }

    globalHashNotifiersByWindow = GlobalEnv._notifiers;

    if (!globalHashNotifiersByWindow) {
        globalHashNotifiersByWindow = {};
        GlobalEnv._notifiers = globalHashNotifiersByWindow;
    }

    hashNotifiersForWindow = globalHashNotifiersByWindow[_historyHashEnvId];

    if (!hashNotifiersForWindow) {
        hashNotifiersForWindow = [];
        globalHashNotifiersByWindow[_historyHashEnvId] = hashNotifiersForWindow;
    }

    Y.Event.define('hashchange', {
        on: function (node, subscriber, notifier) {
            // Ignore this subscription if the node is anything other than the
            // window or document body, since those are the only elements that
            // should support the hashchange event. Note that the body could also be
            // a frameset, but that's okay since framesets support hashchange too.
            if (node.compareTo(win) || node.compareTo(Y.config.doc.body)) {
                hashNotifiersForWindow.push(notifier);
            }
        },

        detach: function (node, subscriber, notifier) {
            var index = YArray.indexOf(hashNotifiersForWindow, notifier);

            if (index !== -1) {
                hashNotifiersForWindow.splice(index, 1);
            }
        }
    });

    oldHash = HistoryHash.getHash();
    oldUrl  = HistoryHash.getUrl();

    if (HistoryBase.nativeHashChange) {
        // Wrap the browser's native hashchange event if there's not already a
        // global listener.
        if (!GlobalEnv._hashHandle) {
            GlobalEnv._hashHandle = {};
        }

        if (!GlobalEnv._hashHandle[_historyHashEnvId]) {
            GlobalEnv._hashHandle[_historyHashEnvId] = Y.Event.attach('hashchange', function (e) {
                var newHash = HistoryHash.getHash(),
                    newUrl  = HistoryHash.getUrl();

                // Iterate over a copy of the hashNotifiersForWindow array since a subscriber
                // could detach during iteration and cause the array to be re-indexed.
                YArray.each(hashNotifiersForWindow.concat(), function (notifier) {
                    notifier.fire({
                        _event : e,
                        oldHash: oldHash,
                        oldUrl : oldUrl,
                        newHash: newHash,
                        newUrl : newUrl
                    });
                });

                oldHash = newHash;
                oldUrl  = newUrl;
            }, win);
            
            if (DEBUG) {
                console.log('Binded hashchange event listener for ', _historyHashEnvId, ' on window', Y.config.win);
            }

            Y.on('beforeunload', function() {
                GlobalEnv._hashHandle[_historyHashEnvId].detach();
                GlobalEnv._hashHandle[_historyHashEnvId] = null;
                delete GlobalEnv._hashHandle[_historyHashEnvId];

                if (DEBUG) {
                    console.log('DETACHED hashchange event listener for ', _historyHashEnvId, ' on window', Y.config.win);
                }
            });
        }
    } else {
        if (!GlobalEnv._hashPoll) {
            GlobalEnv._hashPoll = {};
        }

        // Begin polling for location hash changes if there's not already a global
        // poll running.
        if (!GlobalEnv._hashPoll[_historyHashEnvId]) {
            GlobalEnv._hashPoll[_historyHashEnvId] = Y.later(50, null, function () {
                var newHash = HistoryHash.getHash(),
                    facade, newUrl;

                if (oldHash !== newHash) {
                    newUrl = HistoryHash.getUrl();

                    facade = {
                        oldHash: oldHash,
                        oldUrl : oldUrl,
                        newHash: newHash,
                        newUrl : newUrl
                    };

                    oldHash = newHash;
                    oldUrl  = newUrl;

                    YArray.each(hashNotifiersForWindow.concat(), function (notifier) {
                        notifier.fire(facade);
                    });
                }
            }, null, true);
            if (DEBUG) {
                console.log('Binded hashchange poller for ', _historyHashEnvId, ' on window', Y.config.win);
            }

            Y.on('beforeunload', function() {
                GlobalEnv._hashPoll[_historyHashEnvId].cancel();
                GlobalEnv._hashPoll[_historyHashEnvId] = null;
                delete GlobalEnv._hashPoll[_historyHashEnvId];

                if (DEBUG) {
                    console.log('DETACHED hashchange poller for ', _historyHashEnvId, ' on window', Y.config.win);
                }
            });
        }
    }

    Y.HistoryHash = HistoryHash;

    // HistoryHash will never win over HistoryHTML5 unless useHistoryHTML5 is false.
    if (useHistoryHTML5 === false || (!Y.History && useHistoryHTML5 !== true &&
            (!HistoryBase.html5 || !Y.HistoryHTML5))) {
        Y.History = HistoryHash;
    }


}, '3.17.2', {"requires": ["event-synthetic", "history-base", "yui-later", "squarespace-beforeunload"]});

})(YUI);


/***/ }),

/***/ 277200:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('history-html5', function (Y, NAME) {

/**
 * Provides browser history management using the HTML5 history API.
 *
 * @module history
 * @submodule history-html5
 * @since 3.2.0
 */

/**
 * <p>
 * Provides browser history management using the HTML5 history API.
 * </p>
 *
 * <p>
 * When calling the <code>add()</code>, <code>addValue()</code>,
 * <code>replace()</code>, or <code>replaceValue()</code> methods on
 * <code>HistoryHTML5</code>, the following additional options are supported:
 * </p>
 *
 * <dl>
 *   <dt><strong>title (String)</strong></dt>
 *   <dd>
 *     Title to use for the new history entry. Browsers will typically display
 *     this title to the user in the detailed history window or in a dropdown
 *     menu attached to the back/forward buttons. If not specified, the title
 *     of the current document will be used.
 *   </dd>
 *
 *   <dt><strong>url (String)</strong></dt>
 *   <dd>
 *     URL to display to the user for the new history entry. This URL will be
 *     visible in the browser's address bar and will be the bookmarked URL if
 *     the user bookmarks the page. It may be a relative path ("foo/bar"), an
 *     absolute path ("/foo/bar"), or a full URL ("http://example.com/foo/bar").
 *     If you specify a full URL, the origin <i>must</i> be the same as the
 *     origin of the current page, or an error will occur. If no URL is
 *     specified, the current URL will not be changed.
 *   </dd>
 * </dl>
 *
 * @class HistoryHTML5
 * @extends HistoryBase
 * @constructor
 * @param {Object} config (optional) Configuration object.
 */

var HistoryBase     = Y.HistoryBase,
    Lang            = Y.Lang,
    win             = Y.config.win,
    useHistoryHTML5 = Y.config.useHistoryHTML5,

    SRC_POPSTATE    = 'popstate',
    SRC_REPLACE     = HistoryBase.SRC_REPLACE;

function HistoryHTML5() {
    HistoryHTML5.superclass.constructor.apply(this, arguments);
}

Y.extend(HistoryHTML5, HistoryBase, {
    // -- Initialization -------------------------------------------------------
    _init: function (config) {
        var bookmarkedState;

        try {
            bookmarkedState = win.history.state;
        } catch(e) {
            bookmarkedState = null;
        }

        // Treat empty state objects as `null` so they're not processed further.
        if (Y.Object.isEmpty(bookmarkedState)) {
            bookmarkedState = null;
        }

        config || (config = {});

        // If both the initial state and the bookmarked state are objects, merge
        // them (bookmarked state wins).
        if (config.initialState
                && Lang.type(config.initialState) === 'object'
                && Lang.type(bookmarkedState) === 'object') {

            this._initialState = Y.merge(config.initialState, bookmarkedState);
        } else {
            // Otherwise, the bookmarked state always wins if there is one. If
            // there isn't a bookmarked state, history-base will take care of
            // falling back to config.initialState or null.
            this._initialState = bookmarkedState;
        }

        Y.on('popstate', this._onPopState, win, this);

        HistoryHTML5.superclass._init.apply(this, arguments);
    },

    // -- Protected Methods ----------------------------------------------------

    /**
     * Overrides HistoryBase's <code>_storeState()</code> and pushes or replaces
     * a history entry using the HTML5 history API when necessary.
     *
     * @method _storeState
     * @param {String} src Source of the changes.
     * @param {Object} newState New state to store.
     * @param {Object} options Zero or more options.
     * @protected
     */
    _storeState: function (src, newState, options) {
        if (src !== SRC_POPSTATE) {
            win.history[src === SRC_REPLACE ? 'replaceState' : 'pushState'](
                newState,
                options.title || Y.config.doc.title || '',
                options.url || Y.config.doc.URL
            );
        }

        HistoryHTML5.superclass._storeState.apply(this, arguments);
    },

    // -- Protected Event Handlers ---------------------------------------------

    /**
     * Handler for popstate events.
     *
     * @method _onPopState
     * @param {Event} e
     * @protected
     */
    _onPopState: function (e) {
        this._resolveChanges(SRC_POPSTATE, e._event.state || null);
    }
}, {
    // -- Public Static Properties ---------------------------------------------
    NAME: 'historyhtml5',

    /**
     * Constant used to identify state changes originating from
     * <code>popstate</code> events.
     *
     * @property SRC_POPSTATE
     * @type String
     * @static
     * @final
     */
    SRC_POPSTATE: SRC_POPSTATE
});

if (!Y.Node.DOM_EVENTS.popstate) {
    Y.Node.DOM_EVENTS.popstate = 1;
}

Y.HistoryHTML5 = HistoryHTML5;

/**
 * <p>
 * If <code>true</code>, the <code>Y.History</code> alias will always point to
 * <code>Y.HistoryHTML5</code> when the history-html5 module is loaded, even if
 * the current browser doesn't support HTML5 history.
 * </p>
 *
 * <p>
 * If <code>false</code>, the <code>Y.History</code> alias will always point to
 * <code>Y.HistoryHash</code> when the history-hash module is loaded, even if
 * the current browser supports HTML5 history.
 * </p>
 *
 * <p>
 * If neither <code>true</code> nor <code>false</code>, the
 * <code>Y.History</code> alias will point to the best available history adapter
 * that the browser supports. This is the default behavior.
 * </p>
 *
 * @property useHistoryHTML5
 * @type boolean
 * @for config
 * @since 3.2.0
 */

// HistoryHTML5 will always win over HistoryHash unless useHistoryHTML5 is false
// or HTML5 history is not supported.
if (useHistoryHTML5 === true || (useHistoryHTML5 !== false &&
        HistoryBase.html5)) {
    Y.History = HistoryHTML5;
}


}, '3.17.2', {"optional": ["json"], "requires": ["event-base", "history-base", "node-base"]});


/***/ }),

/***/ 474863:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('intl', function (Y, NAME) {

var _mods = {},

    ROOT_LANG = "yuiRootLang",
    ACTIVE_LANG = "yuiActiveLang",
    NONE = [];

/**
 * Provides utilities to support the management of localized resources (strings and formatting patterns).
 *
 * @module intl
 */

/**
 * The Intl utility provides a central location for managing sets of localized resources (strings and formatting patterns).
 *
 * @class Intl
 * @uses EventTarget
 * @static
 */
Y.mix(Y.namespace("Intl"), {

    /**
     * Private method to retrieve the language hash for a given module.
     *
     * @method _mod
     * @private
     *
     * @param {String} module The name of the module
     * @return {Object} The hash of localized resources for the module, keyed by BCP language tag
     */
    _mod : function(module) {
        if (!_mods[module]) {
            _mods[module] = {};
        }
        return _mods[module];
    },

    /**
     * Sets the active language for the given module.
     *
     * Returns false on failure, which would happen if the language had not been registered through the <a href="#method_add">add()</a> method.
     *
     * @method setLang
     *
     * @param {String} module The module name.
     * @param {String} lang The BCP 47 language tag.
     * @return boolean true if successful, false if not.
     */
    setLang : function(module, lang) {
        var langs = this._mod(module),
            currLang = langs[ACTIVE_LANG],
            exists = !!langs[lang];

        if (exists && lang !== currLang) {
            langs[ACTIVE_LANG] = lang;
            this.fire("intl:langChange", {module: module, prevVal: currLang, newVal: (lang === ROOT_LANG) ? "" : lang});
        }

        return exists;
    },

    /**
     * Get the currently active language for the given module.
     *
     * @method getLang
     *
     * @param {String} module The module name.
     * @return {String} The BCP 47 language tag.
     */
    getLang : function(module) {
        var lang = this._mod(module)[ACTIVE_LANG];
        return (lang === ROOT_LANG) ? "" : lang;
    },

    /**
     * Register a hash of localized resources for the given module and language
     *
     * @method add
     *
     * @param {String} module The module name.
     * @param {String} lang The BCP 47 language tag.
     * @param {Object} strings The hash of localized values, keyed by the string name.
     */
    add : function(module, lang, strings) {
        lang = lang || ROOT_LANG;
        this._mod(module)[lang] = strings;
        this.setLang(module, lang);
    },

    /**
     * Gets the module's localized resources for the currently active language (as provided by the <a href="#method_getLang">getLang</a> method).
     * <p>
     * Optionally, the localized resources for alternate languages which have been added to Intl (see the <a href="#method_add">add</a> method) can
     * be retrieved by providing the BCP 47 language tag as the lang parameter.
     * </p>
     * @method get
     *
     * @param {String} module The module name.
     * @param {String} key Optional. A single resource key. If not provided, returns a copy (shallow clone) of all resources.
     * @param {String} lang Optional. The BCP 47 language tag. If not provided, the module's currently active language is used.
     * @return String | Object A copy of the module's localized resources, or a single value if key is provided.
     */
    get : function(module, key, lang) {
        var mod = this._mod(module),
            strs;

        lang = lang || mod[ACTIVE_LANG];
        strs = mod[lang] || {};

        return (key) ? strs[key] : Y.merge(strs);
    },

    /**
     * Gets the list of languages for which localized resources are available for a given module, based on the module
     * meta-data (part of loader). If loader is not on the page, returns an empty array.
     *
     * @method getAvailableLangs
     * @param {String} module The name of the module
     * @return {Array} The array of languages available.
     */
    getAvailableLangs : function(module) {
        var loader = Y.Env._loader,
            mod = loader && loader.moduleInfo[module],
            langs = mod && mod.lang;
        return (langs) ? langs.concat() : NONE;

    }
});

Y.augment(Y.Intl, Y.EventTarget);

/**
 * Notification event to indicate when the lang for a module has changed. There is no default behavior associated with this event,
 * so the on and after moments are equivalent.
 *
 * @event intl:langChange
 * @param {EventFacade} e The event facade
 * <p>The event facade contains:</p>
 * <dl>
 *     <dt>module</dt><dd>The name of the module for which the language changed</dd>
 *     <dt>newVal</dt><dd>The new language tag</dd>
 *     <dt>prevVal</dt><dd>The current language tag</dd>
 * </dl>
 */
Y.Intl.publish("intl:langChange", {emitFacade:true});


}, '3.17.2', {"requires": ["intl-base", "event-custom"]});


/***/ }),

/***/ 918916:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('io-base', function (Y, NAME) {

/**
Base IO functionality. Provides basic XHR transport support.

@module io
@submodule io-base
@for IO
**/

var // List of events that comprise the IO event lifecycle.
    EVENTS = ['start', 'complete', 'end', 'success', 'failure', 'progress'],

    // Whitelist of used XHR response object properties.
    XHR_PROPS = ['status', 'statusText', 'responseText', 'responseXML'],

    win = Y.config.win,
    uid = 0;

/**
The IO class is a utility that brokers HTTP requests through a simplified
interface.  Specifically, it allows JavaScript to make HTTP requests to
a resource without a page reload.  The underlying transport for making
same-domain requests is the XMLHttpRequest object.  IO can also use
Flash, if specified as a transport, for cross-domain requests.

@class IO
@constructor
@param {Object} config Object of EventTarget's publish method configurations
                    used to configure IO's events.
**/
function IO (config) {
    var io = this;

    io._uid = 'io:' + uid++;
    io._init(config);
    Y.io._map[io._uid] = io;
}

IO.prototype = {
    //--------------------------------------
    //  Properties
    //--------------------------------------

   /**
    * A counter that increments for each transaction.
    *
    * @property _id
    * @private
    * @type {Number}
    */
    _id: 0,

   /**
    * Object of IO HTTP headers sent with each transaction.
    *
    * @property _headers
    * @private
    * @type {Object}
    */
    _headers: {
        'X-Requested-With' : 'XMLHttpRequest'
    },

   /**
    * Object that stores timeout values for any transaction with a defined
    * "timeout" configuration property.
    *
    * @property _timeout
    * @private
    * @type {Object}
    */
    _timeout: {},

    //--------------------------------------
    //  Methods
    //--------------------------------------

    _init: function(config) {
        var io = this, i, len;

        io.cfg = config || {};

        Y.augment(io, Y.EventTarget);
        for (i = 0, len = EVENTS.length; i < len; ++i) {
            // Publish IO global events with configurations, if any.
            // IO global events are set to broadcast by default.
            // These events use the "io:" namespace.
            io.publish('io:' + EVENTS[i], Y.merge({ broadcast: 1 }, config));
            // Publish IO transaction events with configurations, if
            // any.  These events use the "io-trn:" namespace.
            io.publish('io-trn:' + EVENTS[i], config);
        }
    },

   /**
    * Method that creates a unique transaction object for each request.
    *
    * @method _create
    * @private
    * @param {Object} cfg Configuration object subset to determine if
    *                 the transaction is an XDR or file upload,
    *                 requiring an alternate transport.
    * @param {Number} id Transaction id
    * @return {Object} The transaction object
    */
    _create: function(config, id) {
        var io = this,
            transaction = {
                id : Y.Lang.isNumber(id) ? id : io._id++,
                uid: io._uid
            },
            alt = config.xdr ? config.xdr.use : null,
            form = config.form && config.form.upload ? 'iframe' : null,
            use;

        if (alt === 'native') {
            // Non-IE and IE >= 10  can use XHR level 2 and not rely on an
            // external transport.
            alt = Y.UA.ie && !SUPPORTS_CORS ? 'xdr' : null;

            // Prevent "pre-flight" OPTIONS request by removing the
            // `X-Requested-With` HTTP header from CORS requests. This header
            // can be added back on a per-request basis, if desired.
            io.setHeader('X-Requested-With');
        }

        use = alt || form;
        transaction = use ? Y.merge(Y.IO.customTransport(use), transaction) :
                            Y.merge(Y.IO.defaultTransport(), transaction);

        if (transaction.notify) {
            config.notify = function (e, t, c) { io.notify(e, t, c); };
        }

        if (!use) {
            if (win && win.FormData && config.data instanceof win.FormData) {
                transaction.c.upload.onprogress = function (e) {
                    io.progress(transaction, e, config);
                };
                transaction.c.onload = function (e) {
                    io.load(transaction, e, config);
                };
                transaction.c.onerror = function (e) {
                    io.error(transaction, e, config);
                };
                transaction.upload = true;
            }
        }

        return transaction;
    },

    _destroy: function(transaction) {
        if (win && !transaction.notify && !transaction.xdr) {
            if (XHR && !transaction.upload) {
                transaction.c.onreadystatechange = null;
            } else if (transaction.upload) {
                transaction.c.upload.onprogress = null;
                transaction.c.onload = null;
                transaction.c.onerror = null;
            } else if (Y.UA.ie && !transaction.e) {
                // IE, when using XMLHttpRequest as an ActiveX Object, will throw
                // a "Type Mismatch" error if the event handler is set to "null".
                transaction.c.abort();
            }
        }

        transaction = transaction.c = null;
    },

   /**
    * Method for creating and firing events.
    *
    * @method _evt
    * @private
    * @param {String} eventName Event to be published.
    * @param {Object} transaction Transaction object.
    * @param {Object} config Configuration data subset for event subscription.
    */
    _evt: function(eventName, transaction, config) {
        var io          = this, params,
            args        = config['arguments'],
            emitFacade  = io.cfg.emitFacade,
            globalEvent = "io:" + eventName,
            trnEvent    = "io-trn:" + eventName;

        // Workaround for #2532107
        this.detach(trnEvent);

        if (transaction.e) {
            transaction.c = { status: 0, statusText: transaction.e };
        }

        // Fire event with parameters or an Event Facade.
        params = [ emitFacade ?
            {
                id: transaction.id,
                data: transaction.c,
                cfg: config,
                'arguments': args
            } :
            transaction.id
        ];

        if (!emitFacade) {
            if (eventName === EVENTS[0] || eventName === EVENTS[2]) {
                if (args) {
                    params.push(args);
                }
            } else {
                if (transaction.evt) {
                    params.push(transaction.evt);
                } else {
                    params.push(transaction.c);
                }
                if (args) {
                    params.push(args);
                }
            }
        }

        params.unshift(globalEvent);
        // Fire global events.
        io.fire.apply(io, params);
        // Fire transaction events, if receivers are defined.
        if (config.on) {
            params[0] = trnEvent;
            io.once(trnEvent, config.on[eventName], config.context || Y);
            io.fire.apply(io, params);
        }
    },

   /**
    * Fires event "io:start" and creates, fires a transaction-specific
    * start event, if `config.on.start` is defined.
    *
    * @method start
    * @param {Object} transaction Transaction object.
    * @param {Object} config Configuration object for the transaction.
    */
    start: function(transaction, config) {
       /**
        * Signals the start of an IO request.
        * @event io:start
        */
        this._evt(EVENTS[0], transaction, config);
    },

   /**
    * Fires event "io:complete" and creates, fires a
    * transaction-specific "complete" event, if config.on.complete is
    * defined.
    *
    * @method complete
    * @param {Object} transaction Transaction object.
    * @param {Object} config Configuration object for the transaction.
    */
    complete: function(transaction, config) {
       /**
        * Signals the completion of the request-response phase of a
        * transaction. Response status and data are accessible, if
        * available, in this event.
        * @event io:complete
        */
        this._evt(EVENTS[1], transaction, config);
    },

   /**
    * Fires event "io:end" and creates, fires a transaction-specific "end"
    * event, if config.on.end is defined.
    *
    * @method end
    * @param {Object} transaction Transaction object.
    * @param {Object} config Configuration object for the transaction.
    */
    end: function(transaction, config) {
       /**
        * Signals the end of the transaction lifecycle.
        * @event io:end
        */
        this._evt(EVENTS[2], transaction, config);
        this._destroy(transaction);
    },

   /**
    * Fires event "io:success" and creates, fires a transaction-specific
    * "success" event, if config.on.success is defined.
    *
    * @method success
    * @param {Object} transaction Transaction object.
    * @param {Object} config Configuration object for the transaction.
    */
    success: function(transaction, config) {
       /**
        * Signals an HTTP response with status in the 2xx range.
        * Fires after io:complete.
        * @event io:success
        */
        this._evt(EVENTS[3], transaction, config);
        this.end(transaction, config);
    },

   /**
    * Fires event "io:failure" and creates, fires a transaction-specific
    * "failure" event, if config.on.failure is defined.
    *
    * @method failure
    * @param {Object} transaction Transaction object.
    * @param {Object} config Configuration object for the transaction.
    */
    failure: function(transaction, config) {
       /**
        * Signals an HTTP response with status outside of the 2xx range.
        * Fires after io:complete.
        * @event io:failure
        */
        this._evt(EVENTS[4], transaction, config);
        this.end(transaction, config);
    },

   /**
    * Fires event "io:progress" and creates, fires a transaction-specific
    * "progress" event -- for XMLHttpRequest file upload -- if
    * config.on.progress is defined.
    *
    * @method progress
    * @param {Object} transaction Transaction object.
    * @param {Object} progress event.
    * @param {Object} config Configuration object for the transaction.
    */
    progress: function(transaction, e, config) {
       /**
        * Signals the interactive state during a file upload transaction.
        * This event fires after io:start and before io:complete.
        * @event io:progress
        */
        transaction.evt = e;
        this._evt(EVENTS[5], transaction, config);
    },

   /**
    * Fires event "io:complete" and creates, fires a transaction-specific
    * "complete" event -- for XMLHttpRequest file upload -- if
    * config.on.complete is defined.
    *
    * @method load
    * @param {Object} transaction Transaction object.
    * @param {Object} load event.
    * @param {Object} config Configuration object for the transaction.
    */
    load: function (transaction, e, config) {
        transaction.evt = e.target;
        this._evt(EVENTS[1], transaction, config);
    },

   /**
    * Fires event "io:failure" and creates, fires a transaction-specific
    * "failure" event -- for XMLHttpRequest file upload -- if
    * config.on.failure is defined.
    *
    * @method error
    * @param {Object} transaction Transaction object.
    * @param {Object} error event.
    * @param {Object} config Configuration object for the transaction.
    */
    error: function (transaction, e, config) {
        transaction.evt = e;
        this._evt(EVENTS[4], transaction, config);
    },

   /**
    * Retry an XDR transaction, using the Flash tranport, if the native
    * transport fails.
    *
    * @method _retry
    * @private
    * @param {Object} transaction Transaction object.
    * @param {String} uri Qualified path to transaction resource.
    * @param {Object} config Configuration object for the transaction.
    */
    _retry: function(transaction, uri, config) {
        this._destroy(transaction);
        config.xdr.use = 'flash';
        return this.send(uri, config, transaction.id);
    },

   /**
    * Method that concatenates string data for HTTP GET transactions.
    *
    * @method _concat
    * @private
    * @param {String} uri URI or root data.
    * @param {String} data Data to be concatenated onto URI.
    * @return {String}
    */
    _concat: function(uri, data) {
        uri += (uri.indexOf('?') === -1 ? '?' : '&') + data;
        return uri;
    },

   /**
    * Stores default client headers for all transactions. If a label is
    * passed with no value argument, the header will be deleted.
    *
    * @method setHeader
    * @param {String} name HTTP header
    * @param {String} value HTTP header value
    */
    setHeader: function(name, value) {
        if (value) {
            this._headers[name] = value;
        } else {
            delete this._headers[name];
        }
    },

   /**
    * Method that sets all HTTP headers to be sent in a transaction.
    *
    * @method _setHeaders
    * @private
    * @param {Object} transaction - XHR instance for the specific transaction.
    * @param {Object} headers - HTTP headers for the specific transaction, as
    *                    defined in the configuration object passed to YUI.io().
    */
    _setHeaders: function(transaction, headers) {
        headers = Y.merge(this._headers, headers);
        Y.Object.each(headers, function(value, name) {
            if (value !== 'disable') {
                transaction.setRequestHeader(name, headers[name]);
            }
        });
    },

   /**
    * Starts timeout count if the configuration object has a defined
    * timeout property.
    *
    * @method _startTimeout
    * @private
    * @param {Object} transaction Transaction object generated by _create().
    * @param {Object} timeout Timeout in milliseconds.
    */
    _startTimeout: function(transaction, timeout) {
        var io = this;

        io._timeout[transaction.id] = setTimeout(function() {
            io._abort(transaction, 'timeout');
        }, timeout);
    },

   /**
    * Clears the timeout interval started by _startTimeout().
    *
    * @method _clearTimeout
    * @private
    * @param {Number} id - Transaction id.
    */
    _clearTimeout: function(id) {
        clearTimeout(this._timeout[id]);
        delete this._timeout[id];
    },

   /**
    * Method that determines if a transaction response qualifies as success
    * or failure, based on the response HTTP status code, and fires the
    * appropriate success or failure events.
    *
    * @method _result
    * @private
    * @static
    * @param {Object} transaction Transaction object generated by _create().
    * @param {Object} config Configuration object passed to io().
    */
    _result: function(transaction, config) {
        var status;
        // Firefox will throw an exception if attempting to access
        // an XHR object's status property, after a request is aborted.
        try {
            status = transaction.c.status;
        } catch(e) {
            status = 0;
        }

        // IE reports HTTP 204 as HTTP 1223.
        if (status >= 200 && status < 300 || status === 304 || status === 1223) {
            this.success(transaction, config);
        } else {
            this.failure(transaction, config);
        }
    },

   /**
    * Event handler bound to onreadystatechange.
    *
    * @method _rS
    * @private
    * @param {Object} transaction Transaction object generated by _create().
    * @param {Object} config Configuration object passed to YUI.io().
    */
    _rS: function(transaction, config) {
        var io = this;

        if (transaction.c.readyState === 4) {
            if (config.timeout) {
                io._clearTimeout(transaction.id);
            }

            // Yield in the event of request timeout or abort.
            setTimeout(function() {
                io.complete(transaction, config);
                io._result(transaction, config);
            }, 0);
        }
    },

   /**
    * Terminates a transaction due to an explicit abort or timeout.
    *
    * @method _abort
    * @private
    * @param {Object} transaction Transaction object generated by _create().
    * @param {String} type Identifies timed out or aborted transaction.
    */
    _abort: function(transaction, type) {
        if (transaction && transaction.c) {
            transaction.e = type;
            transaction.c.abort();
        }
    },

   /**
    * Requests a transaction. `send()` is implemented as `Y.io()`.  Each
    * transaction may include a configuration object.  Its properties are:
    *
    * <dl>
    *   <dt>method</dt>
    *     <dd>HTTP method verb (e.g., GET or POST). If this property is not
    *         not defined, the default value will be GET.</dd>
    *
    *   <dt>data</dt>
    *     <dd>This is the name-value string that will be sent as the
    *     transaction data. If the request is HTTP GET, the data become
    *     part of querystring. If HTTP POST, the data are sent in the
    *     message body.</dd>
    *
    *   <dt>xdr</dt>
    *     <dd>Defines the transport to be used for cross-domain requests.
    *     By setting this property, the transaction will use the specified
    *     transport instead of XMLHttpRequest. The properties of the
    *     transport object are:
    *     <dl>
    *       <dt>use</dt>
    *         <dd>The transport to be used: 'flash' or 'native'</dd>
    *       <dt>dataType</dt>
    *         <dd>Set the value to 'XML' if that is the expected response
    *         content type.</dd>
    *       <dt>credentials</dt>
    *         <dd>Set the value to 'true' to set XHR.withCredentials property to true.</dd>
    *     </dl></dd>
    *
    *   <dt>form</dt>
    *     <dd>Form serialization configuration object.  Its properties are:
    *     <dl>
    *       <dt>id</dt>
    *         <dd>Node object or id of HTML form</dd>
    *       <dt>useDisabled</dt>
    *         <dd>`true` to also serialize disabled form field values
    *         (defaults to `false`)</dd>
    *     </dl></dd>
    *
    *   <dt>on</dt>
    *     <dd>Assigns transaction event subscriptions. Available events are:
    *     <dl>
    *       <dt>start</dt>
    *         <dd>Fires when a request is sent to a resource.</dd>
    *       <dt>complete</dt>
    *         <dd>Fires when the transaction is complete.</dd>
    *       <dt>success</dt>
    *         <dd>Fires when the HTTP response status is within the 2xx
    *         range.</dd>
    *       <dt>failure</dt>
    *         <dd>Fires when the HTTP response status is outside the 2xx
    *         range, if an exception occurs, if the transation is aborted,
    *         or if the transaction exceeds a configured `timeout`.</dd>
    *       <dt>end</dt>
    *         <dd>Fires at the conclusion of the transaction
    *            lifecycle, after `success` or `failure`.</dd>
    *     </dl>
    *
    *     <p>Callback functions for `start` and `end` receive the id of the
    *     transaction as a first argument. For `complete`, `success`, and
    *     `failure`, callbacks receive the id and the response object
    *     (usually the XMLHttpRequest instance).  If the `arguments`
    *     property was included in the configuration object passed to
    *     `Y.io()`, the configured data will be passed to all callbacks as
    *     the last argument.</p>
    *     </dd>
    *
    *   <dt>sync</dt>
    *     <dd>Pass `true` to make a same-domain transaction synchronous.
    *     <strong>CAVEAT</strong>: This will negatively impact the user
    *     experience. Have a <em>very</em> good reason if you intend to use
    *     this.</dd>
    *
    *   <dt>context</dt>
    *     <dd>The "`this'" object for all configured event handlers. If a
    *     specific context is needed for individual callbacks, bind the
    *     callback to a context using `Y.bind()`.</dd>
    *
    *   <dt>headers</dt>
    *     <dd>Object map of transaction headers to send to the server. The
    *     object keys are the header names and the values are the header
    *     values.</dd>
    *
    *   <dt>username</dt>
    *     <dd>Username to use in a HTTP authentication.</dd>
    *
    *   <dt>password</dt>
    *     <dd>Password to use in a HTTP authentication.</dd>
    *
    *   <dt>timeout</dt>
    *     <dd>Millisecond threshold for the transaction before being
    *     automatically aborted.</dd>
    *
    *   <dt>arguments</dt>
    *     <dd>User-defined data passed to all registered event handlers.
    *     This value is available as the second argument in the "start" and
    *     "end" event handlers. It is the third argument in the "complete",
    *     "success", and "failure" event handlers. <strong>Be sure to quote
    *     this property name in the transaction configuration as
    *     "arguments" is a reserved word in JavaScript</strong> (e.g.
    *     `Y.io({ ..., "arguments": stuff })`).</dd>
    * </dl>
    *
    * @method send
    * @public
    * @param {String} uri Qualified path to transaction resource.
    * @param {Object} config Configuration object for the transaction.
    * @param {Number} id Transaction id, if already set.
    * @return {Object}
    */
    send: function(uri, config, id) {
        var transaction, method, i, len, sync, data,
            io = this,
            u = uri,
            response = {};

        config = config ? Y.Object(config) : {};
        transaction = io._create(config, id);
        method = config.method ? config.method.toUpperCase() : 'GET';
        sync = config.sync;
        data = config.data;

        // Serialize a map object into a key-value string using
        // querystring-stringify-simple.
        if ((Y.Lang.isObject(data) && !data.nodeType) && !transaction.upload) {
            if (Y.QueryString && Y.QueryString.stringify) {
                config.data = data = Y.QueryString.stringify(data);
            } else {
            }
        }

        if (config.form) {
            if (config.form.upload) {
                // This is a file upload transaction, calling
                // upload() in io-upload-iframe.
                return io.upload(transaction, uri, config);
            } else {
                // Serialize HTML form data into a key-value string.
                data = io._serialize(config.form, data);
            }
        }

        // Convert falsy values to an empty string. This way IE can't be
        // rediculous and translate `undefined` to "undefined".
        data || (data = '');

        if (data) {
            switch (method) {
                case 'GET':
                case 'HEAD':
                case 'DELETE':
                    u = io._concat(u, data);
                    data = '';
                    break;
                case 'POST':
                case 'PUT':
                    // If Content-Type is defined in the configuration object, or
                    // or as a default header, it will be used instead of
                    // 'application/x-www-form-urlencoded; charset=UTF-8'
                    config.headers = Y.merge({
                        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
                    }, config.headers);
                    break;
            }
        }

        if (transaction.xdr) {
            // Route data to io-xdr module for flash and XDomainRequest.
            return io.xdr(u, transaction, config);
        }
        else if (transaction.notify) {
            // Route data to custom transport
            return transaction.c.send(transaction, uri, config);
        }

        if (!sync && !transaction.upload) {
            transaction.c.onreadystatechange = function() {
                io._rS(transaction, config);
            };
        }

        try {
            // Determine if request is to be set as
            // synchronous or asynchronous.
            transaction.c.open(method, u, !sync, config.username || null, config.password || null);
            io._setHeaders(transaction.c, config.headers || {});
            io.start(transaction, config);

            // Will work only in browsers that implement the
            // Cross-Origin Resource Sharing draft.
            if (config.xdr && config.xdr.credentials && SUPPORTS_CORS) {
                transaction.c.withCredentials = true;
            }

            // Using "null" with HTTP POST will result in a request
            // with no Content-Length header defined.
            transaction.c.send(data);

            if (sync) {
                // Create a response object for synchronous transactions,
                // mixing id and arguments properties with the xhr
                // properties whitelist.
                for (i = 0, len = XHR_PROPS.length; i < len; ++i) {
                    response[XHR_PROPS[i]] = transaction.c[XHR_PROPS[i]];
                }

                response.getAllResponseHeaders = function() {
                    return transaction.c.getAllResponseHeaders();
                };

                response.getResponseHeader = function(name) {
                    return transaction.c.getResponseHeader(name);
                };

                io.complete(transaction, config);
                io._result(transaction, config);

                return response;
            }
        } catch(e) {
            if (transaction.xdr) {
                // This exception is usually thrown by browsers
                // that do not support XMLHttpRequest Level 2.
                // Retry the request with the XDR transport set
                // to 'flash'.  If the Flash transport is not
                // initialized or available, the transaction
                // will resolve to a transport error.
                return io._retry(transaction, uri, config);
            } else {
                io.complete(transaction, config);
                io._result(transaction, config);
            }
        }

        // If config.timeout is defined, and the request is standard XHR,
        // initialize timeout polling.
        if (config.timeout) {
            io._startTimeout(transaction, config.timeout);
        }

        return {
            id: transaction.id,
            abort: function() {
                return transaction.c ? io._abort(transaction, 'abort') : false;
            },
            isInProgress: function() {
                return transaction.c ? (transaction.c.readyState % 4) : false;
            },
            io: io
        };
    }
};

/**
Method for initiating an ajax call.  The first argument is the url end
point for the call.  The second argument is an object to configure the
transaction and attach event subscriptions.  The configuration object
supports the following properties:

<dl>
  <dt>method</dt>
    <dd>HTTP method verb (e.g., GET or POST). If this property is not
        not defined, the default value will be GET.</dd>

  <dt>data</dt>
    <dd>This is the name-value string that will be sent as the
    transaction data. If the request is HTTP GET, the data become
    part of querystring. If HTTP POST, the data are sent in the
    message body.</dd>

  <dt>xdr</dt>
    <dd>Defines the transport to be used for cross-domain requests.
    By setting this property, the transaction will use the specified
    transport instead of XMLHttpRequest. The properties of the
    transport object are:
    <dl>
      <dt>use</dt>
        <dd>The transport to be used: 'flash' or 'native'</dd>
      <dt>dataType</dt>
        <dd>Set the value to 'XML' if that is the expected response
        content type.</dd>
    </dl></dd>

  <dt>form</dt>
    <dd>Form serialization configuration object.  Its properties are:
    <dl>
      <dt>id</dt>
        <dd>Node object or id of HTML form</dd>
      <dt>useDisabled</dt>
        <dd>`true` to also serialize disabled form field values
        (defaults to `false`)</dd>
    </dl></dd>

  <dt>on</dt>
    <dd>Assigns transaction event subscriptions. Available events are:
    <dl>
      <dt>start</dt>
        <dd>Fires when a request is sent to a resource.</dd>
      <dt>complete</dt>
        <dd>Fires when the transaction is complete.</dd>
      <dt>success</dt>
        <dd>Fires when the HTTP response status is within the 2xx
        range.</dd>
      <dt>failure</dt>
        <dd>Fires when the HTTP response status is outside the 2xx
        range, if an exception occurs, if the transation is aborted,
        or if the transaction exceeds a configured `timeout`.</dd>
      <dt>end</dt>
        <dd>Fires at the conclusion of the transaction
           lifecycle, after `success` or `failure`.</dd>
    </dl>

    <p>Callback functions for `start` and `end` receive the id of the
    transaction as a first argument. For `complete`, `success`, and
    `failure`, callbacks receive the id and the response object
    (usually the XMLHttpRequest instance).  If the `arguments`
    property was included in the configuration object passed to
    `Y.io()`, the configured data will be passed to all callbacks as
    the last argument.</p>
    </dd>

  <dt>sync</dt>
    <dd>Pass `true` to make a same-domain transaction synchronous.
    <strong>CAVEAT</strong>: This will negatively impact the user
    experience. Have a <em>very</em> good reason if you intend to use
    this.</dd>

  <dt>context</dt>
    <dd>The "`this'" object for all configured event handlers. If a
    specific context is needed for individual callbacks, bind the
    callback to a context using `Y.bind()`.</dd>

  <dt>headers</dt>
    <dd>Object map of transaction headers to send to the server. The
    object keys are the header names and the values are the header
    values.</dd>

  <dt>timeout</dt>
    <dd>Millisecond threshold for the transaction before being
    automatically aborted.</dd>

  <dt>arguments</dt>
    <dd>User-defined data passed to all registered event handlers.
    This value is available as the second argument in the "start" and
    "end" event handlers. It is the third argument in the "complete",
    "success", and "failure" event handlers. <strong>Be sure to quote
    this property name in the transaction configuration as
    "arguments" is a reserved word in JavaScript</strong> (e.g.
    `Y.io({ ..., "arguments": stuff })`).</dd>
</dl>

@method io
@static
@param {String} url qualified path to transaction resource.
@param {Object} config configuration object for the transaction.
@return {Object}
@for YUI
**/
Y.io = function(url, config) {
    // Calling IO through the static interface will use and reuse
    // an instance of IO.
    var transaction = Y.io._map['io:0'] || new IO();
    return transaction.send.apply(transaction, [url, config]);
};

/**
Method for setting and deleting IO HTTP headers to be sent with every
request.

Hosted as a property on the `io` function (e.g. `Y.io.header`).

@method header
@param {String} name HTTP header
@param {String} value HTTP header value
@static
**/
Y.io.header = function(name, value) {
    // Calling IO through the static interface will use and reuse
    // an instance of IO.
    var transaction = Y.io._map['io:0'] || new IO();
    transaction.setHeader(name, value);
};

Y.IO = IO;
// Map of all IO instances created.
Y.io._map = {};
var XHR = win && win.XMLHttpRequest,
    XDR = win && win.XDomainRequest,
    AX = win && win.ActiveXObject,

    // Checks for the presence of the `withCredentials` in an XHR instance
    // object, which will be present if the environment supports CORS.
    SUPPORTS_CORS = XHR && 'withCredentials' in (new XMLHttpRequest());


Y.mix(Y.IO, {
    /**
    * The ID of the default IO transport, defaults to `xhr`
    * @property _default
    * @type {String}
    * @static
    */
    _default: 'xhr',
    /**
    *
    * @method defaultTransport
    * @static
    * @param {String} [id] The transport to set as the default, if empty a new transport is created.
    * @return {Object} The transport object with a `send` method
    */
    defaultTransport: function(id) {
        if (id) {
            Y.IO._default = id;
        } else {
            var o = {
                c: Y.IO.transports[Y.IO._default](),
                notify: Y.IO._default === 'xhr' ? false : true
            };
            return o;
        }
    },
    /**
    * An object hash of custom transports available to IO
    * @property transports
    * @type {Object}
    * @static
    */
    transports: {
        xhr: function () {
            return XHR ? new XMLHttpRequest() :
                AX ? new ActiveXObject('Microsoft.XMLHTTP') : null;
        },
        xdr: function () {
            return XDR ? new XDomainRequest() : null;
        },
        iframe: function () { return {}; },
        flash: null,
        nodejs: null
    },
    /**
    * Create a custom transport of type and return it's object
    * @method customTransport
    * @param {String} id The id of the transport to create.
    * @static
    */
    customTransport: function(id) {
        var o = { c: Y.IO.transports[id]() };

        o[(id === 'xdr' || id === 'flash') ? 'xdr' : 'notify'] = true;
        return o;
    }
});

Y.mix(Y.IO.prototype, {
    /**
    * Fired from the notify method of the transport which in turn fires
    * the event on the IO object.
    * @method notify
    * @param {String} event The name of the event
    * @param {Object} transaction The transaction object
    * @param {Object} config The configuration object for this transaction
    */
    notify: function(event, transaction, config) {
        var io = this;

        switch (event) {
            case 'timeout':
            case 'abort':
            case 'transport error':
                transaction.c = { status: 0, statusText: event };
                event = 'failure';
            default:
                io[event].apply(io, [transaction, config]);
        }
    }
});




}, '3.17.2', {"requires": ["event-custom-base", "querystring-stringify-simple"]});


/***/ }),

/***/ 479839:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('io-form', function (Y, NAME) {

/**
* Extends IO to enable HTML form data serialization, when specified
* in the transaction's configuration object.
* @module io
* @submodule io-form
* @for IO
*/

var eUC = encodeURIComponent;

/**
 * Enumerate through an HTML form's elements collection
 * and return a string comprised of key-value pairs.
 *
 * @method stringify
 * @static
 * @param {Node|String} form YUI form node or HTML form id
 * @param {Object} [options] Configuration options.
 * @param {Boolean} [options.useDisabled=false] Whether to include disabled fields.
 * @param {Object|String} [options.extra] Extra values to include. May be a query string or an object with key/value pairs.
 * @return {String}
 */
Y.IO.stringify = function(form, options) {
    options = options || {};

    var s = Y.IO.prototype._serialize({
        id: form,
        useDisabled: options.useDisabled
    },
    options.extra && typeof options.extra === 'object' ? Y.QueryString.stringify(options.extra) : options.extra);

    return s;
};

Y.mix(Y.IO.prototype, {
   /**
    * Enumerate through an HTML form's elements collection
    * and return a string comprised of key-value pairs.
    *
    * @method _serialize
    * @private
    * @param {Object} c
    * @param {String|Element} c.id YUI form node or HTML form id
    * @param {Boolean} c.useDisabled `true` to include disabled fields
    * @param {String} s Key-value data defined in the configuration object.
    * @return {String}
    */
    _serialize: function(c, s) {
        var data = [],
            df = c.useDisabled || false,
            item = 0,
            id = (typeof c.id === 'string') ? c.id : c.id.getAttribute('id'),
            e, f, n, v, d, i, il, j, jl, o;

        if (!id) {
            id = Y.guid('io:');
            c.id.setAttribute('id', id);
        }

        f = Y.config.doc.getElementById(id);

        if (!f || !f.elements) {
            return s || '';
        }

        // Iterate over the form elements collection to construct the
        // label-value pairs.
        for (i = 0, il = f.elements.length; i < il; ++i) {
            e = f.elements[i];
            d = e.disabled;
            n = e.name;

            if (df ? n : n && !d) {
                n = eUC(n) + '=';
                v = eUC(e.value);

                switch (e.type) {
                    // Safari, Opera, FF all default options.value from .text if
                    // value attribute not specified in markup
                    case 'select-one':
                        if (e.selectedIndex > -1) {
                            o = e.options[e.selectedIndex];
                            data[item++] = n + eUC(o.attributes.value && o.attributes.value.specified ? o.value : o.text);
                        }
                        break;
                    case 'select-multiple':
                        if (e.selectedIndex > -1) {
                            for (j = e.selectedIndex, jl = e.options.length; j < jl; ++j) {
                                o = e.options[j];
                                if (o.selected) {
                                  data[item++] = n + eUC(o.attributes.value && o.attributes.value.specified ? o.value : o.text);
                                }
                            }
                        }
                        break;
                    case 'radio':
                    case 'checkbox':
                        if (e.checked) {
                            data[item++] = n + v;
                        }
                        break;
                    case 'file':
                        // stub case as XMLHttpRequest will only send the file path as a string.
                    case undefined:
                        // stub case for fieldset element which returns undefined.
                    case 'reset':
                        // stub case for input type reset button.
                    case 'button':
                        // stub case for input type button elements.
                        break;
                    case 'submit':
                    default:
                        data[item++] = n + v;
                }
            }
        }

        if (s) {
            data[item++] = s;
        }

        return data.join('&');
    }
}, true);


}, '3.17.2', {"requires": ["io-base", "node-base"]});


/***/ }),

/***/ 821303:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('io-queue', function (Y, NAME) {

/**
Extends IO to implement Queue for synchronous
transaction processing.
@module io
@submodule io-queue
@for IO
**/
var io = Y.io._map['io:0'] || new Y.IO();

Y.mix(Y.IO.prototype, {
   /**
    * Array of transactions queued for processing
    *
    * @property _q
    * @private
    * @static
    * @type {Object}
    */
    _q: new Y.Queue(),
    _qActiveId: null,
    _qInit: false,

   /**
    * Property to determine whether the queue is set to
    * 1 (active) or 0 (inactive).  When inactive, transactions
    * will be stored in the queue until the queue is set to active.
    *
    * @property _qState
    * @private
    * @static
    * @type {Number}
    */
    _qState: 1,

   /**
    * Method Process the first transaction from the
    * queue in FIFO order.
    *
    * @method _qShift
    * @private
    * @static
    */
    _qShift: function() {
        var io = this,
            o = io._q.next();

        io._qActiveId = o.id;
        io._qState = 0;
        io.send(o.uri, o.cfg, o.id);
    },

   /**
    * Method for queueing a transaction before the request is sent to the
    * resource, to ensure sequential processing.
    *
    * @method queue
    * @static
    * @return {Object}
    */
    queue: function(uri, c) {
        var io = this,
            o = { uri: uri, cfg:c, id: this._id++ };

        if(!io._qInit) {
            Y.on('io:complete', function(id, o) { io._qNext(id); }, io);
            io._qInit = true;
        }

        io._q.add(o);
        if (io._qState === 1) {
            io._qShift();
        }

        return o;
    },

    _qNext: function(id) {
        var io = this;
        io._qState = 1;
        if (io._qActiveId === id && io._q.size() > 0) {
            io._qShift();
        }
    },

   /**
    * Method for promoting a transaction to the top of the queue.
    *
    * @method promote
    * @static
    */
    qPromote: function(o) {
        this._q.promote(o);
    },

   /**
    * Method for removing a specific, pending transaction from
    * the queue.
    *
    * @method remove
    * @private
    * @static
    */
    qRemove: function(o) {
        this._q.remove(o);
    },

   /**
    * Method for cancel all pending transaction from
    * the queue.
    *
    * @method empty
    * @static
    * @since 3.7.3
    */
    qEmpty: function() {
        this._q = new Y.Queue();
    },

    qStart: function() {
        var io = this;
        io._qState = 1;

        if (io._q.size() > 0) {
            io._qShift();
        }
    },

   /**
    * Method for setting queue processing to inactive.
    * Transaction requests to YUI.io.queue() will be stored in the queue, but
    * not processed until the queue is reset to "active".
    *
    * @method _stop
    * @private
    * @static
    */
    qStop: function() {
        this._qState = 0;
    },

   /**
    * Method to query the current size of the queue.
    *
    * @method _size
    * @private
    * @static
    * @return {Number}
    */
    qSize: function() {
        return this._q.size();
    }

}, true);

function _queue(u, c) {
    return io.queue.apply(io, [u, c]);
}

_queue.start = function () { io.qStart(); };
_queue.stop = function () { io.qStop(); };
_queue.promote = function (o) { io.qPromote(o); };
_queue.remove = function (o) { io.qRemove(o); };
_queue.size = function () { io.qSize(); };
_queue.empty = function () { io.qEmpty(); };
Y.io.queue = _queue;


}, '3.17.2', {"requires": ["io-base", "queue-promote"]});


/***/ }),

/***/ 343140:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('io-upload-iframe', function (Y, NAME) {

/**
Extends the IO  to enable file uploads, with HTML forms
using an iframe as the transport medium.
@module io
@submodule io-upload-iframe
@for IO
**/

var w = Y.config.win,
    d = Y.config.doc,
    _std = (d.documentMode && d.documentMode >= 8),
    _d = decodeURIComponent,
    _end = Y.IO.prototype.end;

/**
 * Creates the iframe transported used in file upload
 * transactions, and binds the response event handler.
 *
 * @method _cFrame
 * @private
 * @param {Object} o Transaction object generated by _create().
 * @param {Object} c Configuration object passed to YUI.io().
 * @param {Object} io
 */
function _cFrame(o, c, io) {
    var i = Y.Node.create('<iframe id="io_iframe' + o.id + '" name="io_iframe' + o.id + '" />');
        i._node.style.position = 'absolute';
        i._node.style.top = '-1000px';
        i._node.style.left = '-1000px';
        Y.one('body').appendChild(i);
    // Bind the onload handler to the iframe to detect the file upload response.
    Y.on("load", function() { io._uploadComplete(o, c); }, '#io_iframe' + o.id);
}

/**
 * Removes the iframe transport used in the file upload
 * transaction.
 *
 * @method _dFrame
 * @private
 * @param {Number} id The transaction ID used in the iframe's creation.
 */
function _dFrame(id) {
	Y.Event.purgeElement('#io_iframe' + id, false);
	Y.one('body').removeChild(Y.one('#io_iframe' + id));
}

Y.mix(Y.IO.prototype, {
   /**
    * Parses the POST data object and creates hidden form elements
    * for each key-value, and appends them to the HTML form object.
    * @method _addData
    * @private
    * @static
    * @param {Object} f HTML form object.
    * @param {String} s The key-value POST data.
    * @return {Array} o Array of created fields.
    */
    _addData: function(f, s) {
        // Serialize an object into a key-value string using
        // querystring-stringify-simple.
        if (Y.Lang.isObject(s)) {
            s = Y.QueryString.stringify(s);
        }

        var o = [],
            m = s.split('='),
            i, l;

        for (i = 0, l = m.length - 1; i < l; i++) {
            o[i] = d.createElement('input');
            o[i].type = 'hidden';
            o[i].name = _d(m[i].substring(m[i].lastIndexOf('&') + 1));
            o[i].value = (i + 1 === l) ? _d(m[i + 1]) : _d(m[i + 1].substring(0, (m[i + 1].lastIndexOf('&'))));
            f.appendChild(o[i]);
        }

        return o;
    },

   /**
    * Removes the custom fields created to pass additional POST
    * data, along with the HTML form fields.
    * @method _removeData
    * @private
    * @static
    * @param {Object} f HTML form object.
    * @param {Object} o HTML form fields created from configuration.data.
    */
    _removeData: function(f, o) {
        var i, l;

        for (i = 0, l = o.length; i < l; i++) {
            f.removeChild(o[i]);
        }
    },

   /**
    * Sets the appropriate attributes and values to the HTML
    * form, in preparation of a file upload transaction.
    * @method _setAttrs
    * @private
    * @static
    * @param {Object} f HTML form object.
    * @param {Object} id The Transaction ID.
    * @param {Object} uri Qualified path to transaction resource.
    */
    _setAttrs: function(f, id, uri) {
        // Track original HTML form attribute values.
        this._originalFormAttrs = {
            action: f.getAttribute('action'),
            target: f.getAttribute('target')
        };

        f.setAttribute('action', uri);
        f.setAttribute('method', 'POST');
        f.setAttribute('target', 'io_iframe' + id );
        f.setAttribute(Y.UA.ie && !_std ? 'encoding' : 'enctype', 'multipart/form-data');
    },

   /**
    * Reset the HTML form attributes to their original values.
    * @method _resetAttrs
    * @private
    * @static
    * @param {Object} f HTML form object.
    * @param {Object} a Object of original attributes.
    */
    _resetAttrs: function(f, a) {
        Y.Object.each(a, function(v, p) {
            if (v) {
                f.setAttribute(p, v);
            }
            else {
                f.removeAttribute(p);
            }
        });
    },

   /**
    * Starts timeout count if the configuration object
    * has a defined timeout property.
    *
    * @method _startUploadTimeout
    * @private
    * @static
    * @param {Object} o Transaction object generated by _create().
    * @param {Object} c Configuration object passed to YUI.io().
    */
    _startUploadTimeout: function(o, c) {
        var io = this;

        io._timeout[o.id] = w.setTimeout(
            function() {
                o.status = 0;
                o.statusText = 'timeout';
                io.complete(o, c);
                io.end(o, c);
            }, c.timeout);
    },

   /**
    * Clears the timeout interval started by _startUploadTimeout().
    * @method _clearUploadTimeout
    * @private
    * @static
    * @param {Number} id - Transaction ID.
    */
    _clearUploadTimeout: function(id) {
        var io = this;

        w.clearTimeout(io._timeout[id]);
        delete io._timeout[id];
    },

   /**
    * Bound to the iframe's Load event and processes
    * the response data.
    * @method _uploadComplete
    * @private
    * @static
    * @param {Object} o The transaction object
    * @param {Object} c Configuration object for the transaction.
    */
    _uploadComplete: function(o, c) {
        var io = this,
            d = Y.one('#io_iframe' + o.id).get('contentWindow.document'),
            b = d.one('body'),
            p;

        if (c.timeout) {
            io._clearUploadTimeout(o.id);
        }

		try {
			if (b) {
				// When a response Content-Type of "text/plain" is used, Firefox and Safari
				// will wrap the response string with <pre></pre>.
				p = b.one('pre:first-child');
				o.c.responseText = p ? p.get('text') : b.get('text');
			}
			else {
				o.c.responseXML = d._node;
			}
		}
		catch (e) {
			o.e = "upload failure";
		}

        io.complete(o, c);
        io.end(o, c);
        // The transaction is complete, so call _dFrame to remove
        // the event listener bound to the iframe transport, and then
        // destroy the iframe.
        w.setTimeout( function() { _dFrame(o.id); }, 0);
    },

   /**
    * Uploads HTML form data, inclusive of files/attachments,
    * using the iframe created in _create to facilitate the transaction.
    * @method _upload
    * @private
    * @static
    * @param {Object} o The transaction object
    * @param {Object} uri Qualified path to transaction resource.
    * @param {Object} c Configuration object for the transaction.
    */
    _upload: function(o, uri, c) {
        var io = this,
            f = (typeof c.form.id === 'string') ? d.getElementById(c.form.id) : c.form.id,
            fields;

        // Initialize the HTML form properties in case they are
        // not defined in the HTML form.
        io._setAttrs(f, o.id, uri);
        if (c.data) {
            fields = io._addData(f, c.data);
        }

        // Start polling if a callback is present and the timeout
        // property has been defined.
        if (c.timeout) {
            io._startUploadTimeout(o, c);
        }

        // Start file upload.
        f.submit();
        io.start(o, c);
        if (c.data) {
            io._removeData(f, fields);
        }

        return {
            id: o.id,
            abort: function() {
                o.status = 0;
                o.statusText = 'abort';
                if (Y.one('#io_iframe' + o.id)) {
                    _dFrame(o.id);
                    io.complete(o, c);
                    io.end(o, c);
                }
                else {
                    return false;
                }
            },
            isInProgress: function() {
                return Y.one('#io_iframe' + o.id) ? true : false;
            },
            io: io
        };
    },

    upload: function(o, uri, c) {
        _cFrame(o, c, this);
        return this._upload(o, uri, c);
    },

    end: function(transaction, config) {
        var form, io;

        if (config) {
            form = config.form;

            if (form && form.upload) {
                io = this;

                // Restore HTML form attributes to their original values.
                form = (typeof form.id === 'string') ? d.getElementById(form.id) : form.id;

                // Check whether the form still exists before resetting it.
                if (form) {
                    io._resetAttrs(form, this._originalFormAttrs);
                }
            }
        }

        return _end.call(this, transaction, config);
    }
}, true);


}, '3.17.2', {"requires": ["io-base", "node-base"]});


/***/ }),

/***/ 480149:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('io-xdr', function (Y, NAME) {

/**
Extends IO to provide an alternate, Flash transport, for making
cross-domain requests.
@module io
@submodule io-xdr
@for IO
@deprecated
**/

// Helpful resources when working with the mess that is XDomainRequest:
// http://www.cypressnorth.com/blog/web-programming-and-development/internet-explorer-aborting-ajax-requests-fixed/
// http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx

/**
Fires when the XDR transport is ready for use.
@event io:xdrReady
**/
var E_XDR_READY = Y.publish('io:xdrReady', { fireOnce: true }),

/**
Map of stored configuration objects when using
Flash as the transport for cross-domain requests.

@property _cB
@private
@type {Object}
**/
_cB = {},

/**
Map of transaction simulated readyState values
when XDomainRequest is the transport.

@property _rS
@private
@type {Object}
**/
_rS = {},

// Document reference
d = Y.config.doc,
// Window reference
w = Y.config.win,
// XDomainRequest cross-origin request detection
xdr = w && w.XDomainRequest;

/**
Method that creates the Flash transport swf.

@method _swf
@private
@param {String} uri - location of io.swf.
@param {String} yid - YUI sandbox id.
@param {String} uid - IO instance id.
**/
function _swf(uri, yid, uid) {
    var o = '<object id="io_swf" type="application/x-shockwave-flash" data="' +
            uri + '" width="0" height="0">' +
            '<param name="movie" value="' + uri + '">' +
            '<param name="FlashVars" value="yid=' + yid + '&uid=' + uid + '">' +
            '<param name="allowScriptAccess" value="always">' +
            '</object>',
        c = d.createElement('div');

    d.body.appendChild(c);
    c.innerHTML = o;
}

/**
Creates a response object for XDR transactions, for success
and failure cases.

@method _data
@private
@param {Object} o - Transaction object generated by _create() in io-base.
@param {Boolean} u - Configuration xdr.use.
@param {Boolean} d - Configuration xdr.dataType.

@return {Object}
**/
function _data(o, u, d) {
    if (u === 'flash') {
        o.c.responseText = decodeURI(o.c.responseText);
    }
    if (d === 'xml') {
        o.c.responseXML = Y.DataType.XML.parse(o.c.responseText);
    }

    return o;
}

/**
Method for intiating an XDR transaction abort.

@method _abort
@private
@param {Object} o - Transaction object generated by _create() in io-base.
@param {Object} c - configuration object for the transaction.
**/
function _abort(o, c) {
    return o.c.abort(o.id, c);
}

/**
Method for determining if an XDR transaction has completed
and all data are received.

@method _isInProgress
@private
@param {Object} o - Transaction object generated by _create() in io-base.
**/
function _isInProgress(o) {
    return xdr ? _rS[o.id] !== 4 : o.c.isInProgress(o.id);
}

Y.mix(Y.IO.prototype, {

    /**
    Map of io transports.

    @property _transport
    @private
    @type {Object}
    **/
    _transport: {},

    /**
    Sets event handlers for XDomainRequest transactions.

    @method _ieEvt
    @private
    @static
    @param {Object} o - Transaction object generated by _create() in io-base.
    @param {Object} c - configuration object for the transaction.
    **/
    _ieEvt: function(o, c) {
        var io = this,
            i = o.id,
            t = 'timeout';

        o.c.onprogress = function() { _rS[i] = 3; };
        o.c.onload = function() {
            _rS[i] = 4;
            io.xdrResponse('success', o, c);
        };
        o.c.onerror = function() {
            _rS[i] = 4;
            io.xdrResponse('failure', o, c);
        };
        o.c.ontimeout = function() {
            _rS[i] = 4;
            io.xdrResponse(t, o, c);
        };
        o.c[t] = c[t] || 0;
    },

    /**
    Method for accessing the transport's interface for making a
    cross-domain transaction.

    @method xdr
    @param {String} uri - qualified path to transaction resource.
    @param {Object} o - Transaction object generated by _create() in io-base.
    @param {Object} c - configuration object for the transaction.
    **/
    xdr: function(uri, o, c) {
        var io = this;

        if (c.xdr.use === 'flash') {
            // The configuration object cannot be serialized safely
            // across Flash's ExternalInterface.
            _cB[o.id] = c;
            w.setTimeout(function() {
                try {
                    o.c.send(uri, { id: o.id,
                                    uid: o.uid,
                                    method: c.method,
                                    data: c.data,
                                    headers: c.headers });
                }
                catch(e) {
                    io.xdrResponse('transport error', o, c);
                    delete _cB[o.id];
                }
            }, Y.io.xdr.delay);
        }
        else if (xdr) {
            io._ieEvt(o, c);
            o.c.open(c.method || 'GET', uri);

            // Make async to protect against IE 8 oddities.
            setTimeout(function() {
                o.c.send(c.data);
            }, 0);
        }
        else {
            o.c.send(uri, o, c);
        }

        return {
            id: o.id,
            abort: function() {
                return o.c ? _abort(o, c) : false;
            },
            isInProgress: function() {
                return o.c ? _isInProgress(o.id) : false;
            },
            io: io
        };
    },

    /**
    Response controller for cross-domain requests when using the
    Flash transport or IE8's XDomainRequest object.

    @method xdrResponse
    @param {String} e Event name
    @param {Object} o Transaction object generated by _create() in io-base.
    @param {Object} c Configuration object for the transaction.
    @return {Object}
    **/
    xdrResponse: function(e, o, c) {
        c = _cB[o.id] ? _cB[o.id] : c;
        var io = this,
            m = xdr ? _rS : _cB,
            u = c.xdr.use,
            d = c.xdr.dataType;

        switch (e) {
            case 'start':
                io.start(o, c);
                break;
           //case 'complete':
                //This case is not used by Flash or XDomainRequest.
                //io.complete(o, c);
                //break;
            case 'success':
                io.success(_data(o, u, d), c);
                delete m[o.id];
                break;
            case 'timeout':
            case 'abort':
            case 'transport error':
                o.c = { status: 0, statusText: e };
            case 'failure':
                io.failure(_data(o, u, d), c);
                delete m[o.id];
                break;
        }
    },

    /**
    Fires event "io:xdrReady"

    @method _xdrReady
    @private
    @param {Number} yid - YUI sandbox id.
    @param {Number} uid - IO instance id.
    **/
    _xdrReady: function(yid, uid) {
        Y.fire(E_XDR_READY, yid, uid);
    },

    /**
    Initializes the desired transport.

    @method transport
    @param {Object} o - object of transport configurations.
    **/
    transport: function(c) {
        if (c.id === 'flash') {
            _swf(Y.UA.ie ? c.src + '?d=' + new Date().valueOf().toString() : c.src, Y.id, c.uid);
            Y.IO.transports.flash = function() { return d.getElementById('io_swf'); };
        }
    }
});

/**
Fires event "io:xdrReady"

@method xdrReady
@protected
@static
@param {Number} yid - YUI sandbox id.
@param {Number} uid - IO instance id.
**/
Y.io.xdrReady = function(yid, uid){
    var io = Y.io._map[uid];
    Y.io.xdr.delay = 0;
    io._xdrReady.apply(io, [yid, uid]);
};

Y.io.xdrResponse = function(e, o, c){
    var io = Y.io._map[o.uid];
    io.xdrResponse.apply(io, [e, o, c]);
};

Y.io.transport = function(c){
    var io = Y.io._map['io:0'] || new Y.IO();
    c.uid = io._uid;
    io.transport.apply(io, [c]);
};

/**
Delay value to calling the Flash transport, in the
event io.swf has not finished loading.  Once the E_XDR_READY
event is fired, this value will be set to 0.

@property delay
@static
@type {Number}
**/
Y.io.xdr = { delay : 100 };


}, '3.17.2', {"requires": ["io-base", "datatype-xml-parse"]});


/***/ }),

/***/ 98315:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('json-parse', function (Y, NAME) {

var _JSON = Y.config.global.JSON;

Y.namespace('JSON').parse = function (obj, reviver, space) {
    return _JSON.parse((typeof obj === 'string' ? obj : obj + ''), reviver, space);
};


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 522353:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('json-stringify', function (Y, NAME) {

/**
 * Provides Y.JSON.stringify method for converting objects to JSON strings.
 *
 * @module json
 * @submodule json-stringify
 * @for JSON
 * @static
 */
var COLON     = ':',
    _JSON     = Y.config.global.JSON;

Y.mix(Y.namespace('JSON'), {
    /**
     * Serializes a Date instance as a UTC date string.  Used internally by
     * stringify.  Override this method if you need Dates serialized in a
     * different format.
     *
     * @method dateToString
     * @param d {Date} The Date to serialize
     * @return {String} stringified Date in UTC format YYYY-MM-DDTHH:mm:SSZ
     * @deprecated Use a replacer function
     * @static
     */
    dateToString: function (d) {
        function _zeroPad(v) {
            return v < 10 ? '0' + v : v;
        }

        return d.getUTCFullYear()           + '-' +
              _zeroPad(d.getUTCMonth() + 1) + '-' +
              _zeroPad(d.getUTCDate())      + 'T' +
              _zeroPad(d.getUTCHours())     + COLON +
              _zeroPad(d.getUTCMinutes())   + COLON +
              _zeroPad(d.getUTCSeconds())   + 'Z';
    },

    /**
     * <p>Converts an arbitrary value to a JSON string representation.</p>
     *
     * <p>Objects with cyclical references will trigger an exception.</p>
     *
     * <p>If a whitelist is provided, only matching object keys will be
     * included.  Alternately, a replacer function may be passed as the
     * second parameter.  This function is executed on every value in the
     * input, and its return value will be used in place of the original value.
     * This is useful to serialize specialized objects or class instances.</p>
     *
     * <p>If a positive integer or non-empty string is passed as the third
     * parameter, the output will be formatted with carriage returns and
     * indentation for readability.  If a String is passed (such as "\t") it
     * will be used once for each indentation level.  If a number is passed,
     * that number of spaces will be used.</p>
     *
     * @method stringify
     * @param o {MIXED} any arbitrary value to convert to JSON string
     * @param w {Array|Function} (optional) whitelist of acceptable object
     *                  keys to include, or a replacer function to modify the
     *                  raw value before serialization
     * @param ind {Number|String} (optional) indentation character or depth of
     *                  spaces to format the output.
     * @return {string} JSON string representation of the input
     * @static
     */
    stringify: function () {
        return _JSON.stringify.apply(_JSON, arguments);
    },

    /**
     * <p>Number of occurrences of a special character within a single call to
     * stringify that should trigger promotion of that character to a dedicated
     * preprocess step for future calls.  This is only used in environments
     * that don't support native JSON, or when useNativeJSONStringify is set to
     * false.</p>
     *
     * <p>So, if set to 50 and an object is passed to stringify that includes
     * strings containing the special character \x07 more than 50 times,
     * subsequent calls to stringify will process object strings through a
     * faster serialization path for \x07 before using the generic, slower,
     * replacement process for all special characters.</p>
     *
     * <p>To prime the preprocessor cache, set this value to 1, then call
     * <code>Y.JSON.stringify("<em>(all special characters to
     * cache)</em>");</code>, then return this setting to a more conservative
     * value.</p>
     *
     * <p>Special characters \ " \b \t \n \f \r are already cached.</p>
     *
     * @property charCacheThreshold
     * @static
     * @default 100
     * @type {Number}
     */
    charCacheThreshold: 100
});


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 614722:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('jsonp', function (Y, NAME) {

var isFunction = Y.Lang.isFunction;

/**
 * <p>Provides a JSONPRequest class for repeated JSONP calls, and a convenience
 * method Y.jsonp(url, callback) to instantiate and send a JSONP request.</p>
 *
 * <p>Both the constructor as well as the convenience function take two
 * parameters: a url string and a callback.</p>
 *
 * <p>The url provided must include the placeholder string
 * &quot;{callback}&quot; which will be replaced by a dynamically
 * generated routing function to pass the data to your callback function.
 * An example url might look like
 * &quot;http://example.com/service?callback={callback}&quot;.</p>
 *
 * <p>The second parameter can be a callback function that accepts the JSON
 * payload as its argument, or a configuration object supporting the keys:</p>
 * <ul>
 *   <li>on - map of callback subscribers
 *      <ul>
 *         <li>success - function handler for successful transmission</li>
 *         <li>failure - function handler for failed transmission</li>
 *         <li>timeout - function handler for transactions that timeout</li>
 *      </ul>
 *  </li>
 *  <li>format  - override function for inserting the proxy name in the url</li>
 *  <li>timeout - the number of milliseconds to wait before giving up</li>
 *  <li>context - becomes <code>this</code> in the callbacks</li>
 *  <li>args    - array of subsequent parameters to pass to the callbacks</li>
 *  <li>allowCache - use the same proxy name for all requests? (boolean)</li>
 * </ul>
 *
 * @module jsonp
 * @class JSONPRequest
 * @constructor
 * @param url {String} the url of the JSONP service
 * @param callback {Object|Function} the default callback configuration or
 *                                   success handler
 */
function JSONPRequest() {
    this._init.apply(this, arguments);
}

JSONPRequest.prototype = {
    /**
     * Set up the success and failure handlers and the regex pattern used
     * to insert the temporary callback name in the url.
     *
     * @method _init
     * @param url {String} the url of the JSONP service
     * @param callback {Object|Function} Optional success callback or config
     *                  object containing success and failure functions and
     *                  the url regex.
     * @protected
     */
    _init : function (url, callback) {
        this.url = url;

        /**
         * Map of the number of requests currently pending responses per
         * generated proxy.  Used to ensure the proxy is not flushed if the
         * request times out and there is a timeout handler and success
         * handler, and used by connections configured to allowCache to make
         * sure the proxy isn't deleted until the last response has returned.
         *
         * @property _requests
         * @private
         * @type {Object}
         */
        this._requests = {};

        /**
         * Map of the number of timeouts received from the destination url
         * by generated proxy.  Used to ensure the proxy is not flushed if the
         * request times out and there is a timeout handler and success
         * handler, and used by connections configured to allowCache to make
         * sure the proxy isn't deleted until the last response has returned.
         *
         * @property _timeouts
         * @private
         * @type {Object}
         */
        this._timeouts = {};

        // Accept a function, an object, or nothing
        callback = (isFunction(callback)) ?
            { on: { success: callback } } :
            callback || {};

        var subs = callback.on || {};

        if (!subs.success) {
            subs.success = this._defaultCallback(url, callback);
        }

        // Apply defaults and store
        this._config = Y.merge({
                context: this,
                args   : [],
                format : this._format,
                allowCache: false
            }, callback, { on: subs });
    },

    /**
     * Override this method to provide logic to default the success callback if
     * it is not provided at construction.  This is overridden by jsonp-url to
     * parse the callback from the url string.
     *
     * @method _defaultCallback
     * @param url {String} the url passed at construction
     * @param config {Object} (optional) the config object passed at
     *                        construction
     * @return {Function}
     */
    _defaultCallback: function () {},

    /**
     * Issues the JSONP request.
     *
     * @method send
     * @param args* {any} any additional arguments to pass to the url formatter
     *              beyond the base url and the proxy function name
     * @chainable
     */
    send : function () {
        var self   = this,
            args   = Y.Array(arguments, 0, true),
            config = self._config,
            proxy  = self._proxy || Y.guid(),
            url;

        // TODO: support allowCache as time value
        if (config.allowCache) {
            self._proxy = proxy;
        }

        if (self._requests[proxy] === undefined) {
            self._requests[proxy] = 0;
        }
        if (self._timeouts[proxy] === undefined) {
            self._timeouts[proxy] = 0;
        }
        self._requests[proxy]++;


        args.unshift(self.url, 'YUI.Env.JSONP.' + proxy);
        url = config.format.apply(self, args);

        if (!config.on.success) {
            return self;
        }

        function wrap(fn, isTimeout) {
            return (isFunction(fn)) ?
                function (data) {
                    var execute = true,
                        counter = '_requests';

                    //if (config.allowCache) {
                        // A lot of wrangling to make sure timeouts result in
                        // fewer success callbacks, but the proxy is properly
                        // cleaned up.
                        if (isTimeout) {
                            ++self._timeouts[proxy];
                            --self._requests[proxy];
                        } else {
                            if (!self._requests[proxy]) {
                                execute = false;
                                counter = '_timeouts';
                            }
                            --self[counter][proxy];
                        }
                    //}

                    if (!self._requests[proxy] && !self._timeouts[proxy]) {
                        delete YUI.Env.JSONP[proxy];
                    }

                    if (execute) {
                        fn.apply(config.context, [data].concat(config.args));
                    }
                } :
                null;
        }

        // Temporary un-sandboxed function alias
        // TODO: queuing
        YUI.Env.JSONP[proxy] = wrap(config.on.success);

        // Y.Get transactions block each other by design, but can easily
        //  be made non-blocking by just calling execute() on the transaction.
        // https://github.com/yui/yui3/pull/393#issuecomment-11961608
        Y.Get.js(url, {
            onFailure : wrap(config.on.failure),
            onTimeout : wrap(config.on.timeout, true),
            timeout   : config.timeout,
            charset   : config.charset,
            attributes: config.attributes,
            async     : config.async
        }).execute();

        return self;
    },

    /**
     * Default url formatter.  Looks for callback= in the url and appends it
     * if not present.  The supplied proxy name will be assigned to the query
     * param.  Override this method by passing a function as the
     * &quot;format&quot; property in the config object to the constructor.
     *
     * @method _format
     * @param url { String } the original url
     * @param proxy {String} the function name that will be used as a proxy to
     *      the configured callback methods.
     * @param args* {any} additional args passed to send()
     * @return {String} fully qualified JSONP url
     * @protected
     */
    _format: function (url, proxy) {
        return url.replace(/\{callback\}/, proxy);
    }
};

Y.JSONPRequest = JSONPRequest;

/**
 *
 * @method jsonp
 * @param url {String} the url of the JSONP service with the {callback}
 *          placeholder where the callback function name typically goes.
 * @param c {Function|Object} Callback function accepting the JSON payload
 *          as its argument, or a configuration object (see above).
 * @param args* {any} additional arguments to pass to send()
 * @return {JSONPRequest}
 * @static
 * @for YUI
 */
Y.jsonp = function (url,c) {
    var req = new Y.JSONPRequest(url,c);
    return req.send.apply(req, Y.Array(arguments, 2, true));
};

if (!YUI.Env.JSONP) {
    YUI.Env.JSONP = {};
}


}, '3.17.2', {"requires": ["get", "oop"]});


/***/ }),

/***/ 317375:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('node-base', function (Y, NAME) {

/**
 * @module node
 * @submodule node-base
 */

var methods = [
/**
 * Determines whether the node has the given className.
 * @method hasClass
 * @for Node
 * @param {String} className the class name to search for
 * @return {Boolean} Whether or not the node has the specified class
 */
 'hasClass',

/**
 * Adds a class name to the node.
 * @method addClass
 * @param {String} className the class name to add to the node's class attribute
 * @chainable
 */
 'addClass',

/**
 * Removes a class name from the node.
 * @method removeClass
 * @param {String} className the class name to remove from the node's class attribute
 * @chainable
 */
 'removeClass',

/**
 * Replace a class with another class on the node.
 * If no oldClassName is present, the newClassName is simply added.
 * @method replaceClass
 * @param {String} oldClassName the class name to be replaced
 * @param {String} newClassName the class name that will be replacing the old class name
 * @chainable
 */
 'replaceClass',

/**
 * If the className exists on the node it is removed, if it doesn't exist it is added.
 * @method toggleClass
 * @param {String} className the class name to be toggled
 * @param {Boolean} force Option to force adding or removing the class.
 * @chainable
 */
 'toggleClass'
];

Y.Node.importMethod(Y.DOM, methods);
/**
 * Determines whether each node has the given className.
 * @method hasClass
 * @see Node.hasClass
 * @for NodeList
 * @param {String} className the class name to search for
 * @return {Array} An array of booleans for each node bound to the NodeList.
 */

/**
 * Adds a class name to each node.
 * @method addClass
 * @see Node.addClass
 * @param {String} className the class name to add to each node's class attribute
 * @chainable
 */

/**
 * Removes a class name from each node.
 * @method removeClass
 * @see Node.removeClass
 * @param {String} className the class name to remove from each node's class attribute
 * @chainable
 */

/**
 * Replace a class with another class for each node.
 * If no oldClassName is present, the newClassName is simply added.
 * @method replaceClass
 * @see Node.replaceClass
 * @param {String} oldClassName the class name to be replaced
 * @param {String} newClassName the class name that will be replacing the old class name
 * @chainable
 */

/**
 * For each node, if the className exists on the node it is removed, if it doesn't exist it is added.
 * @method toggleClass
 * @see Node.toggleClass
 * @param {String} className the class name to be toggled
 * @chainable
 */
Y.NodeList.importMethod(Y.Node.prototype, methods);
/**
 * @module node
 * @submodule node-base
 */

var Y_Node = Y.Node,
    Y_DOM = Y.DOM;

/**
 * Returns a new dom node using the provided markup string.
 * @method create
 * @static
 * @param {String} html The markup used to create the element.
 * Use <a href="../classes/Escape.html#method_html">`Y.Escape.html()`</a>
 * to escape html content.
 * @param {HTMLDocument} doc An optional document context
 * @return {Node} A Node instance bound to a DOM node or fragment
 * @for Node
 */
Y_Node.create = function(html, doc) {
    if (doc && doc._node) {
        doc = doc._node;
    }
    return Y.one(Y_DOM.create(html, doc));
};

Y.mix(Y_Node.prototype, {
    /**
     * Creates a new Node using the provided markup string.
     * @method create
     * @param {String} html The markup used to create the element.
     * Use <a href="../classes/Escape.html#method_html">`Y.Escape.html()`</a>
     * to escape html content.
     * @param {HTMLDocument} doc An optional document context
     * @return {Node} A Node instance bound to a DOM node or fragment
     */
    create: Y_Node.create,

    /**
     * Inserts the content before the reference node.
     * @method insert
     * @param {String | Node | HTMLElement | NodeList | HTMLCollection} content The content to insert.
     * Use <a href="../classes/Escape.html#method_html">`Y.Escape.html()`</a>
     * to escape html content.
     * @param {Int | Node | HTMLElement | String} where The position to insert at.
     * Possible "where" arguments
     * <dl>
     * <dt>Y.Node</dt>
     * <dd>The Node to insert before</dd>
     * <dt>HTMLElement</dt>
     * <dd>The element to insert before</dd>
     * <dt>Int</dt>
     * <dd>The index of the child element to insert before</dd>
     * <dt>"replace"</dt>
     * <dd>Replaces the existing HTML</dd>
     * <dt>"before"</dt>
     * <dd>Inserts before the existing HTML</dd>
     * <dt>"before"</dt>
     * <dd>Inserts content before the node</dd>
     * <dt>"after"</dt>
     * <dd>Inserts content after the node</dd>
     * </dl>
     * @chainable
     */
    insert: function(content, where) {
        this._insert(content, where);
        return this;
    },

    _insert: function(content, where) {
        var node = this._node,
            ret = null;

        if (typeof where == 'number') { // allow index
            where = this._node.childNodes[where];
        } else if (where && where._node) { // Node
            where = where._node;
        }

        if (content && typeof content != 'string') { // allow Node or NodeList/Array instances
            content = content._node || content._nodes || content;
        }
        ret = Y_DOM.addHTML(node, content, where);

        return ret;
    },

    /**
     * Inserts the content as the firstChild of the node.
     * @method prepend
     * @param {String | Node | HTMLElement} content The content to insert.
     * Use <a href="../classes/Escape.html#method_html">`Y.Escape.html()`</a>
     * to escape html content.
     * @chainable
     */
    prepend: function(content) {
        return this.insert(content, 0);
    },

    /**
     * Inserts the content as the lastChild of the node.
     * @method append
     * @param {String | Node | HTMLElement} content The content to insert.
     * Use <a href="../classes/Escape.html#method_html">`Y.Escape.html()`</a>
     * to escape html content.
     * @chainable
     */
    append: function(content) {
        return this.insert(content, null);
    },

    /**
     * @method appendChild
     * @param {String | HTMLElement | Node} node Node to be appended.
     * Use <a href="../classes/Escape.html#method_html">`Y.Escape.html()`</a>
     * to escape html content.
     * @return {Node} The appended node
     */
    appendChild: function(node) {
        return Y_Node.scrubVal(this._insert(node));
    },

    /**
     * @method insertBefore
     * @param {String | HTMLElement | Node} newNode Node to be appended
     * @param {HTMLElement | Node} refNode Node to be inserted before.
     * Use <a href="../classes/Escape.html#method_html">`Y.Escape.html()`</a>
     * to escape html content.
     * @return {Node} The inserted node
     */
    insertBefore: function(newNode, refNode) {
        return Y.Node.scrubVal(this._insert(newNode, refNode));
    },

    /**
     * Appends the node to the given node.
     * @example
     *      // appendTo returns the node that has been created beforehand
     *      Y.Node.create('<p></p>').appendTo('body').set('text', 'hello world!');
     * @method appendTo
     * @param {Node | HTMLElement | String} node The node to append to.
     *  If `node` is a string it will be considered as a css selector and only the first matching node will be used.
     * @chainable
     */
    appendTo: function(node) {
        Y.one(node).append(this);
        return this;
    },
    
    // This method is deprecated, and is intentionally left undocumented.
    // Use `setHTML` instead.
    setContent: function(content) {
        this._insert(content, 'replace');
        return this;
    },
    
    // This method is deprecated, and is intentionally left undocumented.
    // Use `getHTML` instead.
    getContent: function() {
        var node = this;

        if (node._node.nodeType === 11) { // 11 === Node.DOCUMENT_FRAGMENT_NODE
            // "this", when it is a document fragment, must be cloned because
            // the nodes contained in the fragment actually disappear once
            // the fragment is appended anywhere
            node = node.create("<div/>").append(node.cloneNode(true));
        }

        return node.get("innerHTML");
    }
});

/**
 * Replaces the node's current html content with the content provided.
 * Note that this passes to innerHTML and is not escaped.
 * Use <a href="../classes/Escape.html#method_html">`Y.Escape.html()`</a>
 * to escape html content or `set('text')` to add as text.
 * @method setHTML
 * @param {String | Node | HTMLElement | NodeList | HTMLCollection} content The content to insert
 * @chainable
 */
Y.Node.prototype.setHTML = Y.Node.prototype.setContent;

/**
 * Returns the node's current html content (e.g. innerHTML)
 * @method getHTML
 * @return {String} The html content
 */
Y.Node.prototype.getHTML = Y.Node.prototype.getContent;

Y.NodeList.importMethod(Y.Node.prototype, [
    /**
     * Called on each Node instance
     * @for NodeList
     * @method append
     * @see Node.append
     */
    'append',

    /**
     * Called on each Node instance
     * @for NodeList
     * @method insert
     * @see Node.insert
     */
    'insert',

    /**
     * Called on each Node instance
     * @for NodeList
     * @method appendChild
     * @see Node.appendChild
     */
    'appendChild',

    /**
     * Called on each Node instance
     * @for NodeList
     * @method insertBefore
     * @see Node.insertBefore
     */
    'insertBefore',

    /**
     * Called on each Node instance
     * @for NodeList
     * @method prepend
     * @see Node.prepend
     */
    'prepend',

    'setContent',

    'getContent',

    /**
     * Called on each Node instance
     * Note that this passes to innerHTML and is not escaped.
     * Use <a href="../classes/Escape.html#method_html">`Y.Escape.html()`</a>
     * to escape html content or `set('text')` to add as text.
     * @for NodeList
     * @method setHTML
     * @see Node.setHTML
     */
    'setHTML',

    /**
     * Called on each Node instance
     * @for NodeList
     * @method getHTML
     * @see Node.getHTML
     */
    'getHTML'
]);
/**
 * @module node
 * @submodule node-base
 */

var Y_Node = Y.Node,
    Y_DOM = Y.DOM;

/**
 * Static collection of configuration attributes for special handling
 * @property ATTRS
 * @static
 * @type object
 */
Y_Node.ATTRS = {
    /**
     * Allows for getting and setting the text of an element.
     * Formatting is preserved and special characters are treated literally.
     * @config text
     * @type String
     */
    text: {
        getter: function() {
            return Y_DOM.getText(this._node);
        },

        setter: function(content) {
            Y_DOM.setText(this._node, content);
            return content;
        }
    },

    /**
     * Allows for getting and setting the text of an element.
     * Formatting is preserved and special characters are treated literally.
     * @config for
     * @type String
     */
    'for': {
        getter: function() {
            return Y_DOM.getAttribute(this._node, 'for');
        },

        setter: function(val) {
            Y_DOM.setAttribute(this._node, 'for', val);
            return val;
        }
    },

    'options': {
        getter: function() {
            return this._node.getElementsByTagName('option');
        }
    },

    /**
     * Returns a NodeList instance of all HTMLElement children.
     * @readOnly
     * @config children
     * @type NodeList
     */
    'children': {
        getter: function() {
            var node = this._node,
                children = node.children,
                childNodes, i, len;

            if (!children) {
                childNodes = node.childNodes;
                children = [];

                for (i = 0, len = childNodes.length; i < len; ++i) {
                    if (childNodes[i].tagName) {
                        children[children.length] = childNodes[i];
                    }
                }
            }
            return Y.all(children);
        }
    },

    value: {
        getter: function() {
            return Y_DOM.getValue(this._node);
        },

        setter: function(val) {
            Y_DOM.setValue(this._node, val);
            return val;
        }
    }
};

Y.Node.importMethod(Y.DOM, [
    /**
     * Allows setting attributes on DOM nodes, normalizing in some cases.
     * This passes through to the DOM node, allowing for custom attributes.
     * @method setAttribute
     * @for Node
     * @for NodeList
     * @chainable
     * @param {string} name The attribute name
     * @param {string} value The value to set
     */
    'setAttribute',
    /**
     * Allows getting attributes on DOM nodes, normalizing in some cases.
     * This passes through to the DOM node, allowing for custom attributes.
     * @method getAttribute
     * @for Node
     * @for NodeList
     * @param {string} name The attribute name
     * @return {string} The attribute value
     */
    'getAttribute'

]);
/**
 * @module node
 * @submodule node-base
 */

var Y_Node = Y.Node;
var Y_NodeList = Y.NodeList;
/**
 * List of events that route to DOM events
 * @static
 * @property DOM_EVENTS
 * @for Node
 */

Y_Node.DOM_EVENTS = {
    abort: 1,
    beforeunload: 1,
    blur: 1,
    change: 1,
    click: 1,
    close: 1,
    command: 1,
    contextmenu: 1,
    copy: 1,
    cut: 1,
    dblclick: 1,
    DOMMouseScroll: 1,
    drag: 1,
    dragstart: 1,
    dragenter: 1,
    dragover: 1,
    dragleave: 1,
    dragend: 1,
    drop: 1,
    error: 1,
    focus: 1,
    key: 1,
    keydown: 1,
    keypress: 1,
    keyup: 1,
    load: 1,
    message: 1,
    mousedown: 1,
    mouseenter: 1,
    mouseleave: 1,
    mousemove: 1,
    mousemultiwheel: 1,
    mouseout: 1,
    mouseover: 1,
    mouseup: 1,
    mousewheel: 1,
    orientationchange: 1,
    paste: 1,
    reset: 1,
    resize: 1,
    select: 1,
    selectstart: 1,
    submit: 1,
    scroll: 1,
    textInput: 1,
    unload: 1,
    invalid: 1
};

// Add custom event adaptors to this list.  This will make it so
// that delegate, key, available, contentready, etc all will
// be available through Node.on
Y.mix(Y_Node.DOM_EVENTS, Y.Env.evt.plugins);

Y.augment(Y_Node, Y.EventTarget);

Y.mix(Y_Node.prototype, {
    /**
     * Removes event listeners from the node and (optionally) its subtree
     * @method purge
     * @param {Boolean} recurse (optional) Whether or not to remove listeners from the
     * node's subtree
     * @param {String} type (optional) Only remove listeners of the specified type
     * @chainable
     *
     */
    purge: function(recurse, type) {
        Y.Event.purgeElement(this._node, recurse, type);
        return this;
    }

});

Y.mix(Y.NodeList.prototype, {
    _prepEvtArgs: function(type, fn, context) {
        // map to Y.on/after signature (type, fn, nodes, context, arg1, arg2, etc)
        var args = Y.Array(arguments, 0, true);

        if (args.length < 2) { // type only (event hash) just add nodes
            args[2] = this._nodes;
        } else {
            args.splice(2, 0, this._nodes);
        }

        args[3] = context || this; // default to NodeList instance as context

        return args;
    },

    /**
    Subscribe a callback function for each `Node` in the collection to execute
    in response to a DOM event.

    NOTE: Generally, the `on()` method should be avoided on `NodeLists`, in
    favor of using event delegation from a parent Node.  See the Event user
    guide for details.

    Most DOM events are associated with a preventable default behavior, such as
    link clicks navigating to a new page.  Callbacks are passed a
    `DOMEventFacade` object as their first argument (usually called `e`) that
    can be used to prevent this default behavior with `e.preventDefault()`. See
    the `DOMEventFacade` API for all available properties and methods on the
    object.

    By default, the `this` object will be the `NodeList` that the subscription
    came from, <em>not the `Node` that received the event</em>.  Use
    `e.currentTarget` to refer to the `Node`.

    Returning `false` from a callback is supported as an alternative to calling
    `e.preventDefault(); e.stopPropagation();`.  However, it is recommended to
    use the event methods.

    @example

        Y.all(".sku").on("keydown", function (e) {
            if (e.keyCode === 13) {
                e.preventDefault();

                // Use e.currentTarget to refer to the individual Node
                var item = Y.MyApp.searchInventory( e.currentTarget.get('value') );
                // etc ...
            }
        });

    @method on
    @param {String} type The name of the event
    @param {Function} fn The callback to execute in response to the event
    @param {Object} [context] Override `this` object in callback
    @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
    @return {EventHandle} A subscription handle capable of detaching that
                          subscription
    @for NodeList
    **/
    on: function(type, fn, context) {
        return Y.on.apply(Y, this._prepEvtArgs.apply(this, arguments));
    },

    /**
     * Applies an one-time event listener to each Node bound to the NodeList.
     * @method once
     * @param {String} type The event being listened for
     * @param {Function} fn The handler to call when the event fires
     * @param {Object} context The context to call the handler with.
     * Default is the NodeList instance.
     * @return {EventHandle} A subscription handle capable of detaching that
     *                    subscription
     * @for NodeList
     */
    once: function(type, fn, context) {
        return Y.once.apply(Y, this._prepEvtArgs.apply(this, arguments));
    },

    /**
     * Applies an event listener to each Node bound to the NodeList.
     * The handler is called only after all on() handlers are called
     * and the event is not prevented.
     * @method after
     * @param {String} type The event being listened for
     * @param {Function} fn The handler to call when the event fires
     * @param {Object} context The context to call the handler with.
     * Default is the NodeList instance.
     * @return {EventHandle} A subscription handle capable of detaching that
     *                    subscription
     * @for NodeList
     */
    after: function(type, fn, context) {
        return Y.after.apply(Y, this._prepEvtArgs.apply(this, arguments));
    },

    /**
     * Applies an one-time event listener to each Node bound to the NodeList
     * that will be called only after all on() handlers are called and the
     * event is not prevented.
     *
     * @method onceAfter
     * @param {String} type The event being listened for
     * @param {Function} fn The handler to call when the event fires
     * @param {Object} context The context to call the handler with.
     * Default is the NodeList instance.
     * @return {EventHandle} A subscription handle capable of detaching that
     *                    subscription
     * @for NodeList
     */
    onceAfter: function(type, fn, context) {
        return Y.onceAfter.apply(Y, this._prepEvtArgs.apply(this, arguments));
    }
});

Y_NodeList.importMethod(Y.Node.prototype, [
    /**
      * Called on each Node instance
      * @method detach
      * @see Node.detach
      * @for NodeList
      */
    'detach',

    /** Called on each Node instance
      * @method detachAll
      * @see Node.detachAll
      * @for NodeList
      */
    'detachAll'
]);

/**
Subscribe a callback function to execute in response to a DOM event or custom
event.

Most DOM events are associated with a preventable default behavior such as
link clicks navigating to a new page.  Callbacks are passed a `DOMEventFacade`
object as their first argument (usually called `e`) that can be used to
prevent this default behavior with `e.preventDefault()`. See the
`DOMEventFacade` API for all available properties and methods on the object.

If the event name passed as the first parameter is not a whitelisted DOM event,
it will be treated as a custom event subscriptions, allowing
`node.fire('customEventName')` later in the code.  Refer to the Event user guide
for the full DOM event whitelist.

By default, the `this` object in the callback will refer to the subscribed
`Node`.

Returning `false` from a callback is supported as an alternative to calling
`e.preventDefault(); e.stopPropagation();`.  However, it is recommended to use
the event methods.

@example

    Y.one("#my-form").on("submit", function (e) {
        e.preventDefault();

        // proceed with ajax form submission instead...
    });

@method on
@param {String} type The name of the event
@param {Function} fn The callback to execute in response to the event
@param {Object} [context] Override `this` object in callback
@param {Any} [arg*] 0..n additional arguments to supply to the subscriber
@return {EventHandle} A subscription handle capable of detaching that
                      subscription
@for Node
**/

Y.mix(Y.Node.ATTRS, {
    offsetHeight: {
        setter: function(h) {
            Y.DOM.setHeight(this._node, h);
            return h;
        },

        getter: function() {
            return this._node.offsetHeight;
        }
    },

    offsetWidth: {
        setter: function(w) {
            Y.DOM.setWidth(this._node, w);
            return w;
        },

        getter: function() {
            return this._node.offsetWidth;
        }
    }
});

Y.mix(Y.Node.prototype, {
    sizeTo: function(w, h) {
        var node;
        if (arguments.length < 2) {
            node = Y.one(w);
            w = node.get('offsetWidth');
            h = node.get('offsetHeight');
        }

        this.setAttrs({
            offsetWidth: w,
            offsetHeight: h
        });
    }
});

if (!Y.config.doc.documentElement.hasAttribute) { // IE < 8
    Y.Node.prototype.hasAttribute = function(attr) {
        if (attr === 'value') {
            if (this.get('value') !== "") { // IE < 8 fails to populate specified when set in HTML
                return true;
            }
        }
        return !!(this._node.attributes[attr] &&
                this._node.attributes[attr].specified);
    };
}

// IE throws an error when calling focus() on an element that's invisible, not
// displayed, or disabled.
Y.Node.prototype.focus = function () {
    try {
        this._node.focus();
    } catch (e) {
    }

    return this;
};

// IE throws error when setting input.type = 'hidden',
// input.setAttribute('type', 'hidden') and input.attributes.type.value = 'hidden'
Y.Node.ATTRS.type = {
    setter: function(val) {
        if (val === 'hidden') {
            try {
                this._node.type = 'hidden';
            } catch(e) {
                this._node.style.display = 'none';
                this._inputType = 'hidden';
            }
        } else {
            try { // IE errors when changing the type from "hidden'
                this._node.type = val;
            } catch (e) {
            }
        }
        return val;
    },

    getter: function() {
        return this._inputType || this._node.type;
    },

    _bypassProxy: true // don't update DOM when using with Attribute
};

if (Y.config.doc.createElement('form').elements.nodeType) {
    // IE: elements collection is also FORM node which trips up scrubVal.
    Y.Node.ATTRS.elements = {
            getter: function() {
                return this.all('input, textarea, button, select');
            }
    };
}
/**
 * Provides methods for managing custom Node data.
 *
 * @module node
 * @main node
 * @submodule node-data
 */

Y.mix(Y.Node.prototype, {
    _initData: function() {
        if (! ('_data' in this)) {
            this._data = {};
        }
    },

    /**
    * @method getData
    * @for Node
    * @description Retrieves arbitrary data stored on a Node instance.
    * If no data is associated with the Node, it will attempt to retrieve
    * a value from the corresponding HTML data attribute. (e.g. node.getData('foo')
    * will check node.getAttribute('data-foo')).
    * @param {string} name Optional name of the data field to retrieve.
    * If no name is given, all data is returned.
    * @return {any | Object} Whatever is stored at the given field,
    * or an object hash of all fields.
    */
    getData: function(name) {
        this._initData();
        var data = this._data,
            ret = data;

        if (arguments.length) { // single field
            if (name in data) {
                ret = data[name];
            } else { // initialize from HTML attribute
                ret = this._getDataAttribute(name);
            }
        } else if (typeof data == 'object' && data !== null) { // all fields
            ret = {};
            Y.Object.each(data, function(v, n) {
                ret[n] = v;
            });

            ret = this._getDataAttributes(ret);
        }

        return ret;

    },

    _getDataAttributes: function(ret) {
        ret = ret || {};
        var i = 0,
            attrs = this._node.attributes,
            len = attrs.length,
            prefix = this.DATA_PREFIX,
            prefixLength = prefix.length,
            name;

        while (i < len) {
            name = attrs[i].name;
            if (name.indexOf(prefix) === 0) {
                name = name.substr(prefixLength);
                if (!(name in ret)) { // only merge if not already stored
                    ret[name] = this._getDataAttribute(name);
                }
            }

            i += 1;
        }

        return ret;
    },

    _getDataAttribute: function(name) {
        name = this.DATA_PREFIX + name;

        var node = this._node,
            attrs = node.attributes,
            data = attrs && attrs[name] && attrs[name].value;

        return data;
    },

    /**
    * @method setData
    * @for Node
    * @description Stores arbitrary data on a Node instance.
    * This is not stored with the DOM node.
    * @param {string} name The name of the field to set. If no val
    * is given, name is treated as the data and overrides any existing data.
    * @param {any} val The value to be assigned to the field.
    * @chainable
    */
    setData: function(name, val) {
        this._initData();
        if (arguments.length > 1) {
            this._data[name] = val;
        } else {
            this._data = name;
        }

       return this;
    },

    /**
    * @method clearData
    * @for Node
    * @description Clears internally stored data.
    * @param {string} name The name of the field to clear. If no name
    * is given, all data is cleared.
    * @chainable
    */
    clearData: function(name) {
        if ('_data' in this) {
            if (typeof name != 'undefined') {
                delete this._data[name];
            } else {
                delete this._data;
            }
        }

        return this;
    }
});

Y.mix(Y.NodeList.prototype, {
    /**
    * @method getData
    * @for NodeList
    * @description Retrieves arbitrary data stored on each Node instance
    * bound to the NodeList.
    * @see Node
    * @param {string} name Optional name of the data field to retrieve.
    * If no name is given, all data is returned.
    * @return {Array} An array containing all of the data for each Node instance.
    * or an object hash of all fields.
    */
    getData: function(name) {
        var args = (arguments.length) ? [name] : [];
        return this._invoke('getData', args, true);
    },

    /**
    * @method setData
    * @for NodeList
    * @description Stores arbitrary data on each Node instance bound to the
    *  NodeList. This is not stored with the DOM node.
    * @param {string} name The name of the field to set. If no name
    * is given, name is treated as the data and overrides any existing data.
    * @param {any} val The value to be assigned to the field.
    * @chainable
    */
    setData: function(name, val) {
        var args = (arguments.length > 1) ? [name, val] : [name];
        return this._invoke('setData', args);
    },

    /**
    * @method clearData
    * @for NodeList
    * @description Clears data on all Node instances bound to the NodeList.
    * @param {string} name The name of the field to clear. If no name
    * is given, all data is cleared.
    * @chainable
    */
    clearData: function(name) {
        var args = (arguments.length) ? [name] : [];
        return this._invoke('clearData', [name]);
    }
});


}, '3.17.2', {"requires": ["event-base", "node-core", "dom-base", "dom-style"]});


/***/ }),

/***/ 577679:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('node-core', function (Y, NAME) {

/**
 * The Node Utility provides a DOM-like interface for interacting with DOM nodes.
 * @module node
 * @main node
 * @submodule node-core
 */

/**
 * The Node class provides a wrapper for manipulating DOM Nodes.
 * Node properties can be accessed via the set/get methods.
 * Use `Y.one()` to retrieve Node instances.
 *
 * <strong>NOTE:</strong> Node properties are accessed using
 * the <code>set</code> and <code>get</code> methods.
 *
 * @class Node
 * @constructor
 * @param {HTMLElement} node the DOM node to be mapped to the Node instance.
 * @uses EventTarget
 */

// "globals"
var DOT = '.',
    NODE_NAME = 'nodeName',
    NODE_TYPE = 'nodeType',
    OWNER_DOCUMENT = 'ownerDocument',
    TAG_NAME = 'tagName',
    UID = '_yuid',
    EMPTY_OBJ = {},

    _slice = Array.prototype.slice,

    Y_DOM = Y.DOM,

    Y_Node = function(node) {
        /**
         * Nodes in DOM subtrees that are not managed by YUI do not need to be
         * instantiated as Y_Nodes, and YUI caching references to such nodes
         * leads to memory leaks when the nodes are created and destroyed
         * frequently, as is the case with DOM subtrees that are managed by
         * React. In order to signal to YUI that nodes in a DOM subtree should
         * not be cached in Y_Nodes, add the attribute `data-yui-ignore-cache`
         * to the root node of the DOM subtree.
         */
        if (node && node.closest && node.closest('[data-yui-ignore-cache]')) {
            return null;
        }

        if (!this.getDOMNode) { // support optional "new"
            return new Y_Node(node);
        }

        if (typeof node == 'string') {
            node = Y_Node._fromString(node);
            if (!node) {
                return null; // NOTE: return
            }
        }

        var uid = (node.nodeType !== 9) ? node.uniqueID : node[UID];

        if (uid && Y_Node._instances[uid] && Y_Node._instances[uid]._node !== node) {
            node[UID] = null; // unset existing uid to prevent collision (via clone or hack)
        }

        uid = uid || Y.stamp(node);
        if (!uid) { // stamp failed; likely IE non-HTMLElement
            uid = Y.guid();
        }

        this[UID] = uid;

        /**
         * The underlying DOM node bound to the Y.Node instance
         * @property _node
         * @type HTMLElement
         * @private
         */
        this._node = node;

        this._stateProxy = node; // when augmented with Attribute

        if (this._initPlugins) { // when augmented with Plugin.Host
            this._initPlugins();
        }
    },

    // used with previous/next/ancestor tests
    _wrapFn = function(fn) {
        var ret = null;
        if (fn) {
            ret = (typeof fn == 'string') ?
            function(n) {
                return Y.Selector.test(n, fn);
            } :
            function(n) {
                return fn(Y.one(n));
            };
        }

        return ret;
    };
// end "globals"

Y_Node.ATTRS = {};
Y_Node.DOM_EVENTS = {};

Y_Node._fromString = function(node) {
    if (node) {
        if (node.indexOf('doc') === 0) { // doc OR document
            node = Y.config.doc;
        } else if (node.indexOf('win') === 0) { // win OR window
            node = Y.config.win;
        } else {
            node = Y.Selector.query(node, null, true);
        }
    }

    return node || null;
};

/**
 * The name of the component
 * @static
 * @type String
 * @property NAME
 */
Y_Node.NAME = 'node';

/*
 * The pattern used to identify ARIA attributes
 */
Y_Node.re_aria = /^(?:role$|aria-)/;

Y_Node.SHOW_TRANSITION = 'fadeIn';
Y_Node.HIDE_TRANSITION = 'fadeOut';

/**
 * A list of Node instances that have been created
 * @private
 * @type Object
 * @property _instances
 * @static
 *
 */
Y_Node._instances = {};

/**
 * Retrieves the DOM node bound to a Node instance
 * @method getDOMNode
 * @static
 *
 * @param {Node|HTMLElement} node The Node instance or an HTMLElement
 * @return {HTMLElement} The DOM node bound to the Node instance.  If a DOM node is passed
 * as the node argument, it is simply returned.
 */
Y_Node.getDOMNode = function(node) {
    if (node) {
        return (node.nodeType) ? node : node._node || null;
    }
    return null;
};

/**
 * Checks Node return values and wraps DOM Nodes as Y.Node instances
 * and DOM Collections / Arrays as Y.NodeList instances.
 * Other return values just pass thru.  If undefined is returned (e.g. no return)
 * then the Node instance is returned for chainability.
 * @method scrubVal
 * @static
 *
 * @param {HTMLElement|HTMLElement[]|Node} node The Node instance or an HTMLElement
 * @return {Node | NodeList | Any} Depends on what is returned from the DOM node.
 */
Y_Node.scrubVal = function(val, node) {
    if (val) { // only truthy values are risky
         if (typeof val == 'object' || typeof val == 'function') { // safari nodeList === function
            if (NODE_TYPE in val || Y_DOM.isWindow(val)) {// node || window
                val = Y.one(val);
            } else if (typeof SVGElementInstance !== 'undefined' && val.correspondingElement) { // svg node
                val = Y.one(val.correspondingUseElement || val.correspondingElement)
            } else if ((val.item && !val._nodes) || // dom collection or Node instance
                    (val[0] && val[0][NODE_TYPE])) { // array of DOM Nodes
                val = Y.all(val);
            }
        }
    } else if (typeof val === 'undefined') {
        val = node; // for chaining
    } else if (val === null) {
        val = null; // IE: DOM null not the same as null
    }

    return val;
};

/**
 * Adds methods to the Y.Node prototype, routing through scrubVal.
 * @method addMethod
 * @static
 *
 * @param {String} name The name of the method to add
 * @param {Function} fn The function that becomes the method
 * @param {Object} context An optional context to call the method with
 * (defaults to the Node instance)
 * @return {any} Depends on what is returned from the DOM node.
 */
Y_Node.addMethod = function(name, fn, context) {
    if (name && fn && typeof fn == 'function') {
        Y_Node.prototype[name] = function() {
            var args = _slice.call(arguments),
                node = this,
                ret;

            if (args[0] && args[0]._node) {
                args[0] = args[0]._node;
            }

            if (args[1] && args[1]._node) {
                args[1] = args[1]._node;
            }
            args.unshift(node._node);

            ret = fn.apply(context || node, args);

            if (ret) { // scrub truthy
                ret = Y_Node.scrubVal(ret, node);
            }

            (typeof ret != 'undefined') || (ret = node);
            return ret;
        };
    } else {
    }
};

/**
 * Imports utility methods to be added as Y.Node methods.
 * @method importMethod
 * @static
 *
 * @param {Object} host The object that contains the method to import.
 * @param {String} name The name of the method to import
 * @param {String} altName An optional name to use in place of the host name
 * @param {Object} context An optional context to call the method with
 */
Y_Node.importMethod = function(host, name, altName) {
    if (typeof name == 'string') {
        altName = altName || name;
        Y_Node.addMethod(altName, host[name], host);
    } else {
        Y.Array.each(name, function(n) {
            Y_Node.importMethod(host, n);
        });
    }
};

/**
 * Retrieves a NodeList based on the given CSS selector.
 * @method all
 *
 * @param {string} selector The CSS selector to test against.
 * @return {NodeList} A NodeList instance for the matching HTMLCollection/Array.
 * @for YUI
 */

/**
 * Returns a single Node instance bound to the node or the
 * first element matching the given selector. Returns null if no match found.
 * <strong>Note:</strong> For chaining purposes you may want to
 * use <code>Y.all</code>, which returns a NodeList when no match is found.
 * @method one
 * @param {String | HTMLElement} node a node or Selector
 * @return {Node | null} a Node instance or null if no match found.
 * @for YUI
 */

/**
 * Returns a single Node instance bound to the node or the
 * first element matching the given selector. Returns null if no match found.
 * <strong>Note:</strong> For chaining purposes you may want to
 * use <code>Y.all</code>, which returns a NodeList when no match is found.
 * @method one
 * @static
 * @param {String | HTMLElement} node a node or Selector
 * @return {Node | null} a Node instance or null if no match found.
 * @for Node
 */
Y_Node.one = function(node) {
    var instance = null,
        cachedNode,
        uid;

    if (node) {
        if (typeof node == 'string') {
            node = Y_Node._fromString(node);
            if (!node) {
                return null; // NOTE: return
            }
        } else if (node.getDOMNode) {
            return node; // NOTE: return
        }

        // safari svg element fix -bc
        if (typeof SVGElementInstance !== 'undefined') {
            if (!node.nodeType && node.correspondingElement) {
                node = node.correspondingUseElement || node.correspondingElement;
            }
        }

        if (node.nodeType || Y.DOM.isWindow(node)) { // avoid bad input (numbers, boolean, etc)
            uid = (node.uniqueID && node.nodeType !== 9) ? node.uniqueID : node._yuid;
            instance = Y_Node._instances[uid]; // reuse exising instances
            cachedNode = instance ? instance._node : null;
            if (!instance || (cachedNode && node !== cachedNode)) { // new Node when nodes don't match
                instance = new Y_Node(node);
                if (node.nodeType != 11) { // dont cache document fragment
                    Y_Node._instances[instance[UID]] = instance; // cache node
                }
            }
        }
    }

    return instance;
};

/**
 * The default setter for DOM properties
 * Called with instance context (this === the Node instance)
 * @method DEFAULT_SETTER
 * @static
 * @param {String} name The attribute/property being set
 * @param {any} val The value to be set
 * @return {any} The value
 */
Y_Node.DEFAULT_SETTER = function(name, val) {
    var node = this._stateProxy,
        strPath;

    if (name.indexOf(DOT) > -1) {
        strPath = name;
        name = name.split(DOT);
        // only allow when defined on node
        Y.Object.setValue(node, name, val);
    } else if (typeof node[name] != 'undefined') { // pass thru DOM properties
        node[name] = val;
    }

    return val;
};

/**
 * The default getter for DOM properties
 * Called with instance context (this === the Node instance)
 * @method DEFAULT_GETTER
 * @static
 * @param {String} name The attribute/property to look up
 * @return {any} The current value
 */
Y_Node.DEFAULT_GETTER = function(name) {
    var node = this._stateProxy,
        val;

    if (name.indexOf && name.indexOf(DOT) > -1) {
        val = Y.Object.getValue(node, name.split(DOT));
    } else if (typeof node[name] != 'undefined') { // pass thru from DOM
        val = node[name];
    }

    return val;
};

Y.mix(Y_Node.prototype, {
    DATA_PREFIX: 'data-',

    /**
     * The method called when outputting Node instances as strings
     * @method toString
     * @return {String} A string representation of the Node instance
     */
    toString: function() {
        var str = this[UID] + ': not bound to a node',
            node = this._node,
            attrs, id, className;

        if (node) {
            attrs = node.attributes;
            id = (attrs && attrs.id) ? node.getAttribute('id') : null;
            className = (attrs && attrs.className) ? node.getAttribute('className') : null;
            str = node[NODE_NAME];

            if (id) {
                str += '#' + id;
            }

            if (className) {
                str += '.' + className.replace(' ', '.');
            }

            // TODO: add yuid?
            str += ' ' + this[UID];
        }
        return str;
    },

    /**
     * Returns an attribute value on the Node instance.
     * Unless pre-configured (via `Node.ATTRS`), get hands
     * off to the underlying DOM node.  Only valid
     * attributes/properties for the node will be queried.
     * @method get
     * @param {String} attr The attribute
     * @return {any} The current value of the attribute
     */
    get: function(attr) {
        var val;

        if (this._getAttr) { // use Attribute imple
            val = this._getAttr(attr);
        } else {
            val = this._get(attr);
        }

        if (val) {
            val = Y_Node.scrubVal(val, this);
        } else if (val === null) {
            val = null; // IE: DOM null is not true null (even though they ===)
        }
        return val;
    },

    /**
     * Helper method for get.
     * @method _get
     * @private
     * @param {String} attr The attribute
     * @return {any} The current value of the attribute
     */
    _get: function(attr) {
        var attrConfig = Y_Node.ATTRS[attr],
            val;

        if (attrConfig && attrConfig.getter) {
            val = attrConfig.getter.call(this);
        } else if (Y_Node.re_aria.test(attr)) {
            val = this._node.getAttribute(attr, 2);
        } else {
            val = Y_Node.DEFAULT_GETTER.apply(this, arguments);
        }

        return val;
    },

    /**
     * Sets an attribute on the Node instance.
     * Unless pre-configured (via Node.ATTRS), set hands
     * off to the underlying DOM node.  Only valid
     * attributes/properties for the node will be set.
     * To set custom attributes use setAttribute.
     * @method set
     * @param {String} attr The attribute to be set.
     * @param {any} val The value to set the attribute to.
     * @chainable
     */
    set: function(attr, val) {
        var attrConfig = Y_Node.ATTRS[attr];

        if (this._setAttr) { // use Attribute imple
            this._setAttr.apply(this, arguments);
        } else { // use setters inline
            if (attrConfig && attrConfig.setter) {
                attrConfig.setter.call(this, val, attr);
            } else if (Y_Node.re_aria.test(attr)) { // special case Aria
                this._node.setAttribute(attr, val);
            } else {
                Y_Node.DEFAULT_SETTER.apply(this, arguments);
            }
        }

        return this;
    },

    /**
     * Sets multiple attributes.
     * @method setAttrs
     * @param {Object} attrMap an object of name/value pairs to set
     * @chainable
     */
    setAttrs: function(attrMap) {
        if (this._setAttrs) { // use Attribute imple
            this._setAttrs(attrMap);
        } else { // use setters inline
            Y.Object.each(attrMap, function(v, n) {
                this.set(n, v);
            }, this);
        }

        return this;
    },

    /**
     * Returns an object containing the values for the requested attributes.
     * @method getAttrs
     * @param {Array} attrs an array of attributes to get values
     * @return {Object} An object with attribute name/value pairs.
     */
    getAttrs: function(attrs) {
        var ret = {};
        if (this._getAttrs) { // use Attribute imple
            this._getAttrs(attrs);
        } else { // use setters inline
            Y.Array.each(attrs, function(v, n) {
                ret[v] = this.get(v);
            }, this);
        }

        return ret;
    },

    /**
     * Compares nodes to determine if they match.
     * Node instances can be compared to each other and/or HTMLElements.
     * @method compareTo
     * @param {HTMLElement | Node} refNode The reference node to compare to the node.
     * @return {Boolean} True if the nodes match, false if they do not.
     */
    compareTo: function(refNode) {
        var node = this._node;

        if (refNode && refNode._node) {
            refNode = refNode._node;
        }
        return node === refNode;
    },

    /**
     * Determines whether the node is appended to the document.
     * @method inDoc
     * @param {Node|HTMLElement} doc optional An optional document to check against.
     * Defaults to current document.
     * @return {Boolean} Whether or not this node is appended to the document.
     */
    inDoc: function(doc) {
        var node = this._node;

        if (node) {
            doc = (doc) ? doc._node || doc : node[OWNER_DOCUMENT];
            if (doc.documentElement) {
                return Y_DOM.contains(doc.documentElement, node);
            }
        }

        return false;
    },

    getById: function(id) {
        var node = this._node,
            ret = Y_DOM.byId(id, node[OWNER_DOCUMENT]);
        if (ret && Y_DOM.contains(node, ret)) {
            ret = Y.one(ret);
        } else {
            ret = null;
        }
        return ret;
    },

   /**
     * Returns the nearest ancestor that passes the test applied by supplied boolean method.
     * @method ancestor
     * @param {String | Function} fn A selector string or boolean method for testing elements.
     * If a function is used, it receives the current node being tested as the only argument.
     * If fn is not passed as an argument, the parent node will be returned.
     * @param {Boolean} testSelf optional Whether or not to include the element in the scan
     * @param {String | Function} stopFn optional A selector string or boolean
     * method to indicate when the search should stop. The search bails when the function
     * returns true or the selector matches.
     * If a function is used, it receives the current node being tested as the only argument.
     * @return {Node} The matching Node instance or null if not found
     */
    ancestor: function(fn, testSelf, stopFn) {
        // testSelf is optional, check for stopFn as 2nd arg
        if (arguments.length === 2 &&
                (typeof testSelf == 'string' || typeof testSelf == 'function')) {
            stopFn = testSelf;
        }

        return Y.one(Y_DOM.ancestor(this._node, _wrapFn(fn), testSelf, _wrapFn(stopFn)));
    },

   /**
     * Returns the ancestors that pass the test applied by supplied boolean method.
     * @method ancestors
     * @param {String | Function} fn A selector string or boolean method for testing elements.
     * @param {Boolean} testSelf optional Whether or not to include the element in the scan
     * If a function is used, it receives the current node being tested as the only argument.
     * @return {NodeList} A NodeList instance containing the matching elements
     */
    ancestors: function(fn, testSelf, stopFn) {
        if (arguments.length === 2 &&
                (typeof testSelf == 'string' || typeof testSelf == 'function')) {
            stopFn = testSelf;
        }
        return Y.all(Y_DOM.ancestors(this._node, _wrapFn(fn), testSelf, _wrapFn(stopFn)));
    },

    /**
     * Returns the previous matching sibling.
     * Returns the nearest element node sibling if no method provided.
     * @method previous
     * @param {String | Function} fn A selector or boolean method for testing elements.
     * If a function is used, it receives the current node being tested as the only argument.
     * @param {Boolean} [all] Whether text nodes as well as element nodes should be returned, or
     * just element nodes will be returned(default)
     * @return {Node} Node instance or null if not found
     */
    previous: function(fn, all) {
        return Y.one(Y_DOM.elementByAxis(this._node, 'previousSibling', _wrapFn(fn), all));
    },

    /**
     * Returns the next matching sibling.
     * Returns the nearest element node sibling if no method provided.
     * @method next
     * @param {String | Function} fn A selector or boolean method for testing elements.
     * If a function is used, it receives the current node being tested as the only argument.
     * @param {Boolean} [all] Whether text nodes as well as element nodes should be returned, or
     * just element nodes will be returned(default)
     * @return {Node} Node instance or null if not found
     */
    next: function(fn, all) {
        return Y.one(Y_DOM.elementByAxis(this._node, 'nextSibling', _wrapFn(fn), all));
    },

    /**
     * Returns all matching siblings.
     * Returns all siblings if no method provided.
     * @method siblings
     * @param {String | Function} fn A selector or boolean method for testing elements.
     * If a function is used, it receives the current node being tested as the only argument.
     * @return {NodeList} NodeList instance bound to found siblings
     */
    siblings: function(fn) {
        return Y.all(Y_DOM.siblings(this._node, _wrapFn(fn)));
    },

    /**
     * Retrieves a single Node instance, the first element matching the given
     * CSS selector.
     * Returns null if no match found.
     * @method one
     *
     * @param {string} selector The CSS selector to test against.
     * @return {Node | null} A Node instance for the matching HTMLElement or null
     * if no match found.
     */
    one: function(selector) {
        return Y.one(Y.Selector.query(selector, this._node, true));
    },

    /**
     * Retrieves a NodeList based on the given CSS selector.
     * @method all
     *
     * @param {string} selector The CSS selector to test against.
     * @return {NodeList} A NodeList instance for the matching HTMLCollection/Array.
     */
    all: function(selector) {
        var nodelist;

        if (this._node) {
            nodelist = Y.all(Y.Selector.query(selector, this._node));
            nodelist._query = selector;
            nodelist._queryRoot = this._node;
        }

        return nodelist || Y.all([]);
    },

    // TODO: allow fn test
    /**
     * Test if the supplied node matches the supplied selector.
     * @method test
     *
     * @param {string} selector The CSS selector to test against.
     * @return {boolean} Whether or not the node matches the selector.
     */
    test: function(selector) {
        return Y.Selector.test(this._node, selector);
    },

    /**
     * Removes the node from its parent.
     * Shortcut for myNode.get('parentNode').removeChild(myNode);
     * @method remove
     * @param {Boolean} destroy whether or not to call destroy() on the node
     * after removal.
     * @chainable
     *
     */
    remove: function(destroy) {
        var node = this._node;

        if (node && node.parentNode) {
            node.parentNode.removeChild(node);
        }

        if (destroy) {
            this.destroy();
        }

        return this;
    },

    /**
     * Replace the node with the other node. This is a DOM update only
     * and does not change the node bound to the Node instance.
     * Shortcut for myNode.get('parentNode').replaceChild(newNode, myNode);
     * @method replace
     * @param {Node | HTMLElement} newNode Node to be inserted
     * @chainable
     *
     */
    replace: function(newNode) {
        var node = this._node;
        if (typeof newNode == 'string') {
            newNode = Y_Node.create(newNode);
        }
        node.parentNode.replaceChild(Y_Node.getDOMNode(newNode), node);
        return this;
    },

    /**
     * @method replaceChild
     * @for Node
     * @param {String | HTMLElement | Node} node Node to be inserted
     * @param {HTMLElement | Node} refNode Node to be replaced
     * @return {Node} The replaced node
     */
    replaceChild: function(node, refNode) {
        if (typeof node == 'string') {
            node = Y_DOM.create(node);
        }

        return Y.one(this._node.replaceChild(Y_Node.getDOMNode(node), Y_Node.getDOMNode(refNode)));
    },

    /**
     * Nulls internal node references, removes any plugins and event listeners.
     * Note that destroy() will not remove the node from its parent or from the DOM. For that
     * functionality, call remove(true).
     * @method destroy
     * @param {Boolean} recursivePurge (optional) Whether or not to remove listeners from the
     * node's subtree (default is false)
     *
     */
    destroy: function(recursive) {
        var UID = Y.config.doc.uniqueID ? 'uniqueID' : '_yuid',
            instance;

        this.purge(); // TODO: only remove events add via this Node

        if (this.unplug) { // may not be a PluginHost
            this.unplug();
        }

        this.clearData();

        if (recursive) {
            Y.NodeList.each(this.all('*'), function(node) {
                instance = Y_Node._instances[node[UID]];
                if (instance) {
                   instance.destroy();
                } else { // purge in case added by other means
                    Y.Event.purgeElement(node);
                }
            });
        }

        this._node = null;
        this._stateProxy = null;

        delete Y_Node._instances[this._yuid];
    },

    /**
     * Invokes a method on the Node instance
     * @method invoke
     * @param {String} method The name of the method to invoke
     * @param {any} [args*] Arguments to invoke the method with.
     * @return {any} Whatever the underly method returns.
     * DOM Nodes and Collections return values
     * are converted to Node/NodeList instances.
     *
     */
    invoke: function(method, a, b, c, d, e) {
        var node = this._node,
            ret;

        if (a && a._node) {
            a = a._node;
        }

        if (b && b._node) {
            b = b._node;
        }

        ret = node[method](a, b, c, d, e);
        return Y_Node.scrubVal(ret, this);
    },

    /**
    * @method swap
    * @description Swap DOM locations with the given node.
    * This does not change which DOM node each Node instance refers to.
    * @param {Node} otherNode The node to swap with
     * @chainable
    */
    swap: Y.config.doc.documentElement.swapNode ?
        function(otherNode) {
            this._node.swapNode(Y_Node.getDOMNode(otherNode));
        } :
        function(otherNode) {
            otherNode = Y_Node.getDOMNode(otherNode);
            var node = this._node,
                parent = otherNode.parentNode,
                nextSibling = otherNode.nextSibling;

            if (nextSibling === node) {
                parent.insertBefore(node, otherNode);
            } else if (otherNode === node.nextSibling) {
                parent.insertBefore(otherNode, node);
            } else {
                node.parentNode.replaceChild(otherNode, node);
                Y_DOM.addHTML(parent, node, nextSibling);
            }
            return this;
        },


    hasMethod: function(method) {
        var node = this._node;
        return !!(node && method in node &&
                typeof node[method] != 'unknown' &&
            (typeof node[method] == 'function' ||
                String(node[method]).indexOf('function') === 1)); // IE reports as object, prepends space
    },

    isFragment: function() {
        return (this.get('nodeType') === 11);
    },

    /**
     * Removes and destroys all of the nodes within the node.
     * @method empty
     * @chainable
     */
    empty: function() {
        this.get('childNodes').remove().destroy(true);
        return this;
    },

    /**
     * Returns the DOM node bound to the Node instance
     * @method getDOMNode
     * @return {HTMLElement}
     */
    getDOMNode: function() {
        return this._node;
    }
}, true);

Y.Node = Y_Node;
Y.one = Y_Node.one;
/**
 * The NodeList module provides support for managing collections of Nodes.
 * @module node
 * @submodule node-core
 */

/**
 * The NodeList class provides a wrapper for manipulating DOM NodeLists.
 * NodeList properties can be accessed via the set/get methods.
 * Use Y.all() to retrieve NodeList instances.
 *
 * @class NodeList
 * @constructor
 * @param nodes {String|element|Node|Array} A selector, DOM element, Node, list of DOM elements, or list of Nodes with which to populate this NodeList.
 */

var NodeList = function(nodes) {
    var tmp = [];

    if (nodes) {
        if (typeof nodes === 'string') { // selector query
            this._query = nodes;
            nodes = Y.Selector.query(nodes);
        } else if (nodes.nodeType || Y_DOM.isWindow(nodes)) { // domNode || window
            nodes = [nodes];
        } else if (typeof SVGElementInstance !== 'undefined' && nodes.correspondingElement) { // svg node -bc
            nodes = [(nodes.correspondingUseElement || nodes.correspondingElement)];
        } else if (nodes._node) { // Y.Node
            nodes = [nodes._node];
        } else if (nodes[0] && nodes[0]._node) { // allow array of Y.Nodes
            Y.Array.each(nodes, function(node) {
                if (node._node) {
                    tmp.push(node._node);
                }
            });
            nodes = tmp;
        } else { // array of domNodes or domNodeList (no mixed array of Y.Node/domNodes)
            nodes = Y.Array(nodes, 0, true);
        }
    }

    /**
     * The underlying array of DOM nodes bound to the Y.NodeList instance
     * @property _nodes
     * @private
     */
    this._nodes = nodes || [];
};

NodeList.NAME = 'NodeList';

/**
 * Retrieves the DOM nodes bound to a NodeList instance
 * @method getDOMNodes
 * @static
 *
 * @param {NodeList} nodelist The NodeList instance
 * @return {Array} The array of DOM nodes bound to the NodeList
 */
NodeList.getDOMNodes = function(nodelist) {
    return (nodelist && nodelist._nodes) ? nodelist._nodes : nodelist;
};

NodeList.each = function(instance, fn, context) {
    var nodes = instance._nodes;
    if (nodes && nodes.length) {
        Y.Array.each(nodes, fn, context || instance);
    } else {
    }
};

NodeList.addMethod = function(name, fn, context) {
    if (name && fn) {
        NodeList.prototype[name] = function() {
            var ret = [],
                args = arguments;

            Y.Array.each(this._nodes, function(node) {
                var UID = (node.uniqueID && node.nodeType !== 9 ) ? 'uniqueID' : '_yuid',
                    instance = Y.Node._instances[node[UID]],
                    ctx,
                    result;

                if (!instance) {
                    instance = NodeList._getTempNode(node);
                }
                ctx = context || instance;
                result = fn.apply(ctx, args);
                if (result !== undefined && result !== instance) {
                    ret[ret.length] = result;
                }
            });

            // TODO: remove tmp pointer
            return ret.length ? ret : this;
        };
    } else {
    }
};

NodeList.importMethod = function(host, name, altName) {
    if (typeof name === 'string') {
        altName = altName || name;
        NodeList.addMethod(name, host[name]);
    } else {
        Y.Array.each(name, function(n) {
            NodeList.importMethod(host, n);
        });
    }
};

NodeList._getTempNode = function(node) {
    var tmp = NodeList._tempNode;
    if (!tmp) {
        tmp = Y.Node.create('<div></div>');
        NodeList._tempNode = tmp;
    }

    tmp._node = node;
    tmp._stateProxy = node;
    return tmp;
};

Y.mix(NodeList.prototype, {
    _invoke: function(method, args, getter) {
        var ret = (getter) ? [] : this;

        this.each(function(node) {
            var val = node[method].apply(node, args);
            if (getter) {
                ret.push(val);
            }
        });

        return ret;
    },

    /**
     * Retrieves the Node instance at the given index.
     * @method item
     *
     * @param {Number} index The index of the target Node.
     * @return {Node} The Node instance at the given index.
     */
    item: function(index) {
        return Y.one((this._nodes || [])[index]);
    },

    /**
     * Applies the given function to each Node in the NodeList.
     * @method each
     * @param {Function} fn The function to apply. It receives 3 arguments:
     * the current node instance, the node's index, and the NodeList instance
     * @param {Object} context optional An optional context to apply the function with
     * Default context is the current Node instance
     * @chainable
     */
    each: function(fn, context) {
        var instance = this;
        Y.Array.each(this._nodes, function(node, index) {
            node = Y.one(node);
            return fn.call(context || node, node, index, instance);
        });
        return instance;
    },

    batch: function(fn, context) {
        var nodelist = this;

        Y.Array.each(this._nodes, function(node, index) {
            var instance = Y.Node._instances[node[UID]];
            if (!instance) {
                instance = NodeList._getTempNode(node);
            }

            return fn.call(context || instance, instance, index, nodelist);
        });
        return nodelist;
    },

    /**
     * Executes the function once for each node until a true value is returned.
     * @method some
     * @param {Function} fn The function to apply. It receives 3 arguments:
     * the current node instance, the node's index, and the NodeList instance
     * @param {Object} context optional An optional context to execute the function from.
     * Default context is the current Node instance
     * @return {Boolean} Whether or not the function returned true for any node.
     */
    some: function(fn, context) {
        var instance = this;
        return Y.Array.some(this._nodes, function(node, index) {
            node = Y.one(node);
            context = context || node;
            return fn.call(context, node, index, instance);
        });
    },

    /**
     * Creates a documenFragment from the nodes bound to the NodeList instance
     * @method toFrag
     * @return {Node} a Node instance bound to the documentFragment
     */
    toFrag: function() {
        return Y.one(Y.DOM._nl2frag(this._nodes));
    },

    /**
     * Returns the index of the node in the NodeList instance
     * or -1 if the node isn't found.
     * @method indexOf
     * @param {Node | HTMLElement} node the node to search for
     * @return {Number} the index of the node value or -1 if not found
     */
    indexOf: function(node) {
        return Y.Array.indexOf(this._nodes, Y.Node.getDOMNode(node));
    },

    /**
     * Filters the NodeList instance down to only nodes matching the given selector.
     * @method filter
     * @param {String} selector The selector to filter against
     * @return {NodeList} NodeList containing the updated collection
     * @see Selector
     */
    filter: function(selector) {
        return Y.all(Y.Selector.filter(this._nodes, selector));
    },


    /**
     * Creates a new NodeList containing all nodes at every n indices, where
     * remainder n % index equals r.
     * (zero-based index).
     * @method modulus
     * @param {Number} n The offset to use (return every nth node)
     * @param {Number} r An optional remainder to use with the modulus operation (defaults to zero)
     * @return {NodeList} NodeList containing the updated collection
     */
    modulus: function(n, r) {
        r = r || 0;
        var nodes = [];
        NodeList.each(this, function(node, i) {
            if (i % n === r) {
                nodes.push(node);
            }
        });

        return Y.all(nodes);
    },

    /**
     * Creates a new NodeList containing all nodes at odd indices
     * (zero-based index).
     * @method odd
     * @return {NodeList} NodeList containing the updated collection
     */
    odd: function() {
        return this.modulus(2, 1);
    },

    /**
     * Creates a new NodeList containing all nodes at even indices
     * (zero-based index), including zero.
     * @method even
     * @return {NodeList} NodeList containing the updated collection
     */
    even: function() {
        return this.modulus(2);
    },

    destructor: function() {
    },

    /**
     * Reruns the initial query, when created using a selector query
     * @method refresh
     * @chainable
     */
    refresh: function() {
        var doc,
            nodes = this._nodes,
            query = this._query,
            root = this._queryRoot;

        if (query) {
            if (!root) {
                if (nodes && nodes[0] && nodes[0].ownerDocument) {
                    root = nodes[0].ownerDocument;
                }
            }

            this._nodes = Y.Selector.query(query, root);
        }

        return this;
    },

    /**
     * Returns the current number of items in the NodeList.
     * @method size
     * @return {Number} The number of items in the NodeList.
     */
    size: function() {
        return this._nodes.length;
    },

    /**
     * Determines if the instance is bound to any nodes
     * @method isEmpty
     * @return {Boolean} Whether or not the NodeList is bound to any nodes
     */
    isEmpty: function() {
        return this._nodes.length < 1;
    },

    toString: function() {
        var str = '',
            errorMsg = this[UID] + ': not bound to any nodes',
            nodes = this._nodes,
            node;

        if (nodes && nodes[0]) {
            node = nodes[0];
            str += node[NODE_NAME];
            if (node.id) {
                str += '#' + node.id;
            }

            if (node.className) {
                str += '.' + node.className.replace(' ', '.');
            }

            if (nodes.length > 1) {
                str += '...[' + nodes.length + ' items]';
            }
        }
        return str || errorMsg;
    },

    /**
     * Returns the DOM node bound to the Node instance
     * @method getDOMNodes
     * @return {Array}
     */
    getDOMNodes: function() {
        return this._nodes;
    }
}, true);

NodeList.importMethod(Y.Node.prototype, [
     /**
      * Called on each Node instance. Nulls internal node references,
      * removes any plugins and event listeners
      * @method destroy
      * @param {Boolean} recursivePurge (optional) Whether or not to
      * remove listeners from the node's subtree (default is false)
      * @see Node.destroy
      */
    'destroy',

     /**
      * Called on each Node instance. Removes and destroys all of the nodes
      * within the node
      * @method empty
      * @chainable
      * @see Node.empty
      */
    'empty',

     /**
      * Called on each Node instance. Removes the node from its parent.
      * Shortcut for myNode.get('parentNode').removeChild(myNode);
      * @method remove
      * @param {Boolean} destroy whether or not to call destroy() on the node
      * after removal.
      * @chainable
      * @see Node.remove
      */
    'remove',

     /**
      * Called on each Node instance. Sets an attribute on the Node instance.
      * Unless pre-configured (via Node.ATTRS), set hands
      * off to the underlying DOM node.  Only valid
      * attributes/properties for the node will be set.
      * To set custom attributes use setAttribute.
      * @method set
      * @param {String} attr The attribute to be set.
      * @param {any} val The value to set the attribute to.
      * @chainable
      * @see Node.set
      */
    'set'
]);

// one-off implementation to convert array of Nodes to NodeList
// e.g. Y.all('input').get('parentNode');

/** Called on each Node instance
  * @method get
  * @see Node
  */
NodeList.prototype.get = function(attr) {
    var ret = [],
        nodes = this._nodes,
        isNodeList = false,
        getTemp = NodeList._getTempNode,
        instance,
        val;

    if (nodes[0]) {
        instance = Y.Node._instances[nodes[0]._yuid] || getTemp(nodes[0]);
        val = instance._get(attr);
        if (val && val.nodeType) {
            isNodeList = true;
        }
    }

    Y.Array.each(nodes, function(node) {
        instance = Y.Node._instances[node._yuid];

        if (!instance) {
            instance = getTemp(node);
        }

        val = instance._get(attr);
        if (!isNodeList) { // convert array of Nodes to NodeList
            val = Y.Node.scrubVal(val, instance);
        }

        ret.push(val);
    });

    return (isNodeList) ? Y.all(ret) : ret;
};

Y.NodeList = NodeList;

Y.all = function(nodes) {
    return new NodeList(nodes);
};

Y.Node.all = Y.all;
/**
 * @module node
 * @submodule node-core
 */

var Y_NodeList = Y.NodeList,
    ArrayProto = Array.prototype,
    ArrayMethods = {
        /** Returns a new NodeList combining the given NodeList(s)
          * @for NodeList
          * @method concat
          * @param {NodeList | Array} valueN Arrays/NodeLists and/or values to
          * concatenate to the resulting NodeList
          * @return {NodeList} A new NodeList comprised of this NodeList joined with the input.
          */
        'concat': 1,
        /** Removes the last from the NodeList and returns it.
          * @for NodeList
          * @method pop
          * @return {Node | null} The last item in the NodeList, or null if the list is empty.
          */
        'pop': 0,
        /** Adds the given Node(s) to the end of the NodeList.
          * @for NodeList
          * @method push
          * @param {Node | HTMLElement} nodes One or more nodes to add to the end of the NodeList.
          */
        'push': 0,
        /** Removes the first item from the NodeList and returns it.
          * @for NodeList
          * @method shift
          * @return {Node | null} The first item in the NodeList, or null if the NodeList is empty.
          */
        'shift': 0,
        /** Returns a new NodeList comprising the Nodes in the given range.
          * @for NodeList
          * @method slice
          * @param {Number} begin Zero-based index at which to begin extraction.
          As a negative index, start indicates an offset from the end of the sequence. slice(-2) extracts the second-to-last element and the last element in the sequence.
          * @param {Number} end Zero-based index at which to end extraction. slice extracts up to but not including end.
          slice(1,4) extracts the second element through the fourth element (elements indexed 1, 2, and 3).
          As a negative index, end indicates an offset from the end of the sequence. slice(2,-1) extracts the third element through the second-to-last element in the sequence.
          If end is omitted, slice extracts to the end of the sequence.
          * @return {NodeList} A new NodeList comprised of this NodeList joined with the input.
          */
        'slice': 1,
        /** Changes the content of the NodeList, adding new elements while removing old elements.
          * @for NodeList
          * @method splice
          * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end.
          * @param {Number} howMany An integer indicating the number of old array elements to remove. If howMany is 0, no elements are removed. In this case, you should specify at least one new element. If no howMany parameter is specified (second syntax above, which is a SpiderMonkey extension), all elements after index are removed.
          * {Node | HTMLElement| element1, ..., elementN
          The elements to add to the array. If you don't specify any elements, splice simply removes elements from the array.
          * @return {NodeList} The element(s) removed.
          */
        'splice': 1,
        /** Adds the given Node(s) to the beginning of the NodeList.
          * @for NodeList
          * @method unshift
          * @param {Node | HTMLElement} nodes One or more nodes to add to the NodeList.
          */
        'unshift': 0
    };


Y.Object.each(ArrayMethods, function(returnNodeList, name) {
    Y_NodeList.prototype[name] = function() {
        var args = [],
            i = 0,
            arg,
            ret;

        while (typeof (arg = arguments[i++]) != 'undefined') { // use DOM nodes/nodeLists
            args.push(arg._node || arg._nodes || arg);
        }

        ret = ArrayProto[name].apply(this._nodes, args);

        if (returnNodeList) {
            ret = Y.all(ret);
        } else {
            ret = Y.Node.scrubVal(ret);
        }

        return ret;
    };
});
/**
 * @module node
 * @submodule node-core
 */

Y.Array.each([
    /**
     * Passes through to DOM method.
     * @for Node
     * @method removeChild
     * @param {HTMLElement | Node} node Node to be removed
     * @return {Node} The removed node
     */
    'removeChild',

    /**
     * Passes through to DOM method.
     * @method hasChildNodes
     * @return {Boolean} Whether or not the node has any childNodes
     */
    'hasChildNodes',

    /**
     * Passes through to DOM method.
     * @method cloneNode
     * @param {Boolean} deep Whether or not to perform a deep clone, which includes
     * subtree and attributes
     * @return {Node} The clone
     */
    'cloneNode',

    /**
     * Passes through to DOM method.
     * @method hasAttribute
     * @param {String} attribute The attribute to test for
     * @return {Boolean} Whether or not the attribute is present
     */
    'hasAttribute',

    /**
     * Passes through to DOM method.
     * @method scrollIntoView
     * @chainable
     */
    'scrollIntoView',

    /**
     * Passes through to DOM method.
     * @method getElementsByTagName
     * @param {String} tagName The tagName to collect
     * @return {NodeList} A NodeList representing the HTMLCollection
     */
    'getElementsByTagName',

    /**
     * Passes through to DOM method.
     * @method focus
     * @chainable
     */
    'focus',

    /**
     * Passes through to DOM method.
     * @method blur
     * @chainable
     */
    'blur',

    /**
     * Passes through to DOM method.
     * Only valid on FORM elements
     * @method submit
     * @chainable
     */
    'submit',

    /**
     * Passes through to DOM method.
     * Only valid on FORM elements
     * @method reset
     * @chainable
     */
    'reset',

    /**
     * Passes through to DOM method.
     * @method select
     * @chainable
     */
     'select',

    /**
     * Passes through to DOM method.
     * Only valid on TABLE elements
     * @method createCaption
     * @chainable
     */
    'createCaption'

], function(method) {
    Y.Node.prototype[method] = function(arg1, arg2, arg3) {
        var ret = this.invoke(method, arg1, arg2, arg3);
        return ret;
    };
});

/**
 * Passes through to DOM method.
 * @method removeAttribute
 * @param {String} attribute The attribute to be removed
 * @chainable
 */
 // one-off implementation due to IE returning boolean, breaking chaining
Y.Node.prototype.removeAttribute = function(attr) {
    var node = this._node;
    if (node) {
        node.removeAttribute(attr, 0); // comma zero for IE < 8 to force case-insensitive
    }

    return this;
};

Y.Node.importMethod(Y.DOM, [
    /**
     * Determines whether the node is an ancestor of another HTML element in the DOM hierarchy.
     * @method contains
     * @param {Node | HTMLElement} needle The possible node or descendent
     * @return {Boolean} Whether or not this node is the needle its ancestor
     */
    'contains',
    /**
     * Allows setting attributes on DOM nodes, normalizing in some cases.
     * This passes through to the DOM node, allowing for custom attributes.
     * @method setAttribute
     * @for Node
     * @chainable
     * @param {string} name The attribute name
     * @param {string} value The value to set
     */
    'setAttribute',
    /**
     * Allows getting attributes on DOM nodes, normalizing in some cases.
     * This passes through to the DOM node, allowing for custom attributes.
     * @method getAttribute
     * @for Node
     * @param {string} name The attribute name
     * @return {string} The attribute value
     */
    'getAttribute',

    /**
     * Wraps the given HTML around the node.
     * @method wrap
     * @param {String} html The markup to wrap around the node.
     * @chainable
     * @for Node
     */
    'wrap',

    /**
     * Removes the node's parent node.
     * @method unwrap
     * @chainable
     */
    'unwrap',

    /**
     * Applies a unique ID to the node if none exists
     * @method generateID
     * @return {String} The existing or generated ID
     */
    'generateID'
]);

Y.NodeList.importMethod(Y.Node.prototype, [
/**
 * Allows getting attributes on DOM nodes, normalizing in some cases.
 * This passes through to the DOM node, allowing for custom attributes.
 * @method getAttribute
 * @see Node
 * @for NodeList
 * @param {string} name The attribute name
 * @return {string} The attribute value
 */

    'getAttribute',
/**
 * Allows setting attributes on DOM nodes, normalizing in some cases.
 * This passes through to the DOM node, allowing for custom attributes.
 * @method setAttribute
 * @see Node
 * @for NodeList
 * @chainable
 * @param {string} name The attribute name
 * @param {string} value The value to set
 */
    'setAttribute',

/**
 * Allows for removing attributes on DOM nodes.
 * This passes through to the DOM node, allowing for custom attributes.
 * @method removeAttribute
 * @see Node
 * @for NodeList
 * @param {string} name The attribute to remove
 */
    'removeAttribute',
/**
 * Removes the parent node from node in the list.
 * @method unwrap
 * @chainable
 */
    'unwrap',
/**
 * Wraps the given HTML around each node.
 * @method wrap
 * @param {String} html The markup to wrap around the node.
 * @chainable
 */
    'wrap',

/**
 * Applies a unique ID to each node if none exists
 * @method generateID
 * @return {String} The existing or generated ID
 */
    'generateID'
]);


}, '3.17.2', {"requires": ["dom-core", "selector"]});


/***/ }),

/***/ 630173:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('node-event-delegate', function (Y, NAME) {

/**
 * Functionality to make the node a delegated event container
 * @module node
 * @submodule node-event-delegate
 */

/**
 * <p>Sets up a delegation listener for an event occurring inside the Node.
 * The delegated event will be verified against a supplied selector or
 * filtering function to test if the event references at least one node that
 * should trigger the subscription callback.</p>
 *
 * <p>Selector string filters will trigger the callback if the event originated
 * from a node that matches it or is contained in a node that matches it.
 * Function filters are called for each Node up the parent axis to the
 * subscribing container node, and receive at each level the Node and the event
 * object.  The function should return true (or a truthy value) if that Node
 * should trigger the subscription callback.  Note, it is possible for filters
 * to match multiple Nodes for a single event.  In this case, the delegate
 * callback will be executed for each matching Node.</p>
 *
 * <p>For each matching Node, the callback will be executed with its 'this'
 * object set to the Node matched by the filter (unless a specific context was
 * provided during subscription), and the provided event's
 * <code>currentTarget</code> will also be set to the matching Node.  The
 * containing Node from which the subscription was originally made can be
 * referenced as <code>e.container</code>.
 *
 * @method delegate
 * @param type {String} the event type to delegate
 * @param fn {Function} the callback function to execute.  This function
 *              will be provided the event object for the delegated event.
 * @param spec {String|Function} a selector that must match the target of the
 *              event or a function to test target and its parents for a match
 * @param context {Object} optional argument that specifies what 'this' refers to.
 * @param args* {any} 0..n additional arguments to pass on to the callback function.
 *              These arguments will be added after the event object.
 * @return {EventHandle} the detach handle
 * @for Node
 */
Y.Node.prototype.delegate = function(type) {

    var args = Y.Array(arguments, 0, true),
        index = (Y.Lang.isObject(type) && !Y.Lang.isArray(type)) ? 1 : 2;

    args.splice(index, 0, this._node);

    return Y.delegate.apply(Y, args);
};


}, '3.17.2', {"requires": ["node-base", "event-delegate"]});


/***/ }),

/***/ 859077:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('node-event-simulate', function (Y, NAME) {

/**
 * Adds functionality to simulate events.
 * @module node
 * @submodule node-event-simulate
 */

/**
 * Simulates an event on the node.
 * @param {String} type The type of event (i.e., "click").
 * @param {Object} options (Optional) Extra options to copy onto the event object.
 * @for Node
 * @method simulate
 */
Y.Node.prototype.simulate = function (type, options) {

    Y.Event.simulate(Y.Node.getDOMNode(this), type, options);
};

/**
 * Simulates the higher user level gesture of the given name on this node.
 * This method generates a set of low level touch events(Apple specific gesture
 * events as well for the iOS platforms) asynchronously. Note that gesture
 * simulation is relying on `Y.Event.simulate()` method to generate
 * the touch events under the hood. The `Y.Event.simulate()` method
 * itself is a synchronous method.
 *
 * Supported gestures are `tap`, `doubletap`, `press`, `move`, `flick`, `pinch`
 * and `rotate`.
 *
 * The `pinch` gesture is used to simulate the pinching and spreading of two
 * fingers. During a pinch simulation, rotation is also possible. Essentially
 * `pinch` and `rotate` simulations share the same base implementation to allow
 * both pinching and rotation at the same time. The only difference is `pinch`
 * requires `start` and `end` option properties while `rotate` requires `rotation`
 * option property.
 *
 * The `pinch` and `rotate` gestures can be described as placing 2 fingers along a
 * circle. Pinching and spreading can be described by start and end circles while
 * rotation occurs on a single circle. If the radius of the start circle is greater
 * than the end circle, the gesture becomes a pinch, otherwise it is a spread spread.
 *
 * @example
 *
 *     var node = Y.one("#target");
 *
 *     // double tap example
 *     node.simulateGesture("doubletap", function() {
 *         // my callback function
 *     });
 *
 *     // flick example from the center of the node, move 50 pixels down for 50ms)
 *     node.simulateGesture("flick", {
 *         axis: y,
 *         distance: -100
 *         duration: 50
 *     }, function() {
 *         // my callback function
 *     });
 *
 *     // simulate rotating a node 75 degrees counter-clockwise
 *     node.simulateGesture("rotate", {
 *         rotation: -75
 *     });
 *
 *     // simulate a pinch and a rotation at the same time.
 *     // fingers start on a circle of radius 100 px, placed at top/bottom
 *     // fingers end on a circle of radius 50px, placed at right/left
 *     node.simulateGesture("pinch", {
 *         r1: 100,
 *         r2: 50,
 *         start: 0
 *         rotation: 90
 *     });
 *
 * @method simulateGesture
 * @param {String} name The name of the supported gesture to simulate. The
 *      supported gesture name is one of "tap", "doubletap", "press", "move",
 *      "flick", "pinch" and "rotate".
 * @param {Object} [options] Extra options used to define the gesture behavior:
 *
 *      Valid options properties for the `tap` gesture:
 *
 *      @param {Array} [options.point] (Optional) Indicates the [x,y] coordinates
 *        where the tap should be simulated. Default is the center of the node
 *        element.
 *      @param {Number} [options.hold=10] (Optional) The hold time in milliseconds.
 *        This is the time between `touchstart` and `touchend` event generation.
 *      @param {Number} [options.times=1] (Optional) Indicates the number of taps.
 *      @param {Number} [options.delay=10] (Optional) The number of milliseconds
 *        before the next tap simulation happens. This is valid only when `times`
 *        is more than 1.
 *
 *      Valid options properties for the `doubletap` gesture:
 *
 *      @param {Array} [options.point] (Optional) Indicates the [x,y] coordinates
 *        where the doubletap should be simulated. Default is the center of the
 *        node element.
 *
 *      Valid options properties for the `press` gesture:
 *
 *      @param {Array} [options.point] (Optional) Indicates the [x,y] coordinates
 *        where the press should be simulated. Default is the center of the node
 *        element.
 *      @param {Number} [options.hold=3000] (Optional) The hold time in milliseconds.
 *        This is the time between `touchstart` and `touchend` event generation.
 *        Default is 3000ms (3 seconds).
 *
 *      Valid options properties for the `move` gesture:
 *
 *      @param {Object} [options.path] (Optional) Indicates the path of the finger
 *        movement. It's an object with three optional properties: `point`,
 *        `xdist` and  `ydist`.
 *        @param {Array} [options.path.point] A starting point of the gesture.
 *          Default is the center of the node element.
 *        @param {Number} [options.path.xdist=200] A distance to move in pixels
 *          along the X axis. A negative distance value indicates moving left.
 *        @param {Number} [options.path.ydist=0] A distance to move in pixels
 *          along the Y axis. A negative distance value indicates moving up.
 *      @param {Number} [options.duration=1000] (Optional) The duration of the
 *        gesture in milliseconds.
 *
 *      Valid options properties for the `flick` gesture:
 *
 *      @param {Array} [options.point] (Optional) Indicates the [x, y] coordinates
 *        where the flick should be simulated. Default is the center of the
 *        node element.
 *      @param {String} [options.axis='x'] (Optional) Valid values are either
 *        "x" or "y". Indicates axis to move along. The flick can move to one of
 *        4 directions(left, right, up and down).
 *      @param {Number} [options.distance=200] (Optional) Distance to move in pixels
 *      @param {Number} [options.duration=1000] (Optional) The duration of the
 *        gesture in milliseconds. User given value could be automatically
 *        adjusted by the framework if it is below the minimum velocity to be
 *        a flick gesture.
 *
 *      Valid options properties for the `pinch` gesture:
 *
 *      @param {Array} [options.center] (Optional) The center of the circle where
 *        two fingers are placed. Default is the center of the node element.
 *      @param {Number} [options.r1] (Required) Pixel radius of the start circle
 *        where 2 fingers will be on when the gesture starts. The circles are
 *        centered at the center of the element.
 *      @param {Number} [options.r2] (Required) Pixel radius of the end circle
 *        when this gesture ends.
 *      @param {Number} [options.duration=1000] (Optional) The duration of the
 *        gesture in milliseconds.
 *      @param {Number} [options.start=0] (Optional) Starting degree of the first
 *        finger. The value is relative to the path of the north. Default is 0
 *        (i.e., 12:00 on a clock).
 *      @param {Number} [options.rotation=0] (Optional) Degrees to rotate from
 *        the starting degree. A negative value means rotation to the
 *        counter-clockwise direction.
 *
 *      Valid options properties for the `rotate` gesture:
 *
 *      @param {Array} [options.center] (Optional) The center of the circle where
 *        two fingers are placed. Default is the center of the node element.
 *      @param {Number} [options.r1] (Optional) Pixel radius of the start circle
 *        where 2 fingers will be on when the gesture starts. The circles are
 *        centered at the center of the element. Default is a fourth of the node
 *        element width or height, whichever is smaller.
 *      @param {Number} [options.r2] (Optional) Pixel radius of the end circle
 *        when this gesture ends. Default is a fourth of the node element width or
 *        height, whichever is smaller.
 *      @param {Number} [options.duration=1000] (Optional) The duration of the
 *        gesture in milliseconds.
 *      @param {Number} [options.start=0] (Optional) Starting degree of the first
 *        finger. The value is relative to the path of the north. Default is 0
 *        (i.e., 12:00 on a clock).
 *      @param {Number} [options.rotation] (Required) Degrees to rotate from
 *        the starting degree. A negative value means rotation to the
 *        counter-clockwise direction.
 *
 * @param {Function} [cb] The callback to execute when the asynchronouse gesture
 *      simulation is completed.
 *      @param {Error} cb.err An error object if the simulation is failed.
 * @for Node
 */
Y.Node.prototype.simulateGesture = function (name, options, cb) {

    Y.Event.simulateGesture(this, name, options, cb);
};


}, '3.17.2', {"requires": ["node-base", "event-simulate", "gesture-simulate"]});


/***/ }),

/***/ 687596:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('node-load', function (Y, NAME) {

/**
 * Extended Node interface with a basic IO API.
 * @module node
 * @submodule node-load
 */

/**
 * The default IO complete handler.
 * @method _ioComplete
 * @protected
 * @for Node
 * @param {String} code The response code.
 * @param {Object} response The response object.
 * @param {Array} args An array containing the callback and selector
 */

Y.Node.prototype._ioComplete = function(code, response, args) {
    var selector = args[0],
        callback = args[1],
        tmp,
        content;

    if (response && response.responseText) {
        content = response.responseText;
        if (selector) {
            tmp = Y.DOM.create(content);
            content = Y.Selector.query(selector, tmp);
        }
        this.setContent(content);
    }
    if (callback) {
        callback.call(this, code, response);
    }
};

/**
 * Loads content from the given url and replaces the Node's
 * existing content with the remote content.
 * @method load
 * @param {String} url The URL to load via XMLHttpRequest.
 * @param {String} selector An optional selector representing a subset of an HTML document to load.
 * @param {Function} callback An optional function to run after the content has been loaded.
 * @chainable
 */
Y.Node.prototype.load = function(url, selector, callback) {
    if (typeof selector == 'function') {
        callback = selector;
        selector = null;
    }
    var config = {
        context: this,
        on: {
            complete: this._ioComplete
        },
        arguments: [selector, callback]
    };

    Y.io(url, config);
    return this;
};


}, '3.17.2', {"requires": ["node-base", "io-base"]});


/***/ }),

/***/ 24717:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('node-pluginhost', function (Y, NAME) {

/**
 * @module node
 * @submodule node-pluginhost
 */

/**
 * Registers plugins to be instantiated at the class level (plugins
 * which should be plugged into every instance of Node by default).
 *
 * @method plug
 * @static
 * @for Node
 * @param {Function | Array} plugin Either the plugin class, an array of plugin classes or an array of objects (with fn and cfg properties defined)
 * @param {Object} config (Optional) If plugin is the plugin class, the configuration for the plugin
 */
Y.Node.plug = function() {
    var args = Y.Array(arguments);
    args.unshift(Y.Node);
    Y.Plugin.Host.plug.apply(Y.Base, args);
    return Y.Node;
};

/**
 * Unregisters any class level plugins which have been registered by the Node
 *
 * @method unplug
 * @static
 *
 * @param {Function | Array} plugin The plugin class, or an array of plugin classes
 */
Y.Node.unplug = function() {
    var args = Y.Array(arguments);
    args.unshift(Y.Node);
    Y.Plugin.Host.unplug.apply(Y.Base, args);
    return Y.Node;
};

Y.mix(Y.Node, Y.Plugin.Host, false, null, 1);

// run PluginHost constructor on cached Node instances
Y.Object.each(Y.Node._instances, function (node) {
    Y.Plugin.Host.apply(node);
});

// allow batching of plug/unplug via NodeList
// doesn't use NodeList.importMethod because we need real Nodes (not tmpNode)
/**
 * Adds a plugin to each node in the NodeList.
 * This will instantiate the plugin and attach it to the configured namespace on each node
 * @method plug
 * @for NodeList
 * @param P {Function | Object |Array} Accepts the plugin class, or an
 * object with a "fn" property specifying the plugin class and
 * a "cfg" property specifying the configuration for the Plugin.
 * <p>
 * Additionally an Array can also be passed in, with the above function or
 * object values, allowing the user to add multiple plugins in a single call.
 * </p>
 * @param config (Optional) If the first argument is the plugin class, the second argument
 * can be the configuration for the plugin.
 * @chainable
 */
Y.NodeList.prototype.plug = function() {
    var args = arguments;
    Y.NodeList.each(this, function(node) {
        Y.Node.prototype.plug.apply(Y.one(node), args);
    });
    return this;
};

/**
 * Removes a plugin from all nodes in the NodeList. This will destroy the
 * plugin instance and delete the namespace each node.
 * @method unplug
 * @for NodeList
 * @param {String | Function} plugin The namespace of the plugin, or the plugin class with the static NS namespace property defined. If not provided,
 * all registered plugins are unplugged.
 * @chainable
 */
Y.NodeList.prototype.unplug = function() {
    var args = arguments;
    Y.NodeList.each(this, function(node) {
        Y.Node.prototype.unplug.apply(Y.one(node), args);
    });
    return this;
};


}, '3.17.2', {"requires": ["node-base", "pluginhost"]});


/***/ }),

/***/ 338677:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('node-screen', function (Y, NAME) {

/**
 * Extended Node interface for managing regions and screen positioning.
 * Adds support for positioning elements and normalizes window size and scroll detection.
 * @module node
 * @submodule node-screen
 */

// these are all "safe" returns, no wrapping required
Y.each([
    /**
     * Returns the inner width of the viewport (exludes scrollbar).
     * @config winWidth
     * @for Node
     * @type {Number}
     */
    'winWidth',

    /**
     * Returns the inner height of the viewport (exludes scrollbar).
     * @config winHeight
     * @type {Number}
     */
    'winHeight',

    /**
     * Document width
     * @config docWidth
     * @type {Number}
     */
    'docWidth',

    /**
     * Document height
     * @config docHeight
     * @type {Number}
     */
    'docHeight',

    /**
     * Pixel distance the page has been scrolled horizontally
     * @config docScrollX
     * @type {Number}
     */
    'docScrollX',

    /**
     * Pixel distance the page has been scrolled vertically
     * @config docScrollY
     * @type {Number}
     */
    'docScrollY'
    ],
    function(name) {
        Y.Node.ATTRS[name] = {
            getter: function() {
                var args = Array.prototype.slice.call(arguments);
                args.unshift(Y.Node.getDOMNode(this));

                return Y.DOM[name].apply(this, args);
            }
        };
    }
);

Y.Node.ATTRS.scrollLeft = {
    getter: function() {
        var node = Y.Node.getDOMNode(this);
        return ('scrollLeft' in node) ? node.scrollLeft : Y.DOM.docScrollX(node);
    },

    setter: function(val) {
        var node = Y.Node.getDOMNode(this);
        if (node) {
            if ('scrollLeft' in node) {
                node.scrollLeft = val;
            } else if (node.document || node.nodeType === 9) {
                Y.DOM._getWin(node).scrollTo(val, Y.DOM.docScrollY(node)); // scroll window if win or doc
            }
        } else {
        }
    }
};

Y.Node.ATTRS.scrollTop = {
    getter: function() {
        var node = Y.Node.getDOMNode(this);
        return ('scrollTop' in node) ? node.scrollTop : Y.DOM.docScrollY(node);
    },

    setter: function(val) {
        var node = Y.Node.getDOMNode(this);
        if (node) {
            if ('scrollTop' in node) {
                node.scrollTop = val;
            } else if (node.document || node.nodeType === 9) {
                Y.DOM._getWin(node).scrollTo(Y.DOM.docScrollX(node), val); // scroll window if win or doc
            }
        } else {
        }
    }
};

Y.Node.importMethod(Y.DOM, [
/**
 * Gets the current position of the node in page coordinates.
 * @method getXY
 * @for Node
 * @return {Array} The XY position of the node
*/
    'getXY',

/**
 * Set the position of the node in page coordinates, regardless of how the node is positioned.
 * @method setXY
 * @param {Array} xy Contains X & Y values for new position (coordinates are page-based)
 * @chainable
 */
    'setXY',

/**
 * Gets the current position of the node in page coordinates.
 * @method getX
 * @return {Number} The X position of the node
*/
    'getX',

/**
 * Set the position of the node in page coordinates, regardless of how the node is positioned.
 * @method setX
 * @param {Number} x X value for new position (coordinates are page-based)
 * @chainable
 */
    'setX',

/**
 * Gets the current position of the node in page coordinates.
 * @method getY
 * @return {Number} The Y position of the node
*/
    'getY',

/**
 * Set the position of the node in page coordinates, regardless of how the node is positioned.
 * @method setY
 * @param {Number} y Y value for new position (coordinates are page-based)
 * @chainable
 */
    'setY',

/**
 * Swaps the XY position of this node with another node.
 * @method swapXY
 * @param {Node | HTMLElement} otherNode The node to swap with.
 * @chainable
 */
    'swapXY'
]);

/**
 * @module node
 * @submodule node-screen
 */

/**
 * Returns a region object for the node
 * @config region
 * @for Node
 * @type Node
 */
Y.Node.ATTRS.region = {
    getter: function() {
        var node = this.getDOMNode(),
            region;

        if (node && !node.tagName) {
            if (node.nodeType === 9) { // document
                node = node.documentElement;
            }
        }
        if (Y.DOM.isWindow(node)) {
            region = Y.DOM.viewportRegion(node);
        } else {
            region = Y.DOM.region(node);
        }
        return region;
    }
};

/**
 * Returns a region object for the node's viewport
 * @config viewportRegion
 * @type Node
 */
Y.Node.ATTRS.viewportRegion = {
    getter: function() {
        return Y.DOM.viewportRegion(Y.Node.getDOMNode(this));
    }
};

Y.Node.importMethod(Y.DOM, 'inViewportRegion');

// these need special treatment to extract 2nd node arg
/**
 * Compares the intersection of the node with another node or region
 * @method intersect
 * @for Node
 * @param {Node|Object} node2 The node or region to compare with.
 * @param {Object} altRegion An alternate region to use (rather than this node's).
 * @return {Object} An object representing the intersection of the regions.
 */
Y.Node.prototype.intersect = function(node2, altRegion) {
    var node1 = Y.Node.getDOMNode(this);
    if (Y.instanceOf(node2, Y.Node)) { // might be a region object
        node2 = Y.Node.getDOMNode(node2);
    }
    return Y.DOM.intersect(node1, node2, altRegion);
};

/**
 * Determines whether or not the node is within the given region.
 * @method inRegion
 * @param {Node|Object} node2 The node or region to compare with.
 * @param {Boolean} all Whether or not all of the node must be in the region.
 * @param {Object} altRegion An alternate region to use (rather than this node's).
 * @return {Boolean} True if in region, false if not.
 */
Y.Node.prototype.inRegion = function(node2, all, altRegion) {
    var node1 = Y.Node.getDOMNode(this);
    if (Y.instanceOf(node2, Y.Node)) { // might be a region object
        node2 = Y.Node.getDOMNode(node2);
    }
    return Y.DOM.inRegion(node1, node2, all, altRegion);
};


}, '3.17.2', {"requires": ["dom-screen", "node-base"]});


/***/ }),

/***/ 657649:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('node-style', function (Y, NAME) {

(function(Y) {
/**
 * Extended Node interface for managing node styles.
 * @module node
 * @submodule node-style
 */

Y.mix(Y.Node.prototype, {
    /**
     * Sets a style property of the node.
     * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
     * @method setStyle
     * @param {String} attr The style attribute to set.
     * @param {String|Number} val The value.
     * @chainable
     */
    setStyle: function(attr, val) {
        Y.DOM.setStyle(this._node, attr, val);
        return this;
    },

    /**
     * Sets multiple style properties on the node.
     * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
     * @method setStyles
     * @param {Object} hash An object literal of property:value pairs.
     * @chainable
     */
    setStyles: function(hash) {
        Y.DOM.setStyles(this._node, hash);
        return this;
    },

    /**
     * Returns the style's current value.
     * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
     * @method getStyle
     * @for Node
     * @param {String} attr The style attribute to retrieve.
     * @return {String} The current value of the style property for the element.
     */

     getStyle: function(attr) {
        return Y.DOM.getStyle(this._node, attr);
     },

    /**
     * Returns the computed value for the given style property.
     * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
     * @method getComputedStyle
     * @param {String} attr The style attribute to retrieve.
     * @return {String} The computed value of the style property for the element.
     */
     getComputedStyle: function(attr) {
        return Y.DOM.getComputedStyle(this._node, attr);
     }
});

/**
 * Returns an array of values for each node.
 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
 * @method getStyle
 * @for NodeList
 * @see Node.getStyle
 * @param {String} attr The style attribute to retrieve.
 * @return {Array} The current values of the style property for the element.
 */

/**
 * Returns an array of the computed value for each node.
 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
 * @method getComputedStyle
 * @see Node.getComputedStyle
 * @param {String} attr The style attribute to retrieve.
 * @return {Array} The computed values for each node.
 */

/**
 * Sets a style property on each node.
 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
 * @method setStyle
 * @see Node.setStyle
 * @param {String} attr The style attribute to set.
 * @param {String|Number} val The value.
 * @chainable
 */

/**
 * Sets multiple style properties on each node.
 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
 * @method setStyles
 * @see Node.setStyles
 * @param {Object} hash An object literal of property:value pairs.
 * @chainable
 */

// These are broken out to handle undefined return (avoid false positive for
// chainable)

Y.NodeList.importMethod(Y.Node.prototype, ['getStyle', 'getComputedStyle', 'setStyle', 'setStyles']);
})(Y);
/**
 * @module node
 * @submodule node-base
 */

var Y_Node = Y.Node;

Y.mix(Y_Node.prototype, {
    /**
     * Makes the node visible.
     * If the "transition" module is loaded, show optionally
     * animates the showing of the node using either the default
     * transition effect ('fadeIn'), or the given named effect.
     * @method show
     * @for Node
     * @param {String} name A named Transition effect to use as the show effect.
     * @param {Object} config Options to use with the transition.
     * @param {Function} callback An optional function to run after the transition completes.
     * @chainable
     */
    show: function(callback) {
        callback = arguments[arguments.length - 1];
        this.toggleView(true, callback);
        return this;
    },

    /**
     * The implementation for showing nodes.
     * Default is to remove the hidden attribute and reset the CSS style.display property.
     * @method _show
     * @protected
     * @chainable
     */
    _show: function() {
        this.removeAttribute('hidden');

        // For back-compat we need to leave this in for browsers that
        // do not visually hide a node via the hidden attribute
        // and for users that check visibility based on style display.
        this.setStyle('display', '');

    },

    /**
    Returns whether the node is hidden by YUI or not. The hidden status is
    determined by the 'hidden' attribute and the value of the 'display' CSS
    property.

    @method _isHidden
    @return {Boolean} `true` if the node is hidden.
    @private
    **/
    _isHidden: function() {
        return  this.hasAttribute('hidden') || Y.DOM.getComputedStyle(this._node, 'display') === 'none';
    },

    /**
     * Displays or hides the node.
     * If the "transition" module is loaded, toggleView optionally
     * animates the toggling of the node using given named effect.
     * @method toggleView
     * @for Node
     * @param {Boolean} [on] An optional boolean value to force the node to be shown or hidden
     * @param {Function} [callback] An optional function to run after the transition completes.
     * @chainable
     */
    toggleView: function(on, callback) {
        this._toggleView.apply(this, arguments);
        return this;
    },

    _toggleView: function(on, callback) {
        callback = arguments[arguments.length - 1];

        // base on current state if not forcing
        if (typeof on != 'boolean') {
            on = (this._isHidden()) ? 1 : 0;
        }

        if (on) {
            this._show();
        }  else {
            this._hide();
        }

        if (typeof callback == 'function') {
            callback.call(this);
        }

        return this;
    },

    /**
     * Hides the node.
     * If the "transition" module is loaded, hide optionally
     * animates the hiding of the node using either the default
     * transition effect ('fadeOut'), or the given named effect.
     * @method hide
     * @param {String} name A named Transition effect to use as the show effect.
     * @param {Object} config Options to use with the transition.
     * @param {Function} callback An optional function to run after the transition completes.
     * @chainable
     */
    hide: function(callback) {
        callback = arguments[arguments.length - 1];
        this.toggleView(false, callback);
        return this;
    },

    /**
     * The implementation for hiding nodes.
     * Default is to set the hidden attribute to true and set the CSS style.display to 'none'.
     * @method _hide
     * @protected
     * @chainable
     */
    _hide: function() {
        this.setAttribute('hidden', 'hidden');

        // For back-compat we need to leave this in for browsers that
        // do not visually hide a node via the hidden attribute
        // and for users that check visibility based on style display.
        this.setStyle('display', 'none');
    }
});

Y.NodeList.importMethod(Y.Node.prototype, [
    /**
     * Makes each node visible.
     * If the "transition" module is loaded, show optionally
     * animates the showing of the node using either the default
     * transition effect ('fadeIn'), or the given named effect.
     * @method show
     * @param {String} name A named Transition effect to use as the show effect.
     * @param {Object} config Options to use with the transition.
     * @param {Function} callback An optional function to run after the transition completes.
     * @for NodeList
     * @chainable
     */
    'show',

    /**
     * Hides each node.
     * If the "transition" module is loaded, hide optionally
     * animates the hiding of the node using either the default
     * transition effect ('fadeOut'), or the given named effect.
     * @method hide
     * @param {String} name A named Transition effect to use as the show effect.
     * @param {Object} config Options to use with the transition.
     * @param {Function} callback An optional function to run after the transition completes.
     * @chainable
     */
    'hide',

    /**
     * Displays or hides each node.
     * If the "transition" module is loaded, toggleView optionally
     * animates the toggling of the nodes using given named effect.
     * @method toggleView
     * @param {Boolean} [on] An optional boolean value to force the nodes to be shown or hidden
     * @param {Function} [callback] An optional function to run after the transition completes.
     * @chainable
     */
    'toggleView'
]);


}, '3.17.2', {"requires": ["dom-style", "node-base"]});


/***/ }),

/***/ 159585:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('oop', function (Y, NAME) {

/**
Adds object inheritance and manipulation utilities to the YUI instance. This
module is required by most YUI components.

@module oop
**/

var L            = Y.Lang,
    A            = Y.Array,
    OP           = Object.prototype,
    CLONE_MARKER = '_~yuim~_',

    hasOwn   = OP.hasOwnProperty,
    toString = OP.toString;

/**
Calls the specified _action_ method on _o_ if it exists. Otherwise, if _o_ is an
array, calls the _action_ method on `Y.Array`, or if _o_ is an object, calls the
_action_ method on `Y.Object`.

If _o_ is an array-like object, it will be coerced to an array.

This is intended to be used with array/object iteration methods that share
signatures, such as `each()`, `some()`, etc.

@method dispatch
@param {Object} o Array or object to dispatch to.
@param {Function} f Iteration callback.
    @param {Mixed} f.value Value being iterated.
    @param {Mixed} f.key Current object key or array index.
    @param {Mixed} f.object Object or array being iterated.
@param {Object} c `this` object to bind the iteration callback to.
@param {Boolean} proto If `true`, prototype properties of objects will be
    iterated.
@param {String} action Function name to be dispatched on _o_. For example:
    'some', 'each', etc.
@private
@return {Mixed} Returns the value returned by the chosen iteration action, which
    varies.
**/
function dispatch(o, f, c, proto, action) {
    if (o && o[action] && o !== Y) {
        return o[action].call(o, f, c);
    } else {
        switch (A.test(o)) {
            case 1:
                return A[action](o, f, c);
            case 2:
                return A[action](Y.Array(o, 0, true), f, c);
            default:
                return Y.Object[action](o, f, c, proto);
        }
    }
}

/**
Augments the _receiver_ with prototype properties from the _supplier_. The
receiver may be a constructor function or an object. The supplier must be a
constructor function.

If the _receiver_ is an object, then the _supplier_ constructor will be called
immediately after _receiver_ is augmented, with _receiver_ as the `this` object.

If the _receiver_ is a constructor function, then all prototype methods of
_supplier_ that are copied to _receiver_ will be sequestered, and the
_supplier_ constructor will not be called immediately. The first time any
sequestered method is called on the _receiver_'s prototype, all sequestered
methods will be immediately copied to the _receiver_'s prototype, the
_supplier_'s constructor will be executed, and finally the newly unsequestered
method that was called will be executed.

This sequestering logic sounds like a bunch of complicated voodoo, but it makes
it cheap to perform frequent augmentation by ensuring that suppliers'
constructors are only called if a supplied method is actually used. If none of
the supplied methods is ever used, then there's no need to take the performance
hit of calling the _supplier_'s constructor.

@method augment
@param {Function|Object} receiver Object or function to be augmented.
@param {Function} supplier Function that supplies the prototype properties with
  which to augment the _receiver_.
@param {Boolean} [overwrite=false] If `true`, properties already on the receiver
  will be overwritten if found on the supplier's prototype.
@param {String[]} [whitelist] An array of property names. If specified,
  only the whitelisted prototype properties will be applied to the receiver, and
  all others will be ignored.
@param {Array|any} [args] Argument or array of arguments to pass to the
  supplier's constructor when initializing.
@return {Function} Augmented object.
@for YUI
**/
Y.augment = function (receiver, supplier, overwrite, whitelist, args) {
    var rProto    = receiver.prototype,
        sequester = rProto && supplier,
        sProto    = supplier.prototype,
        to        = rProto || receiver,

        copy,
        newPrototype,
        replacements,
        sequestered,
        unsequester;

    args = args ? Y.Array(args) : [];

    if (sequester) {
        newPrototype = {};
        replacements = {};
        sequestered  = {};

        copy = function (value, key) {
            if (overwrite || !(key in rProto)) {
                if (toString.call(value) === '[object Function]') {
                    sequestered[key] = value;

                    newPrototype[key] = replacements[key] = function () {
                        return unsequester(this, value, arguments);
                    };
                } else {
                    newPrototype[key] = value;
                }
            }
        };

        unsequester = function (instance, fn, fnArgs) {
            // Unsequester all sequestered functions.
            for (var key in sequestered) {
                if (hasOwn.call(sequestered, key)
                        && instance[key] === replacements[key]) {

                    instance[key] = sequestered[key];
                }
            }

            // Execute the supplier constructor.
            supplier.apply(instance, args);

            // Finally, execute the original sequestered function.
            return fn.apply(instance, fnArgs);
        };

        if (whitelist) {
            Y.Array.each(whitelist, function (name) {
                if (name in sProto) {
                    copy(sProto[name], name);
                }
            });
        } else {
            Y.Object.each(sProto, copy, null, true);
        }
    }

    Y.mix(to, newPrototype || sProto, overwrite, whitelist);

    if (!sequester) {
        supplier.apply(to, args);
    }

    return receiver;
};

/**
 * Copies object properties from the supplier to the receiver. If the target has
 * the property, and the property is an object, the target object will be
 * augmented with the supplier's value.
 *
 * @method aggregate
 * @param {Object} receiver Object to receive the augmentation.
 * @param {Object} supplier Object that supplies the properties with which to
 *     augment the receiver.
 * @param {Boolean} [overwrite=false] If `true`, properties already on the receiver
 *     will be overwritten if found on the supplier.
 * @param {String[]} [whitelist] Whitelist. If supplied, only properties in this
 *     list will be applied to the receiver.
 * @return {Object} Augmented object.
 */
Y.aggregate = function(r, s, ov, wl) {
    return Y.mix(r, s, ov, wl, 0, true);
};

/**
 * Utility to set up the prototype, constructor and superclass properties to
 * support an inheritance strategy that can chain constructors and methods.
 * Static members will not be inherited.
 *
 * @method extend
 * @param {function} r   the object to modify.
 * @param {function} s the object to inherit.
 * @param {object} px prototype properties to add/override.
 * @param {object} sx static properties to add/override.
 * @return {object} the extended object.
 */
Y.extend = function(r, s, px, sx) {
    if (!s || !r) {
        Y.error('extend failed, verify dependencies');
    }

    var sp = s.prototype, rp = Y.Object(sp);
    r.prototype = rp;

    rp.constructor = r;
    r.superclass = sp;

    // assign constructor property
    if (s != Object && sp.constructor == OP.constructor) {
        sp.constructor = s;
    }

    // add prototype overrides
    if (px) {
        Y.mix(rp, px, true);
    }

    // add object overrides
    if (sx) {
        Y.mix(r, sx, true);
    }

    return r;
};

/**
 * Executes the supplied function for each item in
 * a collection.  Supports arrays, objects, and
 * NodeLists
 * @method each
 * @param {object} o the object to iterate.
 * @param {function} f the function to execute.  This function
 * receives the value, key, and object as parameters.
 * @param {object} c the execution context for the function.
 * @param {boolean} proto if true, prototype properties are
 * iterated on objects.
 * @return {YUI} the YUI instance.
 */
Y.each = function(o, f, c, proto) {
    return dispatch(o, f, c, proto, 'each');
};

/**
 * Executes the supplied function for each item in
 * a collection.  The operation stops if the function
 * returns true. Supports arrays, objects, and
 * NodeLists.
 * @method some
 * @param {object} o the object to iterate.
 * @param {function} f the function to execute.  This function
 * receives the value, key, and object as parameters.
 * @param {object} c the execution context for the function.
 * @param {boolean} proto if true, prototype properties are
 * iterated on objects.
 * @return {boolean} true if the function ever returns true,
 * false otherwise.
 */
Y.some = function(o, f, c, proto) {
    return dispatch(o, f, c, proto, 'some');
};

/**
Deep object/array copy. Function clones are actually wrappers around the
original function. Array-like objects are treated as arrays. Primitives are
returned untouched. Optionally, a function can be provided to handle other data
types, filter keys, validate values, etc.

**Note:** Cloning a non-trivial object is a reasonably heavy operation, due to
the need to recursively iterate down non-primitive properties. Clone should be
used only when a deep clone down to leaf level properties is explicitly
required. This method will also

In many cases (for example, when trying to isolate objects used as hashes for
configuration properties), a shallow copy, using `Y.merge()` is normally
sufficient. If more than one level of isolation is required, `Y.merge()` can be
used selectively at each level which needs to be isolated from the original
without going all the way to leaf properties.

@method clone
@param {object} o what to clone.
@param {boolean} safe if true, objects will not have prototype items from the
    source. If false, they will. In this case, the original is initially
    protected, but the clone is not completely immune from changes to the source
    object prototype. Also, cloned prototype items that are deleted from the
    clone will result in the value of the source prototype being exposed. If
    operating on a non-safe clone, items should be nulled out rather than
    deleted.
@param {function} f optional function to apply to each item in a collection; it
    will be executed prior to applying the value to the new object.
    Return false to prevent the copy.
@param {object} c optional execution context for f.
@param {object} owner Owner object passed when clone is iterating an object.
    Used to set up context for cloned functions.
@param {object} cloned hash of previously cloned objects to avoid multiple
    clones.
@return {Array|Object} the cloned object.
**/
Y.clone = function(o, safe, f, c, owner, cloned) {
    var o2, marked, stamp;

    // Does not attempt to clone:
    //
    // * Non-typeof-object values, "primitive" values don't need cloning.
    //
    // * YUI instances, cloning complex object like YUI instances is not
    //   advised, this is like cloning the world.
    //
    // * DOM nodes (#2528250), common host objects like DOM nodes cannot be
    //   "subclassed" in Firefox and old versions of IE. Trying to use
    //   `Object.create()` or `Y.extend()` on a DOM node will throw an error in
    //   these browsers.
    //
    // Instad, the passed-in `o` will be return as-is when it matches one of the
    // above criteria.
    if (!L.isObject(o) ||
            Y.instanceOf(o, YUI) ||
            (o.addEventListener || o.attachEvent)) {

        return o;
    }

    marked = cloned || {};

    switch (L.type(o)) {
        case 'date':
            return new Date(o);
        case 'regexp':
            // if we do this we need to set the flags too
            // return new RegExp(o.source);
            return o;
        case 'function':
            // o2 = Y.bind(o, owner);
            // break;
            return o;
        case 'array':
            o2 = [];
            break;
        default:

            // #2528250 only one clone of a given object should be created.
            if (o[CLONE_MARKER]) {
                return marked[o[CLONE_MARKER]];
            }

            stamp = Y.guid();

            if (safe) {
              o2 = {}
            } else {
              // sqsp change to YUI
              // Model data first set by `immer` makes each field have property `writeable: false`. We shallow clone
              // o so o2's prototype fields are writeable and can be put on o2 properly in Y.each below
              var prototype = {};
              for (var keyToCopyToPrototype in o) {
                if (o.hasOwnProperty(keyToCopyToPrototype)) {
                  prototype[keyToCopyToPrototype] = o[keyToCopyToPrototype];
                }
              }
              o2 = Y.Object(prototype);
            }

            o[CLONE_MARKER] = stamp;
            marked[stamp] = o;
    }

    Y.each(o, function(v, k) {
        if ((k || k === 0) && (!f || (f.call(c || this, v, k, this, o) !== false))) {
            if (k !== CLONE_MARKER) {
                if (k == 'prototype') {
                    // skip the prototype
                // } else if (o[k] === o) {
                //     this[k] = this;
                } else {
                    this[k] =
                        Y.clone(v, safe, f, c, owner || o, marked);
                }
            }
        }
    }, o2);

    if (!cloned) {
        Y.Object.each(marked, function(v, k) {
            if (v[CLONE_MARKER]) {
                try {
                    delete v[CLONE_MARKER];
                } catch (e) {
                    v[CLONE_MARKER] = null;
                }
            }
        }, this);
        marked = null;
    }

    return o2;
};

/**
 * Returns a function that will execute the supplied function in the
 * supplied object's context, optionally adding any additional
 * supplied parameters to the beginning of the arguments collection the
 * supplied to the function.
 *
 * @method bind
 * @param {Function|String} f the function to bind, or a function name
 * to execute on the context object.
 * @param {object} c the execution context.
 * @param {any} args* 0..n arguments to include before the arguments the
 * function is executed with.
 * @return {function} the wrapped function.
 */
Y.bind = function(f, c) {
    var xargs = arguments.length > 2 ?
            Y.Array(arguments, 2, true) : null;
    return function() {
        var fn = L.isString(f) ? c[f] : f,
            args = (xargs) ?
                xargs.concat(Y.Array(arguments, 0, true)) : arguments;
        return fn.apply(c || fn, args);
    };
};

/**
 * Returns a function that will execute the supplied function in the
 * supplied object's context, optionally adding any additional
 * supplied parameters to the end of the arguments the function
 * is executed with.
 *
 * @method rbind
 * @param {Function|String} f the function to bind, or a function name
 * to execute on the context object.
 * @param {object} c the execution context.
 * @param {any} args* 0..n arguments to append to the end of
 * arguments collection supplied to the function.
 * @return {function} the wrapped function.
 */
Y.rbind = function(f, c) {
    var xargs = arguments.length > 2 ? Y.Array(arguments, 2, true) : null;
    return function() {
        var fn = L.isString(f) ? c[f] : f,
            args = (xargs) ?
                Y.Array(arguments, 0, true).concat(xargs) : arguments;
        return fn.apply(c || fn, args);
    };
};


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 693373:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('plugin', function (Y, NAME) {

    /**
     * Provides the base Plugin class, which plugin developers should extend, when creating custom plugins
     *
     * @module plugin
     */

    /**
     * The base class for all Plugin instances.
     *
     * @class Plugin.Base
     * @extends Base
     * @param {Object} config Configuration object with property name/value pairs.
     */
    function Plugin(config) {
        if (! (this.hasImpl && this.hasImpl(Y.Plugin.Base)) ) {
            Plugin.superclass.constructor.apply(this, arguments);
        } else {
            Plugin.prototype.initializer.apply(this, arguments);
        }
    }

    /**
     * Object defining the set of attributes supported by the Plugin.Base class
     *
     * @property ATTRS
     * @type Object
     * @static
     */
    Plugin.ATTRS = {

        /**
         * The plugin's host object.
         *
         * @attribute host
         * @writeonce
         * @type Plugin.Host
         */
        host : {
            writeOnce: true
        }
    };

    /**
     * The string identifying the Plugin.Base class. Plugins extending
     * Plugin.Base should set their own NAME value.
     *
     * @property NAME
     * @type String
     * @static
     */
    Plugin.NAME = 'plugin';

    /**
     * The name of the property the the plugin will be attached to
     * when plugged into a Plugin Host. Plugins extending Plugin.Base,
     * should set their own NS value.
     *
     * @property NS
     * @type String
     * @static
     */
    Plugin.NS = 'plugin';

    Y.extend(Plugin, Y.Base, {

        /**
         * The list of event handles for event listeners or AOP injected methods
         * applied by the plugin to the host object.
         *
         * @property _handles
         * @private
         * @type Array
         * @value null
         */
        _handles: null,

        /**
         * Initializer lifecycle implementation.
         *
         * @method initializer
         * @param {Object} config Configuration object with property name/value pairs.
         */
        initializer : function(config) {
            this._handles = [];
        },

        /**
         * Destructor lifecycle implementation.
         *
         * Removes any event listeners or injected methods applied by the Plugin
         *
         * @method destructor
         */
        destructor: function() {
            // remove all handles
            if (this._handles) {
                for (var i = 0, l = this._handles.length; i < l; i++) {
                   this._handles[i].detach();
                }
            }
        },

        /**
         * Listens for the "on" moment of events fired by the host,
         * or injects code "before" a given method on the host.
         *
         * @method doBefore
         *
         * @param strMethod {String} The event to listen for, or method to inject logic before.
         * @param fn {Function} The handler function. For events, the "on" moment listener. For methods, the function to execute before the given method is executed.
         * @param context {Object} An optional context to call the handler with. The default context is the plugin instance.
         * @return handle {EventHandle} The detach handle for the handler.
         */
        doBefore: function(strMethod, fn, context) {
            var host = this.get("host"), handle;

            if (strMethod in host) { // method
                handle = this.beforeHostMethod(strMethod, fn, context);
            } else if (host.on) { // event
                handle = this.onHostEvent(strMethod, fn, context);
            }

            return handle;
        },

        /**
         * Listens for the "after" moment of events fired by the host,
         * or injects code "after" a given method on the host.
         *
         * @method doAfter
         *
         * @param strMethod {String} The event to listen for, or method to inject logic after.
         * @param fn {Function} The handler function. For events, the "after" moment listener. For methods, the function to execute after the given method is executed.
         * @param context {Object} An optional context to call the handler with. The default context is the plugin instance.
         * @return handle {EventHandle} The detach handle for the listener.
         */
        doAfter: function(strMethod, fn, context) {
            var host = this.get("host"), handle;

            if (strMethod in host) { // method
                handle = this.afterHostMethod(strMethod, fn, context);
            } else if (host.after) { // event
                handle = this.afterHostEvent(strMethod, fn, context);
            }

            return handle;
        },

        /**
         * Listens for the "on" moment of events fired by the host object.
         *
         * Listeners attached through this method will be detached when the plugin is unplugged.
         *
         * @method onHostEvent
         * @param {String | Object} type The event type.
         * @param {Function} fn The listener.
         * @param {Object} context The execution context. Defaults to the plugin instance.
         * @return handle {EventHandle} The detach handle for the listener.
         */
        onHostEvent : function(type, fn, context) {
            var handle = this.get("host").on(type, fn, context || this);
            this._handles.push(handle);
            return handle;
        },

        /**
         * Listens for the "on" moment of events fired by the host object one time only.
         * The listener is immediately detached when it is executed.
         *
         * Listeners attached through this method will be detached when the plugin is unplugged.
         *
         * @method onceHostEvent
         * @param {String | Object} type The event type.
         * @param {Function} fn The listener.
         * @param {Object} context The execution context. Defaults to the plugin instance.
         * @return handle {EventHandle} The detach handle for the listener.
         */
        onceHostEvent : function(type, fn, context) {
            var handle = this.get("host").once(type, fn, context || this);
            this._handles.push(handle);
            return handle;
        },

        /**
         * Listens for the "after" moment of events fired by the host object.
         *
         * Listeners attached through this method will be detached when the plugin is unplugged.
         *
         * @method afterHostEvent
         * @param {String | Object} type The event type.
         * @param {Function} fn The listener.
         * @param {Object} context The execution context. Defaults to the plugin instance.
         * @return handle {EventHandle} The detach handle for the listener.
         */
        afterHostEvent : function(type, fn, context) {
            var handle = this.get("host").after(type, fn, context || this);
            this._handles.push(handle);
            return handle;
        },

        /**
         * Listens for the "after" moment of events fired by the host object one time only.
         * The listener is immediately detached when it is executed.
         *
         * Listeners attached through this method will be detached when the plugin is unplugged.
         *
         * @method onceAfterHostEvent
         * @param {String | Object} type The event type.
         * @param {Function} fn The listener.
         * @param {Object} context The execution context. Defaults to the plugin instance.
         * @return handle {EventHandle} The detach handle for the listener.
         */
        onceAfterHostEvent : function(type, fn, context) {
            var handle = this.get("host").onceAfter(type, fn, context || this);
            this._handles.push(handle);
            return handle;
        },

        /**
         * Injects a function to be executed before a given method on host object.
         *
         * The function will be detached when the plugin is unplugged.
         *
         * @method beforeHostMethod
         * @param {String} method The name of the method to inject the function before.
         * @param {Function} fn The function to inject.
         * @param {Object} context The execution context. Defaults to the plugin instance.
         * @return handle {EventHandle} The detach handle for the injected function.
         */
        beforeHostMethod : function(strMethod, fn, context) {
            var handle = Y.Do.before(fn, this.get("host"), strMethod, context || this);
            this._handles.push(handle);
            return handle;
        },

        /**
         * Injects a function to be executed after a given method on host object.
         *
         * The function will be detached when the plugin is unplugged.
         *
         * @method afterHostMethod
         * @param {String} method The name of the method to inject the function after.
         * @param {Function} fn The function to inject.
         * @param {Object} context The execution context. Defaults to the plugin instance.
         * @return handle {EventHandle} The detach handle for the injected function.
         */
        afterHostMethod : function(strMethod, fn, context) {
            var handle = Y.Do.after(fn, this.get("host"), strMethod, context || this);
            this._handles.push(handle);
            return handle;
        },

        toString: function() {
            return this.constructor.NAME + '[' + this.constructor.NS + ']';
        }
    });

    Y.namespace("Plugin").Base = Plugin;


}, '3.17.2', {"requires": ["base-base"]});


/***/ }),

/***/ 786763:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('pluginhost-base', function (Y, NAME) {

    /**
     * Provides the augmentable PluginHost interface, which can be added to any class.
     * @module pluginhost
     */

    /**
     * Provides the augmentable PluginHost interface, which can be added to any class.
     * @module pluginhost-base
     */

    /**
     * <p>
     * An augmentable class, which provides the augmented class with the ability to host plugins.
     * It adds <a href="#method_plug">plug</a> and <a href="#method_unplug">unplug</a> methods to the augmented class, which can
     * be used to add or remove plugins from instances of the class.
     * </p>
     *
     * <p>Plugins can also be added through the constructor configuration object passed to the host class' constructor using
     * the "plugins" property. Supported values for the "plugins" property are those defined by the <a href="#method_plug">plug</a> method.
     *
     * For example the following code would add the AnimPlugin and IOPlugin to Overlay (the plugin host):
     * <xmp>
     * var o = new Overlay({plugins: [ AnimPlugin, {fn:IOPlugin, cfg:{section:"header"}}]});
     * </xmp>
     * </p>
     * <p>
     * Plug.Host's protected <a href="#method_initPlugins">_initPlugins</a> and <a href="#method_destroyPlugins">_destroyPlugins</a>
     * methods should be invoked by the host class at the appropriate point in the host's lifecyle.
     * </p>
     *
     * @class Plugin.Host
     */

    var L = Y.Lang;

    function PluginHost() {
        this._plugins = {};
    }

    PluginHost.prototype = {

        /**
         * Adds a plugin to the host object. This will instantiate the
         * plugin and attach it to the configured namespace on the host object.
         *
         * @method plug
         * @chainable
         * @param P {Function | Object |Array} Accepts the plugin class, or an
         * object with a "fn" property specifying the plugin class and
         * a "cfg" property specifying the configuration for the Plugin.
         * <p>
         * Additionally an Array can also be passed in, with the above function or
         * object values, allowing the user to add multiple plugins in a single call.
         * </p>
         * @param config (Optional) If the first argument is the plugin class, the second argument
         * can be the configuration for the plugin.
         * @return {Base} A reference to the host object
         */
        plug: function(Plugin, config) {
            var i, ln, ns;

            if (L.isArray(Plugin)) {
                for (i = 0, ln = Plugin.length; i < ln; i++) {
                    this.plug(Plugin[i]);
                }
            } else {
                if (Plugin && !L.isFunction(Plugin)) {
                    config = Plugin.cfg;
                    Plugin = Plugin.fn;
                }

                // Plugin should be fn by now
                if (Plugin && Plugin.NS) {
                    ns = Plugin.NS;

                    config = config || {};
                    config.host = this;

                    if (this.hasPlugin(ns)) {
                        // Update config
                        if (this[ns].setAttrs) {
                            this[ns].setAttrs(config);
                        }
                    } else {
                        // Create new instance
                        this[ns] = new Plugin(config);
                        this._plugins[ns] = Plugin;
                    }
                }
            }
            return this;
        },

        /**
         * Removes a plugin from the host object. This will destroy the
         * plugin instance and delete the namespace from the host object.
         *
         * @method unplug
         * @param {String | Function} plugin The namespace of the plugin, or the plugin class with the static NS namespace property defined. If not provided,
         * all registered plugins are unplugged.
         * @return {Base} A reference to the host object
         * @chainable
         */
        unplug: function(plugin) {
            var ns = plugin,
                plugins = this._plugins;

            if (plugin) {
                if (L.isFunction(plugin)) {
                    ns = plugin.NS;
                    if (ns && (!plugins[ns] || plugins[ns] !== plugin)) {
                        ns = null;
                    }
                }

                if (ns) {
                    if (this[ns]) {
                        if (this[ns].destroy) {
                            this[ns].destroy();
                        }
                        delete this[ns];
                    }
                    if (plugins[ns]) {
                        delete plugins[ns];
                    }
                }
            } else {
                for (ns in this._plugins) {
                    if (this._plugins.hasOwnProperty(ns)) {
                        this.unplug(ns);
                    }
                }
            }
            return this;
        },

        /**
         * Determines if a plugin has plugged into this host.
         *
         * @method hasPlugin
         * @param {String} ns The plugin's namespace
         * @return {Plugin} Returns a truthy value (the plugin instance) if present, or undefined if not.
         */
        hasPlugin : function(ns) {
            return (this._plugins[ns] && this[ns]);
        },

        /**
         * Initializes static plugins registered on the host (using the
         * Base.plug static method) and any plugins passed to the
         * instance through the "plugins" configuration property.
         *
         * @method _initPlugins
         * @param {Object} config The configuration object with property name/value pairs.
         * @private
         */

        _initPlugins: function(config) {
            this._plugins = this._plugins || {};

            if (this._initConfigPlugins) {
                this._initConfigPlugins(config);
            }
        },

        /**
         * Unplugs and destroys all plugins on the host
         * @method _destroyPlugins
         * @private
         */
        _destroyPlugins: function() {
            this.unplug();
        }
    };

    Y.namespace("Plugin").Host = PluginHost;


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 508996:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('pluginhost-config', function (Y, NAME) {

    /**
     * Adds pluginhost constructor configuration and static configuration support
     * @submodule pluginhost-config
     */

    var PluginHost = Y.Plugin.Host,
        L = Y.Lang;

    /**
     * A protected initialization method, used by the host class to initialize
     * plugin configurations passed the constructor, through the config object.
     *
     * Host objects should invoke this method at the appropriate time in their
     * construction lifecycle.
     *
     * @method _initConfigPlugins
     * @param {Object} config The configuration object passed to the constructor
     * @protected
     * @for Plugin.Host
     */
    PluginHost.prototype._initConfigPlugins = function(config) {

        // Class Configuration
        var classes = (this._getClasses) ? this._getClasses() : [this.constructor],
            plug = [],
            unplug = {},
            constructor, i, classPlug, classUnplug, pluginClassName;

        // TODO: Room for optimization. Can we apply statically/unplug in same pass?
        for (i = classes.length - 1; i >= 0; i--) {
            constructor = classes[i];

            classUnplug = constructor._UNPLUG;
            if (classUnplug) {
                // subclasses over-write
                Y.mix(unplug, classUnplug, true);
            }

            classPlug = constructor._PLUG;
            if (classPlug) {
                // subclasses over-write
                Y.mix(plug, classPlug, true);
            }
        }

        for (pluginClassName in plug) {
            if (plug.hasOwnProperty(pluginClassName)) {
                if (!unplug[pluginClassName]) {
                    this.plug(plug[pluginClassName]);
                }
            }
        }

        // User Configuration
        if (config && config.plugins) {
            this.plug(config.plugins);
        }
    };

    /**
     * Registers plugins to be instantiated at the class level (plugins
     * which should be plugged into every instance of the class by default).
     *
     * @method plug
     * @static
     *
     * @param {Function} hostClass The host class on which to register the plugins
     * @param {Function | Array} plugin Either the plugin class, an array of plugin classes or an array of objects (with fn and cfg properties defined)
     * @param {Object} config (Optional) If plugin is the plugin class, the configuration for the plugin
     * @for Plugin.Host
     */
    PluginHost.plug = function(hostClass, plugin, config) {
        // Cannot plug into Base, since Plugins derive from Base [ will cause infinite recurrsion ]
        var p, i, l, name;

        if (hostClass !== Y.Base) {
            hostClass._PLUG = hostClass._PLUG || {};

            if (!L.isArray(plugin)) {
                if (config) {
                    plugin = {fn:plugin, cfg:config};
                }
                plugin = [plugin];
            }

            for (i = 0, l = plugin.length; i < l;i++) {
                p = plugin[i];
                name = p.NAME || p.fn.NAME;
                hostClass._PLUG[name] = p;
            }
        }
    };

    /**
     * Unregisters any class level plugins which have been registered by the host class, or any
     * other class in the hierarchy.
     *
     * @method unplug
     * @static
     *
     * @param {Function} hostClass The host class from which to unregister the plugins
     * @param {Function | Array} plugin The plugin class, or an array of plugin classes
     * @for Plugin.Host
     */
    PluginHost.unplug = function(hostClass, plugin) {
        var p, i, l, name;

        if (hostClass !== Y.Base) {
            hostClass._UNPLUG = hostClass._UNPLUG || {};

            if (!L.isArray(plugin)) {
                plugin = [plugin];
            }

            for (i = 0, l = plugin.length; i < l; i++) {
                p = plugin[i];
                name = p.NAME;
                if (!hostClass._PLUG[name]) {
                    hostClass._UNPLUG[name] = p;
                } else {
                    delete hostClass._PLUG[name];
                }
            }
        }
    };


}, '3.17.2', {"requires": ["pluginhost-base"]});


/***/ }),

/***/ 244345:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('promise', function (Y, NAME) {

/**
Wraps the execution of asynchronous operations, providing a promise object that
can be used to subscribe to the various ways the operation may terminate.

When the operation completes successfully, call the Resolver's `resolve()`
method, passing any relevant response data for subscribers.  If the operation
encounters an error or is unsuccessful in some way, call `reject()`, again
passing any relevant data for subscribers.

The Resolver object should be shared only with the code resposible for
resolving or rejecting it. Public access for the Resolver is through its
_promise_, which is returned from the Resolver's `promise` property. While both
Resolver and promise allow subscriptions to the Resolver's state changes, the
promise may be exposed to non-controlling code. It is the preferable interface
for adding subscriptions.

Subscribe to state changes in the Resolver with the promise's
`then(callback, errback)` method.  `then()` wraps the passed callbacks in a
new Resolver and returns the corresponding promise, allowing chaining of
asynchronous or synchronous operations. E.g.
`promise.then(someAsyncFunc).then(anotherAsyncFunc)`

@module promise
@since 3.9.0
**/

var Lang  = Y.Lang,
    slice = [].slice;

/**
A promise represents a value that may not yet be available. Promises allow
you to chain asynchronous operations, write synchronous looking code and
handle errors throughout the process.

This constructor takes a function as a parameter where you can insert the logic
that fulfills or rejects this promise. The fulfillment value and the rejection
reason can be any JavaScript value. It's encouraged that rejection reasons be
error objects

<pre><code>
var fulfilled = new Y.Promise(function (resolve) {
    resolve('I am a fulfilled promise');
});

var rejected = new Y.Promise(function (resolve, reject) {
    reject(new Error('I am a rejected promise'));
});
</code></pre>

@class Promise
@constructor
@param {Function} fn A function where to insert the logic that resolves this
        promise. Receives `resolve` and `reject` functions as parameters.
        This function is called synchronously.
**/
function Promise(fn) {
    if (!(this instanceof Promise)) {
        return new Promise(fn);
    }

    var resolver = new Promise.Resolver(this);

    /**
    A reference to the resolver object that handles this promise

    @property _resolver
    @type Object
    @private
    */
    this._resolver = resolver;

    try {
        fn.call(this, function (value) {
            resolver.resolve(value);
        }, function (reason) {
            resolver.reject(reason);
        });
    } catch (e) {
        resolver.reject(e);
    }
}

Y.mix(Promise.prototype, {
    /**
    Schedule execution of a callback to either or both of "fulfill" and
    "reject" resolutions for this promise. The callbacks are wrapped in a new
    promise and that promise is returned.  This allows operation chaining ala
    `functionA().then(functionB).then(functionC)` where `functionA` returns
    a promise, and `functionB` and `functionC` _may_ return promises.

    Asynchronicity of the callbacks is guaranteed.

    @method then
    @param {Function} [callback] function to execute if the promise
                resolves successfully
    @param {Function} [errback] function to execute if the promise
                resolves unsuccessfully
    @return {Promise} A promise wrapping the resolution of either "resolve" or
                "reject" callback
    **/
    then: function (callback, errback) {
        var Constructor = this.constructor,
            resolver = this._resolver;

        // using this.constructor allows for customized promises to be
        // returned instead of plain ones
        return new Constructor(function (resolve, reject) {
            resolver._addCallbacks(
                // Check if callbacks are functions. If not, default to
                // `resolve` and `reject` respectively.
                // The wrapping of the callbacks is done here and not in
                // `_addCallbacks` because it is a feature specific to  `then`.
                // If `done` is added to promises it would call `_addCallbacks`
                // without defaulting to anything and without wrapping
                typeof callback === 'function' ?
                    Promise._wrap(resolve, reject, callback) : resolve,
                typeof errback === 'function' ?
                    Promise._wrap(resolve, reject, errback) : reject
            );
        });
    },

    /**
    A shorthand for `promise.then(undefined, callback)`.

    Returns a new promise and the error callback gets the same treatment as in
    `then`: errors get caught and turned into rejections, and the return value
    of the callback becomes the fulfilled value of the returned promise.

    @method catch
    @param [Function] errback Callback to be called in case this promise is
                        rejected
    @return {Promise} A new promise modified by the behavior of the error
                        callback
    **/
    'catch': function (errback) {
        return this.then(undefined, errback);
    },

    /**
    Returns the current status of the operation. Possible results are
    "pending", "fulfilled", and "rejected".

    @method getStatus
    @return {String}
    @deprecated
    **/
    getStatus: function () {
        return this._resolver.getStatus();
    }
});

/**
Wraps the callback in another function to catch exceptions and turn them into
rejections.

@method _wrap
@param {Function} resolve Resolving function of the resolver that
                    handles this promise
@param {Function} reject Rejection function of the resolver that
                    handles this promise
@param {Function} fn Callback to wrap
@return {Function}
@private
**/
Promise._wrap = function (resolve, reject, fn) {
    // callbacks and errbacks only get one argument
    return function (valueOrReason) {
        var result;

        // Promises model exception handling through callbacks
        // making both synchronous and asynchronous errors behave
        // the same way
        try {
            // Use the argument coming in to the callback/errback from the
            // resolution of the parent promise.
            // The function must be called as a normal function, with no
            // special value for |this|, as per Promises A+
            result = fn(valueOrReason);
        } catch (e) {
          if (e instanceof Error) {
            console.error(e.stack);
          } else {
            console.error('Non-error error: Please throw actual errors!' + '\n' + e);
          }
            reject(e);
            return;
        }

        resolve(result);
    };
};

/**
Checks if an object or value is a promise. This is cross-implementation
compatible, so promises returned from other libraries or native components
that are compatible with the Promises A+ spec should be recognized by this
method.

@method isPromise
@param {Any} obj The object to test
@return {Boolean} Whether the object is a promise or not
@static
**/
Promise.isPromise = function (obj) {
    var then;
    // We test promises by structure to be able to identify other
    // implementations' promises. This is important for cross compatibility and
    // In particular Y.when which should recognize any kind of promise
    // Use try...catch when retrieving obj.then. Return false if it throws
    // See Promises/A+ 1.1
    try {
        then = obj.then;
    } catch (_) {}
    return typeof then === 'function';
};

/**
Ensures that a certain value is a promise. If it is not a promise, it wraps it
in one.

This method can be copied or inherited in subclasses. In that case it will
check that the value passed to it is an instance of the correct class.
This means that `PromiseSubclass.resolve()` will always return instances of
`PromiseSubclass`.

@method resolve
@param {Any} Any object that may or may not be a promise
@return {Promise}
@static
**/
Promise.resolve = function (value) {
    return Promise.isPromise(value) && value.constructor === this ? value :
        /*jshint newcap: false */
        new this(function (resolve) {
        /*jshint newcap: true */
            resolve(value);
        });
};

/**
A shorthand for creating a rejected promise.

@method reject
@param {Any} reason Reason for the rejection of this promise. Usually an Error
    Object
@return {Promise} A rejected promise
@static
**/
Promise.reject = function (reason) {
    /*jshint newcap: false */
    return new this(function (resolve, reject) {
    /*jshint newcap: true */
        reject(reason);
    });
};

/**
Returns a promise that is resolved or rejected when all values are resolved or
any is rejected. This is useful for waiting for the resolution of multiple
promises, such as reading multiple files in Node.js or making multiple XHR
requests in the browser.

@method all
@param {Any[]} values An array of any kind of values, promises or not. If a value is not
@return [Promise] A promise for an array of all the fulfillment values
@static
**/
Promise.all = function (values) {
    var Promise = this;
    return new Promise(function (resolve, reject) {
        if (!Lang.isArray(values)) {
            reject(new TypeError('Promise.all expects an array of values or promises'));
            return;
        }

        var remaining = values.length,
            i         = 0,
            length    = values.length,
            results   = [];

        function oneDone(index) {
            return function (value) {
                results[index] = value;

                remaining--;

                if (!remaining) {
                    resolve(results);
                }
            };
        }

        if (length < 1) {
            return resolve(results);
        }

        for (; i < length; i++) {
            Promise.resolve(values[i]).then(oneDone(i), reject);
        }
    });
};

/**
Returns a promise that is resolved or rejected when any of values is either
resolved or rejected. Can be used for providing early feedback in the UI
while other operations are still pending.

@method race
@param {Any[]} values An array of values or promises
@return {Promise}
@static
**/
Promise.race = function (values) {
    var Promise = this;
    return new Promise(function (resolve, reject) {
        if (!Lang.isArray(values)) {
            reject(new TypeError('Promise.race expects an array of values or promises'));
            return;
        }
        
        // just go through the list and resolve and reject at the first change
        // This abuses the fact that calling resolve/reject multiple times
        // doesn't change the state of the returned promise
        for (var i = 0, count = values.length; i < count; i++) {
            Promise.resolve(values[i]).then(resolve, reject);
        }
    });
};

Y.Promise = Promise;
/**
Represents an asynchronous operation. Provides a
standard API for subscribing to the moment that the operation completes either
successfully (`fulfill()`) or unsuccessfully (`reject()`).

@class Promise.Resolver
@constructor
@param {Promise} promise The promise instance this resolver will be handling
**/
function Resolver(promise) {
    /**
    List of success callbacks

    @property _callbacks
    @type Array
    @private
    **/
    this._callbacks = [];

    /**
    List of failure callbacks

    @property _errbacks
    @type Array
    @private
    **/
    this._errbacks = [];

    /**
    The promise for this Resolver.

    @property promise
    @type Promise
    @deprecated
    **/
    this.promise = promise;

    /**
    The status of the operation. This property may take only one of the following
    values: 'pending', 'fulfilled' or 'rejected'.

    @property _status
    @type String
    @default 'pending'
    @private
    **/
    this._status = 'pending';

    /**
    This value that this promise represents.

    @property _result
    @type Any
    @private
    **/
    this._result = null;
}

Y.mix(Resolver.prototype, {
    /**
    Resolves the promise, signaling successful completion of the
    represented operation. All "onFulfilled" subscriptions are executed and passed
    the value provided to this method. After calling `fulfill()`, `reject()` and
    `notify()` are disabled.

    @method fulfill
    @param {Any} value Value to pass along to the "onFulfilled" subscribers
    **/
    fulfill: function (value) {
        if (this._status === 'pending') {
            this._result = value;
            this._status = 'fulfilled';
        }

        if (this._status === 'fulfilled') {
            this._notify(this._callbacks, this._result);

            // Reset the callback list so that future calls to fulfill()
            // won't call the same callbacks again. Promises keep a list
            // of callbacks, they're not the same as events. In practice,
            // calls to fulfill() after the first one should not be made by
            // the user but by then()
            this._callbacks = [];

            // Once a promise gets fulfilled it can't be rejected, so
            // there is no point in keeping the list. Remove it to help
            // garbage collection
            this._errbacks = null;
        }
    },

    /**
    Resolves the promise, signaling *un*successful completion of the
    represented operation. All "onRejected" subscriptions are executed with
    the value provided to this method. After calling `reject()`, `resolve()`
    and `notify()` are disabled.

    @method reject
    @param {Any} value Value to pass along to the "reject" subscribers
    **/
    reject: function (reason) {
        if (this._status === 'pending') {
            this._result = reason;
            this._status = 'rejected';
        }

        if (this._status === 'rejected') {
            this._notify(this._errbacks, this._result);

            // See fulfill()
            this._callbacks = null;
            this._errbacks = [];
        }
    },

    /*
    Given a certain value A passed as a parameter, this method resolves the
    promise to the value A.

    If A is a promise, `resolve` will cause the resolver to adopt the state of A
    and once A is resolved, it will resolve the resolver's promise as well.
    This behavior "flattens" A by calling `then` recursively and essentially
    disallows promises-for-promises.

    This is the default algorithm used when using the function passed as the
    first argument to the promise initialization function. This means that
    the following code returns a promise for the value 'hello world':

        var promise1 = new Y.Promise(function (resolve) {
            resolve('hello world');
        });
        var promise2 = new Y.Promise(function (resolve) {
            resolve(promise1);
        });
        promise2.then(function (value) {
            assert(value === 'hello world'); // true
        });

    @method resolve
    @param [Any] value A regular JS value or a promise
    */
    resolve: function (value) {
        var self = this;

        if (Promise.isPromise(value)) {
            value.then(function (value) {
                self.resolve(value);
            }, function (reason) {
                self.reject(reason);
            });
        } else {
            this.fulfill(value);
        }
    },

    /**
    Schedule execution of a callback to either or both of "resolve" and
    "reject" resolutions for the Resolver.  The callbacks
    are wrapped in a new Resolver and that Resolver's corresponding promise
    is returned.  This allows operation chaining ala
    `functionA().then(functionB).then(functionC)` where `functionA` returns
    a promise, and `functionB` and `functionC` _may_ return promises.

    @method then
    @param {Function} [callback] function to execute if the Resolver
                resolves successfully
    @param {Function} [errback] function to execute if the Resolver
                resolves unsuccessfully
    @return {Promise} The promise of a new Resolver wrapping the resolution
                of either "resolve" or "reject" callback
    @deprecated
    **/
    then: function (callback, errback) {
        return this.promise.then(callback, errback);
    },

    /**
    Schedule execution of a callback to either or both of "resolve" and
    "reject" resolutions of this resolver. If the resolver is not pending,
    the correct callback gets called automatically.

    @method _addCallbacks
    @param {Function} [callback] function to execute if the Resolver
                resolves successfully
    @param {Function} [errback] function to execute if the Resolver
                resolves unsuccessfully
    @private
    **/
    _addCallbacks: function (callback, errback) {
        var callbackList = this._callbacks,
            errbackList  = this._errbacks,
            status       = this._status,
            result       = this._result;

        if (callbackList && typeof callback === 'function') {
            callbackList.push(callback);
        }
        if (errbackList && typeof errback === 'function') {
            errbackList.push(errback);
        }

        // If a promise is already fulfilled or rejected, notify the newly added
        // callbacks by calling fulfill() or reject()
        if (status === 'fulfilled') {
            this.fulfill(result);
        } else if (status === 'rejected') {
            this.reject(result);
        }
    },

    /**
    Returns the current status of the Resolver as a string "pending",
    "fulfilled", or "rejected".

    @method getStatus
    @return {String}
    @deprecated
    **/
    getStatus: function () {
        return this._status;
    },

    /**
    Executes an array of callbacks from a specified context, passing a set of
    arguments.

    @method _notify
    @param {Function[]} subs The array of subscriber callbacks
    @param {Any} result Value to pass the callbacks
    @protected
    **/
    _notify: function (subs, result) {
        // Since callback lists are reset synchronously, the subs list never
        // changes after _notify() receives it. Avoid calling Y.soon() for
        // an empty list
        if (subs.length) {
            // Calling all callbacks after Y.soon to guarantee
            // asynchronicity. Because setTimeout can cause unnecessary
            // delays that *can* become noticeable in some situations
            // (especially in Node.js)
            Y.soon(function () {
                var i, len;

                for (i = 0, len = subs.length; i < len; ++i) {
                    subs[i](result);
                }
            });
        }
    }

}, true);

Y.Promise.Resolver = Resolver;
/**
Abstraction API allowing you to interact with promises or raw values as if they
were promises. If a non-promise object is passed in, a new Resolver is created
and scheduled to resolve asynchronously with the provided value.

In either case, a promise is returned.  If either _callback_ or _errback_ are
provided, the promise returned is the one returned from calling
`promise.then(callback, errback)` on the provided or created promise.  If neither
are provided, the original promise is returned.

@for YUI
@method when
@param {Any} promise Promise object or value to wrap in a resolved promise
@param {Function} [callback] callback to execute if the promise is resolved
@param {Function} [errback] callback to execute if the promise is rejected
@return {Promise}
**/
Y.when = function (promise, callback, errback) {
    promise = Promise.resolve(promise);

    return (callback || errback) ? promise.then(callback, errback) : promise;
};
/**
Returns a new promise that will be resolved when all operations have completed.
Takes both any numer of values as arguments. If an argument is a not a promise,
it will be wrapped in a new promise, same as in `Y.when()`.

@for YUI
@method batch
@param {Any} operation* Any number of Y.Promise objects or regular JS values
@return {Promise} Promise to be fulfilled when all provided promises are
                    resolved
**/
Y.batch = function () {
    return Promise.all(slice.call(arguments));
};


}, '3.17.2', {"requires": ["timers"]});


/***/ }),

/***/ 668205:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('querystring-stringify-simple', function (Y, NAME) {

/*global Y */
/**
 * <p>Provides Y.QueryString.stringify method for converting objects to Query Strings.
 * This is a subset implementation of the full querystring-stringify.</p>
 * <p>This module provides the bare minimum functionality (encoding a hash of simple values),
 * without the additional support for nested data structures.  Every key-value pair is
 * encoded by encodeURIComponent.</p>
 * <p>This module provides a minimalistic way for io to handle  single-level objects
 * as transaction data.</p>
 *
 * @module querystring
 * @submodule querystring-stringify-simple
 */

var QueryString = Y.namespace("QueryString"),
    EUC = encodeURIComponent;


QueryString.stringify = function (obj, c) {
    var qs = [],
        // Default behavior is false; standard key notation.
        s = c && c.arrayKey ? true : false,
        key, i, l;

    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (Y.Lang.isArray(obj[key])) {
                for (i = 0, l = obj[key].length; i < l; i++) {
                    qs.push(EUC(s ? key + '[]' : key) + '=' + EUC(obj[key][i]));
                }
            }
            else {
                qs.push(EUC(key) + '=' + EUC(obj[key]));
            }
        }
    }

    return qs.join('&');
};


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 794964:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('querystring-stringify', function (Y, NAME) {

/**
 * Provides Y.QueryString.stringify method for converting objects to Query Strings.
 *
 * @module querystring
 * @submodule querystring-stringify
 */

var QueryString = Y.namespace("QueryString"),
    stack = [],
    L = Y.Lang;

/**
 * Provides Y.QueryString.escape method to be able to override default encoding
 * method.  This is important in cases where non-standard delimiters are used, if
 * the delimiters would not normally be handled properly by the builtin
 * (en|de)codeURIComponent functions.
 * Default: encodeURIComponent
 *
 * @method escape
 * @for QueryString
 * @static
 **/
QueryString.escape = encodeURIComponent;

/**
 * <p>Converts an arbitrary value to a Query String representation.</p>
 *
 * <p>Objects with cyclical references will trigger an exception.</p>
 *
 * @method stringify
 * @for QueryString
 * @public
 * @param obj {Any} any arbitrary value to convert to query string
 * @param cfg {Object} (optional) Configuration object.  The three
 * supported configurations are:
 * <ul><li>sep: When defined, the value will be used as the key-value
 * separator.  The default value is "&".</li>
 * <li>eq: When defined, the value will be used to join the key to
 * the value.  The default value is "=".</li>
 * <li>arrayKey: When set to true, the key of an array will have the
 * '[]' notation appended to the key.  The default value is false.
 * </li></ul>
 * @param name {String} (optional) Name of the current key, for handling children recursively.
 * @static
 */
QueryString.stringify = function (obj, c, name) {
    var begin, end, i, l, n, s,
        sep = c && c.sep ? c.sep : "&",
        eq = c && c.eq ? c.eq : "=",
        aK = c && c.arrayKey ? c.arrayKey : false;

    if (L.isNull(obj) || L.isUndefined(obj) || L.isFunction(obj)) {
        return name ? QueryString.escape(name) + eq : '';
    }

    if (L.isBoolean(obj) || Object.prototype.toString.call(obj) === '[object Boolean]') {
        obj =+ obj;
    }

    if (L.isNumber(obj) || L.isString(obj)) {
        return QueryString.escape(name) + eq + QueryString.escape(obj);
    }

    if (L.isArray(obj)) {
        s = [];
        name = aK ? name + '[]' : name;
        l = obj.length;
        for (i = 0; i < l; i++) {
            s.push( QueryString.stringify(obj[i], c, name) );
        }

        return s.join(sep);
    }
    // now we know it's an object.

    // Check for cyclical references in nested objects
    for (i = stack.length - 1; i >= 0; --i) {
        if (stack[i] === obj) {
            throw new Error("QueryString.stringify. Cyclical reference");
        }
    }

    stack.push(obj);
    s = [];
    begin = name ? name + '[' : '';
    end = name ? ']' : '';
    for (i in obj) {
        if (obj.hasOwnProperty(i)) {
            n = begin + i + end;
            s.push(QueryString.stringify(obj[i], c, n));
        }
    }

    stack.pop();
    s = s.join(sep);
    if (!s && name) {
        return name + "=";
    }

    return s;
};


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 18709:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('queue-promote', function (Y, NAME) {

/**
 * Adds methods promote, remove, and indexOf to Queue instances.
 *
 * @module queue-promote
 * @for Queue
 */

Y.mix(Y.Queue.prototype, {
    /**
     * Returns the current index in the queue of the specified item
     *
     * @method indexOf
     * @param needle {MIXED} the item to search for
     * @return {Number} the index of the item or -1 if not found
     */
    indexOf : function (callback) {
        return Y.Array.indexOf(this._q, callback);
    },

    /**
     * Moves the referenced item to the head of the queue
     *
     * @method promote
     * @param item {MIXED} an item in the queue
     */
    promote : function (callback) {
        var index = this.indexOf(callback);

        if (index > -1) {
            this._q.unshift(this._q.splice(index,1)[0]);
        }
    },

    /**
     * Removes the referenced item from the queue
     *
     * @method remove
     * @param item {MIXED} an item in the queue
     */
    remove : function (callback) {
        var index = this.indexOf(callback);

        if (index > -1) {
            this._q.splice(index,1);
        }
    }

});


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 383324:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('selector-native', function (Y, NAME) {

(function(Y) {
/**
 * The selector-native module provides support for native querySelector
 * @module dom
 * @submodule selector-native
 * @for Selector
 */

/**
 * Provides support for using CSS selectors to query the DOM
 * @class Selector
 * @static
 * @for Selector
 */

Y.namespace('Selector'); // allow native module to standalone

var COMPARE_DOCUMENT_POSITION = 'compareDocumentPosition',
    OWNER_DOCUMENT = 'ownerDocument';

var Selector = {
    _types: {
        esc: {
            token: '\uE000',
            re: /\\[:\[\]\(\)#\.\'\>+~"]/gi
        },

        attr: {
            token: '\uE001',
            re: /(\[[^\]]*\])/g
        },

        pseudo: {
            token: '\uE002',
            re: /(\([^\)]*\))/g
        }
    },

    /**
     *  Use the native version of `querySelectorAll`, if it exists.
     *
     * @property useNative
     * @default true
     * @static
     */
    useNative: true,

    _escapeId: function(id) {
        if (id) {
            id = id.replace(/([:\[\]\(\)#\.'<>+~"])/g,'\\$1');
        }
        return id;
    },

    _compare: ('sourceIndex' in Y.config.doc.documentElement) ?
        function(nodeA, nodeB) {
            var a = nodeA.sourceIndex,
                b = nodeB.sourceIndex;

            if (a === b) {
                return 0;
            } else if (a > b) {
                return 1;
            }

            return -1;

        } : (Y.config.doc.documentElement[COMPARE_DOCUMENT_POSITION] ?
        function(nodeA, nodeB) {
            if (nodeA[COMPARE_DOCUMENT_POSITION](nodeB) & 4) {
                return -1;
            } else {
                return 1;
            }
        } :
        function(nodeA, nodeB) {
            var rangeA, rangeB, compare;
            if (nodeA && nodeB) {
                rangeA = nodeA[OWNER_DOCUMENT].createRange();
                rangeA.setStart(nodeA, 0);
                rangeB = nodeB[OWNER_DOCUMENT].createRange();
                rangeB.setStart(nodeB, 0);
                compare = rangeA.compareBoundaryPoints(1, rangeB); // 1 === Range.START_TO_END
            }

            return compare;

    }),

    _sort: function(nodes) {
        if (nodes) {
            nodes = Y.Array(nodes, 0, true);
            if (nodes.sort) {
                nodes.sort(Selector._compare);
            }
        }

        return nodes;
    },

    _deDupe: function(nodes) {
        var ret = [],
            i, node;

        for (i = 0; (node = nodes[i++]);) {
            if (!node._found) {
                ret[ret.length] = node;
                node._found = true;
            }
        }

        for (i = 0; (node = ret[i++]);) {
            node._found = null;
            node.removeAttribute('_found');
        }

        return ret;
    },

    /**
     * Retrieves a set of nodes based on a given CSS selector.
     * @method query
     *
     * @param {String} selector A CSS selector.
     * @param {HTMLElement} root optional A node to start the query from. Defaults to `Y.config.doc`.
     * @param {Boolean} firstOnly optional Whether or not to return only the first match.
     * @return {HTMLElement[]} The array of nodes that matched the given selector.
     * @static
     */
    query: function(selector, root, firstOnly, skipNative) {
        root = root || Y.config.doc;
        var ret = [],
            useNative = (Y.Selector.useNative && Y.config.doc.querySelector && !skipNative),
            queries = [[selector, root]],
            query,
            result,
            i,
            fn = (useNative) ? Y.Selector._nativeQuery : Y.Selector._bruteQuery;

        if (selector && fn) {
            // split group into seperate queries
            if (!skipNative && // already done if skipping
                    (!useNative || root.tagName)) { // split native when element scoping is needed
                queries = Selector._splitQueries(selector, root);
            }

            for (i = 0; (query = queries[i++]);) {
                result = fn(query[0], query[1], firstOnly);
                if (!firstOnly) { // coerce DOM Collection to Array
                    result = Y.Array(result, 0, true);
                }
                if (result) {
                    ret = ret.concat(result);
                }
            }

            if (queries.length > 1) { // remove dupes and sort by doc order
                ret = Selector._sort(Selector._deDupe(ret));
            }
        }

        return (firstOnly) ? (ret[0] || null) : ret;

    },

    _replaceSelector: function(selector) {
        var esc = Y.Selector._parse('esc', selector), // pull escaped colon, brackets, etc.
            attrs,
            pseudos;

        // first replace escaped chars, which could be present in attrs or pseudos
        selector = Y.Selector._replace('esc', selector);

        // then replace pseudos before attrs to avoid replacing :not([foo])
        pseudos = Y.Selector._parse('pseudo', selector);
        selector = Selector._replace('pseudo', selector);

        attrs = Y.Selector._parse('attr', selector);
        selector = Y.Selector._replace('attr', selector);

        return {
            esc: esc,
            attrs: attrs,
            pseudos: pseudos,
            selector: selector
        };
    },

    _restoreSelector: function(replaced) {
        var selector = replaced.selector;
        selector = Y.Selector._restore('attr', selector, replaced.attrs);
        selector = Y.Selector._restore('pseudo', selector, replaced.pseudos);
        selector = Y.Selector._restore('esc', selector, replaced.esc);
        return selector;
    },

    _replaceCommas: function(selector) {
        var replaced = Y.Selector._replaceSelector(selector),
            selector = replaced.selector;

        if (selector) {
            selector = selector.replace(/,/g, '\uE007');
            replaced.selector = selector;
            selector = Y.Selector._restoreSelector(replaced);
        }
        return selector;
    },

    // allows element scoped queries to begin with combinator
    // e.g. query('> p', document.body) === query('body > p')
    _splitQueries: function(selector, node) {
        if (selector.indexOf(',') > -1) {
            selector = Y.Selector._replaceCommas(selector);
        }

        var groups = selector.split('\uE007'), // split on replaced comma token
            queries = [],
            prefix = '',
            id,
            i,
            len;

        if (node) {
            // enforce for element scoping
            if (node.nodeType === 1) { // Elements only
                id = Y.Selector._escapeId(Y.DOM.getId(node));

                if (!id) {
                    id = Y.guid();
                    Y.DOM.setId(node, id);
                }

                prefix = '[id="' + id + '"] ';
            }

            for (i = 0, len = groups.length; i < len; ++i) {
                selector =  prefix + groups[i];
                queries.push([selector, node]);
            }
        }

        return queries;
    },

    _nativeQuery: function(selector, root, one) {
        if (
            (Y.UA.webkit || Y.UA.opera) &&          // webkit (chrome, safari) and Opera
            selector.indexOf(':checked') > -1 &&    // fail to pick up "selected"  with ":checked"
            (Y.Selector.pseudos && Y.Selector.pseudos.checked)
        ) {
            return Y.Selector.query(selector, root, one, true); // redo with skipNative true to try brute query
        }
        try {
            return root['querySelector' + (one ? '' : 'All')](selector);
        } catch(e) { // fallback to brute if available
            return Y.Selector.query(selector, root, one, true); // redo with skipNative true
        }
    },

    /**
     * Filters out nodes that do not match the given CSS selector.
     * @method filter
     *
     * @param {HTMLElement[]} nodes An array of nodes.
     * @param {String} selector A CSS selector to test each node against.
     * @return {HTMLElement[]} The nodes that matched the given CSS selector.
     * @static
     */
    filter: function(nodes, selector) {
        var ret = [],
            i, node;

        if (nodes && selector) {
            for (i = 0; (node = nodes[i++]);) {
                if (Y.Selector.test(node, selector)) {
                    ret[ret.length] = node;
                }
            }
        } else {
        }

        return ret;
    },

    /**
     * Determines whether or not the given node matches the given CSS selector.
     * @method test
     * 
     * @param {HTMLElement} node A node to test.
     * @param {String} selector A CSS selector to test the node against.
     * @param {HTMLElement} root optional A node to start the query from. Defaults to the parent document of the node.
     * @return {Boolean} Whether or not the given node matched the given CSS selector.
     * @static
     */
    test: function(node, selector, root) {
        var ret = false,
            useFrag = false,
            groups,
            parent,
            item,
            items,
            frag,
            id,
            i, j, group;

        if (node && node.tagName) { // only test HTMLElements

            if (typeof selector == 'function') { // test with function
                ret = selector.call(node, node);
            } else { // test with query
                // we need a root if off-doc
                groups = selector.split(',');
                if (!root && !Y.DOM.inDoc(node)) {
                    parent = node.parentNode;
                    if (parent) {
                        root = parent;
                    } else { // only use frag when no parent to query
                        frag = node[OWNER_DOCUMENT].createDocumentFragment();
                        frag.appendChild(node);
                        root = frag;
                        useFrag = true;
                    }
                }
                root = root || node[OWNER_DOCUMENT];

                id = Y.Selector._escapeId(Y.DOM.getId(node));
                if (!id) {
                    id = Y.guid();
                    Y.DOM.setId(node, id);
                }

                for (i = 0; (group = groups[i++]);) { // TODO: off-dom test
                    group += '[id="' + id + '"]';
                    items = Y.Selector.query(group, root);

                    for (j = 0; item = items[j++];) {
                        if (item === node) {
                            ret = true;
                            break;
                        }
                    }
                    if (ret) {
                        break;
                    }
                }

                if (useFrag) { // cleanup
                    frag.removeChild(node);
                }
            };
        }

        return ret;
    },

    /**
     * A convenience method to emulate Y.Node's aNode.ancestor(selector).
     * @method ancestor
     *
     * @param {HTMLElement} node A node to start the query from.
     * @param {String} selector A CSS selector to test the node against.
     * @param {Boolean} testSelf optional Whether or not to include the node in the scan.
     * @return {HTMLElement} The ancestor node matching the selector, or null.
     * @static
     */
    ancestor: function (node, selector, testSelf) {
        return Y.DOM.ancestor(node, function(n) {
            return Y.Selector.test(n, selector);
        }, testSelf);
    },

    _parse: function(name, selector) {
        return selector.match(Y.Selector._types[name].re);
    },

    _replace: function(name, selector) {
        var o = Y.Selector._types[name];
        return selector.replace(o.re, o.token);
    },

    _restore: function(name, selector, items) {
        if (items) {
            var token = Y.Selector._types[name].token,
                i, len;
            for (i = 0, len = items.length; i < len; ++i) {
                selector = selector.replace(token, items[i]);
            }
        }
        return selector;
    }
};

Y.mix(Y.Selector, Selector, true);

})(Y);


}, '3.17.2', {"requires": ["dom-base"]});


/***/ }),

/***/ 723949:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('selector', function (Y, NAME) {



}, '3.17.2', {"requires": ["selector-native"]});


/***/ }),

/***/ 287917:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('timers', function (Y, NAME) {

/**
Provides utilities for timed asynchronous callback execution.
Y.soon is a setImmediate/process.nextTick/setTimeout wrapper.

This module includes [asap.js](https://github.com/kriskowal/asap) for scheduling
asynchronous tasks.

@module timers
@author Steven Olmsted
**/

// Hack. asap.js is written as a Node module and expects require, module and
// global to be available in the module's scope.
var module = {},
    global = Y.config.global;

// `asap` only requires a `queue` module that is bundled into this same file.
function require(mod) {
    return Queue;
}
"use strict";

module.exports = Queue;
function Queue(capacity) {
    this.capacity = this.snap(capacity);
    this.length = 0;
    this.front = 0;
    this.initialize();
}

Queue.prototype.push = function (value) {
    var length = this.length;
    if (this.capacity <= length) {
        this.grow(this.snap(this.capacity * this.growFactor));
    }
    var index = (this.front + length) & (this.capacity - 1);
    this[index] = value;
    this.length = length + 1;
};

Queue.prototype.shift = function () {
    var front = this.front;
    var result = this[front];

    this[front] = void 0;
    this.front = (front + 1) & (this.capacity - 1);
    this.length--;
    return result;
};

Queue.prototype.grow = function (capacity) {
    var oldFront = this.front;
    var oldCapacity = this.capacity;
    var oldQueue = new Array(oldCapacity);
    var length = this.length;

    copy(this, 0, oldQueue, 0, oldCapacity);
    this.capacity = capacity;
    this.initialize();
    this.front = 0;
    if (oldFront + length <= oldCapacity) {
        // Can perform direct linear copy
        copy(oldQueue, oldFront, this, 0, length);
    } else {
        // Cannot perform copy directly, perform as much as possible at the
        // end, and then copy the rest to the beginning of the buffer
        var lengthBeforeWrapping =
            length - ((oldFront + length) & (oldCapacity - 1));
        copy(
            oldQueue,
            oldFront,
            this,
            0,
            lengthBeforeWrapping
        );
        copy(
            oldQueue,
            0,
            this,
            lengthBeforeWrapping,
            length - lengthBeforeWrapping
        );
    }
};

Queue.prototype.initialize = function () {
    var length = this.capacity;
    for (var i = 0; i < length; ++i) {
        this[i] = void 0;
    }
};

Queue.prototype.snap = function (capacity) {
    if (typeof capacity !== "number") {
        return this.minCapacity;
    }
    return pow2AtLeast(
        Math.min(this.maxCapacity, Math.max(this.minCapacity, capacity))
    );
};

Queue.prototype.maxCapacity = (1 << 30) | 0;
Queue.prototype.minCapacity = 16;
Queue.prototype.growFactor = 8;

function copy(source, sourceIndex, target, targetIndex, length) {
    for (var index = 0; index < length; ++index) {
        target[index + targetIndex] = source[index + sourceIndex];
    }
}

function pow2AtLeast(n) {
    n = n >>> 0;
    n = n - 1;
    n = n | (n >> 1);
    n = n | (n >> 2);
    n = n | (n >> 4);
    n = n | (n >> 8);
    n = n | (n >> 16);
    return n + 1;
}
"use strict";

// Use the fastest possible means to execute a task in a future turn
// of the event loop.

// Queue is a circular buffer with good locality of reference and doesn't
// allocate new memory unless there are more than `InitialCapacity` parallel
// tasks in which case it will resize itself generously to x8 more capacity.
// The use case of asap should require no or few amount of resizes during
// runtime.
// Calling a task frees a slot immediately so if the calling
// has a side effect of queuing itself again, it can be sustained
// without additional memory
// Queue specifically uses
// http://en.wikipedia.org/wiki/Circular_buffer#Use_a_Fill_Count
// Because:
// 1. We need fast .length operation, since queue
//   could have changed after every iteration
// 2. Modulus can be negated by using power-of-two
//   capacities and replacing it with bitwise AND
// 3. It will not be used in a multi-threaded situation.

var Queue = require("./queue");

//1024 = InitialCapacity
var queue = new Queue(1024);
var flushing = false;
var requestFlush = void 0;
var hasSetImmediate = typeof setImmediate === "function";
var domain;

// Avoid shims from browserify.
// The existence of `global` in browsers is guaranteed by browserify.
var process = global.process;

// Note that some fake-Node environments,
// like the Mocha test runner, introduce a `process` global.
var isNodeJS = !!process && ({}).toString.call(process) === "[object process]";

function flush() {
    /* jshint loopfunc: true */

    while (queue.length > 0) {
        var task = queue.shift();

        try {
            task.call();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them to interrupt flushing!

                // Ensure continuation if an uncaught exception is suppressed
                // listening process.on("uncaughtException") or domain("error").
                requestFlush();

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }
    }

    flushing = false;
}

if (isNodeJS) {
    // Node.js
    requestFlush = function () {
        // Ensure flushing is not bound to any domain.
        var currentDomain = process.domain;
        if (currentDomain) {
            domain = domain || (1,require)("domain");
            domain.active = process.domain = null;
        }

        // Avoid tick recursion - use setImmediate if it exists.
        if (flushing && hasSetImmediate) {
            setImmediate(flush);
        } else {
            process.nextTick(flush);
        }

        if (currentDomain) {
            domain.active = process.domain = currentDomain;
        }
    };

} else if (hasSetImmediate) {
    // In IE10, or https://github.com/NobleJS/setImmediate
    requestFlush = function () {
        setImmediate(flush);
    };

} else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
    // working message ports the first time a page loads.
    channel.port1.onmessage = function () {
        requestFlush = requestPortFlush;
        channel.port1.onmessage = flush;
        flush();
    };
    var requestPortFlush = function () {
        // Opera requires us to provide a message payload, regardless of
        // whether we use it.
        channel.port2.postMessage(0);
    };
    requestFlush = function () {
        setTimeout(flush, 0);
        requestPortFlush();
    };

} else {
    // old browsers
    requestFlush = function () {
        setTimeout(flush, 0);
    };
}

function asap(task) {
    if (isNodeJS && process.domain) {
        task = process.domain.bind(task);
    }

    queue.push(task);

    if (!flushing) {
        requestFlush();
        flushing = true;
    }
};

module.exports = asap;
/**
Y.soon accepts a callback function.  The callback function will be called
once in a future turn of the JavaScript event loop.  If the function
requires a specific execution context or arguments, wrap it with Y.bind.
Y.soon returns an object with a cancel method.  If the cancel method is
called before the callback function, the callback function won't be
called.

@method soon
@for YUI
@param {Function} callbackFunction
@return {Object} An object with a cancel method.  If the cancel method is
    called before the callback function, the callback function won't be
    called.
**/
function soon(callbackFunction) {
    var canceled;

    soon._asynchronizer(function () {
        // Some asynchronizers may provide their own cancellation
        // methods such as clearImmediate or clearTimeout but some
        // asynchronizers do not.  For simplicity, cancellation is
        // entirely handled here rather than wrapping the other methods.
        // All asynchronizers are expected to always call this anonymous
        // function.
        if (!canceled) {
            callbackFunction();
        }
    });

    return {
        cancel: function () {
            canceled = 1;
        }
    };
}

soon._asynchronizer = asap;
soon._impl = 'asap';

Y.soon = soon;


}, '3.17.2', {"requires": ["yui-base"]});


/***/ }),

/***/ 165221:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('transition', function (Y, NAME) {

/**
* Provides the transition method for Node.
* Transition has no API of its own, but adds the transition method to Node.
*
* @module transition
* @requires node-style
*/

var CAMEL_VENDOR_PREFIX = '',
    VENDOR_PREFIX = '',
    DOCUMENT = Y.config.doc,
    DOCUMENT_ELEMENT = 'documentElement',
    DOCUMENT_STYLE = DOCUMENT[DOCUMENT_ELEMENT].style,
    TRANSITION_CAMEL = 'transition',
    TRANSITION_PROPERTY_CAMEL = 'transitionProperty',
    TRANSITION_PROPERTY,
    TRANSITION_DURATION,
    TRANSITION_TIMING_FUNCTION,
    TRANSITION_DELAY,
    TRANSITION_END,
    ON_TRANSITION_END,

    EMPTY_OBJ = {},

    VENDORS = [
        'Webkit',
        'Moz'
    ],

    VENDOR_TRANSITION_END = {
        Webkit: 'webkitTransitionEnd'
    },

/**
 * A class for constructing transition instances.
 * Adds the "transition" method to Node.
 * @class Transition
 * @constructor
 */

Transition = function() {
    this.init.apply(this, arguments);
};

// One off handling of transform-prefixing.
Transition._TRANSFORM = 'transform';

Transition._toCamel = function(property) {
    property = property.replace(/-([a-z])/gi, function(m0, m1) {
        return m1.toUpperCase();
    });

    return property;
};

Transition._toHyphen = function(property) {
    property = property.replace(/([A-Z]?)([a-z]+)([A-Z]?)/g, function(m0, m1, m2, m3) {
        var str = ((m1) ? '-' + m1.toLowerCase() : '') + m2;

        if (m3) {
            str += '-' + m3.toLowerCase();
        }

        return str;
    });

    return property;
};

Transition.SHOW_TRANSITION = 'fadeIn';
Transition.HIDE_TRANSITION = 'fadeOut';

Transition.useNative = false;

// Map transition properties to vendor-specific versions.
if ('transition' in DOCUMENT_STYLE
    && 'transitionProperty' in DOCUMENT_STYLE
    && 'transitionDuration' in DOCUMENT_STYLE
    && 'transitionTimingFunction' in DOCUMENT_STYLE
    && 'transitionDelay' in DOCUMENT_STYLE) {
    Transition.useNative = true;
    Transition.supported = true; // TODO: remove
} else {
    Y.Array.each(VENDORS, function(val) { // then vendor specific
        var property = val + 'Transition';
        if (property in DOCUMENT[DOCUMENT_ELEMENT].style) {
            CAMEL_VENDOR_PREFIX = val;
            VENDOR_PREFIX       = Transition._toHyphen(val) + '-';

            Transition.useNative = true;
            Transition.supported = true; // TODO: remove
            Transition._VENDOR_PREFIX = val;
        }
    });
}

// Map transform property to vendor-specific versions.
// One-off required for cssText injection.
if (typeof DOCUMENT_STYLE.transform === 'undefined') {
    Y.Array.each(VENDORS, function(val) { // then vendor specific
        var property = val + 'Transform';
        if (typeof DOCUMENT_STYLE[property] !== 'undefined') {
            Transition._TRANSFORM = property;
        }
    });
}

if (CAMEL_VENDOR_PREFIX) {
    TRANSITION_CAMEL          = CAMEL_VENDOR_PREFIX + 'Transition';
    TRANSITION_PROPERTY_CAMEL = CAMEL_VENDOR_PREFIX + 'TransitionProperty';
}

TRANSITION_PROPERTY        = VENDOR_PREFIX + 'transition-property';
TRANSITION_DURATION        = VENDOR_PREFIX + 'transition-duration';
TRANSITION_TIMING_FUNCTION = VENDOR_PREFIX + 'transition-timing-function';
TRANSITION_DELAY           = VENDOR_PREFIX + 'transition-delay';

TRANSITION_END    = 'transitionend';
ON_TRANSITION_END = 'on' + CAMEL_VENDOR_PREFIX.toLowerCase() + 'transitionend';
TRANSITION_END    = VENDOR_TRANSITION_END[CAMEL_VENDOR_PREFIX] || TRANSITION_END;

Transition.fx = {};
Transition.toggles = {};

Transition._hasEnd = {};

Transition._reKeywords = /^(?:node|duration|iterations|easing|delay|on|onstart|onend)$/i;

Y.Node.DOM_EVENTS[TRANSITION_END] = 1;

Transition.NAME = 'transition';

Transition.DEFAULT_EASING = 'ease';
Transition.DEFAULT_DURATION = 0.5;
Transition.DEFAULT_DELAY = 0;

Transition._nodeAttrs = {};

Transition.prototype = {
    constructor: Transition,
    init: function(node, config) {
        var anim = this;
        anim._node = node;
        if (!anim._running && config) {
            anim._config = config;
            node._transition = anim; // cache for reuse

            anim._duration = ('duration' in config) ?
                config.duration: anim.constructor.DEFAULT_DURATION;

            anim._delay = ('delay' in config) ?
                config.delay: anim.constructor.DEFAULT_DELAY;

            anim._easing = config.easing || anim.constructor.DEFAULT_EASING;
            anim._count = 0; // track number of animated properties
            anim._running = false;

        }

        return anim;
    },

    addProperty: function(prop, config) {
        var anim = this,
            node = this._node,
            uid = Y.stamp(node),
            nodeInstance = Y.one(node),
            attrs = Transition._nodeAttrs[uid],
            computed,
            compareVal,
            dur,
            attr,
            val;

        if (!attrs) {
            attrs = Transition._nodeAttrs[uid] = {};
        }

        attr = attrs[prop];

        // might just be a value
        if (config && config.value !== undefined) {
            val = config.value;
        } else if (config !== undefined) {
            val = config;
            config = EMPTY_OBJ;
        }

        if (typeof val === 'function') {
            val = val.call(nodeInstance, nodeInstance);
        }

        if (attr && attr.transition) {
            // take control if another transition owns this property
            if (attr.transition !== anim) {
                attr.transition._count--; // remapping attr to this transition
            }
        }

        anim._count++; // properties per transition

        // make 0 async and fire events
        dur = ((typeof config.duration !== 'undefined') ? config.duration :
                    anim._duration) || 0.0001;

        attrs[prop] = {
            value: val,
            duration: dur,
            delay: (typeof config.delay !== 'undefined') ? config.delay :
                    anim._delay,

            easing: config.easing || anim._easing,

            transition: anim
        };

        // native end event doesnt fire when setting to same value
        // supplementing with timer
        // val may be a string or number (height: 0, etc), but computedStyle is always string
        computed = Y.DOM.getComputedStyle(node, prop);
        compareVal = (typeof val === 'string') ? computed : parseFloat(computed);

        if (Transition.useNative && compareVal === val) {
            setTimeout(function() {
                anim._onNativeEnd.call(node, {
                    propertyName: prop,
                    elapsedTime: dur
                });
            }, dur * 1000);
        }
    },

    removeProperty: function(prop) {
        var anim = this,
            attrs = Transition._nodeAttrs[Y.stamp(anim._node)];

        if (attrs && attrs[prop]) {
            delete attrs[prop];
            anim._count--;
        }

    },

    initAttrs: function(config) {
        var attr,
            node = this._node;

        if (config.transform && !config[Transition._TRANSFORM]) {
            config[Transition._TRANSFORM] = config.transform;
            delete config.transform; // TODO: copy
        }

        for (attr in config) {
            if (config.hasOwnProperty(attr) && !Transition._reKeywords.test(attr)) {
                this.addProperty(attr, config[attr]);

                // when size is auto or % webkit starts from zero instead of computed
                // (https://bugs.webkit.org/show_bug.cgi?id=16020)
                // TODO: selective set
                if (node.style[attr] === '') {
                    Y.DOM.setStyle(node, attr, Y.DOM.getComputedStyle(node, attr));
                }
            }
        }
    },

    /**
     * Starts or an animation.
     * @method run
     * @chainable
     * @private
     */
    run: function(callback) {
        var anim = this,
            node = anim._node,
            config = anim._config,
            data = {
                type: 'transition:start',
                config: config
            };


        if (!anim._running) {
            anim._running = true;

            if (config.on && config.on.start) {
                config.on.start.call(Y.one(node), data);
            }

            anim.initAttrs(anim._config);

            anim._callback = callback;
            anim._start();
        }


        return anim;
    },

    _start: function() {
        this._runNative();
    },

    _prepDur: function(dur) {
        dur = parseFloat(dur) * 1000;

        return dur + 'ms';
    },

    _runNative: function() {
        var anim = this,
            node = anim._node,
            uid = Y.stamp(node),
            style = node.style,
            computed = node.ownerDocument.defaultView.getComputedStyle(node),
            attrs = Transition._nodeAttrs[uid],
            cssText = '',
            cssTransition = computed[Transition._toCamel(TRANSITION_PROPERTY)],

            transitionText = TRANSITION_PROPERTY + ': ',
            duration = TRANSITION_DURATION + ': ',
            easing = TRANSITION_TIMING_FUNCTION + ': ',
            delay = TRANSITION_DELAY + ': ',
            hyphy,
            attr,
            name;

        // preserve existing transitions
        if (cssTransition !== 'all') {
            transitionText += cssTransition + ',';
            duration += computed[Transition._toCamel(TRANSITION_DURATION)] + ',';
            easing += computed[Transition._toCamel(TRANSITION_TIMING_FUNCTION)] + ',';
            delay += computed[Transition._toCamel(TRANSITION_DELAY)] + ',';

        }

        // run transitions mapped to this instance
        for (name in attrs) {
            hyphy = Transition._toHyphen(name);
            attr = attrs[name];
            if ((attr = attrs[name]) && attr.transition === anim) {
                if (name in node.style) { // only native styles allowed
                    duration += anim._prepDur(attr.duration) + ',';
                    delay += anim._prepDur(attr.delay) + ',';
                    easing += (attr.easing) + ',';

                    transitionText += hyphy + ',';
                    cssText += hyphy + ': ' + attr.value + '; ';
                } else {
                    this.removeProperty(name);
                }
            }
        }

        transitionText = transitionText.replace(/,$/, ';');
        duration = duration.replace(/,$/, ';');
        easing = easing.replace(/,$/, ';');
        delay = delay.replace(/,$/, ';');

        // only one native end event per node
        if (!Transition._hasEnd[uid]) {
            node.addEventListener(TRANSITION_END, anim._onNativeEnd, '');
            Transition._hasEnd[uid] = true;

        }

        style.cssText += transitionText + duration + easing + delay + cssText;

    },

    _end: function(elapsed) {
        var anim = this,
            node = anim._node,
            callback = anim._callback,
            config = anim._config,
            data = {
                type: 'transition:end',
                config: config,
                elapsedTime: elapsed
            },

            nodeInstance = Y.one(node);

        anim._running = false;
        anim._callback = null;

        if (node) {
            if (config.on && config.on.end) {
                setTimeout(function() { // IE: allow previous update to finish
                    config.on.end.call(nodeInstance, data);

                    // nested to ensure proper fire order
                    if (callback) {
                        callback.call(nodeInstance, data);
                    }

                }, 1);
            } else if (callback) {
                setTimeout(function() { // IE: allow previous update to finish
                    callback.call(nodeInstance, data);
                }, 1);
            }
        }

    },

    _endNative: function(name) {
        var node = this._node,
            value = node.ownerDocument.defaultView.getComputedStyle(node, '')[Transition._toCamel(TRANSITION_PROPERTY)];

        name = Transition._toHyphen(name);
        if (typeof value === 'string') {
            value = value.replace(new RegExp('(?:^|,\\s)' + name + ',?'), ',');
            value = value.replace(/^,|,$/, '');
            node.style[TRANSITION_CAMEL] = value;
        }
    },

    _onNativeEnd: function(e) {
        var node = this,
            uid = Y.stamp(node),
            event = e,//e._event,
            name = Transition._toCamel(event.propertyName),
            elapsed = event.elapsedTime,
            attrs = Transition._nodeAttrs[uid],
            attr = attrs[name],
            anim = (attr) ? attr.transition : null,
            data,
            config;

        if (anim) {
            anim.removeProperty(name);
            anim._endNative(name);
            config = anim._config[name];

            data = {
                type: 'propertyEnd',
                propertyName: name,
                elapsedTime: elapsed,
                config: config
            };

            if (config && config.on && config.on.end) {
                config.on.end.call(Y.one(node), data);
            }

            if (anim._count <= 0)  { // after propertyEnd fires
                anim._end(elapsed);
                node.style[TRANSITION_PROPERTY_CAMEL] = ''; // clean up style
            }
        }
    },

    destroy: function() {
        var anim = this,
            node = anim._node;

        if (node) {
            node.removeEventListener(TRANSITION_END, anim._onNativeEnd, false);
            anim._node = null;
        }
    }
};

Y.Transition = Transition;
Y.TransitionNative = Transition; // TODO: remove

/**
 *   Animate one or more css properties to a given value. Requires the "transition" module.
 *   <pre>example usage:
 *       Y.one('#demo').transition({
 *           duration: 1, // in seconds, default is 0.5
 *           easing: 'ease-out', // default is 'ease'
 *           delay: '1', // delay start for 1 second, default is 0
 *
 *           height: '10px',
 *           width: '10px',
 *
 *           opacity: { // per property
 *               value: 0,
 *               duration: 2,
 *               delay: 2,
 *               easing: 'ease-in'
 *           }
 *       });
 *   </pre>
 *   @for Node
 *   @method transition
 *   @param {Object} config An object containing one or more style properties, a duration and an easing.
 *   @param {Function} callback A function to run after the transition has completed.
 *   @chainable
*/
Y.Node.prototype.transition = function(name, config, callback) {
    var
        transitionAttrs = Transition._nodeAttrs[Y.stamp(this._node)],
        anim = (transitionAttrs) ? transitionAttrs.transition || null : null,
        fxConfig,
        prop;

    if (typeof name === 'string') { // named effect, pull config from registry
        if (typeof config === 'function') {
            callback = config;
            config = null;
        }

        fxConfig = Transition.fx[name];

        if (config && typeof config === 'object') {
            config = Y.clone(config);

            for (prop in fxConfig) {
                if (fxConfig.hasOwnProperty(prop)) {
                    if (! (prop in config)) {
                        config[prop] = fxConfig[prop];
                    }
                }
            }
        } else {
            config = fxConfig;
        }

    } else { // name is a config, config is a callback or undefined
        callback = config;
        config = name;
    }

    if (anim && !anim._running) {
        anim.init(this, config);
    } else {
        anim = new Transition(this._node, config);
    }

    anim.run(callback);
    return this;
};

Y.Node.prototype.show = function(name, config, callback) {
    this._show(); // show prior to transition
    if (name && Y.Transition) {
        if (typeof name !== 'string' && !name.push) { // named effect or array of effects supercedes default
            if (typeof config === 'function') {
                callback = config;
                config = name;
            }
            name = Transition.SHOW_TRANSITION;
        }
        this.transition(name, config, callback);
    }
    return this;
};

Y.NodeList.prototype.show = function(name, config, callback) {
    var nodes = this._nodes,
        i = 0,
        node;

    while ((node = nodes[i++])) {
        Y.one(node).show(name, config, callback);
    }

    return this;
};



var _wrapCallBack = function(anim, fn, callback) {
    return function() {
        if (fn) {
            fn.call(anim);
        }
        if (callback && typeof callback === 'function') {
            callback.apply(anim._node, arguments);
        }
    };
};

Y.Node.prototype.hide = function(name, config, callback) {
    if (name && Y.Transition) {
        if (typeof config === 'function') {
            callback = config;
            config = null;
        }

        callback = _wrapCallBack(this, this._hide, callback); // wrap with existing callback
        if (typeof name !== 'string' && !name.push) { // named effect or array of effects supercedes default
            if (typeof config === 'function') {
                callback = config;
                config = name;
            }
            name = Transition.HIDE_TRANSITION;
        }
        this.transition(name, config, callback);
    } else {
        this._hide();
    }
    return this;
};

Y.NodeList.prototype.hide = function(name, config, callback) {
    var nodes = this._nodes,
        i = 0,
        node;

    while ((node = nodes[i++])) {
        Y.one(node).hide(name, config, callback);
    }

    return this;
};

/**
 *   Animate one or more css properties to a given value. Requires the "transition" module.
 *   <pre>example usage:
 *       Y.all('.demo').transition({
 *           duration: 1, // in seconds, default is 0.5
 *           easing: 'ease-out', // default is 'ease'
 *           delay: '1', // delay start for 1 second, default is 0
 *
 *           height: '10px',
 *           width: '10px',
 *
 *           opacity: { // per property
 *               value: 0,
 *               duration: 2,
 *               delay: 2,
 *               easing: 'ease-in'
 *           }
 *       });
 *   </pre>
 *   @for NodeList
 *   @method transition
 *   @param {Object} config An object containing one or more style properties, a duration and an easing.
 *   @param {Function} callback A function to run after the transition has completed. The callback fires
 *       once per item in the NodeList.
 *   @param {Boolean} callbackOnce If true, the callback will be called only after the
 *       last transition has completed
 *   @chainable
*/
Y.NodeList.prototype.transition = function(config, callback, callbackOnce) {
    var nodes = this._nodes,
        size = this.size(),
         i = 0,
        callbackOnce = callbackOnce === true,
        node;

    while ((node = nodes[i++])) {
        if (i < size && callbackOnce){
            Y.one(node).transition(config);
        } else {
            Y.one(node).transition(config, callback);
        }
    }

    return this;
};

Y.Node.prototype.toggleView = function(name, on, callback) {
    this._toggles = this._toggles || [];
    callback = arguments[arguments.length - 1];

    if (typeof name !== 'string') { // no transition, just toggle
        on = name;
        this._toggleView(on, callback); // call original _toggleView in Y.Node
        return;
    }

    if (typeof on === 'function') { // Ignore "on" if used for callback argument.
        on = undefined;
    }

    if (typeof on === 'undefined' && name in this._toggles) { // reverse current toggle
        on = ! this._toggles[name];
    }

    on = (on) ? 1 : 0;
    if (on) {
        this._show();
    }  else {
        callback = _wrapCallBack(this, this._hide, callback);
    }

    this._toggles[name] = on;
    this.transition(Y.Transition.toggles[name][on], callback);

    return this;
};

Y.NodeList.prototype.toggleView = function(name, on, callback) {
    var nodes = this._nodes,
        i = 0,
        node;

    while ((node = nodes[i++])) {
        node = Y.one(node);
        node.toggleView.apply(node, arguments);
    }

    return this;
};

Y.mix(Transition.fx, {
    fadeOut: {
        opacity: 0,
        duration: 0.5,
        easing: 'ease-out'
    },

    fadeIn: {
        opacity: 1,
        duration: 0.5,
        easing: 'ease-in'
    },

    sizeOut: {
        height: 0,
        width: 0,
        duration: 0.75,
        easing: 'ease-out'
    },

    sizeIn: {
        height: function(node) {
            return node.get('scrollHeight') + 'px';
        },
        width: function(node) {
            return node.get('scrollWidth') + 'px';
        },
        duration: 0.5,
        easing: 'ease-in',

        on: {
            start: function() {
                var overflow = this.getStyle('overflow');
                if (overflow !== 'hidden') { // enable scrollHeight/Width
                    this.setStyle('overflow', 'hidden');
                    this._transitionOverflow = overflow;
                }
            },

            end: function() {
                if (this._transitionOverflow) { // revert overridden value
                    this.setStyle('overflow', this._transitionOverflow);
                    delete this._transitionOverflow;
                }
            }
        }
    }
});

Y.mix(Transition.toggles, {
    size: ['sizeOut', 'sizeIn'],
    fade: ['fadeOut', 'fadeIn']
});


}, '3.17.2', {"requires": ["node-style"]});


/***/ }),

/***/ 649253:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('widget-base', function (Y, NAME) {

/**
 * Provides the base Widget class, with HTML Parser support
 *
 * @module widget
 * @main widget
 */

/**
 * Provides the base Widget class
 *
 * @module widget
 * @submodule widget-base
 */
var L = Y.Lang,
    Node = Y.Node,

    ClassNameManager = Y.ClassNameManager,

    _getClassName = ClassNameManager.getClassName,
    _getWidgetClassName,

    _toInitialCap = Y.cached(function(str) {
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }),

    // K-Weight, IE GC optimizations
    CONTENT = "content",
    VISIBLE = "visible",
    HIDDEN = "hidden",
    DISABLED = "disabled",
    FOCUSED = "focused",
    WIDTH = "width",
    HEIGHT = "height",
    BOUNDING_BOX = "boundingBox",
    CONTENT_BOX = "contentBox",
    PARENT_NODE = "parentNode",
    OWNER_DOCUMENT = "ownerDocument",
    AUTO = "auto",
    SRC_NODE = "srcNode",
    BODY = "body",
    TAB_INDEX = "tabIndex",
    ID = "id",
    RENDER = "render",
    RENDERED = "rendered",
    DESTROYED = "destroyed",
    STRINGS = "strings",
    DIV = "<div></div>",
    CHANGE = "Change",
    LOADING = "loading",

    _UISET = "_uiSet",

    EMPTY_STR = "",
    EMPTY_FN = function() {},

    TRUE = true,
    FALSE = false,

    UI,
    ATTRS = {},
    UI_ATTRS = [VISIBLE, DISABLED, HEIGHT, WIDTH, FOCUSED, TAB_INDEX],

    WEBKIT = Y.UA.webkit,

    // Widget nodeid-to-instance map.
    _instances = {};

/**
 * A base class for widgets, providing:
 * <ul>
 *    <li>The render lifecycle method, in addition to the init and destroy
 *        lifecycle methods provide by Base</li>
 *    <li>Abstract methods to support consistent MVC structure across
 *        widgets: renderer, renderUI, bindUI, syncUI</li>
 *    <li>Support for common widget attributes, such as boundingBox, contentBox, visible,
 *        disabled, focused, strings</li>
 * </ul>
 *
 * @param config {Object} Object literal specifying widget configuration properties.
 *
 * @class Widget
 * @constructor
 * @extends Base
 */
function Widget(config) {

    // kweight
    var widget = this,
        parentNode,
        render,
        constructor = widget.constructor;

    widget._strs = {};
    widget._cssPrefix = constructor.CSS_PREFIX || _getClassName(constructor.NAME.toLowerCase());

    // We need a config for HTML_PARSER to work.
    config = config || {};

    Widget.superclass.constructor.call(widget, config);

    render = widget.get(RENDER);

    if (render) {
        // Render could be a node or boolean
        if (render !== TRUE) {
            parentNode = render;
        }
        widget.render(parentNode);
    }
}

/**
 * Static property provides a string to identify the class.
 * <p>
 * Currently used to apply class identifiers to the bounding box
 * and to classify events fired by the widget.
 * </p>
 *
 * @property NAME
 * @type String
 * @static
 */
Widget.NAME = "widget";

/**
 * Constant used to identify state changes originating from
 * the DOM (as opposed to the JavaScript model).
 *
 * @property UI_SRC
 * @type String
 * @static
 * @final
 */
UI = Widget.UI_SRC = "ui";

/**
 * Static property used to define the default attribute
 * configuration for the Widget.
 *
 * @property ATTRS
 * @type Object
 * @static
 */
Widget.ATTRS = ATTRS;

// Trying to optimize kweight by setting up attrs this way saves about 0.4K min'd

/**
 * @attribute id
 * @writeOnce
 * @default Generated using guid()
 * @type String
 */

ATTRS[ID] = {
    valueFn: "_guid",
    writeOnce: TRUE
};

/**
 * Flag indicating whether or not this Widget
 * has been through the render lifecycle phase.
 *
 * @attribute rendered
 * @readOnly
 * @default false
 * @type boolean
 */
ATTRS[RENDERED] = {
    value:FALSE,
    readOnly: TRUE
};

/**
 * @attribute boundingBox
 * @description The outermost DOM node for the Widget, used for sizing and positioning
 * of a Widget as well as a containing element for any decorator elements used
 * for skinning.
 * @type String | Node
 * @writeOnce
 */
ATTRS[BOUNDING_BOX] = {
    valueFn:"_defaultBB",
    setter: "_setBB",
    writeOnce: TRUE
};

/**
 * @attribute contentBox
 * @description A DOM node that is a direct descendant of a Widget's bounding box that
 * houses its content.
 * @type String | Node
 * @writeOnce
 */
ATTRS[CONTENT_BOX] = {
    valueFn:"_defaultCB",
    setter: "_setCB",
    writeOnce: TRUE
};

/**
 * @attribute tabIndex
 * @description Number (between -32767 to 32767) indicating the widget's
 * position in the default tab flow.  The value is used to set the
 * "tabIndex" attribute on the widget's bounding box.  Negative values allow
 * the widget to receive DOM focus programmatically (by calling the focus
 * method), while being removed from the default tab flow.  A value of
 * null removes the "tabIndex" attribute from the widget's bounding box.
 * @type Number
 * @default null
 */
ATTRS[TAB_INDEX] = {
    value: null,
    validator: "_validTabIndex"
};

/**
 * @attribute focused
 * @description Boolean indicating if the Widget, or one of its descendants,
 * has focus.
 * @readOnly
 * @default false
 * @type boolean
 */
ATTRS[FOCUSED] = {
    value: FALSE,
    readOnly:TRUE
};

/**
 * @attribute disabled
 * @description Boolean indicating if the Widget should be disabled. The disabled implementation
 * is left to the specific classes extending widget.
 * @default false
 * @type boolean
 */
ATTRS[DISABLED] = {
    value: FALSE
};

/**
 * @attribute visible
 * @description Boolean indicating whether or not the Widget is visible.
 * @default TRUE
 * @type boolean
 */
ATTRS[VISIBLE] = {
    value: TRUE
};

/**
 * @attribute height
 * @description String with units, or number, representing the height of the Widget. If a number is provided,
 * the default unit, defined by the Widgets DEF_UNIT, property is used.
 * @default EMPTY_STR
 * @type {String | Number}
 */
ATTRS[HEIGHT] = {
    value: EMPTY_STR
};

/**
 * @attribute width
 * @description String with units, or number, representing the width of the Widget. If a number is provided,
 * the default unit, defined by the Widgets DEF_UNIT, property is used.
 * @default EMPTY_STR
 * @type {String | Number}
 */
ATTRS[WIDTH] = {
    value: EMPTY_STR
};

/**
 * @attribute strings
 * @description Collection of strings used to label elements of the Widget's UI.
 * @default null
 * @type Object
 */
ATTRS[STRINGS] = {
    value: {},
    setter: "_strSetter",
    getter: "_strGetter"
};

/**
 * Whether or not to render the widget automatically after init, and optionally, to which parent node.
 *
 * @attribute render
 * @type boolean | Node
 * @writeOnce
 */
ATTRS[RENDER] = {
    value:FALSE,
    writeOnce:TRUE
};

/**
 * The css prefix which the static Widget.getClassName method should use when constructing class names
 *
 * @property CSS_PREFIX
 * @type String
 * @default Widget.NAME.toLowerCase()
 * @private
 * @static
 */
Widget.CSS_PREFIX = _getClassName(Widget.NAME.toLowerCase());

/**
 * Generate a standard prefixed classname for the Widget, prefixed by the default prefix defined
 * by the <code>Y.config.classNamePrefix</code> attribute used by <code>ClassNameManager</code> and
 * <code>Widget.NAME.toLowerCase()</code> (e.g. "yui-widget-xxxxx-yyyyy", based on default values for
 * the prefix and widget class name).
 * <p>
 * The instance based version of this method can be used to generate standard prefixed classnames,
 * based on the instances NAME, as opposed to Widget.NAME. This method should be used when you
 * need to use a constant class name across different types instances.
 * </p>
 * @method getClassName
 * @param {String*} args* 0..n strings which should be concatenated, using the default separator defined by ClassNameManager, to create the class name
 */
Widget.getClassName = function() {
    // arguments needs to be array'fied to concat
    return _getClassName.apply(ClassNameManager, [Widget.CSS_PREFIX].concat(Y.Array(arguments), true));
};

_getWidgetClassName = Widget.getClassName;

/**
 * Returns the widget instance whose bounding box contains, or is, the given node.
 * <p>
 * In the case of nested widgets, the nearest bounding box ancestor is used to
 * return the widget instance.
 * </p>
 * @method getByNode
 * @static
 * @param node {Node | String} The node for which to return a Widget instance. If a selector
 * string is passed in, which selects more than one node, the first node found is used.
 * @return {Widget} Widget instance, or null if not found.
 */
Widget.getByNode = function(node) {
    var widget,
        widgetMarker = _getWidgetClassName();

    node = Node.one(node);
    if (node) {
        node = node.ancestor("." + widgetMarker, true);
        if (node) {
            widget = _instances[Y.stamp(node, true)];
        }
    }

    return widget || null;
};

Y.extend(Widget, Y.Base, {

    /**
     * Returns a class name prefixed with the the value of the
     * <code>YUI.config.classNamePrefix</code> attribute + the instances <code>NAME</code> property.
     * Uses <code>YUI.config.classNameDelimiter</code> attribute to delimit the provided strings.
     * e.g.
     * <code>
     * <pre>
     *    // returns "yui-slider-foo-bar", for a slider instance
     *    var scn = slider.getClassName('foo','bar');
     *
     *    // returns "yui-overlay-foo-bar", for an overlay instance
     *    var ocn = overlay.getClassName('foo','bar');
     * </pre>
     * </code>
     *
     * @method getClassName
     * @param {String} [classnames*] One or more classname bits to be joined and prefixed
     */
    getClassName: function () {
        return _getClassName.apply(ClassNameManager, [this._cssPrefix].concat(Y.Array(arguments), true));
    },

    /**
     * Initializer lifecycle implementation for the Widget class. Registers the
     * widget instance, and runs through the Widget's HTML_PARSER definition.
     *
     * @method initializer
     * @protected
     * @param  config {Object} Configuration object literal for the widget
     */
    initializer: function(config) {

        var bb = this.get(BOUNDING_BOX);

        if (bb instanceof Node) {
            this._mapInstance(Y.stamp(bb));
        }

        /**
         * Notification event, which widget implementations can fire, when
         * they change the content of the widget. This event has no default
         * behavior and cannot be prevented, so the "on" or "after"
         * moments are effectively equivalent (with on listeners being invoked before
         * after listeners).
         *
         * @event widget:contentUpdate
         * @preventable false
         * @param {EventFacade} e The Event Facade
         */
    },

    /**
     * Utility method used to add an entry to the boundingBox id to instance map.
     *
     * This method can be used to populate the instance with lazily created boundingBox Node references.
     *
     * @method _mapInstance
     * @param {String} The boundingBox id
     * @protected
     */
    _mapInstance : function(id) {
        _instances[id] = this;
    },

    /**
     * Destructor lifecycle implementation for the Widget class. Purges events attached
     * to the bounding box and content box, removes them from the DOM and removes
     * the Widget from the list of registered widgets.
     *
     * @method destructor
     * @protected
     */
    destructor: function() {

        var boundingBox = this.get(BOUNDING_BOX),
            bbGuid;

        if (boundingBox instanceof Node) {
            bbGuid = Y.stamp(boundingBox,true);

            if (bbGuid in _instances) {
                delete _instances[bbGuid];
            }

            this._destroyBox();
        }
    },

    /**
     * <p>
     * Destroy lifecycle method. Fires the destroy
     * event, prior to invoking destructors for the
     * class hierarchy.
     *
     * Overrides Base's implementation, to support arguments to destroy
     * </p>
     * <p>
     * Subscribers to the destroy
     * event can invoke preventDefault on the event object, to prevent destruction
     * from proceeding.
     * </p>
     * @method destroy
     * @param destroyAllNodes {Boolean} If true, all nodes contained within the Widget are
     * removed and destroyed. Defaults to false due to potentially high run-time cost.
     * @return {Widget} A reference to this object
     * @chainable
     */
    destroy: function(destroyAllNodes) {
        this._destroyAllNodes = destroyAllNodes;
        return Widget.superclass.destroy.apply(this);
    },

    /**
     * Removes and destroys the widgets rendered boundingBox, contentBox,
     * and detaches bound UI events.
     *
     * @method _destroyBox
     * @protected
     */
    _destroyBox : function() {

        var boundingBox = this.get(BOUNDING_BOX),
            contentBox = this.get(CONTENT_BOX),
            deep = this._destroyAllNodes,
            same;

        same = boundingBox && boundingBox.compareTo(contentBox);

        if (this.UI_EVENTS) {
            this._destroyUIEvents();
        }

        this._unbindUI(boundingBox);

        if (contentBox) {
            if (deep) {
                contentBox.empty();
            }
            contentBox.remove(TRUE);
        }

        if (!same) {
            if (deep) {
                boundingBox.empty();
            }
            boundingBox.remove(TRUE);
        }
    },

    /**
     * Establishes the initial DOM for the widget. Invoking this
     * method will lead to the creating of all DOM elements for
     * the widget (or the manipulation of existing DOM elements
     * for the progressive enhancement use case).
     * <p>
     * This method should only be invoked once for an initialized
     * widget.
     * </p>
     * <p>
     * It delegates to the widget specific renderer method to do
     * the actual work.
     * </p>
     *
     * @method render
     * @chainable
     * @final
     * @param  parentNode {Object | String} Optional. The Node under which the
     * Widget is to be rendered. This can be a Node instance or a CSS selector string.
     * <p>
     * If the selector string returns more than one Node, the first node will be used
     * as the parentNode. NOTE: This argument is required if both the boundingBox and contentBox
     * are not currently in the document. If it's not provided, the Widget will be rendered
     * to the body of the current document in this case.
     * </p>
     */
    render: function(parentNode) {

        if (!this.get(DESTROYED) && !this.get(RENDERED)) {
             /**
              * Lifecycle event for the render phase, fired prior to rendering the UI
              * for the widget (prior to invoking the widget's renderer method).
              * <p>
              * Subscribers to the "on" moment of this event, will be notified
              * before the widget is rendered.
              * </p>
              * <p>
              * Subscribers to the "after" moment of this event, will be notified
              * after rendering is complete.
              * </p>
              *
              * @event render
              * @preventable _defRenderFn
              * @param {EventFacade} e The Event Facade
              */
            this.publish(RENDER, {
                queuable:FALSE,
                fireOnce:TRUE,
                defaultTargetOnly:TRUE,
                defaultFn: this._defRenderFn
            });

            this.fire(RENDER, {parentNode: (parentNode) ? Node.one(parentNode) : null});
        }
        return this;
    },

    /**
     * Default render handler
     *
     * @method _defRenderFn
     * @protected
     * @param {EventFacade} e The Event object
     * @param {Node} parentNode The parent node to render to, if passed in to the <code>render</code> method
     */
    _defRenderFn : function(e) {
        this._parentNode = e.parentNode;

        this.renderer();
        this._set(RENDERED, TRUE);

        this._removeLoadingClassNames();
    },

    /**
     * Creates DOM (or manipulates DOM for progressive enhancement)
     * This method is invoked by render() and is not chained
     * automatically for the class hierarchy (unlike initializer, destructor)
     * so it should be chained manually for subclasses if required.
     *
     * @method renderer
     * @protected
     */
    renderer: function() {
        // kweight
        var widget = this;

        widget._renderUI();
        widget.renderUI();

        widget._bindUI();
        widget.bindUI();

        widget._syncUI();
        widget.syncUI();
    },

    /**
     * Configures/Sets up listeners to bind Widget State to UI/DOM
     *
     * This method is not called by framework and is not chained
     * automatically for the class hierarchy.
     *
     * @method bindUI
     * @protected
     */
    bindUI: EMPTY_FN,

    /**
     * Adds nodes to the DOM
     *
     * This method is not called by framework and is not chained
     * automatically for the class hierarchy.
     *
     * @method renderUI
     * @protected
     */
    renderUI: EMPTY_FN,

    /**
     * Refreshes the rendered UI, based on Widget State
     *
     * This method is not called by framework and is not chained
     * automatically for the class hierarchy.
     *
     * @method syncUI
     * @protected
     *
     */
    syncUI: EMPTY_FN,

    /**
     * @method hide
     * @description Hides the Widget by setting the "visible" attribute to "false".
     * @chainable
     */
    hide: function() {
        return this.set(VISIBLE, FALSE);
    },

    /**
     * @method show
     * @description Shows the Widget by setting the "visible" attribute to "true".
     * @chainable
     */
    show: function() {
        return this.set(VISIBLE, TRUE);
    },

    /**
     * @method focus
     * @description Causes the Widget to receive the focus by setting the "focused"
     * attribute to "true".
     * @chainable
     */
    focus: function () {
        return this._set(FOCUSED, TRUE);
    },

    /**
     * @method blur
     * @description Causes the Widget to lose focus by setting the "focused" attribute
     * to "false"
     * @chainable
     */
    blur: function () {
        return this._set(FOCUSED, FALSE);
    },

    /**
     * @method enable
     * @description Set the Widget's "disabled" attribute to "false".
     * @chainable
     */
    enable: function() {
        return this.set(DISABLED, FALSE);
    },

    /**
     * @method disable
     * @description Set the Widget's "disabled" attribute to "true".
     * @chainable
     */
    disable: function() {
        return this.set(DISABLED, TRUE);
    },

    /**
     * @method _uiSizeCB
     * @protected
     * @param {boolean} expand
     */
    _uiSizeCB : function(expand) {
        this.get(CONTENT_BOX).toggleClass(_getWidgetClassName(CONTENT, "expanded"), expand);
    },

    /**
     * Helper method to collect the boundingBox and contentBox and append to the provided parentNode, if not
     * already a child. The owner document of the boundingBox, or the owner document of the contentBox will be used
     * as the document into which the Widget is rendered if a parentNode is node is not provided. If both the boundingBox and
     * the contentBox are not currently in the document, and no parentNode is provided, the widget will be rendered
     * to the current document's body.
     *
     * @method _renderBox
     * @private
     * @param {Node} parentNode The parentNode to render the widget to. If not provided, and both the boundingBox and
     * the contentBox are not currently in the document, the widget will be rendered to the current document's body.
     */
    _renderBox: function(parentNode) {

        // TODO: Performance Optimization [ More effective algo to reduce Node refs, compares, replaces? ]

        var widget = this, // kweight
            contentBox = widget.get(CONTENT_BOX),
            boundingBox = widget.get(BOUNDING_BOX),
            srcNode = widget.get(SRC_NODE),
            defParentNode = widget.DEF_PARENT_NODE,

            doc = (srcNode && srcNode.get(OWNER_DOCUMENT)) || boundingBox.get(OWNER_DOCUMENT) || contentBox.get(OWNER_DOCUMENT);

        // If srcNode (assume it's always in doc), have contentBox take its place (widget render responsible for re-use of srcNode contents)
        if (srcNode && !srcNode.compareTo(contentBox) && !contentBox.inDoc(doc)) {
            srcNode.replace(contentBox);
        }

        if (!boundingBox.compareTo(contentBox.get(PARENT_NODE)) && !boundingBox.compareTo(contentBox)) {
            // If contentBox box is already in the document, have boundingBox box take it's place
            if (contentBox.inDoc(doc)) {
                contentBox.replace(boundingBox);
            }
            boundingBox.appendChild(contentBox);
        }

        parentNode = parentNode || (defParentNode && Node.one(defParentNode));

        if (parentNode) {
            parentNode.appendChild(boundingBox);
        } else if (!boundingBox.inDoc(doc)) {
            Node.one(BODY).insert(boundingBox, 0);
        }
    },

    /**
     * Setter for the boundingBox attribute
     *
     * @method _setBB
     * @private
     * @param {Node|String} node
     * @return Node
     */
    _setBB: function(node) {
        return this._setBox(this.get(ID), node, this.BOUNDING_TEMPLATE, true);
    },

    /**
     * Setter for the contentBox attribute
     *
     * @method _setCB
     * @private
     * @param {Node|String} node
     * @return Node
     */
    _setCB: function(node) {
        return (this.CONTENT_TEMPLATE === null) ? this.get(BOUNDING_BOX) : this._setBox(null, node, this.CONTENT_TEMPLATE, false);
    },

    /**
     * Returns the default value for the boundingBox attribute.
     *
     * For the Widget class, this will most commonly be null (resulting in a new
     * boundingBox node instance being created), unless a srcNode was provided
     * and CONTENT_TEMPLATE is null, in which case it will be srcNode.
     * This behavior was introduced in 3.17.2 to accomodate single-box widgets
     * whose BB & CB both point to srcNode (e.g. Y.Button).
     *
     * @method _defaultBB
     * @protected
     */
    _defaultBB : function() {
        var node = this.get(SRC_NODE),
            nullCT = (this.CONTENT_TEMPLATE === null);

        return ((node && nullCT) ? node : null);
    },

    /**
     * Returns the default value for the contentBox attribute.
     *
     * For the Widget class, this will be the srcNode if provided, otherwise null (resulting in
     * a new contentBox node instance being created)
     *
     * @method _defaultCB
     * @protected
     */
    _defaultCB : function(node) {
        return this.get(SRC_NODE) || null;
    },

    /**
     * Helper method to set the bounding/content box, or create it from
     * the provided template if not found.
     *
     * @method _setBox
     * @private
     *
     * @param {String} id The node's id attribute
     * @param {Node|String} node The node reference
     * @param {String} template HTML string template for the node
     * @param {boolean} isBounding true if this is the boundingBox, false if it's the contentBox
     * @return {Node} The node
     */
    _setBox : function(id, node, template, isBounding) {

        node = Node.one(node);

        if (!node) {
            node = Node.create(template);

            if (isBounding) {
                this._bbFromTemplate = true;
            } else {
                this._cbFromTemplate = true;
            }
        }

        if (!node.get(ID)) {
            node.set(ID, id || Y.guid());
        }

        return node;
    },

    /**
     * Initializes the UI state for the Widget's bounding/content boxes.
     *
     * @method _renderUI
     * @protected
     */
    _renderUI: function() {
        this._renderBoxClassNames();
        this._renderBox(this._parentNode);
    },

    /**
     * Applies standard class names to the boundingBox and contentBox
     *
     * @method _renderBoxClassNames
     * @protected
     */
    _renderBoxClassNames : function() {
        var classes = this._getClasses(),
            cl,
            boundingBox = this.get(BOUNDING_BOX),
            i;

        boundingBox.addClass(_getWidgetClassName());

        // Start from Widget Sub Class
        for (i = classes.length-3; i >= 0; i--) {
            cl = classes[i];
            boundingBox.addClass(cl.CSS_PREFIX || _getClassName(cl.NAME.toLowerCase()));
        }

        // Use instance based name for content box
        this.get(CONTENT_BOX).addClass(this.getClassName(CONTENT));
    },

    /**
     * Removes class names representative of the widget's loading state from
     * the boundingBox.
     *
     * @method _removeLoadingClassNames
     * @protected
     */
    _removeLoadingClassNames: function () {

        var boundingBox = this.get(BOUNDING_BOX),
            contentBox = this.get(CONTENT_BOX),
            instClass = this.getClassName(LOADING),
            widgetClass = _getWidgetClassName(LOADING);

        boundingBox.removeClass(widgetClass)
                   .removeClass(instClass);

        contentBox.removeClass(widgetClass)
                  .removeClass(instClass);
    },

    /**
     * Sets up DOM and CustomEvent listeners for the widget.
     *
     * @method _bindUI
     * @protected
     */
    _bindUI: function() {
        this._bindAttrUI(this._UI_ATTRS.BIND);
        this._bindDOM();
    },

    /**
     * @method _unbindUI
     * @protected
     */
    _unbindUI : function(boundingBox) {
        this._unbindDOM(boundingBox);
    },

    /**
     * Sets up DOM listeners, on elements rendered by the widget.
     *
     * @method _bindDOM
     * @protected
     */
    _bindDOM : function() {
        var oDocument = this.get(BOUNDING_BOX).get(OWNER_DOCUMENT),
            focusHandle = Widget._hDocFocus;

        // Shared listener across all Widgets.
        if (!focusHandle) {
            focusHandle = Widget._hDocFocus = oDocument.on("focus", this._onDocFocus, this);
            focusHandle.listeners = {
                count: 0
            };
        }

        focusHandle.listeners[Y.stamp(this, true)] = true;
        focusHandle.listeners.count++;

        //	Fix for Webkit:
        //	Document doesn't receive focus in Webkit when the user mouses
        //	down on it, so the "focused" attribute won't get set to the
        //	correct value. Keeping this instance based for now, potential better performance.
        //  Otherwise we'll end up looking up widgets from the DOM on every mousedown.
        if (WEBKIT){
            this._hDocMouseDown = oDocument.on("mousedown", this._onDocMouseDown, this);
        }
    },

    /**
     * @method _unbindDOM
     * @protected
     */
    _unbindDOM : function(boundingBox) {

        var focusHandle = Widget._hDocFocus,
            yuid = Y.stamp(this, true),
            focusListeners,
            mouseHandle = this._hDocMouseDown;

        if (focusHandle) {

            focusListeners = focusHandle.listeners;

            if (focusListeners[yuid]) {
                delete focusListeners[yuid];
                focusListeners.count--;
            }

            if (focusListeners.count === 0) {
                focusHandle.detach();
                Widget._hDocFocus = null;
            }
        }

        if (WEBKIT && mouseHandle) {
            mouseHandle.detach();
        }
    },

    /**
     * Updates the widget UI to reflect the attribute state.
     *
     * @method _syncUI
     * @protected
     */
    _syncUI: function() {
        this._syncAttrUI(this._UI_ATTRS.SYNC);
    },

    /**
     * Sets the height on the widget's bounding box element
     *
     * @method _uiSetHeight
     * @protected
     * @param {String | Number} val
     */
    _uiSetHeight: function(val) {
        this._uiSetDim(HEIGHT, val);
        this._uiSizeCB((val !== EMPTY_STR && val !== AUTO));
    },

    /**
     * Sets the width on the widget's bounding box element
     *
     * @method _uiSetWidth
     * @protected
     * @param {String | Number} val
     */
    _uiSetWidth: function(val) {
        this._uiSetDim(WIDTH, val);
    },

    /**
     * @method _uiSetDim
     * @private
     * @param {String} dim The dimension - "width" or "height"
     * @param {Number | String} val The value to set
     */
    _uiSetDim: function(dimension, val) {
        this.get(BOUNDING_BOX).setStyle(dimension, L.isNumber(val) ? val + this.DEF_UNIT : val);
    },

    /**
     * Sets the visible state for the UI
     *
     * @method _uiSetVisible
     * @protected
     * @param {boolean} val
     */
    _uiSetVisible: function(val) {
        this.get(BOUNDING_BOX).toggleClass(this.getClassName(HIDDEN), !val);
    },

    /**
     * Sets the disabled state for the UI
     *
     * @method _uiSetDisabled
     * @protected
     * @param {boolean} val
     */
    _uiSetDisabled: function(val) {
        this.get(BOUNDING_BOX).toggleClass(this.getClassName(DISABLED), val);
    },

    /**
     * Sets the focused state for the UI
     *
     * @method _uiSetFocused
     * @protected
     * @param {boolean} val
     * @param {string} src String representing the source that triggered an update to
     * the UI.
     */
    _uiSetFocused: function(val, src) {
         var boundingBox = this.get(BOUNDING_BOX);
         boundingBox.toggleClass(this.getClassName(FOCUSED), val);

         if (src !== UI) {
            if (val) {
                boundingBox.focus();
            } else {
                boundingBox.blur();
            }
         }
    },

    /**
     * Set the tabIndex on the widget's rendered UI
     *
     * @method _uiSetTabIndex
     * @protected
     * @param Number
     */
    _uiSetTabIndex: function(index) {
        var boundingBox = this.get(BOUNDING_BOX);

        if (L.isNumber(index)) {
            boundingBox.set(TAB_INDEX, index);
        } else {
            boundingBox.removeAttribute(TAB_INDEX);
        }
    },

    /**
     * @method _onDocMouseDown
     * @description "mousedown" event handler for the owner document of the
     * widget's bounding box.
     * @protected
     * @param {EventFacade} evt The event facade for the DOM focus event
     */
    _onDocMouseDown: function (evt) {
        if (this._domFocus) {
            this._onDocFocus(evt);
        }
    },

    /**
     * DOM focus event handler, used to sync the state of the Widget with the DOM
     *
     * @method _onDocFocus
     * @protected
     * @param {EventFacade} evt The event facade for the DOM focus event
     */
    _onDocFocus: function (evt) {
        var widget = Widget.getByNode(evt.target),
            activeWidget = Widget._active;

        if (activeWidget && (activeWidget !== widget)) {
            activeWidget._domFocus = false;
            activeWidget._set(FOCUSED, false, {src:UI});

            Widget._active = null;
        }

        if (widget) {
            widget._domFocus = true;
            widget._set(FOCUSED, true, {src:UI});

            Widget._active = widget;
        }
    },

    /**
     * Generic toString implementation for all widgets.
     *
     * @method toString
     * @return {String} The default string value for the widget [ displays the NAME of the instance, and the unique id ]
     */
    toString: function() {
        // Using deprecated name prop for kweight squeeze.
        return this.name + "[" + this.get(ID) + "]";
    },

    /**
     * Default unit to use for dimension values
     *
     * @property DEF_UNIT
     * @type String
     */
    DEF_UNIT : "px",

    /**
     * Default node to render the bounding box to. If not set,
     * will default to the current document body.
     *
     * @property DEF_PARENT_NODE
     * @type String | Node
     */
    DEF_PARENT_NODE : null,

    /**
     * Property defining the markup template for content box. If your Widget doesn't
     * need the dual boundingBox/contentBox structure, set CONTENT_TEMPLATE to null,
     * and contentBox and boundingBox will both point to the same Node.
     *
     * @property CONTENT_TEMPLATE
     * @type String
     */
    CONTENT_TEMPLATE : DIV,

    /**
     * Property defining the markup template for bounding box.
     *
     * @property BOUNDING_TEMPLATE
     * @type String
     */
    BOUNDING_TEMPLATE : DIV,

    /**
     * @method _guid
     * @protected
     */
    _guid : function() {
        return Y.guid();
    },

    /**
     * @method _validTabIndex
     * @protected
     * @param {Number} tabIndex
     */
    _validTabIndex : function (tabIndex) {
        return (L.isNumber(tabIndex) || L.isNull(tabIndex));
    },

    /**
     * Binds after listeners for the list of attributes provided
     *
     * @method _bindAttrUI
     * @private
     * @param {Array} attrs
     */
    _bindAttrUI : function(attrs) {
        var i,
            l = attrs.length;

        for (i = 0; i < l; i++) {
            this.after(attrs[i] + CHANGE, this._setAttrUI);
        }
    },

    /**
     * Invokes the _uiSet&#61;ATTR NAME&#62; method for the list of attributes provided
     *
     * @method _syncAttrUI
     * @private
     * @param {Array} attrs
     */
    _syncAttrUI : function(attrs) {
        var i, l = attrs.length, attr;
        for (i = 0; i < l; i++) {
            attr = attrs[i];
            this[_UISET + _toInitialCap(attr)](this.get(attr));
        }
    },

    /**
     * @method _setAttrUI
     * @private
     * @param {EventFacade} e
     */
    _setAttrUI : function(e) {
        if (e.target === this) {
            this[_UISET + _toInitialCap(e.attrName)](e.newVal, e.src);
        }
    },

    /**
     * The default setter for the strings attribute. Merges partial sets
     * into the full string set, to allow users to partial sets of strings
     *
     * @method _strSetter
     * @protected
     * @param {Object} strings
     * @return {String} The full set of strings to set
     */
    _strSetter : function(strings) {
        return Y.merge(this.get(STRINGS), strings);
    },

    /**
     * Helper method to get a specific string value
     *
     * @deprecated Used by deprecated WidgetLocale implementations.
     * @method getString
     * @param {String} key
     * @return {String} The string
     */
    getString : function(key) {
        return this.get(STRINGS)[key];
    },

    /**
     * Helper method to get the complete set of strings for the widget
     *
     * @deprecated  Used by deprecated WidgetLocale implementations.
     * @method getStrings
     * @param {String} key
     * @return {String} The strings
     */
    getStrings : function() {
        return this.get(STRINGS);
    },

    /**
     * The lists of UI attributes to bind and sync for widget's _bindUI and _syncUI implementations
     *
     * @property _UI_ATTRS
     * @type Object
     * @private
     */
    _UI_ATTRS : {
        BIND: UI_ATTRS,
        SYNC: UI_ATTRS
    }
});

Y.Widget = Widget;


}, '3.17.2', {
    "requires": [
        "attribute",
        "base-base",
        "base-pluginhost",
        "classnamemanager",
        "event-focus",
        "node-base",
        "node-style"
    ],
    "skinnable": true
});


/***/ }),

/***/ 221634:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('widget-htmlparser', function (Y, NAME) {

/**
 * Adds HTML Parser support to the base Widget class
 *
 * @module widget
 * @submodule widget-htmlparser
 * @for Widget
 */

var Widget = Y.Widget,
    Node = Y.Node,
    Lang = Y.Lang,

    SRC_NODE = "srcNode",
    CONTENT_BOX = "contentBox";

/**
 * Object hash, defining how attribute values are to be parsed from
 * markup contained in the widget's content box. e.g.:
 * <pre>
 *   {
 *       // Set single Node references using selector syntax
 *       // (selector is run through node.one)
 *       titleNode: "span.yui-title",
 *       // Set NodeList references using selector syntax
 *       // (array indicates selector is to be run through node.all)
 *       listNodes: ["li.yui-item"],
 *       // Set other attribute types, using a parse function.
 *       // Context is set to the widget instance.
 *       label: function(contentBox) {
 *           return contentBox.one("span.title").get("innerHTML");
 *       }
 *   }
 * </pre>
 *
 * @property HTML_PARSER
 * @type Object
 * @static
 */
Widget.HTML_PARSER = {};

/**
 * The build configuration for the Widget class.
 * <p>
 * Defines the static fields which need to be aggregated,
 * when this class is used as the main class passed to
 * the <a href="Base.html#method_build">Base.build</a> method.
 * </p>
 * @property _buildCfg
 * @type Object
 * @static
 * @final
 * @private
 */
Widget._buildCfg = {
    aggregates : ["HTML_PARSER"]
};

/**
 * The DOM node to parse for configuration values, passed to the Widget's HTML_PARSER definition
 *
 * @attribute srcNode
 * @type String | Node
 * @writeOnce
 */
Widget.ATTRS[SRC_NODE] = {
    value: null,
    setter: Node.one,
    getter: "_getSrcNode",
    writeOnce: true
};

Y.mix(Widget.prototype, {

    /**
     * @method _getSrcNode
     * @protected
     * @return {Node} The Node to apply HTML_PARSER to
     */
    _getSrcNode : function(val) {
        return val || this.get(CONTENT_BOX);
    },

    /**
     * Implement the BaseCore _preAddAttrs method hook, to add
     * the srcNode and related attributes, so that HTML_PARSER
     * (which relies on `this.get("srcNode")`) can merge in it's
     * results before the rest of the attributes are added.
     *
     * @method _preAddAttrs
     * @protected
     *
     * @param attrs {Object} The full hash of statically defined ATTRS
     * attributes being added for this instance
     *
     * @param userVals {Object} The hash of user values passed to
     * the constructor
     *
     * @param lazy {boolean} Whether or not to add the attributes lazily
     */
    _preAddAttrs : function(attrs, userVals, lazy) {

        var preAttrs = {
            id : attrs.id,
            boundingBox : attrs.boundingBox,
            contentBox : attrs.contentBox,
            srcNode : attrs.srcNode
        };

        this.addAttrs(preAttrs, userVals, lazy);

        delete attrs.boundingBox;
        delete attrs.contentBox;
        delete attrs.srcNode;
        delete attrs.id;

        if (this._applyParser) {
            this._applyParser(userVals);
        }
    },

    /**
     * @method _applyParsedConfig
     * @protected
     * @return {Object} The merged configuration literal
     */
    _applyParsedConfig : function(node, cfg, parsedCfg) {
        return (parsedCfg) ? Y.mix(cfg, parsedCfg, false) : cfg;
    },

    /**
     * Utility method used to apply the <code>HTML_PARSER</code> configuration for the
     * instance, to retrieve config data values.
     *
     * @method _applyParser
     * @protected
     * @param config {Object} User configuration object (will be populated with values from Node)
     */
    _applyParser : function(config) {

        var widget = this,
            srcNode = this._getNodeToParse(),
            schema = widget._getHtmlParser(),
            parsedConfig,
            val;

        if (schema && srcNode) {
            Y.Object.each(schema, function(v, k, o) {
                val = null;

                if (Lang.isFunction(v)) {
                    val = v.call(widget, srcNode);
                } else {
                    if (Lang.isArray(v)) {
                        val = srcNode.all(v[0]);
                        if (val.isEmpty()) {
                            val = null;
                        }
                    } else {
                        val = srcNode.one(v);
                    }
                }

                if (val !== null && val !== undefined) {
                    parsedConfig = parsedConfig || {};
                    parsedConfig[k] = val;
                }
            });
        }
        config = widget._applyParsedConfig(srcNode, config, parsedConfig);
    },

    /**
     * Determines whether we have a node reference which we should try and parse.
     *
     * The current implementation does not parse nodes generated from CONTENT_TEMPLATE,
     * only explicitly set srcNode, or contentBox attributes.
     *
     * @method _getNodeToParse
     * @return {Node} The node reference to apply HTML_PARSER to.
     * @private
     */
    _getNodeToParse : function() {
        var srcNode = this.get("srcNode");
        return (!this._cbFromTemplate) ? srcNode : null;
    },

    /**
     * Gets the HTML_PARSER definition for this instance, by merging HTML_PARSER
     * definitions across the class hierarchy.
     *
     * @private
     * @method _getHtmlParser
     * @return {Object} HTML_PARSER definition for this instance
     */
    _getHtmlParser : function() {
        // Removed caching for kweight. This is a private method
        // and only called once so don't need to cache HTML_PARSER
        var classes = this._getClasses(),
            parser = {},
            i, p;

        for (i = classes.length - 1; i >= 0; i--) {
            p = classes[i].HTML_PARSER;
            if (p) {
                Y.mix(parser, p, true);
            }
        }
        return parser;
    }
});


}, '3.17.2', {"requires": ["widget-base"]});


/***/ }),

/***/ 34813:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('widget-skin', function (Y, NAME) {

/**
 * Provides skin related utlility methods.
 *
 * @module widget
 * @submodule widget-skin
 */
var BOUNDING_BOX = "boundingBox",
    CONTENT_BOX = "contentBox",
    SKIN = "skin",
    _getClassName = Y.ClassNameManager.getClassName;

/**
 * Returns the name of the skin that's currently applied to the widget.
 *
 * Searches up the Widget's ancestor axis for, by default, a class
 * yui3-skin-(name), and returns the (name) portion. Otherwise, returns null.
 *
 * This is only really useful after the widget's DOM structure is in the
 * document, either by render or by progressive enhancement.
 *
 * @method getSkinName
 * @for Widget
 * @param {String} [skinPrefix] The prefix which the implementation uses for the skin
 * ("yui3-skin-" is the default).
 *
 * NOTE: skinPrefix will be used as part of a regular expression:
 *
 *     new RegExp('\\b' + skinPrefix + '(\\S+)')
 *
 * Although an unlikely use case, literal characters which may result in an invalid
 * regular expression should be escaped.
 *
 * @return {String} The name of the skin, or null, if a matching skin class is not found.
 */

Y.Widget.prototype.getSkinName = function (skinPrefix) {

    var root = this.get( CONTENT_BOX ) || this.get( BOUNDING_BOX ),
        match,
        search;

    skinPrefix = skinPrefix || _getClassName(SKIN, "");

    search = new RegExp( '\\b' + skinPrefix + '(\\S+)' );

    if ( root ) {
        root.ancestor( function ( node ) {
            match = node.get( 'className' ).match( search );
            return match;
        } );
    }

    return ( match ) ? match[1] : null;
};


}, '3.17.2', {"requires": ["widget-base"]});


/***/ }),

/***/ 398089:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('widget-uievents', function (Y, NAME) {

/**
 * Support for Widget UI Events (Custom Events fired by the widget, which wrap the underlying DOM events - e.g. widget:click, widget:mousedown)
 *
 * @module widget
 * @submodule widget-uievents
 */

var BOUNDING_BOX = "boundingBox",
    Widget = Y.Widget,
    RENDER = "render",
    L = Y.Lang,
    EVENT_PREFIX_DELIMITER = ":",

    //  Map of Node instances serving as a delegation containers for a specific
    //  event type to Widget instances using that delegation container.
    _uievts = Y.Widget._uievts = Y.Widget._uievts || {};

Y.mix(Widget.prototype, {

    /**
     * Destructor logic for UI event infrastructure,
     * invoked during Widget destruction.
     *
     * @method _destroyUIEvents
     * @for Widget
     * @private
     */
    _destroyUIEvents: function() {

        var widgetGuid = Y.stamp(this, true);

        Y.each(_uievts, function (info, key) {
            if (info.instances[widgetGuid]) {
                //  Unregister this Widget instance as needing this delegated
                //  event listener.
                delete info.instances[widgetGuid];

                //  There are no more Widget instances using this delegated
                //  event listener, so detach it.

                if (Y.Object.isEmpty(info.instances)) {
                    info.handle.detach();

                    if (_uievts[key]) {
                        delete _uievts[key];
                    }
                }
            }
        });
    },

    /**
     * Map of DOM events that should be fired as Custom Events by the
     * Widget instance.
     *
     * @property UI_EVENTS
     * @for Widget
     * @type Object
     */
    UI_EVENTS: Y.Node.DOM_EVENTS,

    /**
     * Returns the node on which to bind delegate listeners.
     *
     * @method _getUIEventNode
     * @for Widget
     * @protected
     */
    _getUIEventNode: function () {
        return this.get(BOUNDING_BOX);
    },

    /**
     * Binds a delegated DOM event listener of the specified type to the
     * Widget's outtermost DOM element to facilitate the firing of a Custom
     * Event of the same type for the Widget instance.
     *
     * @method _createUIEvent
     * @for Widget
     * @param type {String} String representing the name of the event
     * @private
     */
    _createUIEvent: function (type) {

        var uiEvtNode = this._getUIEventNode(),
            key = (Y.stamp(uiEvtNode) + type),
            info = _uievts[key],
            handle;

        //  For each Node instance: Ensure that there is only one delegated
        //  event listener used to fire Widget UI events.

        if (!info) {

            handle = uiEvtNode.delegate(type, function (evt) {

                var widget = Widget.getByNode(this);

                // Widget could be null if node instance belongs to
                // another Y instance.

                if (widget) {
                    if (widget._filterUIEvent(evt)) {
                        widget.fire(evt.type, { domEvent: evt });
                    }
                }

            }, "." + Y.Widget.getClassName());

            _uievts[key] = info = { instances: {}, handle: handle };
        }

        //  Register this Widget as using this Node as a delegation container.
        info.instances[Y.stamp(this)] = 1;
    },

    /**
     * This method is used to determine if we should fire
     * the UI Event or not. The default implementation makes sure
     * that for nested delegates (nested unrelated widgets), we don't
     * fire the UI event listener more than once at each level.
     *
     * <p>For example, without the additional filter, if you have nested
     * widgets, each widget will have a delegate listener. If you
     * click on the inner widget, the inner delegate listener's
     * filter will match once, but the outer will match twice
     * (based on delegate's design) - once for the inner widget,
     * and once for the outer.</p>
     *
     * @method _filterUIEvent
     * @for Widget
     * @param {DOMEventFacade} evt
     * @return {boolean} true if it's OK to fire the custom UI event, false if not.
     * @private
     *
     */
    _filterUIEvent: function(evt) {
        // Either it's hitting this widget's delegate container (and not some other widget's),
        // or the container it's hitting is handling this widget's ui events.
        return (evt.currentTarget.compareTo(evt.container) || evt.container.compareTo(this._getUIEventNode()));
    },

    /**
     * Determines if the specified event is a UI event.
     *
     * @private
     * @method _isUIEvent
     * @for Widget
     * @param type {String} String representing the name of the event
     * @return {String} Event Returns the name of the UI Event, otherwise
     * undefined.
     */
    _getUIEvent: function (type) {

        if (L.isString(type)) {
            var sType = this.parseType(type)[1],
                iDelim,
                returnVal;

            if (sType) {
                // TODO: Get delimiter from ET, or have ET support this.
                iDelim = sType.indexOf(EVENT_PREFIX_DELIMITER);
                if (iDelim > -1) {
                    sType = sType.substring(iDelim + EVENT_PREFIX_DELIMITER.length);
                }

                if (this.UI_EVENTS[sType]) {
                    returnVal = sType;
                }
            }

            return returnVal;
        }
    },

    /**
     * Sets up infrastructure required to fire a UI event.
     *
     * @private
     * @method _initUIEvent
     * @for Widget
     * @param type {String} String representing the name of the event
     * @return {String}
     */
    _initUIEvent: function (type) {
        var sType = this._getUIEvent(type),
            queue = this._uiEvtsInitQueue || {};

        if (sType && !queue[sType]) {

            this._uiEvtsInitQueue = queue[sType] = 1;

            this.after(RENDER, function() {
                this._createUIEvent(sType);
                delete this._uiEvtsInitQueue[sType];
            });
        }
    },

    //  Override of "on" from Base to facilitate the firing of Widget events
    //  based on DOM events of the same name/type (e.g. "click", "mouseover").
    //  Temporary solution until we have the ability to listen to when
    //  someone adds an event listener (bug 2528230)
    on: function (type) {
        this._initUIEvent(type);
        return Widget.superclass.on.apply(this, arguments);
    },

    //  Override of "publish" from Base to facilitate the firing of Widget events
    //  based on DOM events of the same name/type (e.g. "click", "mouseover").
    //  Temporary solution until we have the ability to listen to when
    //  someone publishes an event (bug 2528230)
    publish: function (type, config) {
        var sType = this._getUIEvent(type);
        if (sType && config && config.defaultFn) {
            this._initUIEvent(sType);
        }
        return Widget.superclass.publish.apply(this, arguments);
    }

}, true); // overwrite existing EventTarget methods


}, '3.17.2', {"requires": ["node-event-delegate", "widget-base"]});


/***/ }),

/***/ 677582:
/***/ (function() {

/*
YUI 3.17.2 (build 9c3c78e)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

YUI.add('yui-throttle', function (Y, NAME) {

/**
Throttles a call to a method based on the time between calls. This method is attached
to the `Y` object and is <a href="../classes/YUI.html#method_throttle">documented there</a>.

    var fn = Y.throttle(function() {
        counter++;
    });

    for (i; i< 35000; i++) {
        out++;
        fn();
    }


@module yui
@submodule yui-throttle
*/

/*! Based on work by Simon Willison: http://gist.github.com/292562 */
/**
 * Throttles a call to a method based on the time between calls.
 * @method throttle
 * @for YUI
 * @param fn {function} The function call to throttle.
 * @param ms {Number} The number of milliseconds to throttle the method call.
 * Can set globally with Y.config.throttleTime or by call. Passing a -1 will
 * disable the throttle. Defaults to 150.
 * @return {function} Returns a wrapped function that calls fn throttled.
 * @since 3.1.0
 */
Y.throttle = function(fn, ms) {
    ms = (ms) ? ms : (Y.config.throttleTime || 150);

    if (ms === -1) {
        return function() {
            fn.apply(this, arguments);
        };
    }

    var last = Y.Lang.now();

    return function() {
        var now = Y.Lang.now();
        if (now - last > ms) {
            last = now;
            fn.apply(this, arguments);
        }
    };
};


}, '3.17.2', {"requires": ["yui-base"]});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLXZlbmRvcnMtc3RhYmxlLTVjMmQ5Y2FkZGI2NGQ5MzM5MWQwLW1pbi5lbi1VUy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjs7QUFFakIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7O0FBRWpCLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FB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QUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBOztBQUVBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLFVBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsVUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxvQkFBb0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsVUFBVTtBQUNyQixRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxzQkFBc0IsUUFBUSxnQkFBZ0IsVUFBVTs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isb0NBQW9DOztBQUUxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxVQUFVO0FBQ2xCLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLHFEQUFxRCxZQUFZO0FBQ2pFLEtBQUssWUFBWTtBQUNqQjtBQUNBLHNDQUFzQyxJQUFJLE1BQU0sY0FBYyxFQUFFO0FBQ2hFO0FBQ0EsS0FBSyxZQUFZO0FBQ2pCLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsS0FBSztBQUNiLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUEscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsU0FBUztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBLG9DQUFvQyxTQUFTO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLE9BQU87QUFDZixRQUFRLFVBQVU7QUFDbEI7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksT0FBTztBQUNuQixRQUFRLFFBQVE7QUFDaEIsU0FBUyxLQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRix3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0EsUUFBUSxVQUFVO0FBQ2xCLFFBQVEsT0FBTztBQUNmLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsT0FBTztBQUNmLFFBQVEsS0FBSztBQUNiLFFBQVEsUUFBUTtBQUNoQixTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsT0FBTztBQUNmLFFBQVEsVUFBVTtBQUNsQjtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLFFBQVEsUUFBUTtBQUNoQixTQUFTLFNBQVM7QUFDbEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixTQUFTLFFBQVE7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRLFdBQVc7QUFDM0M7O0FBRUE7QUFDQSxRQUFRLFVBQVU7QUFDbEIsUUFBUSxRQUFRLFNBQVM7QUFDekI7QUFDQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLFFBQVE7QUFDaEIsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQSxRQUFRLFVBQVU7QUFDbEI7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLHNDQUFzQywwQkFBMEIsSUFBSSxHQUFHO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBLHFDQUFxQztBQUNyQztBQUNBLGNBQWMsT0FBTztBQUNyQix1Q0FBdUMsZUFBZTs7QUFFdEQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCLGdCQUFnQixPQUFPLGFBQWEsT0FBTztBQUMzQztBQUNBLHVCQUF1QixPQUFPO0FBQzlCLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxlQUFlO0FBQ3ZCLFFBQVEsZUFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsQ0FBQyxhQUFhLGdFQUFnRTtBQUM5RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFROztBQUV2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7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O0FBRUEsa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsK0NBQStDO0FBQy9DLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FB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S0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsRUFBRTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNB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Szs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIs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K0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7OztBQUdkOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEIsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixLQUFLO0FBQ3hCLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEtBQUs7QUFDeEIsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEtBQUs7QUFDeEIsbUJBQW1CLEtBQUs7QUFDeEIsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxTQUFTO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxDQUFDLGFBQWEsNkJBQTZCOzs7Ozs7OztBQ2xQM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLENBQUMsYUFBYSwrREFBK0Q7Ozs7Ozs7O0FDOUw3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsNENBQTRDLE9BQU87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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztB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QUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksU0FBUztBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUEsQ0FBQyxh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bEd2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsQ0FBQyxhQUFhLDBCQUEwQjs7Ozs7Ozs7QUNyVHhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLEVBQUU7QUFDRiw2QkFBNkIscUJBQXFCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQix5QkFBeUIsYUFBYTtBQUN0QyxtQkFBbUIsYUFBYTtBQUNoQzs7QUFFQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGNBQWMsVUFBVTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGNBQWMsVUFBVTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQixZQUFZLEtBQUs7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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Q0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELENBQUMsYUFBYSw0REFBNEQ7Ozs7Ozs7O0FDclIxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RCxTQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFNBQVM7QUFDakU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBLENBQUMsYUFBYSxnQ0FBZ0M7Ozs7Ozs7O0FDOVI5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLENBQUMsYUFBYSxpQ0FBaUM7Ozs7Ozs7O0FDNUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOzs7QUFHRCxDQUFDLGFBQWEsNERBQTREOzs7Ozs7OztBQ2xsQjFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsQ0FBQyxhQUFhLGdDQUFnQzs7Ozs7Ozs7QUNqSDlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELENBQUMsYUFBYSw2Q0FBNkM7Ozs7Ozs7O0FDM0QzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxDQUFDLGFBQWEsMEJBQTBCOzs7Ozs7OztBQzNNeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07O0FBRWxCLFlBQVksUUFBUTtBQUNwQixnQkFBZ0IsYUFBYTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVkseUJBQXlCOztBQUVyQyxZQUFZLFFBQVE7QUFDcEIsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQSxnQkFBZ0IsU0FBUztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7O0FBSUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsS0FBSztBQUMvQyxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLGNBQWM7QUFDMUIsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxjQUFjO0FBQzFCLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2Qzs7O0FBR0EsQ0FBQyxhQUFhLCtDQUErQzs7Ozs7Ozs7QUNoakI3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QyxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELGNBQWM7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixtQkFBbUIsUUFBUTtBQUMz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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFR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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNi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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLFVBQVUscURBQXFEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBLENBQUMsYUFBYSx3Q0FBd0M7Ozs7Ozs7O0FDakd0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMkVBQTJFO0FBQzNFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCwyRUFBMkU7QUFDM0U7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLFFBQVE7QUFDaEIsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsVUFBVSwyREFBMkQ7QUFDN0U7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLFFBQVE7QUFDaEI7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQSxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxRQUFRLFVBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxVQUFVO0FBQ2xCO0FBQ0EsUUFBUSxVQUFVO0FBQ2xCO0FBQ0EsUUFBUSxVQUFVO0FBQ2xCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsS0FBSztBQUNiLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUFLO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsS0FBSztBQUNiO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLE9BQU87QUFDZixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkNBQTZDO0FBQzdDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLFVBQVU7QUFDbEIsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxDQUFDLGFBQWEseUJBQXlCOzs7Ozs7OztBQzNUdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsRUFBRTtBQUNGLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBRUQ7OztBQUdBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDL3dDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxTQUFTOzs7QUFHVixDQUFDLGFBQWEsbURBQW1EOzs7Ozs7OztBQ3hPakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLENBQUMsYUFBYSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkveXVpLWJhc2UveXVpLWJhc2UuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL3l1aS1iYXNlL3l1aS1iYXNlLWV4cG9zZWQuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2FuaW0tYmFzZS9hbmltLWJhc2UuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2FuaW0tY29sb3IvYW5pbS1jb2xvci5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvYW5pbS1jdXJ2ZS9hbmltLWN1cnZlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9hbmltLWVhc2luZy9hbmltLWVhc2luZy5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvYW5pbS1ub2RlLXBsdWdpbi9hbmltLW5vZGUtcGx1Z2luLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9hbmltLXNjcm9sbC9hbmltLXNjcm9sbC5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvYW5pbS14eS9hbmltLXh5LmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9hcnJheS1leHRyYXMvYXJyYXktZXh0cmFzLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9hcnJheS1pbnZva2UvYXJyYXktaW52b2tlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9hcnJheWxpc3QvYXJyYXlsaXN0LmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9hc3luYy1xdWV1ZS9hc3luYy1xdWV1ZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvYXR0cmlidXRlLWJhc2UvYXR0cmlidXRlLWJhc2UuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2F0dHJpYnV0ZS1jb21wbGV4L2F0dHJpYnV0ZS1jb21wbGV4LmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9hdHRyaWJ1dGUtY29yZS9hdHRyaWJ1dGUtY29yZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvYXR0cmlidXRlLWV4dHJhcy9hdHRyaWJ1dGUtZXh0cmFzLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9hdHRyaWJ1dGUtb2JzZXJ2YWJsZS9hdHRyaWJ1dGUtb2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvYmFzZS1iYXNlL2Jhc2UtYmFzZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvYmFzZS1idWlsZC9iYXNlLWJ1aWxkLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9iYXNlLWNvcmUvYmFzZS1jb3JlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9iYXNlLW9ic2VydmFibGUvYmFzZS1vYnNlcnZhYmxlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9iYXNlLXBsdWdpbmhvc3QvYmFzZS1wbHVnaW5ob3N0LmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9jbGFzc25hbWVtYW5hZ2VyL2NsYXNzbmFtZW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2NvbG9yLWJhc2UvY29sb3ItYmFzZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvY29va2llL2Nvb2tpZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvZGF0YXR5cGUteG1sLXBhcnNlL2RhdGF0eXBlLXhtbC1wYXJzZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvZG9tLWJhc2UvZG9tLWJhc2UuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2RvbS1jb3JlL2RvbS1jb3JlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9kb20tc2NyZWVuL2RvbS1zY3JlZW4uanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2RvbS1zdHlsZS1pZS9kb20tc3R5bGUtaWUuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2RvbS1zdHlsZS9kb20tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2VzY2FwZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2V2ZW50LWJhc2UtaWUvZXZlbnQtYmFzZS1pZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvZXZlbnQtYmFzZS9ldmVudC1iYXNlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9ldmVudC1jdXN0b20tYmFzZS9ldmVudC1jdXN0b20tYmFzZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvZXZlbnQtY3VzdG9tLWNvbXBsZXgvZXZlbnQtY3VzdG9tLWNvbXBsZXguanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2V2ZW50LWRlbGVnYXRlL2V2ZW50LWRlbGVnYXRlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9ldmVudC1mbGljay9ldmVudC1mbGljay5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvZXZlbnQtZm9jdXMvZXZlbnQtZm9jdXMuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2V2ZW50LWhvdmVyL2V2ZW50LWhvdmVyLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9ldmVudC1rZXkvZXZlbnQta2V5LmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9ldmVudC1tb3VzZWVudGVyL2V2ZW50LW1vdXNlZW50ZXIuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2V2ZW50LW1vdXNld2hlZWwvZXZlbnQtbW91c2V3aGVlbC5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvZXZlbnQtbW92ZS9ldmVudC1tb3ZlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9ldmVudC1vdXRzaWRlL2V2ZW50LW91dHNpZGUuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2V2ZW50LXJlc2l6ZS9ldmVudC1yZXNpemUuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2V2ZW50LXNpbXVsYXRlL2V2ZW50LXNpbXVsYXRlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9ldmVudC1zeW50aGV0aWMvZXZlbnQtc3ludGhldGljLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9ldmVudC10YXAvZXZlbnQtdGFwLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9ldmVudC10b3VjaC9ldmVudC10b3VjaC5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvZXZlbnQtdmFsdWVjaGFuZ2UvZXZlbnQtdmFsdWVjaGFuZ2UuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2dlc3R1cmUtc2ltdWxhdGUvZ2VzdHVyZS1zaW11bGF0ZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvaGlzdG9yeS1iYXNlL2hpc3RvcnktYmFzZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvaGlzdG9yeS1oYXNoLWllL2hpc3RvcnktaGFzaC1pZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvaGlzdG9yeS1oYXNoL2hpc3RvcnktaGFzaC5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvaGlzdG9yeS1odG1sNS9oaXN0b3J5LWh0bWw1LmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9pbnRsL2ludGwuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2lvLWJhc2UvaW8tYmFzZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvaW8tZm9ybS9pby1mb3JtLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9pby1xdWV1ZS9pby1xdWV1ZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvaW8tdXBsb2FkLWlmcmFtZS9pby11cGxvYWQtaWZyYW1lLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9pby14ZHIvaW8teGRyLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9qc29uLXBhcnNlL2pzb24tcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL2pzb24tc3RyaW5naWZ5L2pzb24tc3RyaW5naWZ5LmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9qc29ucC9qc29ucC5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvbm9kZS1iYXNlL25vZGUtYmFzZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvbm9kZS1jb3JlL25vZGUtY29yZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvbm9kZS1ldmVudC1kZWxlZ2F0ZS9ub2RlLWV2ZW50LWRlbGVnYXRlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9ub2RlLWV2ZW50LXNpbXVsYXRlL25vZGUtZXZlbnQtc2ltdWxhdGUuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL25vZGUtbG9hZC9ub2RlLWxvYWQuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL25vZGUtcGx1Z2luaG9zdC9ub2RlLXBsdWdpbmhvc3QuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL25vZGUtc2NyZWVuL25vZGUtc2NyZWVuLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9ub2RlLXN0eWxlL25vZGUtc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL29vcC9vb3AuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL3BsdWdpbi9wbHVnaW4uanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL3BsdWdpbmhvc3QtYmFzZS9wbHVnaW5ob3N0LWJhc2UuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL3BsdWdpbmhvc3QtY29uZmlnL3BsdWdpbmhvc3QtY29uZmlnLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9wcm9taXNlL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL3F1ZXJ5c3RyaW5nLXN0cmluZ2lmeS1zaW1wbGUvcXVlcnlzdHJpbmctc3RyaW5naWZ5LXNpbXBsZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvcXVlcnlzdHJpbmctc3RyaW5naWZ5L3F1ZXJ5c3RyaW5nLXN0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvcXVldWUtcHJvbW90ZS9xdWV1ZS1wcm9tb3RlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9zZWxlY3Rvci1uYXRpdmUvc2VsZWN0b3ItbmF0aXZlLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS9zZWxlY3Rvci9zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvdGltZXJzL3RpbWVycy5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS93aWRnZXQtYmFzZS93aWRnZXQtYmFzZS5qcyIsIndlYnBhY2s6Ly9leHRyYWN0LWNzcy8uLi9mcm9udGVuZC9wYWNrYWdlcy95dWkvd2lkZ2V0LWh0bWxwYXJzZXIvd2lkZ2V0LWh0bWxwYXJzZXIuanMiLCJ3ZWJwYWNrOi8vZXh0cmFjdC1jc3MvLi4vZnJvbnRlbmQvcGFja2FnZXMveXVpL3dpZGdldC1za2luL3dpZGdldC1za2luLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS93aWRnZXQtdWlldmVudHMvd2lkZ2V0LXVpZXZlbnRzLmpzIiwid2VicGFjazovL2V4dHJhY3QtY3NzLy4uL2Zyb250ZW5kL3BhY2thZ2VzL3l1aS95dWktdGhyb3R0bGUveXVpLXRocm90dGxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG4vKipcblRoZSBZVUkgbW9kdWxlIGNvbnRhaW5zIHRoZSBjb21wb25lbnRzIHJlcXVpcmVkIGZvciBidWlsZGluZyB0aGUgWVVJIHNlZWQgZmlsZS5cblRoaXMgaW5jbHVkZXMgdGhlIHNjcmlwdCBsb2FkaW5nIG1lY2hhbmlzbSwgYSBzaW1wbGUgcXVldWUsIGFuZCB0aGUgY29yZVxudXRpbGl0aWVzIGZvciB0aGUgbGlicmFyeS5cblxuQG1vZHVsZSB5dWlcbkBtYWluIHl1aVxuQHN1Ym1vZHVsZSB5dWktYmFzZVxuKiovXG5cbi8qanNoaW50IGVxZXFlcTogZmFsc2UqL1xuaWYgKHR5cGVvZiBZVUkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBZVUkuX1lVSSA9IFlVSTtcbn1cblxuLyoqXG5UaGUgWVVJIGdsb2JhbCBuYW1lc3BhY2Ugb2JqZWN0LiBUaGlzIGlzIHRoZSBjb25zdHJ1Y3RvciBmb3IgYWxsIFlVSSBpbnN0YW5jZXMuXG5cblRoaXMgaXMgYSBzZWxmLWluc3RhbnRpYWJsZSBmYWN0b3J5IGZ1bmN0aW9uLCBtZWFuaW5nIHlvdSBkb24ndCBuZWVkIHRvIHByZWNlZGVcbml0IHdpdGggdGhlIGBuZXdgIG9wZXJhdG9yLiBZb3UgY2FuIGludm9rZSBpdCBkaXJlY3RseSBsaWtlIHRoaXM6XG5cbiAgICBZVUkoKS51c2UoJyonLCBmdW5jdGlvbiAoWSkge1xuICAgICAgICAvLyBZIGlzIGEgbmV3IFlVSSBpbnN0YW5jZS5cbiAgICB9KTtcblxuQnV0IGl0IGFsc28gd29ya3MgbGlrZSB0aGlzOlxuXG4gICAgdmFyIFkgPSBZVUkoKTtcblxuVGhlIGBZVUlgIGNvbnN0cnVjdG9yIGFjY2VwdHMgYW4gb3B0aW9uYWwgY29uZmlnIG9iamVjdCwgbGlrZSB0aGlzOlxuXG4gICAgWVVJKHtcbiAgICAgICAgZGVidWc6IHRydWUsXG4gICAgICAgIGNvbWJpbmU6IGZhbHNlXG4gICAgfSkudXNlKCdub2RlJywgZnVuY3Rpb24gKFkpIHtcbiAgICAgICAgLy8gWS5Ob2RlIGlzIHJlYWR5IHRvIHVzZS5cbiAgICB9KTtcblxuU2VlIHRoZSBBUEkgZG9jcyBmb3IgdGhlIDxhIGhyZWY9XCJjb25maWcuaHRtbFwiPkNvbmZpZzwvYT4gY2xhc3MgZm9yIHRoZSBjb21wbGV0ZVxubGlzdCBvZiBzdXBwb3J0ZWQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGFjY2VwdGVkIGJ5IHRoZSBZVUkgY29uc3R1Y3Rvci5cblxuSWYgYSBnbG9iYWwgYFlVSWAgb2JqZWN0IGlzIGFscmVhZHkgZGVmaW5lZCwgdGhlIGV4aXN0aW5nIFlVSSBvYmplY3Qgd2lsbCBub3QgYmVcbm92ZXJ3cml0dGVuLCB0byBlbnN1cmUgdGhhdCBkZWZpbmVkIG5hbWVzcGFjZXMgYXJlIHByZXNlcnZlZC5cblxuRWFjaCBZVUkgaW5zdGFuY2UgaGFzIGZ1bGwgY3VzdG9tIGV2ZW50IHN1cHBvcnQsIGJ1dCBvbmx5IGlmIHRoZSBldmVudCBzeXN0ZW0gaXNcbmF2YWlsYWJsZS5cblxuQGNsYXNzIFlVSVxuQHVzZXMgRXZlbnRUYXJnZXRcbkBjb25zdHJ1Y3RvclxuQGdsb2JhbFxuQHBhcmFtIHtPYmplY3R9IFtjb25maWddKiBaZXJvIG9yIG1vcmUgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3RzLiBDb25maWdcbiAgICB2YWx1ZXMgYXJlIHN0b3JlZCBpbiB0aGUgYFkuY29uZmlnYCBwcm9wZXJ0eS4gU2VlIHRoZVxuICAgIDxhIGhyZWY9XCJjb25maWcuaHRtbFwiPkNvbmZpZzwvYT4gZG9jcyBmb3IgdGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIHByb3BlcnRpZXMuXG4qKi9cblxuICAgIC8qZ2xvYmFsIFlVSSovXG4gICAgLypnbG9iYWwgWVVJX2NvbmZpZyovXG4gICAgdmFyIFlVSSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBZID0gdGhpcyxcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBsID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICBpbnN0YW5jZU9mID0gZnVuY3Rpb24obywgdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAobyAmJiBvLmhhc093blByb3BlcnR5ICYmIChvIGluc3RhbmNlb2YgdHlwZSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdjb25mID0gKHR5cGVvZiBZVUlfY29uZmlnICE9PSAndW5kZWZpbmVkJykgJiYgWVVJX2NvbmZpZztcblxuICAgICAgICBpZiAoIShpbnN0YW5jZU9mKFksIFlVSSkpKSB7XG4gICAgICAgICAgICBZID0gbmV3IFlVSSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBjb3JlIGVudmlyb25tZW50XG4gICAgICAgICAgICBZLl9pbml0KCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgTWFzdGVyIGNvbmZpZ3VyYXRpb24gdGhhdCBtaWdodCBzcGFuIG11bHRpcGxlIGNvbnRleHRzIGluIGEgbm9uLVxuICAgICAgICAgICAgYnJvd3NlciBlbnZpcm9ubWVudC4gSXQgaXMgYXBwbGllZCBmaXJzdCB0byBhbGwgaW5zdGFuY2VzIGluIGFsbFxuICAgICAgICAgICAgY29udGV4dHMuXG5cbiAgICAgICAgICAgIEBleGFtcGxlXG5cbiAgICAgICAgICAgICAgICBZVUkuR2xvYmFsQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6ICdkZWJ1ZydcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgWVVJKCkudXNlKCdub2RlJywgZnVuY3Rpb24gKFkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVidWcgZmlsZXMgdXNlZCBoZXJlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBZVUkoe1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6ICdtaW4nXG4gICAgICAgICAgICAgICAgfSkudXNlKCdub2RlJywgZnVuY3Rpb24gKFkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWluIGZpbGVzIHVzZWQgaGVyZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBAcHJvcGVydHkge09iamVjdH0gR2xvYmFsQ29uZmlnXG4gICAgICAgICAgICBAZ2xvYmFsXG4gICAgICAgICAgICBAc3RhdGljXG4gICAgICAgICAgICAqKi9cbiAgICAgICAgICAgIGlmIChZVUkuR2xvYmFsQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgWS5hcHBseUNvbmZpZyhZVUkuR2xvYmFsQ29uZmlnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBQYWdlLWxldmVsIGNvbmZpZyBhcHBsaWVkIHRvIGFsbCBZVUkgaW5zdGFuY2VzIGNyZWF0ZWQgb24gdGhlXG4gICAgICAgICAgICBjdXJyZW50IHBhZ2UuIFRoaXMgaXMgYXBwbGllZCBhZnRlciBgWVVJLkdsb2JhbENvbmZpZ2AgYW5kIGJlZm9yZVxuICAgICAgICAgICAgYW55IGluc3RhbmNlLWxldmVsIGNvbmZpZ3VyYXRpb24uXG5cbiAgICAgICAgICAgIEBleGFtcGxlXG5cbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgZ2xvYmFsIHZhciB0byBpbmNsdWRlIGJlZm9yZSBZVUkgc2VlZCBmaWxlXG4gICAgICAgICAgICAgICAgWVVJX2NvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiAnZGVidWcnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFlVSSgpLnVzZSgnbm9kZScsIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlYnVnIGZpbGVzIHVzZWQgaGVyZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgWVVJKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiAnbWluJ1xuICAgICAgICAgICAgICAgIH0pLnVzZSgnbm9kZScsIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbiBmaWxlcyB1c2VkIGhlcmVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgQHByb3BlcnR5IHtPYmplY3R9IFlVSV9jb25maWdcbiAgICAgICAgICAgIEBnbG9iYWxcbiAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgaWYgKGdjb25mKSB7XG4gICAgICAgICAgICAgICAgWS5hcHBseUNvbmZpZyhnY29uZik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIHNwZWNpZmllZCBhZGRpdGlvbmFsIG1vZHVsZXMgZm9yIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgICAgIGlmICghbCkge1xuICAgICAgICAgICAgICAgIFkuX3NldHVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgLy8gRWFjaCBpbnN0YW5jZSBjYW4gYWNjZXB0IG9uZSBvciBtb3JlIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBhcHBsaWVkIGFmdGVyIFlVSS5HbG9iYWxDb25maWcgYW5kIFlVSV9Db25maWcsXG4gICAgICAgICAgICAvLyBvdmVycmlkaW5nIHZhbHVlcyBzZXQgaW4gdGhvc2UgY29uZmlnIGZpbGVzIGlmIHRoZXJlIGlzIGFcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBZLmFwcGx5Q29uZmlnKGFyZ3NbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBZLl9zZXR1cCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgWS5pbnN0YW5jZU9mID0gaW5zdGFuY2VPZjtcblxuICAgICAgICByZXR1cm4gWTtcbiAgICB9O1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgcHJvdG8sIHByb3AsXG4gICAgICAgIFZFUlNJT04gPSAnMy4xNy4yJyxcbiAgICAgICAgUEVSSU9EID0gJy4nLFxuICAgICAgICBCQVNFID0gJ2h0dHA6Ly95dWkueWFob29hcGlzLmNvbS8nLFxuICAgICAgICAvKlxuICAgICAgICAgICAgVGhlc2UgQ1NTIGNsYXNzIG5hbWVzIGNhbid0IGJlIGdlbmVyYXRlZCBieVxuICAgICAgICAgICAgZ2V0Q2xhc3NOYW1lIHNpbmNlIGl0IGlzIG5vdCBhdmFpbGFibGUgYXQgdGhlXG4gICAgICAgICAgICB0aW1lIHRoZXkgYXJlIGJlaW5nIHVzZWQuXG4gICAgICAgICovXG4gICAgICAgIERPQ19MQUJFTCA9ICd5dWkzLWpzLWVuYWJsZWQnLFxuICAgICAgICBDU1NfU1RBTVBfRUwgPSAneXVpMy1jc3Mtc3RhbXAnLFxuICAgICAgICBOT09QID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgU0xJQ0UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICAgIEFQUExZX1RPX0FVVEggPSB7ICdpby54ZHJSZWFkeSc6IDEsICAgLy8gdGhlIGZ1bmN0aW9ucyBhcHBseVRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpby54ZHJSZXNwb25zZSc6IDEsICAgLy8gY2FuIGNhbGwuIHRoaXMgc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdTV0YuZXZlbnRIYW5kbGVyJzogMSB9LCAvLyBiZSBkb25lIGF0IGJ1aWxkIHRpbWVcbiAgICAgICAgaGFzV2luID0gKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpLFxuICAgICAgICB3aW4gPSAoaGFzV2luKSA/IHdpbmRvdyA6IG51bGwsXG4gICAgICAgIGRvYyA9IChoYXNXaW4pID8gd2luLmRvY3VtZW50IDogbnVsbCxcbiAgICAgICAgZG9jRWwgPSBkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgZG9jQ2xhc3MgPSBkb2NFbCAmJiBkb2NFbC5jbGFzc05hbWUsXG4gICAgICAgIGluc3RhbmNlcyA9IHt9LFxuICAgICAgICB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgIGFkZCA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuICAgICAgICAgICAgaWYgKGVsICYmIGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBjYXB0dXJlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwgJiYgZWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmUgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpIHtcbiAgICAgICAgICAgIGlmIChlbCAmJiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gdGhyb3cgYW4gdW5jYXVnaHQgZXhjZXB0aW9uIGluIEZGXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgY2FwdHVyZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHt9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsICYmIGVsLmRldGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlUmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFlVSS5FbnYuRE9NUmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGhhc1dpbikge1xuICAgICAgICAgICAgICAgIHJlbW92ZShkb2MsICdET01Db250ZW50TG9hZGVkJywgaGFuZGxlUmVhZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVMb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBZVUkuRW52LndpbmRvd0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBZVUkuRW52LkRPTVJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChoYXNXaW4pIHtcbiAgICAgICAgICAgICAgICByZW1vdmUod2luZG93LCAnbG9hZCcsIGhhbmRsZUxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRMb2FkZXIgPSBmdW5jdGlvbihZLCBvKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gWS5FbnYuX2xvYWRlcixcbiAgICAgICAgICAgICAgICBsQ29yZSA9IFsgJ2xvYWRlci1iYXNlJyBdLFxuICAgICAgICAgICAgICAgIEdfRU5WID0gWVVJLkVudixcbiAgICAgICAgICAgICAgICBtb2RzID0gR19FTlYubW9kcztcblxuICAgICAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgICAgICAgIC8vbG9hZGVyLl9jb25maWcoWS5jb25maWcpO1xuICAgICAgICAgICAgICAgIGxvYWRlci5pZ25vcmVSZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbG9hZGVyLm9uRW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsb2FkZXIuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbG9hZGVyLnJlcXVpcmVkID0gW107XG4gICAgICAgICAgICAgICAgbG9hZGVyLmxvYWRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyID0gbmV3IFkuTG9hZGVyKFkuY29uZmlnKTtcbiAgICAgICAgICAgICAgICBZLkVudi5fbG9hZGVyID0gbG9hZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZHMgJiYgbW9kcy5sb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBsQ29yZSA9IFtdLmNvbmNhdChsQ29yZSwgWVVJLkVudi5sb2FkZXJFeHRyYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgWVVJLkVudi5jb3JlID0gWS5BcnJheS5kZWR1cGUoW10uY29uY2F0KFlVSS5FbnYuY29yZSwgbENvcmUpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9iYmVyID0gZnVuY3Rpb24ociwgcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcltpXSA9IHNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEFMUkVBRFlfRE9ORSA9IHsgc3VjY2VzczogdHJ1ZSB9O1xuXG4vLyAgU3RhbXAgdGhlIGRvY3VtZW50RWxlbWVudCAoSFRNTCkgd2l0aCBhIGNsYXNzIG9mIFwieXVpLWxvYWRlZFwiIHRvXG4vLyAgZW5hYmxlIHN0eWxlcyB0aGF0IG5lZWQgdG8ga2V5IG9mZiBvZiBKUyBiZWluZyBlbmFibGVkLlxuaWYgKGRvY0VsICYmIGRvY0NsYXNzLmluZGV4T2YoRE9DX0xBQkVMKSA9PSAtMSkge1xuICAgIGlmIChkb2NDbGFzcykge1xuICAgICAgICBkb2NDbGFzcyArPSAnICc7XG4gICAgfVxuICAgIGRvY0NsYXNzICs9IERPQ19MQUJFTDtcbiAgICBkb2NFbC5jbGFzc05hbWUgPSBkb2NDbGFzcztcbn1cblxuaWYgKFZFUlNJT04uaW5kZXhPZignQCcpID4gLTEpIHtcbiAgICBWRVJTSU9OID0gJzMuNS4wJzsgLy8gZGV2IHRpbWUgaGFjayBmb3IgY2RuIHRlc3Rcbn1cblxudmFyIERFRkFVTFRfWVVJX1NUQVRTID0ge307XG5cbnByb3RvID0ge1xuICAgIHN0YXRzOiB7XG4gICAgICBnZXRBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cudG9wLllVSVN0YXRzID0gd2luZG93LnRvcC5ZVUlTdGF0cyB8fCBERUZBVUxUX1lVSV9TVEFUUztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBERUZBVUxUX1lVSV9TVEFUUztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldE9uZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvLnN0YXRzLmdldEFsbCgpW25hbWVdID0gcHJvdG8uc3RhdHMuZ2V0QWxsKClbbmFtZV0gfHwgeyBjcmVhdGU6IDAsIGluaXRpYWxpemVyOiAwLCBkZXN0cnVjdG9yOiAwIH07XG4gICAgICB9LFxuICAgICAgZ2V0U2VyaWFsaXplZERhdGFGb3JSZXBvcnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0cmllID0ge307XG4gICAgICAgIHZhciBhbGxZVUlTdGF0cyA9IHByb3RvLnN0YXRzLmdldEFsbCgpO1xuXG4gICAgICAgIFkuT2JqZWN0LmtleXMoYWxsWVVJU3RhdHMpLmZvckVhY2goZnVuY3Rpb24gKHl1aUNsYXNzKSB7XG4gICAgICAgICAgdmFyIHl1aUNsYXNzRGF0YSA9IGFsbFlVSVN0YXRzW3l1aUNsYXNzXTtcbiAgICAgICAgICB2YXIgY3JlYXRlQ2FsbHMgPSB5dWlDbGFzc0RhdGEuY3JlYXRlO1xuICAgICAgICAgIHZhciBpbml0aWFsaXplckNhbGxzID0geXVpQ2xhc3NEYXRhLmluaXRpYWxpemVyO1xuICAgICAgICAgIHZhciBkZXN0cnVjdG9yQ2FsbHMgPSB5dWlDbGFzc0RhdGEuZGVzdHJ1Y3RvcjtcblxuICAgICAgICAgIGlmICghdHJpZS5oYXNPd25Qcm9wZXJ0eShjcmVhdGVDYWxscykpIHtcbiAgICAgICAgICAgIHRyaWVbY3JlYXRlQ2FsbHNdID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0cmllW2NyZWF0ZUNhbGxzXS5oYXNPd25Qcm9wZXJ0eShpbml0aWFsaXplckNhbGxzKSkge1xuICAgICAgICAgICAgdHJpZVtjcmVhdGVDYWxsc11baW5pdGlhbGl6ZXJDYWxsc10gPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRyaWVbY3JlYXRlQ2FsbHNdW2luaXRpYWxpemVyQ2FsbHNdLmhhc093blByb3BlcnR5KGRlc3RydWN0b3JDYWxscykpIHtcbiAgICAgICAgICAgIHRyaWVbY3JlYXRlQ2FsbHNdW2luaXRpYWxpemVyQ2FsbHNdW2Rlc3RydWN0b3JDYWxsc10gPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmllW2NyZWF0ZUNhbGxzXVtpbml0aWFsaXplckNhbGxzXVtkZXN0cnVjdG9yQ2FsbHNdLnB1c2goeXVpQ2xhc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJpZTtcbiAgICAgIH0sXG4gICAgICBtYXJrQ3JlYXRlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgc3RhdCA9IHByb3RvLnN0YXRzLmdldE9uZShuYW1lKTtcbiAgICAgICAgc3RhdC5jcmVhdGUrKztcbiAgICAgIH0sXG4gICAgICBtYXJrSW5pdGlhbGl6ZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBzdGF0ID0gcHJvdG8uc3RhdHMuZ2V0T25lKG5hbWUpO1xuICAgICAgICBzdGF0LmluaXRpYWxpemVyKys7XG4gICAgICB9LFxuICAgICAgbWFya0Rlc3RydWN0b3I6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBzdGF0ID0gcHJvdG8uc3RhdHMuZ2V0T25lKG5hbWUpO1xuICAgICAgICBzdGF0LmRlc3RydWN0b3IrKztcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgIEFwcGxpZXMgYSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gdGhlIGNvbmZpZyBvZiB0aGlzIFlVSSBpbnN0YW5jZS4gVGhpc1xuICAgIHdpbGwgbWVyZ2UgbmV3IGdyb3VwL21vZHVsZSBkZWZpbml0aW9ucywgYW5kIHdpbGwgYWxzbyB1cGRhdGUgdGhlIGxvYWRlclxuICAgIGNhY2hlIGlmIG5lY2Vzc2FyeS4gVXBkYXRpbmcgYFkuY29uZmlnYCBkaXJlY3RseSB3aWxsIG5vdCB1cGRhdGUgdGhlIGNhY2hlLlxuXG4gICAgQG1ldGhvZCBhcHBseUNvbmZpZ1xuICAgIEBwYXJhbSB7T2JqZWN0fSBvIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICBAc2luY2UgMy4yLjBcbiAgICAqKi9cbiAgICBhcHBseUNvbmZpZzogZnVuY3Rpb24obykge1xuXG4gICAgICAgIG8gPSBvIHx8IE5PT1A7XG5cbiAgICAgICAgdmFyIGF0dHIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgLy8gZGV0YWlsLFxuICAgICAgICAgICAgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgICAgICBtb2RzID0gY29uZmlnLm1vZHVsZXMsXG4gICAgICAgICAgICBncm91cHMgPSBjb25maWcuZ3JvdXBzLFxuICAgICAgICAgICAgYWxpYXNlcyA9IGNvbmZpZy5hbGlhc2VzLFxuICAgICAgICAgICAgbG9hZGVyID0gdGhpcy5FbnYuX2xvYWRlcjtcblxuICAgICAgICBmb3IgKG5hbWUgaW4gbykge1xuICAgICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhdHRyID0gb1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobW9kcyAmJiBuYW1lID09ICdtb2R1bGVzJykge1xuICAgICAgICAgICAgICAgICAgICBjbG9iYmVyKG1vZHMsIGF0dHIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxpYXNlcyAmJiBuYW1lID09ICdhbGlhc2VzJykge1xuICAgICAgICAgICAgICAgICAgICBjbG9iYmVyKGFsaWFzZXMsIGF0dHIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBzICYmIG5hbWUgPT0gJ2dyb3VwcycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvYmJlcihncm91cHMsIGF0dHIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSAnd2luJykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWdbbmFtZV0gPSAoYXR0ciAmJiBhdHRyLmNvbnRlbnRXaW5kb3cpIHx8IGF0dHI7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kb2MgPSBjb25maWdbbmFtZV0gPyBjb25maWdbbmFtZV0uZG9jdW1lbnQgOiBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSAnX3l1aWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXNlcnZlIHRoZSBndWlkXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW25hbWVdID0gYXR0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICBsb2FkZXIuX2NvbmZpZyhvKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgIE9sZCB3YXkgdG8gYXBwbHkgYSBjb25maWcgdG8gdGhpcyBpbnN0YW5jZSAoY2FsbHMgYGFwcGx5Q29uZmlnYCB1bmRlciB0aGVcbiAgICBob29kKS5cblxuICAgIEBwcml2YXRlXG4gICAgQG1ldGhvZCBfY29uZmlnXG4gICAgQHBhcmFtIHtPYmplY3R9IG8gVGhlIGNvbmZpZyB0byBhcHBseVxuICAgICoqL1xuICAgIF9jb25maWc6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdGhpcy5hcHBseUNvbmZpZyhvKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgSW5pdGlhbGl6ZXMgdGhpcyBZVUkgaW5zdGFuY2UuXG5cbiAgICBAcHJpdmF0ZVxuICAgIEBtZXRob2QgX2luaXRcbiAgICAqKi9cbiAgICBfaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWx0ZXIsIGVsLFxuICAgICAgICAgICAgWSA9IHRoaXMsXG4gICAgICAgICAgICBHX0VOViA9IFlVSS5FbnYsXG4gICAgICAgICAgICBFbnYgPSBZLkVudixcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSB2ZXJzaW9uIG51bWJlciBvZiB0aGlzIFlVSSBpbnN0YW5jZS5cblxuICAgICAgICBUaGlzIHZhbHVlIGlzIHR5cGljYWxseSB1cGRhdGVkIGJ5IGEgc2NyaXB0IHdoZW4gYSBZVUkgcmVsZWFzZSBpcyBidWlsdCxcbiAgICAgICAgc28gaXQgbWF5IG5vdCByZWZsZWN0IHRoZSBjb3JyZWN0IHZlcnNpb24gbnVtYmVyIHdoZW4gWVVJIGlzIHJ1biBmcm9tXG4gICAgICAgIHRoZSBkZXZlbG9wbWVudCBzb3VyY2UgdHJlZS5cblxuICAgICAgICBAcHJvcGVydHkge1N0cmluZ30gdmVyc2lvblxuICAgICAgICAqKi9cbiAgICAgICAgWS52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgICAgICBpZiAoIUVudikge1xuICAgICAgICAgICAgWS5FbnYgPSB7XG4gICAgICAgICAgICAgICAgY29yZTogWydnZXQnLCAnZmVhdHVyZXMnLCAnaW50bC1iYXNlJywgJ3l1aS1sb2cnLCAneXVpLWxhdGVyJ10sXG4gICAgICAgICAgICAgICAgbG9hZGVyRXh0cmFzOiBbJ2xvYWRlci1yb2xsdXAnLCAnbG9hZGVyLXl1aTMnXSxcbiAgICAgICAgICAgICAgICBtb2RzOiB7fSwgLy8gZmxhdCBtb2R1bGUgbWFwXG4gICAgICAgICAgICAgICAgdmVyc2lvbnM6IHt9LCAvLyB2ZXJzaW9uIG1vZHVsZSBtYXBcbiAgICAgICAgICAgICAgICBiYXNlOiBCQVNFLFxuICAgICAgICAgICAgICAgIGNkbjogQkFTRSArIFZFUlNJT04gKyAnL2J1aWxkLycsXG4gICAgICAgICAgICAgICAgLy8gYm9vdHN0cmFwcGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBfaWR4OiAwLFxuICAgICAgICAgICAgICAgIF91c2VkOiB7fSxcbiAgICAgICAgICAgICAgICBfYXR0YWNoZWQ6IHt9LFxuICAgICAgICAgICAgICAgIF9leHBvcnRlZDoge30sXG4gICAgICAgICAgICAgICAgX21pc3NlZDogW10sXG4gICAgICAgICAgICAgICAgX3lpZHg6IDAsXG4gICAgICAgICAgICAgICAgX3VpZHg6IDAsXG4gICAgICAgICAgICAgICAgX2d1aWRwOiAneScsXG4gICAgICAgICAgICAgICAgX2xvYWRlZDoge30sXG4gICAgICAgICAgICAgICAgLy8gc2VydmljZWQ6IHt9LFxuICAgICAgICAgICAgICAgIC8vIFJlZ2V4IGluIEVuZ2xpc2g6XG4gICAgICAgICAgICAgICAgLy8gSSdsbCBzdGFydCBhdCB0aGUgXFxiKHl1aSkuXG4gICAgICAgICAgICAgICAgLy8gMS4gTG9vayBpbiB0aGUgdGVzdCBzdHJpbmcgZm9yIFwieXVpXCIgb3JcbiAgICAgICAgICAgICAgICAvLyAgICBcInl1aS1iYXNlXCIgb3IgXCJ5dWktZGF2Z2xhc3NcIiBvciBcInl1aS1mb29iYXJcIiB0aGF0IGNvbWVzIGFmdGVyIGEgd29yZCBicmVhay4gIFRoYXQgaXMsIGl0XG4gICAgICAgICAgICAgICAgLy8gICAgY2FuJ3QgbWF0Y2ggXCJmb3l1aVwiIG9yIFwiaV9oZWFydF95dWlcIi4gVGhpcyBjYW4gYmUgYW55d2hlcmUgaW4gdGhlIHN0cmluZy5cbiAgICAgICAgICAgICAgICAvLyAyLiBBZnRlciAjMSBtdXN0IGNvbWUgYSBmb3J3YXJkIHNsYXNoIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmcgbWF0Y2hlZCBpbiAjMSwgc29cbiAgICAgICAgICAgICAgICAvLyAgICBcInl1aS1iYXNlL3l1aS1iYXNlXCIgb3IgXCJ5dWktcGFudHMveXVpLXBhbnRzXCIuXG4gICAgICAgICAgICAgICAgLy8gMy4gVGhlIHNlY29uZCBvY2N1cmVuY2Ugb2YgdGhlICMxIHRva2VuIGNhbiBvcHRpb25hbGx5IGJlIGZvbGxvd2VkIGJ5IFwiLWRlYnVnXCIgb3IgXCItbWluXCIsXG4gICAgICAgICAgICAgICAgLy8gICAgc28gXCJ5dWkveXVpLW1pblwiLCBcInl1aS95dWktZGVidWdcIiwgXCJ5dWktYmFzZS95dWktYmFzZS1kZWJ1Z1wiLiBOT1QgXCJ5dWkveXVpLXRzaGlydFwiLlxuICAgICAgICAgICAgICAgIC8vIDQuIFRoaXMgaXMgZm9sbG93ZWQgYnkgXCIuanNcIiwgc28gXCJ5dWkveXVpLmpzXCIuXG4gICAgICAgICAgICAgICAgLy8gMC4gR29pbmcgYmFjayB0byB0aGUgYmVnaW5uaW5nLCBub3cuIElmIGFsbCB0aGF0IHN0dWZmIGluIDEtNCBjb21lcyBhZnRlciBhIFwiP1wiIGluIHRoZSBzdHJpbmcsXG4gICAgICAgICAgICAgICAgLy8gICAgdGhlbiBjYXB0dXJlIHRoZSBqdW5rIGJldHdlZW4gdGhlIExBU1QgXCImXCIgYW5kIHRoZSBzdHJpbmcgaW4gMS00LiAgU29cbiAgICAgICAgICAgICAgICAvLyAgICBcImJsYWg/Zm9vL3l1aS95dWkuanNcIiB3aWxsIGNhcHR1cmUgXCJmb28vXCIgYW5kIFwiYmxhaD9zb21lL3RoaW5nLmpzJjMuMy4wL2J1aWxkL3l1aS1kYXZnbGFzcy95dWktZGF2Z2xhc3MuanNcIlxuICAgICAgICAgICAgICAgIC8vICAgIHdpbGwgY2FwdHVyZSBcIjMuMy4wL2J1aWxkL1wiXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBSZWdleCBFeHBsb2RlZDpcbiAgICAgICAgICAgICAgICAvLyAoPzpcXD8gICAgICAgICAgICAgRmluZCBhID9cbiAgICAgICAgICAgICAgICAvLyAgICg/OlteJl0qJikgICAgICBmb2xsb3dlZCBieSAwLi5uIGNoYXJhY3RlcnMgZm9sbG93ZWQgYnkgYW4gJlxuICAgICAgICAgICAgICAgIC8vICAgKiAgICAgICAgICAgICAgIGluIGZhY3QsIGZpbmQgYXMgbWFueSBzZXRzIG9mIGNoYXJhY3RlcnMgZm9sbG93ZWQgYnkgYSAmIGFzIHlvdSBjYW5cbiAgICAgICAgICAgICAgICAvLyAgIChbXiZdKikgICAgICAgICBjYXB0dXJlIHRoZSBzdHVmZiBhZnRlciB0aGUgbGFzdCAmIGluIFxcMVxuICAgICAgICAgICAgICAgIC8vICk/ICAgICAgICAgICAgICAgIGJ1dCBpdCdzIG9rIGlmIGFsbCB0aGlzID9qdW5rJm1vcmVfanVuayBzdHVmZiBpc24ndCBldmVuIHRoZXJlXG4gICAgICAgICAgICAgICAgLy8gXFxiKCAgICAgICAgICAgICAgIGFmdGVyIGEgd29yZCBicmVhayBmaW5kIGVpdGhlciB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgLy8gICAgeXVpKD86LVxcdyspPyAgIFwieXVpXCIgb3B0aW9uYWxseSBmb2xsb3dlZCBieSBhIC0sIHRoZW4gbW9yZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgLy8gKSAgICAgICAgICAgICAgICAgYW5kIHN0b3JlIHRoZSB5dWktKiBzdHJpbmcgaW4gXFwyXG4gICAgICAgICAgICAgICAgLy8gXFwvXFwyICAgICAgICAgICAgICB0aGVuIGNvbWVzIGEgLyBmb2xsb3dlZCBieSB0aGUgeXVpLSogc3RyaW5nIGluIFxcMlxuICAgICAgICAgICAgICAgIC8vICg/Oi0obWlufGRlYnVnKSk/IG9wdGlvbmFsbHkgZm9sbG93ZWQgYnkgXCItbWluXCIgb3IgXCItZGVidWdcIlxuICAgICAgICAgICAgICAgIC8vIC5qcyAgICAgICAgICAgICAgIGFuZCBlbmRpbmcgaW4gXCIuanNcIlxuICAgICAgICAgICAgICAgIF9CQVNFX1JFOiAvKD86XFw/KD86W14mXSomKSooW14mXSopKT9cXGIoeXVpKD86LVxcdyspPylcXC9cXDIoPzotKG1pbnxkZWJ1ZykpP1xcLmpzLyxcbiAgICAgICAgICAgICAgICBwYXJzZUJhc2VQYXRoOiBmdW5jdGlvbihzcmMsIHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gc3JjLm1hdGNoKHBhdHRlcm4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCwgZmlsdGVyO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFJlZ0V4cC5sZWZ0Q29udGV4dCB8fCBzcmMuc2xpY2UoMCwgc3JjLmluZGV4T2YobWF0Y2hbMF0pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBzZXQgdXAgdGhlIHBhdGggdG8gdGhlIGxvYWRlci4gIFRoZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgZm9yIGxvYWRlciBzaG91bGQgbWF0Y2ggdGhlIHl1aSBpbmNsdWRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gbWF0Y2hbM107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4dHJhY3QgY29ycmVjdCBwYXRoIGZvciBtaXhlZCBjb21ibyB1cmxzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8veXVpbGlicmFyeS5jb20vcHJvamVjdHMveXVpMy90aWNrZXQvMjUyODQyM1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCArPSAnPycgKyBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldEJhc2U6IEdfRU5WICYmIEdfRU5WLmdldEJhc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSAoZG9jICYmIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JykpIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gRW52LmNkbiwgcGFyc2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLCBsZW4sIHNyYztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IG5vZGVzW2ldLnNyYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gWS5FbnYucGFyc2VCYXNlUGF0aChzcmMsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IHBhcnNlZC5maWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIENETiBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEVudiA9IFkuRW52O1xuXG4gICAgICAgICAgICBFbnYuX2xvYWRlZFtWRVJTSU9OXSA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoR19FTlYgJiYgWSAhPT0gWVVJKSB7XG4gICAgICAgICAgICAgICAgRW52Ll95aWR4ID0gKytHX0VOVi5feWlkeDtcbiAgICAgICAgICAgICAgICBFbnYuX2d1aWRwID0gKCd5dWlfJyArIFZFUlNJT04gKyAnXycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbnYuX3lpZHggKyAnXycgKyB0aW1lKS5yZXBsYWNlKC9bXmEtejAtOV9dKy9nLCAnXycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChZVUkuX1lVSSkge1xuXG4gICAgICAgICAgICAgICAgR19FTlYgPSBZVUkuX1lVSS5FbnY7XG4gICAgICAgICAgICAgICAgRW52Ll95aWR4ICs9IEdfRU5WLl95aWR4O1xuICAgICAgICAgICAgICAgIEVudi5fdWlkeCArPSBHX0VOVi5fdWlkeDtcblxuICAgICAgICAgICAgICAgIGZvciAocHJvcCBpbiBHX0VOVikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9wIGluIEVudikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVudltwcm9wXSA9IEdfRU5WW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIFlVSS5fWVVJO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBZLmlkID0gWS5zdGFtcChZKTtcbiAgICAgICAgICAgIGluc3RhbmNlc1tZLmlkXSA9IFk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIFkuY29uc3RydWN0b3IgPSBZVUk7XG5cbiAgICAgICAgLy8gY29uZmlndXJhdGlvbiBkZWZhdWx0c1xuICAgICAgICBZLmNvbmZpZyA9IFkuY29uZmlnIHx8IHtcbiAgICAgICAgICAgIGJvb3RzdHJhcDogdHJ1ZSxcbiAgICAgICAgICAgIGNhY2hlVXNlOiB0cnVlLFxuICAgICAgICAgICAgZGVidWc6IHRydWUsXG4gICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgIGZldGNoQ1NTOiB0cnVlLFxuICAgICAgICAgICAgdGhyb3dGYWlsOiB0cnVlLFxuICAgICAgICAgICAgdXNlQnJvd3NlckNvbnNvbGU6IHRydWUsXG4gICAgICAgICAgICB1c2VOYXRpdmVFUzU6IHRydWUsXG4gICAgICAgICAgICB3aW46IHdpbixcbiAgICAgICAgICAgIGdsb2JhbDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vUmVnaXN0ZXIgdGhlIENTUyBzdGFtcCBlbGVtZW50XG4gICAgICAgIGlmIChkb2MgJiYgIWRvYy5nZXRFbGVtZW50QnlJZChDU1NfU1RBTVBfRUwpKSB7XG4gICAgICAgICAgICBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9ICc8ZGl2IGlkPVwiJyArIENTU19TVEFNUF9FTCArICdcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50OyB2aXNpYmlsaXR5OiBoaWRkZW4gIWltcG9ydGFudFwiPjwvZGl2Pic7XG4gICAgICAgICAgICBZVUkuRW52LmNzc1N0YW1wRWwgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGRvYy5ib2R5KSB7XG4gICAgICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoWVVJLkVudi5jc3NTdGFtcEVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jRWwuaW5zZXJ0QmVmb3JlKFlVSS5FbnYuY3NzU3RhbXBFbCwgZG9jRWwuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jICYmIGRvYy5nZXRFbGVtZW50QnlJZChDU1NfU1RBTVBfRUwpICYmICFZVUkuRW52LmNzc1N0YW1wRWwpIHtcbiAgICAgICAgICAgIFlVSS5FbnYuY3NzU3RhbXBFbCA9IGRvYy5nZXRFbGVtZW50QnlJZChDU1NfU1RBTVBfRUwpO1xuICAgICAgICB9XG5cbiAgICAgICAgWS5jb25maWcubGFuZyA9IFkuY29uZmlnLmxhbmcgfHwgJ2VuLVVTJztcblxuICAgICAgICBZLmNvbmZpZy5iYXNlID0gWVVJLmNvbmZpZy5iYXNlIHx8IFkuRW52LmdldEJhc2UoWS5FbnYuX0JBU0VfUkUpO1xuXG4gICAgICAgIGlmICghZmlsdGVyIHx8ICghKCdtaW5kZWJ1ZycpLmluZGV4T2YoZmlsdGVyKSkpIHtcbiAgICAgICAgICAgIGZpbHRlciA9ICdtaW4nO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlciA9IChmaWx0ZXIpID8gJy0nICsgZmlsdGVyIDogZmlsdGVyO1xuICAgICAgICBZLmNvbmZpZy5sb2FkZXJQYXRoID0gWVVJLmNvbmZpZy5sb2FkZXJQYXRoIHx8ICdsb2FkZXIvbG9hZGVyJyArIGZpbHRlciArICcuanMnO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgIEZpbmlzaGVzIHRoZSBpbnN0YW5jZSBzZXR1cC4gQXR0YWNoZXMgd2hhdGV2ZXIgWVVJIG1vZHVsZXMgd2VyZSBkZWZpbmVkXG4gICAgYXQgdGhlIHRpbWUgdGhhdCB0aGlzIGluc3RhbmNlIHdhcyBjcmVhdGVkLlxuXG4gICAgQG1ldGhvZCBfc2V0dXBcbiAgICBAcHJpdmF0ZVxuICAgICoqL1xuICAgIF9zZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLCBZID0gdGhpcyxcbiAgICAgICAgICAgIGNvcmUgPSBbXSxcbiAgICAgICAgICAgIG1vZHMgPSBZVUkuRW52Lm1vZHMsXG4gICAgICAgICAgICBleHRyYXMgPSBZLmNvbmZpZy5jb3JlIHx8IFtdLmNvbmNhdChZVUkuRW52LmNvcmUpOyAvL0Nsb25lIGl0Li5cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXh0cmFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobW9kc1tleHRyYXNbaV1dKSB7XG4gICAgICAgICAgICAgICAgY29yZS5wdXNoKGV4dHJhc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBZLl9hdHRhY2goWyd5dWktYmFzZSddKTtcbiAgICAgICAgWS5fYXR0YWNoKGNvcmUpO1xuXG4gICAgICAgIGlmIChZLkxvYWRlcikge1xuICAgICAgICAgICAgZ2V0TG9hZGVyKFkpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgRXhlY3V0ZXMgdGhlIG5hbWVkIG1ldGhvZCBvbiB0aGUgc3BlY2lmaWVkIFlVSSBpbnN0YW5jZSBpZiB0aGF0IG1ldGhvZCBpc1xuICAgIHdoaXRlbGlzdGVkLlxuXG4gICAgQG1ldGhvZCBhcHBseVRvXG4gICAgQHBhcmFtIHtTdHJpbmd9IGlkIFlVSSBpbnN0YW5jZSBpZC5cbiAgICBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgdGhlIG1ldGhvZCB0byBleGVjdXRlLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgJ09iamVjdC5rZXlzJy5cbiAgICBAcGFyYW0ge0FycmF5fSBhcmdzIEFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgbWV0aG9kLlxuICAgIEByZXR1cm4ge01peGVkfSBSZXR1cm4gdmFsdWUgZnJvbSB0aGUgYXBwbGllZCBtZXRob2QsIG9yIGBudWxsYCBpZiB0aGVcbiAgICAgICAgc3BlY2lmaWVkIGluc3RhbmNlIHdhcyBub3QgZm91bmQgb3IgdGhlIG1ldGhvZCB3YXMgbm90IHdoaXRlbGlzdGVkLlxuICAgICoqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKGlkLCBtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgaWYgKCEobWV0aG9kIGluIEFQUExZX1RPX0FVVEgpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhtZXRob2QgKyAnOiBhcHBseVRvIG5vdCBhbGxvd2VkJywgJ3dhcm4nLCAneXVpJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1tpZF0sIG5lc3QsIG0sIGk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgbmVzdCA9IG1ldGhvZC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgbSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5lc3QubGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBtID0gbVtuZXN0W2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coJ2FwcGx5VG8gbm90IGZvdW5kOiAnICsgbWV0aG9kLCAnd2FybicsICd5dWknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbSAmJiBtLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbi8qKlxuUmVnaXN0ZXJzIGEgWVVJIG1vZHVsZSBhbmQgbWFrZXMgaXQgYXZhaWxhYmxlIGZvciB1c2UgaW4gYSBgWVVJKCkudXNlKClgIGNhbGwgb3JcbmFzIGEgZGVwZW5kZW5jeSBmb3Igb3RoZXIgbW9kdWxlcy5cblxuVGhlIGVhc2llc3Qgd2F5IHRvIGNyZWF0ZSBhIGZpcnN0LWNsYXNzIFlVSSBtb2R1bGUgaXMgdG8gdXNlXG48YSBocmVmPVwiaHR0cDovL3l1aS5naXRodWIuY29tL3NoaWZ0ZXIvXCI+U2hpZnRlcjwvYT4sIHRoZSBZVUkgY29tcG9uZW50IGJ1aWxkXG50b29sLlxuXG5TaGlmdGVyIHdpbGwgYXV0b21hdGljYWxseSB3cmFwIHlvdXIgbW9kdWxlIGNvZGUgaW4gYSBgWVVJLmFkZCgpYCBjYWxsIGFsb25nXG53aXRoIGFueSBjb25maWd1cmF0aW9uIGluZm8gcmVxdWlyZWQgZm9yIHRoZSBtb2R1bGUuXG5cbkBleGFtcGxlXG5cbiAgICBZVUkuYWRkKCdkYXZnbGFzcycsIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgIFkuZGF2Z2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH07XG4gICAgfSwgJzMuNC4wJywge1xuICAgICAgICByZXF1aXJlczogWydoYXJsZXktZGF2aWRzb24nLCAnbXQtZGV3J11cbiAgICB9KTtcblxuQG1ldGhvZCBhZGRcbkBwYXJhbSB7U3RyaW5nfSBuYW1lIE1vZHVsZSBuYW1lLlxuQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gY29udGFpbmluZyBtb2R1bGUgY29kZS4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlXG4gICAgZXhlY3V0ZWQgd2hlbmV2ZXIgdGhlIG1vZHVsZSBpcyBhdHRhY2hlZCB0byBhIHNwZWNpZmljIFlVSSBpbnN0YW5jZS5cblxuICAgIEBwYXJhbSB7WVVJfSBmbi5ZIFRoZSBZVUkgaW5zdGFuY2UgdG8gd2hpY2ggdGhpcyBtb2R1bGUgaXMgYXR0YWNoZWQuXG4gICAgQHBhcmFtIHtTdHJpbmd9IGZuLm5hbWUgTmFtZSBvZiB0aGUgbW9kdWxlXG5cbkBwYXJhbSB7U3RyaW5nfSB2ZXJzaW9uIE1vZHVsZSB2ZXJzaW9uIG51bWJlci4gVGhpcyBpcyBjdXJyZW50bHkgdXNlZCBvbmx5IGZvclxuICAgIGluZm9ybWF0aW9uYWwgcHVycG9zZXMsIGFuZCBpcyBub3QgdXNlZCBpbnRlcm5hbGx5IGJ5IFlVSS5cblxuQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzXSBNb2R1bGUgY29uZmlnLlxuICAgIEBwYXJhbSB7QXJyYXl9IFtkZXRhaWxzLnJlcXVpcmVzXSBBcnJheSBvZiBvdGhlciBtb2R1bGUgbmFtZXMgdGhhdCBtdXN0IGJlXG4gICAgICAgIGF0dGFjaGVkIGJlZm9yZSB0aGlzIG1vZHVsZSBjYW4gYmUgYXR0YWNoZWQuXG4gICAgQHBhcmFtIHtBcnJheX0gW2RldGFpbHMub3B0aW9uYWxdIEFycmF5IG9mIG9wdGlvbmFsIG1vZHVsZSBuYW1lcyB0aGF0IHNob3VsZFxuICAgICAgICBiZSBhdHRhY2hlZCBiZWZvcmUgdGhpcyBtb2R1bGUgaXMgYXR0YWNoZWQgaWYgdGhleSd2ZSBhbHJlYWR5IGJlZW5cbiAgICAgICAgbG9hZGVkLiBJZiB0aGUgYGxvYWRPcHRpb25hbGAgWVVJIG9wdGlvbiBpcyBgdHJ1ZWAsIG9wdGlvbmFsIG1vZHVsZXNcbiAgICAgICAgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBsb2FkZWQgd2lsbCBiZSBsb2FkZWQganVzdCBhcyBpZiB0aGV5IHdlcmUgaGFyZFxuICAgICAgICByZXF1aXJlbWVudHMuXG4gICAgQHBhcmFtIHtBcnJheX0gW2RldGFpbHMudXNlXSBBcnJheSBvZiBtb2R1bGUgbmFtZXMgdGhhdCBhcmUgaW5jbHVkZWQgd2l0aGluXG4gICAgICAgIG9yIG90aGVyd2lzZSBwcm92aWRlZCBieSB0aGlzIG1vZHVsZSwgYW5kIHdoaWNoIHNob3VsZCBiZSBhdHRhY2hlZFxuICAgICAgICBhdXRvbWF0aWNhbGx5IHdoZW4gdGhpcyBtb2R1bGUgaXMgYXR0YWNoZWQuIFRoaXMgbWFrZXMgaXQgcG9zc2libGUgdG9cbiAgICAgICAgY3JlYXRlIFwidmlydHVhbCByb2xsdXBcIiBtb2R1bGVzIHRoYXQgc2ltcGx5IGF0dGFjaCBhIGNvbGxlY3Rpb24gb2Ygb3RoZXJcbiAgICAgICAgbW9kdWxlcyBvciBzdWJtb2R1bGVzLlxuXG5AcmV0dXJuIHtZVUl9IFRoaXMgWVVJIGluc3RhbmNlLlxuKiovXG4gICAgYWRkOiBmdW5jdGlvbihuYW1lLCBmbiwgdmVyc2lvbiwgZGV0YWlscykge1xuICAgICAgICBkZXRhaWxzID0gZGV0YWlscyB8fCB7fTtcbiAgICAgICAgdmFyIGVudiA9IFlVSS5FbnYsXG4gICAgICAgICAgICBtb2QgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBmbjogZm4sXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9JbnN0YW5jZSBoYXNoIHNvIHdlIGRvbid0IGFwcGx5IGl0IHRvIHRoZSBzYW1lIGluc3RhbmNlIHR3aWNlXG4gICAgICAgICAgICBhcHBsaWVkID0ge30sXG4gICAgICAgICAgICBsb2FkZXIsIGluc3QsIG1vZEluZm8sXG4gICAgICAgICAgICBpLCB2ZXJzaW9ucyA9IGVudi52ZXJzaW9ucztcblxuICAgICAgICBlbnYubW9kc1tuYW1lXSA9IG1vZDtcbiAgICAgICAgdmVyc2lvbnNbdmVyc2lvbl0gPSB2ZXJzaW9uc1t2ZXJzaW9uXSB8fCB7fTtcbiAgICAgICAgdmVyc2lvbnNbdmVyc2lvbl1bbmFtZV0gPSBtb2Q7XG5cbiAgICAgICAgZm9yIChpIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIGluc3QgPSBpbnN0YW5jZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFhcHBsaWVkW2luc3QuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWRbaW5zdC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsb2FkZXIgPSBpbnN0LkVudi5fbG9hZGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RJbmZvID0gbG9hZGVyLmdldE1vZHVsZUluZm8obmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1vZEluZm8gfHwgbW9kSW5mby50ZW1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVyLmFkZE1vZHVsZShkZXRhaWxzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBFeGVjdXRlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gYXNzb2NpYXRlZCB3aXRoIGVhY2ggcmVxdWlyZWQgbW9kdWxlLFxuICAgIGF0dGFjaGluZyB0aGUgbW9kdWxlIHRvIHRoaXMgWVVJIGluc3RhbmNlLlxuXG4gICAgQG1ldGhvZCBfYXR0YWNoXG4gICAgQHBhcmFtIHtBcnJheX0gciBUaGUgYXJyYXkgb2YgbW9kdWxlcyB0byBhdHRhY2hcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFttb290PWZhbHNlXSBJZiBgdHJ1ZWAsIGRvbid0IHRocm93IGEgd2FybmluZyBpZiB0aGUgbW9kdWxlXG4gICAgICAgIGlzIG5vdCBhdHRhY2hlZC5cbiAgICBAcHJpdmF0ZVxuICAgICoqL1xuICAgIF9hdHRhY2g6IGZ1bmN0aW9uKHIsIG1vb3QpIHtcbiAgICAgICAgdmFyIGksIG5hbWUsIG1vZCwgZGV0YWlscywgcmVxLCB1c2UsIGFmdGVyLFxuICAgICAgICAgICAgbW9kcyA9IFlVSS5FbnYubW9kcyxcbiAgICAgICAgICAgIGFsaWFzZXMgPSBZVUkuRW52LmFsaWFzZXMsXG4gICAgICAgICAgICBZID0gdGhpcywgaixcbiAgICAgICAgICAgIGNhY2hlID0gWVVJLkVudi5fcmVuZGVyZWRNb2RzLFxuICAgICAgICAgICAgbG9hZGVyID0gWS5FbnYuX2xvYWRlcixcbiAgICAgICAgICAgIGRvbmUgPSBZLkVudi5fYXR0YWNoZWQsXG4gICAgICAgICAgICBleHBvcnRlZCA9IFkuRW52Ll9leHBvcnRlZCxcbiAgICAgICAgICAgIGxlbiA9IHIubGVuZ3RoLCBsb2FkZXIsIGRlZiwgZ28sXG4gICAgICAgICAgICBjID0gW10sXG4gICAgICAgICAgICBtb2RBcmdzLCBlc0NvbXBhdCwgcmVxbGVuLCBtb2RJbmZvLFxuICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgX19leHBvcnRzX18sIF9faW1wb3J0c19fO1xuXG4gICAgICAgIC8vQ2hlY2sgZm9yIGNvbmRpdGlvbmFsIG1vZHVsZXMgKGluIGEgc2Vjb25kKyBpbnN0YW5jZSkgYW5kIGFkZCB0aGVpciByZXF1aXJlbWVudHNcbiAgICAgICAgLy9UT0RPIEkgaGF0ZSB0aGlzIGVudGlyZSBtZXRob2QsIGl0IG5lZWRzIHRvIGJlIGZpeGVkIEFTQVAgKDMuNS4wKSBeZGF2Z2xhc3NcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gcltpXTtcbiAgICAgICAgICAgIG1vZCA9IG1vZHNbbmFtZV07XG4gICAgICAgICAgICBjLnB1c2gobmFtZSk7XG4gICAgICAgICAgICBpZiAobG9hZGVyICYmIGxvYWRlci5jb25kaXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqIGluIGxvYWRlci5jb25kaXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkZXIuY29uZGl0aW9uc1tuYW1lXS5oYXNPd25Qcm9wZXJ0eShqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmID0gbG9hZGVyLmNvbmRpdGlvbnNbbmFtZV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICBnbyA9IGRlZiAmJiAoKGRlZi51YSAmJiBZLlVBW2RlZi51YV0pIHx8IChkZWYudGVzdCAmJiBkZWYudGVzdChZKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5wdXNoKGRlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByID0gYztcbiAgICAgICAgbGVuID0gci5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWRvbmVbcltpXV0pIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gcltpXTtcbiAgICAgICAgICAgICAgICBtb2QgPSBtb2RzW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFsaWFzZXMgJiYgYWxpYXNlc1tuYW1lXSAmJiAhbW9kKSB7XG4gICAgICAgICAgICAgICAgICAgIFkuX2F0dGFjaChhbGlhc2VzW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbW9kKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZEluZm8gPSBsb2FkZXIgJiYgbG9hZGVyLmdldE1vZHVsZUluZm8obmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2QgPSBtb2RJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9vdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKCFsb2FkZXIgfHwgIWxvYWRlci5tb2R1bGVJbmZvW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKCghbG9hZGVyIHx8ICFsb2FkZXIubW9kdWxlSW5mb1tuYW1lXSkgJiYgIW1vb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb290ICYmIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobmFtZS5pbmRleE9mKCdza2luLScpID09PSAtMSkgJiYgKG5hbWUuaW5kZXhPZignY3NzJykgPT09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFkuRW52Ll9taXNzZWQucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBZLkVudi5fbWlzc2VkID0gWS5BcnJheS5kZWR1cGUoWS5FbnYuX21pc3NlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWS5tZXNzYWdlKCdOT1QgbG9hZGVkOiAnICsgbmFtZSwgJ3dhcm4nLCAneXVpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb25lW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy9Eb24ndCBsaWtlIHRoaXMsIGJ1dCBpbiBjYXNlIGEgbW9kIHdhcyBhc2tlZCBmb3Igb25jZSwgdGhlbiB3ZSBmZXRjaCBpdFxuICAgICAgICAgICAgICAgICAgICAvL1dlIG5lZWQgdG8gcmVtb3ZlIGl0IGZyb20gdGhlIG1pc3NlZCBsaXN0IF5kYXZnbGFzc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgWS5FbnYuX21pc3NlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFkuRW52Ll9taXNzZWRbal0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBZLm1lc3NhZ2UoJ0ZvdW5kOiAnICsgbmFtZSArICcgKHdhcyByZXBvcnRlZCBhcyBtaXNzaW5nIGVhcmxpZXIpJywgJ3dhcm4nLCAneXVpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWS5FbnYuX21pc3NlZC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbCBkZXBlbmRlbmNpZXMgbm9ybWFsbHkgd29yayBieSBtb2RpZnlpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlcGVuZGVuY3kgbGlzdCBvZiBhIG1vZHVsZS4gSWYgdGhlIGRlcGVuZGVuY3kncyB0ZXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3NlcyBpdCBpcyBhZGRlZCB0byB0aGUgbGlzdC4gSWYgbm90LCBpdCdzIG5vdCBsb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZm9sbG93aW5nIGNoZWNrIGVuc3VyZXMgdGhhdCBvcHRpb25hbCBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIG5vdCBhdHRhY2hlZCB3aGVuIHRoZXkgd2VyZSBhbHJlYWR5IGxvYWRlZCBpbnRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBwYWdlICh3aGVuIGJ1bmRsaW5nIGZvciBleGFtcGxlKVxuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGVyICYmICFsb2FkZXIuX2NhbkJlQXR0YWNoZWQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgIElmIGl0J3MgYSB0ZW1wIG1vZHVsZSwgd2UgbmVlZCB0byByZWRvIGl0J3MgcmVxdWlyZW1lbnRzIGlmIGl0J3MgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmNlIGl0IG1heSBoYXZlIGJlZW4gbG9hZGVkIGJ5IGFub3RoZXIgaW5zdGFuY2UgYW5kIGl0J3MgZGVwZW5kZW5jaWVzIG1pZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlIGJlZW4gcmVkZWZpbmVkIGluc2lkZSB0aGUgZmV0Y2hlZCBmaWxlLlxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGVyICYmIGNhY2hlICYmIGNhY2hlW25hbWVdICYmIGNhY2hlW25hbWVdLnRlbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlci5nZXRSZXF1aXJlcyhjYWNoZVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZEluZm8gPSBsb2FkZXIuZ2V0TW9kdWxlSW5mbyhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiBpbiBtb2RJbmZvLmV4cGFuZGVkX21hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RJbmZvLmV4cGFuZGVkX21hcC5oYXNPd25Qcm9wZXJ0eShqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEucHVzaChqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBZLl9hdHRhY2gocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBtb2QuZGV0YWlscztcbiAgICAgICAgICAgICAgICAgICAgcmVxID0gZGV0YWlscy5yZXF1aXJlcztcbiAgICAgICAgICAgICAgICAgICAgZXNDb21wYXQgPSBkZXRhaWxzLmVzO1xuICAgICAgICAgICAgICAgICAgICB1c2UgPSBkZXRhaWxzLnVzZTtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBkZXRhaWxzLmFmdGVyO1xuICAgICAgICAgICAgICAgICAgICAvL0ZvcmNlIEludGwgbG9hZCBpZiB0aGVyZSBpcyBhIGxhbmd1YWdlIChMb2FkZXIgbG9naWMpIEB0b2RvIGZpeCB0aGlzIHNoaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldGFpbHMubGFuZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gcmVxIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnVuc2hpZnQoJ2ludGwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcWxlbiA9IHJlcS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmVxbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmVbcmVxW2pdXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVkuX2F0dGFjaChyZXEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYWZ0ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmVbYWZ0ZXJbal1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghWS5fYXR0YWNoKGFmdGVyLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2QuZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZEFyZ3MgPSBbWSwgbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXNDb21wYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2ltcG9ydHNfXyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZXhwb3J0c19fID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFzc2luZyBgZXhwb3J0c2AgYW5kIGBpbXBvcnRzYCBvbnRvIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RBcmdzLnB1c2goX19pbXBvcnRzX18sIF9fZXhwb3J0c19fKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcWxlbiA9IHJlcS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByZXFsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19pbXBvcnRzX19bcmVxW2pdXSA9IGV4cG9ydGVkLmhhc093blByb3BlcnR5KHJlcVtqXSkgPyBleHBvcnRlZFtyZXFbal1dIDogWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChZLmNvbmZpZy50aHJvd0ZhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2V4cG9ydHNfXyA9IG1vZC5mbi5hcHBseShlc0NvbXBhdCA/IHVuZGVmaW5lZCA6IG1vZCwgbW9kQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZXhwb3J0c19fID0gbW9kLmZuLmFwcGx5KGVzQ29tcGF0ID8gdW5kZWZpbmVkIDogbW9kLCBtb2RBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFkuZXJyb3IoJ0F0dGFjaCBlcnJvcjogJyArIG5hbWUsIGUsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVzQ29tcGF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgdGhlIGBleHBvcnRzYCBpbiBjYXNlIG90aGVycyBgZXNgIG1vZHVsZXMgcmVxdWlyZXMgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFtuYW1lXSA9IF9fZXhwb3J0c19fO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gRVMgbW9kdWxlIGlzIGNvbmRpdGlvbmFsbHkgbG9hZGVkIGFuZCBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSB1c2VkIFwiaW5zdGVhZFwiIGFub3RoZXIgbW9kdWxlLCByZXBsYWNlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgbW9kdWxlJ3MgY29udGVudCB3aXRoIHRoZSBjb25kaXRpb25hbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9hZGVkIG9uZSBzbyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHJlcXVpcmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIG1ha2VzIHNlbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uID0gbW9kLmRldGFpbHMuY29uZGl0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24gJiYgY29uZGl0aW9uLndoZW4gPT09ICdpbnN0ZWFkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFtjb25kaXRpb24udHJpZ2dlcl0gPSBfX2V4cG9ydHNfXztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdXNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb25lW3VzZVtqXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFZLl9hdHRhY2godXNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBEZWxheXMgdGhlIGB1c2VgIGNhbGxiYWNrIHVudGlsIGFub3RoZXIgZXZlbnQgaGFzIHRha2VuIHBsYWNlIHN1Y2ggYXNcbiAgICBgd2luZG93Lm9ubG9hZGAsIGBkb21yZWFkeWAsIGBjb250ZW50cmVhZHlgLCBvciBgYXZhaWxhYmxlYC5cblxuICAgIEBwcml2YXRlXG4gICAgQG1ldGhvZCBfZGVsYXlDYWxsYmFja1xuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBvcmlnaW5hbCBgdXNlYCBjYWxsYmFjay5cbiAgICBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVudGlsIEVpdGhlciBhbiBldmVudCBuYW1lICgnbG9hZCcsICdkb21yZWFkeScsIGV0Yy4pXG4gICAgICAgIG9yIGFuIG9iamVjdCBjb250YWluaW5nIGV2ZW50L2FyZ3Mga2V5cyBmb3IgY29udGVudHJlYWR5L2F2YWlsYWJsZS5cbiAgICBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAqKi9cbiAgICBfZGVsYXlDYWxsYmFjazogZnVuY3Rpb24oY2IsIHVudGlsKSB7XG5cbiAgICAgICAgdmFyIFkgPSB0aGlzLFxuICAgICAgICAgICAgbW9kID0gWydldmVudC1iYXNlJ107XG5cbiAgICAgICAgdW50aWwgPSAoWS5MYW5nLmlzT2JqZWN0KHVudGlsKSA/IHVudGlsIDogeyBldmVudDogdW50aWwgfSk7XG5cbiAgICAgICAgaWYgKHVudGlsLmV2ZW50ID09PSAnbG9hZCcpIHtcbiAgICAgICAgICAgIG1vZC5wdXNoKCdldmVudC1zeW50aGV0aWMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgWS5fdXNlKG1vZCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgWS5vbih1bnRpbC5ldmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMV0uZGVsYXlVbnRpbCA9IHVudGlsLmV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBjYi5hcHBseShZLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9LCB1bnRpbC5hcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBBdHRhY2hlcyBvbmUgb3IgbW9yZSBtb2R1bGVzIHRvIHRoaXMgWVVJIGluc3RhbmNlLiBXaGVuIHRoaXMgaXMgZXhlY3V0ZWQsXG4gICAgdGhlIHJlcXVpcmVtZW50cyBvZiB0aGUgZGVzaXJlZCBtb2R1bGVzIGFyZSBhbmFseXplZCwgYW5kIG9uZSBvZiBzZXZlcmFsXG4gICAgdGhpbmdzIGNhbiBoYXBwZW46XG5cblxuICAgICAgKiBBbGwgcmVxdWlyZWQgbW9kdWxlcyBoYXZlIGFscmVhZHkgYmVlbiBsb2FkZWQsIGFuZCBqdXN0IG5lZWQgdG8gYmVcbiAgICAgICAgYXR0YWNoZWQgdG8gdGhpcyBZVUkgaW5zdGFuY2UuIEluIHRoaXMgY2FzZSwgdGhlIGB1c2UoKWAgY2FsbGJhY2sgd2lsbFxuICAgICAgICBiZSBleGVjdXRlZCBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBtb2R1bGVzIGFyZSBhdHRhY2hlZC5cblxuICAgICAgKiBPbmUgb3IgbW9yZSBtb2R1bGVzIGhhdmUgbm90IHlldCBiZWVuIGxvYWRlZCwgb3IgdGhlIEdldCB1dGlsaXR5IGlzIG5vdFxuICAgICAgICBhdmFpbGFibGUsIG9yIHRoZSBgYm9vdHN0cmFwYCBjb25maWcgb3B0aW9uIGlzIGBmYWxzZWAuIEluIHRoaXMgY2FzZSxcbiAgICAgICAgYSB3YXJuaW5nIGlzIGlzc3VlZCBpbmRpY2F0aW5nIHRoYXQgbW9kdWxlcyBhcmUgbWlzc2luZywgYnV0IGFsbFxuICAgICAgICBhdmFpbGFibGUgbW9kdWxlcyB3aWxsIHN0aWxsIGJlIGF0dGFjaGVkIGFuZCB0aGUgYHVzZSgpYCBjYWxsYmFjayB3aWxsXG4gICAgICAgIGJlIGV4ZWN1dGVkIHN5bmNocm9ub3VzbHkuXG5cbiAgICAgICogT25lIG9yIG1vcmUgbW9kdWxlcyBhcmUgbWlzc2luZyBhbmQgdGhlIExvYWRlciBpcyBub3QgYXZhaWxhYmxlIGJ1dCB0aGVcbiAgICAgICAgR2V0IHV0aWxpdHkgaXMsIGFuZCBgYm9vdHN0cmFwYCBpcyBub3QgYGZhbHNlYC4gSW4gdGhpcyBjYXNlLCB0aGUgR2V0XG4gICAgICAgIHV0aWxpdHkgd2lsbCBiZSB1c2VkIHRvIGxvYWQgdGhlIExvYWRlciwgYW5kIHdlIHdpbGwgdGhlbiBwcm9jZWVkIHRvXG4gICAgICAgIHRoZSBmb2xsb3dpbmcgc3RhdGU6XG5cbiAgICAgICogT25lIG9yIG1vcmUgbW9kdWxlcyBhcmUgbWlzc2luZyBhbmQgdGhlIExvYWRlciBpcyBhdmFpbGFibGUuIEluIHRoaXNcbiAgICAgICAgY2FzZSwgdGhlIExvYWRlciB3aWxsIGJlIHVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVwZW5kZW5jeSB0cmVlIGZvciB0aGVcbiAgICAgICAgbWlzc2luZyBtb2R1bGVzIGFuZCBsb2FkIHRoZW0gYW5kIHRoZWlyIGRlcGVuZGVuY2llcy4gV2hlbiB0aGUgTG9hZGVyIGlzXG4gICAgICAgIGZpbmlzaGVkIGxvYWRpbmcgbW9kdWxlcywgdGhlIGB1c2UoKWAgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZFxuICAgICAgICBhc3luY2hyb25vdXNseS5cblxuICAgIEBleGFtcGxlXG5cbiAgICAgICAgLy8gTG9hZHMgYW5kIGF0dGFjaGVzIGRkIGFuZCBpdHMgZGVwZW5kZW5jaWVzLlxuICAgICAgICBZVUkoKS51c2UoJ2RkJywgZnVuY3Rpb24gKFkpIHtcbiAgICAgICAgICAgIC8vIC4uLlxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMb2FkcyBhbmQgYXR0YWNoZXMgZGQgYW5kIG5vZGUgYXMgd2VsbCBhcyBhbGwgb2YgdGhlaXIgZGVwZW5kZW5jaWVzLlxuICAgICAgICBZVUkoKS51c2UoWydkZCcsICdub2RlJ10sIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgICAgICAvLyAuLi5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXR0YWNoZXMgYWxsIG1vZHVsZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBsb2FkZWQuXG4gICAgICAgIFlVSSgpLnVzZSgnKicsIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgICAgICAvLyAuLi5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXR0YWNoZXMgYSBnYWxsZXJ5IG1vZHVsZS5cbiAgICAgICAgWVVJKCkudXNlKCdnYWxsZXJ5LXlxbCcsIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgICAgICAvLyAuLi5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXR0YWNoZXMgYSBZVUkgMmluMyBtb2R1bGUuXG4gICAgICAgIFlVSSgpLnVzZSgneXVpMi1kYXRhdGFibGUnLCBmdW5jdGlvbiAoWSkge1xuICAgICAgICAgICAgLy8gLi4uXG4gICAgICAgIH0pO1xuXG4gICAgQG1ldGhvZCB1c2VcbiAgICBAcGFyYW0ge1N0cmluZ3xBcnJheX0gbW9kdWxlcyogT25lIG9yIG1vcmUgbW9kdWxlIG5hbWVzIHRvIGF0dGFjaC5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UgYWxsXG4gICAgICAgIHNwZWNpZmllZCBtb2R1bGVzIGFuZCB0aGVpciBkZXBlbmRlbmNpZXMgaGF2ZSBiZWVuIGF0dGFjaGVkLlxuICAgIEBwYXJhbSB7WVVJfSBjYWxsYmFjay5ZIFRoZSBZVUkgaW5zdGFuY2UgY3JlYXRlZCBmb3IgdGhpcyBzYW5kYm94LlxuICAgIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjay5zdGF0dXMgT2JqZWN0IGNvbnRhaW5pbmcgYHN1Y2Nlc3NgLCBgbXNnYCBhbmRcbiAgICAgICAgYGRhdGFgIHByb3BlcnRpZXMuXG4gICAgQGNoYWluYWJsZVxuICAgICoqL1xuICAgIHVzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gU0xJQ0UuY2FsbChhcmd1bWVudHMsIDApLFxuICAgICAgICAgICAgY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBZID0gdGhpcyxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIEVudiA9IFkuRW52LFxuICAgICAgICAgICAgcHJvdmlzaW9uZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoZSBsYXN0IGFyZ3VtZW50IHN1cHBsaWVkIHRvIHVzZSBjYW4gYmUgYSBsb2FkIGNvbXBsZXRlIGNhbGxiYWNrXG4gICAgICAgIGlmIChZLkxhbmcuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBpZiAoWS5jb25maWcuZGVsYXlVbnRpbCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gWS5fZGVsYXlDYWxsYmFjayhjYWxsYmFjaywgWS5jb25maWcuZGVsYXlVbnRpbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFkuTGFuZy5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChZLmNvbmZpZy5jYWNoZVVzZSkge1xuICAgICAgICAgICAgd2hpbGUgKChuYW1lID0gYXJnc1tpKytdKSkge1xuICAgICAgICAgICAgICAgIGlmICghRW52Ll9hdHRhY2hlZFtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aXNpb25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm92aXNpb25lZCkge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBZLl9ub3RpZnkoY2FsbGJhY2ssIEFMUkVBRFlfRE9ORSwgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoWS5fbG9hZGluZykge1xuICAgICAgICAgICAgWS5fdXNlUXVldWUgPSBZLl91c2VRdWV1ZSB8fCBuZXcgWS5RdWV1ZSgpO1xuICAgICAgICAgICAgWS5fdXNlUXVldWUuYWRkKFthcmdzLCBjYWxsYmFja10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgWS5fdXNlKGFyZ3MsIGZ1bmN0aW9uKFksIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgWS5fbm90aWZ5KGNhbGxiYWNrLCByZXNwb25zZSwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBTdWdhciBmb3IgbG9hZGluZyBib3RoIGxlZ2FjeSBhbmQgRVM2LWJhc2VkIFlVSSBtb2R1bGVzLlxuXG4gICAgQG1ldGhvZCByZXF1aXJlXG4gICAgQHBhcmFtIHtTdHJpbmd9IFttb2R1bGVzKl0gTGlzdCBvZiBtb2R1bGUgbmFtZXMgdG8gaW1wb3J0IG9yIGEgc2luZ2xlXG4gICAgICAgIG1vZHVsZSBuYW1lLlxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgZ2V0cyBjYWxsZWQgb25jZSBhbGwgdGhlIG1vZHVsZXNcbiAgICAgICAgd2VyZSBsb2FkZWQuIEVhY2ggcGFyYW1ldGVyIG9mIHRoZSBjYWxsYmFjayBpcyB0aGUgZXhwb3J0IHZhbHVlIG9mIHRoZVxuICAgICAgICBjb3JyZXNwb25kaW5nIG1vZHVsZSBpbiB0aGUgbGlzdC4gSWYgdGhlIG1vZHVsZSBpcyBhIGxlZ2FjeSBZVUkgbW9kdWxlLFxuICAgICAgICB0aGUgWVVJIGluc3RhbmNlIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgbW9kdWxlIGV4cG9ydHMuXG4gICAgQGV4YW1wbGVcbiAgICBgYGBcbiAgICBZVUkoKS5yZXF1aXJlKFsnZXM2LXNldCddLCBmdW5jdGlvbiAoWSwgaW1wb3J0cykge1xuICAgICAgICB2YXIgU2V0ID0gaW1wb3J0cy5TZXQsXG4gICAgICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgfSk7XG4gICAgYGBgXG4gICAgKiovXG4gICAgcmVxdWlyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFNMSUNFLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGNhbGxiYWNrO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRoZSBjYWxsYmFjayBpZiBvbmUgd2FzIHByb3ZpZGVkXG4gICAgICAgICAgICAvLyBZVUkoKS5yZXF1aXJlKCdmb28nKTsgaXMgdmFsaWRcbiAgICAgICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoWSkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBsZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWQgPSBZLkVudi5fZXhwb3J0ZWQsXG4gICAgICAgICAgICAgICAgICAgIF9faW1wb3J0c19fID0ge307XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgb25seSB0aGUgaW1wb3J0cyByZXF1ZXN0ZWQgYXMgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRlZC5oYXNPd25Qcm9wZXJ0eShhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX19pbXBvcnRzX19bYXJnc1tpXV0gPSBleHBvcnRlZFthcmdzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIGB1bmRlZmluZWRgIGJlY2F1c2U6XG4gICAgICAgICAgICAgICAgLy8gLSBVc2luZyBgWS5jb25maWcuZ2xvYmFsYCB3b3VsZCBmb3JjZSB0aGUgdmFsdWUgb2YgYHRoaXNgIHRvIGJlXG4gICAgICAgICAgICAgICAgLy8gICB0aGUgZ2xvYmFsIG9iamVjdCBldmVuIGluIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAgICAgLy8gLSBVc2luZyBgWWAgZ29lcyBhZ2FpbnN0IHRoZSBnb2FsIG9mIG1vdmluZyBhd2F5IGZyb20gYSBzaGFyZWRcbiAgICAgICAgICAgICAgICAvLyAgIG9iamVjdCBhbmQgc3RhcnQgdGhpbmtpbmcgaW4gdGVybXMgb2YgaW1wb3J0ZWQgYW5kIGV4cG9ydGVkXG4gICAgICAgICAgICAgICAgLy8gICBvYmplY3RzXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh1bmRlZmluZWQsIFksIF9faW1wb3J0c19fKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCByZXR1cm4gdGhlIFkgb2JqZWN0LiBUaGlzIG1ha2VzIGl0IGhhcmQgdG8gZm9sbG93IHRoaXNcbiAgICAgICAgLy8gdHJhZGl0aW9uYWwgcGF0dGVybjpcbiAgICAgICAgLy8gICB2YXIgWSA9IFlVSSgpLnVzZSguLi4pO1xuICAgICAgICAvLyBUaGlzIGlzIGEgZ29vZCBpZGVhIGluIHRoZSBsaWdodCBvZiBFUzYgbW9kdWxlcywgdG8gYXZvaWQgd29ya2luZ1xuICAgICAgICAvLyBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICAgICAgICAvLyBUaGlzIGFsc28gbGVhdmVzIHRoZSBkb29yIG9wZW4gZm9yIHJldHVybmluZyBhIHByb21pc2UsIG9uY2UgdGhlXG4gICAgICAgIC8vIFlVSSBsb2FkZXIgaXMgYmFzZWQgb24gdGhlIEVTNiBsb2FkZXIgd2hpY2ggdXNlc1xuICAgICAgICAvLyBsb2FkZXIuaW1wb3J0KC4uLikudGhlbiguLi4pXG4gICAgICAgIHRoaXMudXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBIYW5kbGVzIExvYWRlciBub3RpZmljYXRpb25zIGFib3V0IGF0dGFjaG1lbnQvbG9hZCBlcnJvcnMuXG5cbiAgICBAbWV0aG9kIF9ub3RpZnlcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBwYXNzIHRvIGBZLmNvbmZpZy5sb2FkRXJyb3JGbmAuXG4gICAgQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFJlc3BvbnNlIHJldHVybmVkIGZyb20gTG9hZGVyLlxuICAgIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJndW1lbnRzIHBhc3NlZCBmcm9tIExvYWRlci5cbiAgICBAcHJpdmF0ZVxuICAgICoqL1xuICAgIF9ub3RpZnk6IGZ1bmN0aW9uKGNhbGxiYWNrLCByZXNwb25zZSwgYXJncykge1xuICAgICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MgJiYgdGhpcy5jb25maWcubG9hZEVycm9yRm4pIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvYWRFcnJvckZuLmNhbGwodGhpcywgdGhpcywgY2FsbGJhY2ssIHJlc3BvbnNlLCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuRW52Ll9taXNzZWQgJiYgdGhpcy5FbnYuX21pc3NlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5tc2cgPSAnTWlzc2luZyBtb2R1bGVzOiAnICsgdGhpcy5FbnYuX21pc3NlZC5qb2luKCk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRocm93RmFpbCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcigndXNlIGNhbGxiYWNrIGVycm9yJywgZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgIENhbGxlZCBmcm9tIHRoZSBgdXNlYCBtZXRob2QgcXVldWUgdG8gZW5zdXJlIHRoYXQgb25seSBvbmUgc2V0IG9mIGxvYWRpbmdcbiAgICBsb2dpYyBpcyBwZXJmb3JtZWQgYXQgYSB0aW1lLlxuXG4gICAgQG1ldGhvZCBfdXNlXG4gICAgQHBhcmFtIHtTdHJpbmd9IGFyZ3MqIE9uZSBvciBtb3JlIG1vZHVsZXMgdG8gYXR0YWNoLlxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gRnVuY3Rpb24gdG8gY2FsbCBvbmNlIGFsbCByZXF1aXJlZCBtb2R1bGVzIGhhdmVcbiAgICAgICAgYmVlbiBhdHRhY2hlZC5cbiAgICBAcHJpdmF0ZVxuICAgICoqL1xuICAgIF91c2U6IGZ1bmN0aW9uKGFyZ3MsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLkFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2goWyd5dWktYmFzZSddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW4sIGxvYWRlciwgaGFuZGxlQm9vdCxcbiAgICAgICAgICAgIFkgPSB0aGlzLFxuICAgICAgICAgICAgR19FTlYgPSBZVUkuRW52LFxuICAgICAgICAgICAgbW9kcyA9IEdfRU5WLm1vZHMsXG4gICAgICAgICAgICBFbnYgPSBZLkVudixcbiAgICAgICAgICAgIHVzZWQgPSBFbnYuX3VzZWQsXG4gICAgICAgICAgICBhbGlhc2VzID0gR19FTlYuYWxpYXNlcyxcbiAgICAgICAgICAgIHF1ZXVlID0gR19FTlYuX2xvYWRlclF1ZXVlLFxuICAgICAgICAgICAgZmlyc3RBcmcgPSBhcmdzWzBdLFxuICAgICAgICAgICAgWUFycmF5ID0gWS5BcnJheSxcbiAgICAgICAgICAgIGNvbmZpZyA9IFkuY29uZmlnLFxuICAgICAgICAgICAgYm9vdCA9IGNvbmZpZy5ib290c3RyYXAsXG4gICAgICAgICAgICBtaXNzaW5nID0gW10sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgciA9IFtdLFxuICAgICAgICAgICAgcmV0ID0gdHJ1ZSxcbiAgICAgICAgICAgIGZldGNoQ1NTID0gY29uZmlnLmZldGNoQ1NTLFxuICAgICAgICAgICAgcHJvY2VzcyA9IGZ1bmN0aW9uKG5hbWVzLCBza2lwKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIGEgPSBbXSwgbmFtZSwgbGVuLCBtLCByZXEsIHVzZTtcblxuICAgICAgICAgICAgICAgIGlmICghbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxpYXNlcykge1xuICAgICAgICAgICAgICAgICAgICBsZW4gPSBuYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWFzZXNbbmFtZXNbaV1dICYmICFtb2RzW25hbWVzW2ldXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBbXS5jb25jYXQoYSwgYWxpYXNlc1tuYW1lc1tpXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobmFtZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzID0gYTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZW4gPSBuYW1lcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYXR0YWNoIGEgbW9kdWxlIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZWRbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbSA9IG1vZHNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHJlcSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHVzZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gbS5kZXRhaWxzLnJlcXVpcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlID0gbS5kZXRhaWxzLnVzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENTUyBmaWxlcyBkb24ndCByZWdpc3RlciB0aGVtc2VsdmVzLCBzZWUgaWYgaXQgaGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWVuIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFHX0VOVi5fbG9hZGVkW1ZFUlNJT05dW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkW25hbWVdID0gdHJ1ZTsgLy8gcHJvYmFibHkgY3NzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgcmVxdWlyZW1lbnRzIGFyZSBhdHRhY2hlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxICYmIHJlcS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBncmFiIHRoZSBzdWJtb2R1bGUgZGVwZW5kZW5jaWVzIHRvb1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlICYmIHVzZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3ModXNlLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGFuZGxlTG9hZGVyID0gZnVuY3Rpb24oZnJvbUxvYWRlcikge1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IGZyb21Mb2FkZXIgfHwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZzogJ25vdCBkeW5hbWljJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWRvLCBvcmlnTWlzc2luZyxcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICAgICAgICAgICAgICBZLl9sb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnTWlzc2luZyA9IG1pc3Npbmc7XG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZWRvID0gbWlzc2luZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoW10uY29uY2F0KG1pc3NpbmcpLnNvcnQoKS5qb2luKCkgPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ01pc3Npbmcuc29ydCgpLmpvaW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZG8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZWRvICYmIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgWS5fbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIFkuX3VzZShtaXNzaW5nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChZLl9hdHRhY2goZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBZLl9ub3RpZnkoY2FsbGJhY2ssIHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IFkuX2F0dGFjaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBZLl9ub3RpZnkoY2FsbGJhY2ssIHJlc3BvbnNlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChZLl91c2VRdWV1ZSAmJiBZLl91c2VRdWV1ZS5zaXplKCkgJiYgIVkuX2xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgWS5fdXNlLmFwcGx5KFksIFkuX3VzZVF1ZXVlLm5leHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgLy8gWVVJKCkudXNlKCcqJyk7IC8vIGJpbmQgZXZlcnl0aGluZyBhdmFpbGFibGVcbiAgICAgICAgaWYgKGZpcnN0QXJnID09PSAnKicpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBtb2RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldCA9IFkuX2F0dGFjaChhcmdzKTtcbiAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVMb2FkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChtb2RzLmxvYWRlciB8fCBtb2RzWydsb2FkZXItYmFzZSddKSAmJiAhWS5Mb2FkZXIpIHtcbiAgICAgICAgICAgIFkuX2F0dGFjaChbJ2xvYWRlcicgKyAoKCFtb2RzLmxvYWRlcikgPyAnLWJhc2UnIDogJycpXSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIHVzZSBsb2FkZXIgdG8gZXhwYW5kIGRlcGVuZGVuY2llcyBhbmQgc29ydCB0aGVcbiAgICAgICAgLy8gcmVxdWlyZW1lbnRzIGlmIGl0IGlzIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKGJvb3QgJiYgWS5Mb2FkZXIgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvYWRlciA9IGdldExvYWRlcihZKTtcbiAgICAgICAgICAgIGxvYWRlci5yZXF1aXJlKGFyZ3MpO1xuICAgICAgICAgICAgbG9hZGVyLmlnbm9yZVJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgbG9hZGVyLl9ib290ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvYWRlci5jYWxjdWxhdGUobnVsbCwgKGZldGNoQ1NTKSA/IG51bGwgOiAnanMnKTtcbiAgICAgICAgICAgIGFyZ3MgPSBsb2FkZXIuc29ydGVkO1xuICAgICAgICAgICAgbG9hZGVyLl9ib290ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzKGFyZ3MpO1xuXG4gICAgICAgIGxlbiA9IG1pc3NpbmcubGVuZ3RoO1xuXG5cbiAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgbWlzc2luZyA9IFlBcnJheS5kZWR1cGUobWlzc2luZyk7XG4gICAgICAgICAgICBsZW4gPSBtaXNzaW5nLmxlbmd0aDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gZHluYW1pYyBsb2FkXG4gICAgICAgIGlmIChib290ICYmIGxlbiAmJiBZLkxvYWRlcikge1xuICAgICAgICAgICAgWS5fbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICBsb2FkZXIgPSBnZXRMb2FkZXIoWSk7XG4gICAgICAgICAgICBsb2FkZXIub25FbmQgPSBoYW5kbGVMb2FkZXI7XG4gICAgICAgICAgICBsb2FkZXIuY29udGV4dCA9IFk7XG4gICAgICAgICAgICBsb2FkZXIuZGF0YSA9IGFyZ3M7XG4gICAgICAgICAgICBsb2FkZXIuaWdub3JlUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbG9hZGVyLnJlcXVpcmUobWlzc2luZyk7XG4gICAgICAgICAgICBsb2FkZXIuaW5zZXJ0KG51bGwsIChmZXRjaENTUykgPyBudWxsIDogJ2pzJyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChib290ICYmIGxlbiAmJiBZLkdldCAmJiAhRW52LmJvb3RzdHJhcHBlZCkge1xuXG4gICAgICAgICAgICBZLl9sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgaGFuZGxlQm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIFkuX2xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgRW52LmJvb3RzdHJhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgR19FTlYuX2Jvb3RzdHJhcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoWS5fYXR0YWNoKFsnbG9hZGVyJ10pKSB7XG4gICAgICAgICAgICAgICAgICAgIFkuX3VzZShhcmdzLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKEdfRU5WLl9ib290c3RyYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgcXVldWUuYWRkKGhhbmRsZUJvb3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBHX0VOVi5fYm9vdHN0cmFwcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgWS5HZXQuc2NyaXB0KGNvbmZpZy5iYXNlICsgY29uZmlnLmxvYWRlclBhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgb25FbmQ6IGhhbmRsZUJvb3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gWS5fYXR0YWNoKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUxvYWRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgVXRpbGl0eSBtZXRob2QgZm9yIHNhZmVseSBjcmVhdGluZyBuYW1lc3BhY2VzIGlmIHRoZXkgZG9uJ3QgYWxyZWFkeSBleGlzdC5cbiAgICBNYXkgYmUgY2FsbGVkIHN0YXRpY2FsbHkgb24gdGhlIFlVSSBnbG9iYWwgb2JqZWN0IG9yIGFzIGEgbWV0aG9kIG9uIGEgWVVJXG4gICAgaW5zdGFuY2UuXG5cbiAgICBXaGVuIGNhbGxlZCBzdGF0aWNhbGx5LCBhIG5hbWVzcGFjZSB3aWxsIGJlIGNyZWF0ZWQgb24gdGhlIFlVSSBnbG9iYWxcbiAgICBvYmplY3Q6XG5cbiAgICAgICAgLy8gQ3JlYXRlIGBZVUkueW91ci5uYW1lc3BhY2UuaGVyZWAgYXMgbmVzdGVkIG9iamVjdHMsIHByZXNlcnZpbmcgYW55XG4gICAgICAgIC8vIG9iamVjdHMgdGhhdCBhbHJlYWR5IGV4aXN0IGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgdGhlbS5cbiAgICAgICAgWVVJLm5hbWVzcGFjZSgneW91ci5uYW1lc3BhY2UuaGVyZScpO1xuXG4gICAgV2hlbiBjYWxsZWQgYXMgYSBtZXRob2Qgb24gYSBZVUkgaW5zdGFuY2UsIGEgbmFtZXNwYWNlIHdpbGwgYmUgY3JlYXRlZCBvblxuICAgIHRoYXQgaW5zdGFuY2U6XG5cbiAgICAgICAgLy8gQ3JlYXRlcyBgWS5wcm9wZXJ0eS5wYWNrYWdlYC5cbiAgICAgICAgWS5uYW1lc3BhY2UoJ3Byb3BlcnR5LnBhY2thZ2UnKTtcblxuICAgIERvdHMgaW4gdGhlIGlucHV0IHN0cmluZyBjYXVzZSBgbmFtZXNwYWNlYCB0byBjcmVhdGUgbmVzdGVkIG9iamVjdHMgZm9yIGVhY2hcbiAgICB0b2tlbi4gSWYgYW55IHBhcnQgb2YgdGhlIHJlcXVlc3RlZCBuYW1lc3BhY2UgYWxyZWFkeSBleGlzdHMsIHRoZSBjdXJyZW50XG4gICAgb2JqZWN0IHdpbGwgYmUgbGVmdCBpbiBwbGFjZSBhbmQgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4uIFRoaXMgYWxsb3dzXG4gICAgbXVsdGlwbGUgY2FsbHMgdG8gYG5hbWVzcGFjZWAgdG8gcHJlc2VydmUgZXhpc3RpbmcgbmFtZXNwYWNlZCBwcm9wZXJ0aWVzLlxuXG4gICAgSWYgdGhlIGZpcnN0IHRva2VuIGluIHRoZSBuYW1lc3BhY2Ugc3RyaW5nIGlzIFwiWUFIT09cIiwgdGhhdCB0b2tlbiBpc1xuICAgIGRpc2NhcmRlZC4gVGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggWVVJIDIuXG5cbiAgICBCZSBjYXJlZnVsIHdpdGggbmFtZXNwYWNlIHRva2Vucy4gUmVzZXJ2ZWQgd29yZHMgbWF5IHdvcmsgaW4gc29tZSBicm93c2Vyc1xuICAgIGFuZCBub3Qgb3RoZXJzLiBGb3IgaW5zdGFuY2UsIHRoZSBmb2xsb3dpbmcgd2lsbCBmYWlsIGluIHNvbWUgYnJvd3NlcnNcbiAgICBiZWNhdXNlIHRoZSBzdXBwb3J0ZWQgdmVyc2lvbiBvZiBKYXZhU2NyaXB0IHJlc2VydmVzIHRoZSB3b3JkIFwibG9uZ1wiOlxuXG4gICAgICAgIFkubmFtZXNwYWNlKCdyZWFsbHkubG9uZy5uZXN0ZWQubmFtZXNwYWNlJyk7XG5cbiAgICBOb3RlOiBJZiB5b3UgcGFzcyBtdWx0aXBsZSBhcmd1bWVudHMgdG8gY3JlYXRlIG11bHRpcGxlIG5hbWVzcGFjZXMsIG9ubHkgdGhlXG4gICAgbGFzdCBvbmUgY3JlYXRlZCBpcyByZXR1cm5lZCBmcm9tIHRoaXMgZnVuY3Rpb24uXG5cbiAgICBAbWV0aG9kIG5hbWVzcGFjZVxuICAgIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UqIE9uZSBvciBtb3JlIG5hbWVzcGFjZXMgdG8gY3JlYXRlLlxuICAgIEByZXR1cm4ge09iamVjdH0gUmVmZXJlbmNlIHRvIHRoZSBsYXN0IG5hbWVzcGFjZSBvYmplY3QgY3JlYXRlZC5cbiAgICAqKi9cbiAgICBuYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cywgbywgaSA9IDAsIGosIGQsIGFyZztcblxuICAgICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG8gPSB0aGlzOyAvL1Jlc2V0IGJhc2Ugb2JqZWN0IHBlciBhcmd1bWVudCBvciBpdCB3aWxsIGdldCByZXVzZWQgZnJvbSB0aGUgbGFzdFxuICAgICAgICAgICAgYXJnID0gYVtpXTtcbiAgICAgICAgICAgIGlmIChhcmcuaW5kZXhPZihQRVJJT0QpID4gLTEpIHsgLy9Ta2lwIHRoaXMgaWYgbm8gXCIuXCIgaXMgcHJlc2VudFxuICAgICAgICAgICAgICAgIGQgPSBhcmcuc3BsaXQoUEVSSU9EKTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAoZFswXSA9PSAnWUFIT08nKSA/IDEgOiAwOyBqIDwgZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBvW2Rbal1dID0gb1tkW2pdXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbyA9IG9bZFtqXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvW2FyZ10gPSBvW2FyZ10gfHwge307XG4gICAgICAgICAgICAgICAgbyA9IG9bYXJnXTsgLy9SZXNldCBiYXNlIG9iamVjdCB0byB0aGUgbmV3IG9iamVjdCBzbyBpdCdzIHJldHVybmVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8vIHRoaXMgaXMgcmVwbGFjZWQgaWYgdGhlIGxvZyBtb2R1bGUgaXMgaW5jbHVkZWRcbiAgICBsb2c6IE5PT1AsXG4gICAgbWVzc2FnZTogTk9PUCxcbiAgICAvLyB0aGlzIGlzIHJlcGxhY2VkIGlmIHRoZSBkdW1wIG1vZHVsZSBpcyBpbmNsdWRlZFxuICAgIGR1bXA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiAnJytvOyB9LFxuXG4gICAgLyoqXG4gICAgUmVwb3J0cyBhbiBlcnJvci5cblxuICAgIFRoZSByZXBvcnRpbmcgbWVjaGFuaXNtIGlzIGNvbnRyb2xsZWQgYnkgdGhlIGB0aHJvd0ZhaWxgIGNvbmZpZ3VyYXRpb25cbiAgICBhdHRyaWJ1dGUuIElmIGB0aHJvd0ZhaWxgIGlzIGZhbHN5LCB0aGUgbWVzc2FnZSBpcyBsb2dnZWQuIElmIGB0aHJvd0ZhaWxgIGlzXG4gICAgdHJ1dGh5LCBhIEpTIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5cbiAgICBJZiBhbiBgZXJyb3JGbmAgaXMgc3BlY2lmaWVkIGluIHRoZSBjb25maWcgaXQgbXVzdCByZXR1cm4gYHRydWVgIHRvIGluZGljYXRlXG4gICAgdGhhdCB0aGUgZXhjZXB0aW9uIHdhcyBoYW5kbGVkIGFuZCBrZWVwIGl0IGZyb20gYmVpbmcgdGhyb3duLlxuXG4gICAgQG1ldGhvZCBlcnJvclxuICAgIEBwYXJhbSB7U3RyaW5nfSBtc2cgRXJyb3IgbWVzc2FnZS5cbiAgICBAcGFyYW0ge0Vycm9yfFN0cmluZ30gW2VdIEphdmFTY3JpcHQgZXJyb3Igb2JqZWN0IG9yIGFuIGVycm9yIHN0cmluZy5cbiAgICBAcGFyYW0ge1N0cmluZ30gW3NyY10gU291cmNlIG9mIHRoZSBlcnJvciAoc3VjaCBhcyB0aGUgbmFtZSBvZiB0aGUgbW9kdWxlIGluXG4gICAgICAgIHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZCkuXG4gICAgQGNoYWluYWJsZVxuICAgICoqL1xuICAgIGVycm9yOiBmdW5jdGlvbihtc2csIGUsIHNyYykge1xuICAgICAgICAvL1RPRE8gQWRkIGNoZWNrIGZvciB3aW5kb3cub25lcnJvciBoZXJlXG5cbiAgICAgICAgdmFyIFkgPSB0aGlzLCByZXQ7XG5cbiAgICAgICAgaWYgKFkuY29uZmlnLmVycm9yRm4pIHtcbiAgICAgICAgICAgIHJldCA9IFkuY29uZmlnLmVycm9yRm4uYXBwbHkoWSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmV0KSB7XG4gICAgICAgICAgICB0aHJvdyAoZSB8fCBuZXcgRXJyb3IobXNnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBZLm1lc3NhZ2UobXNnLCAnZXJyb3InLCAnJytzcmMpOyAvLyBkb24ndCBzY3J1YiB0aGlzIG9uZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIEdlbmVyYXRlcyBhbiBpZCBzdHJpbmcgdGhhdCBpcyB1bmlxdWUgYW1vbmcgYWxsIFlVSSBpbnN0YW5jZXMgaW4gdGhpc1xuICAgIGV4ZWN1dGlvbiBjb250ZXh0LlxuXG4gICAgQG1ldGhvZCBndWlkXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtwcmVdIFByZWZpeC5cbiAgICBAcmV0dXJuIHtTdHJpbmd9IFVuaXF1ZSBpZC5cbiAgICAqKi9cbiAgICBndWlkOiBmdW5jdGlvbihwcmUpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5FbnYuX2d1aWRwICsgJ18nICsgKCsrdGhpcy5FbnYuX3VpZHgpO1xuICAgICAgICByZXR1cm4gKHByZSkgPyAocHJlICsgaWQpIDogaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIFJldHVybnMgYSB1bmlxdWUgaWQgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBvYmplY3QgYW5kIChpZiAqcmVhZE9ubHkqIGlzXG4gICAgZmFsc3kpIHN0YW1wcyB0aGUgb2JqZWN0IHdpdGggdGhhdCBpZCBzbyBpdCBjYW4gYmUgaWRlbnRpZmllZCBpbiB0aGUgZnV0dXJlLlxuXG4gICAgU3RhbXBpbmcgYW4gb2JqZWN0IGludm9sdmVzIGFkZGluZyBhIGBfeXVpZGAgcHJvcGVydHkgdG8gaXQgdGhhdCBjb250YWluc1xuICAgIHRoZSBvYmplY3QncyBpZC4gT25lIGV4Y2VwdGlvbiB0byB0aGlzIGlzIHRoYXQgaW4gSW50ZXJuZXQgRXhwbG9yZXIsIERPTVxuICAgIG5vZGVzIGhhdmUgYSBgdW5pcXVlSURgIHByb3BlcnR5IHRoYXQgY29udGFpbnMgYSBicm93c2VyLWdlbmVyYXRlZCB1bmlxdWVcbiAgICBpZCwgd2hpY2ggd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgYSBZVUktZ2VuZXJhdGVkIGlkIHdoZW4gYXZhaWxhYmxlLlxuXG4gICAgQG1ldGhvZCBzdGFtcFxuICAgIEBwYXJhbSB7T2JqZWN0fSBvIE9iamVjdCB0byBzdGFtcC5cbiAgICBAcGFyYW0ge0Jvb2xlYW59IHJlYWRPbmx5IElmIHRydXRoeSBhbmQgdGhlIGdpdmVuIG9iamVjdCBoYXMgbm90IGFscmVhZHlcbiAgICAgICAgYmVlbiBzdGFtcGVkLCB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIG1vZGlmaWVkIGFuZCBgbnVsbGAgd2lsbCBiZVxuICAgICAgICByZXR1cm5lZC5cbiAgICBAcmV0dXJuIHtTdHJpbmd9IE9iamVjdCdzIHVuaXF1ZSBpZCwgb3IgYG51bGxgIGlmICpyZWFkT25seSogd2FzIHRydXRoeSBhbmRcbiAgICAgICAgdGhlIGdpdmVuIG9iamVjdCB3YXMgbm90IGFscmVhZHkgc3RhbXBlZC5cbiAgICAqKi9cbiAgICBzdGFtcDogZnVuY3Rpb24obywgcmVhZE9ubHkpIHtcbiAgICAgICAgdmFyIHVpZDtcbiAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGdlbmVyYXRlcyBpdHMgb3duIHVuaXF1ZSBJRCBmb3IgZG9tIG5vZGVzXG4gICAgICAgIC8vIFRoZSB1bmlxdWVJRCBwcm9wZXJ0eSBvZiBhIGRvY3VtZW50IG5vZGUgcmV0dXJucyBhIG5ldyBJRFxuICAgICAgICBpZiAoby51bmlxdWVJRCAmJiBvLm5vZGVUeXBlICYmIG8ubm9kZVR5cGUgIT09IDkpIHtcbiAgICAgICAgICAgIHVpZCA9IG8udW5pcXVlSUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1aWQgPSAodHlwZW9mIG8gPT09ICdzdHJpbmcnKSA/IG8gOiBvLl95dWlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1aWQpIHtcbiAgICAgICAgICAgIHVpZCA9IHRoaXMuZ3VpZCgpO1xuICAgICAgICAgICAgaWYgKCFyZWFkT25seSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG8uX3l1aWQgPSB1aWQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB1aWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWlkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBEZXN0cm95cyB0aGlzIFlVSSBpbnN0YW5jZS5cblxuICAgIEBtZXRob2QgZGVzdHJveVxuICAgIEBzaW5jZSAzLjMuMFxuICAgICoqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgWSA9IHRoaXM7XG4gICAgICAgIGlmIChZLkV2ZW50KSB7XG4gICAgICAgICAgICBZLkV2ZW50Ll91bmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgaW5zdGFuY2VzW1kuaWRdO1xuICAgICAgICBkZWxldGUgWS5FbnY7XG4gICAgICAgIGRlbGV0ZSBZLmNvbmZpZztcbiAgICB9XG5cbiAgICAvKipcbiAgICBTYWZlIGBpbnN0YW5jZW9mYCB3cmFwcGVyIHRoYXQgd29ya3MgYXJvdW5kIGEgbWVtb3J5IGxlYWsgaW4gSUUgd2hlbiB0aGVcbiAgICBvYmplY3QgYmVpbmcgdGVzdGVkIGlzIGB3aW5kb3dgIG9yIGBkb2N1bWVudGAuXG5cbiAgICBVbmxlc3MgeW91IGFyZSB0ZXN0aW5nIG9iamVjdHMgdGhhdCBtYXkgYmUgYHdpbmRvd2Agb3IgYGRvY3VtZW50YCwgeW91XG4gICAgc2hvdWxkIHVzZSB0aGUgbmF0aXZlIGBpbnN0YW5jZW9mYCBvcGVyYXRvciBpbnN0ZWFkIG9mIHRoaXMgbWV0aG9kLlxuXG4gICAgQG1ldGhvZCBpbnN0YW5jZU9mXG4gICAgQHBhcmFtIHtPYmplY3R9IG8gT2JqZWN0IHRvIGNoZWNrLlxuICAgIEBwYXJhbSB7T2JqZWN0fSB0eXBlIENsYXNzIHRvIGNoZWNrIGFnYWluc3QuXG4gICAgQHNpbmNlIDMuMy4wXG4gICAgKiovXG59O1xuXG4gICAgWVVJLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gICAgLy8gaW5oZXJpdGFuY2UgdXRpbGl0aWVzIGFyZSBub3QgYXZhaWxhYmxlIHlldFxuICAgIGZvciAocHJvcCBpbiBwcm90bykge1xuICAgICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIFlVSVtwcm9wXSA9IHByb3RvW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgQXBwbGllcyBhIGNvbmZpZ3VyYXRpb24gdG8gYWxsIFlVSSBpbnN0YW5jZXMgaW4gdGhpcyBleGVjdXRpb24gY29udGV4dC5cblxuICAgIFRoZSBtYWluIHVzZSBjYXNlIGZvciB0aGlzIG1ldGhvZCBpcyBpbiBcIm1hc2h1cHNcIiB3aGVyZSBzZXZlcmFsIHRoaXJkLXBhcnR5XG4gICAgc2NyaXB0cyBuZWVkIHRvIHdyaXRlIHRvIGEgZ2xvYmFsIFlVSSBjb25maWcsIGJ1dCBjYW5ub3Qgc2hhcmUgYSBzaW5nbGVcbiAgICBjZW50cmFsbHktbWFuYWdlZCBjb25maWcgb2JqZWN0LiBUaGlzIHdheSB0aGV5IGNhbiBhbGwgY2FsbFxuICAgIGBZVUkuYXBwbHlDb25maWcoe30pYCBpbnN0ZWFkIG9mIG92ZXJ3cml0aW5nIHRoZSBzaW5nbGUgZ2xvYmFsIGNvbmZpZy5cblxuICAgIEBleGFtcGxlXG5cbiAgICAgICAgWVVJLmFwcGx5Q29uZmlnKHtcbiAgICAgICAgICAgIG1vZHVsZXM6IHtcbiAgICAgICAgICAgICAgICBkYXZnbGFzczoge1xuICAgICAgICAgICAgICAgICAgICBmdWxscGF0aDogJy4vZGF2Z2xhc3MuanMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBZVUkuYXBwbHlDb25maWcoe1xuICAgICAgICAgICAgbW9kdWxlczoge1xuICAgICAgICAgICAgICAgIGZvbzoge1xuICAgICAgICAgICAgICAgICAgICBmdWxscGF0aDogJy4vZm9vLmpzJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgWVVJKCkudXNlKCdkYXZnbGFzcycsIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgICAgICAvLyBNb2R1bGUgZGF2Z2xhc3Mgd2lsbCBiZSBhdmFpbGFibGUgaGVyZS5cbiAgICAgICAgfSk7XG5cbiAgICBAbWV0aG9kIGFwcGx5Q29uZmlnXG4gICAgQHBhcmFtIHtPYmplY3R9IG8gQ29uZmlndXJhdGlvbiBvYmplY3QgdG8gYXBwbHkuXG4gICAgQHN0YXRpY1xuICAgIEBzaW5jZSAzLjUuMFxuICAgICoqL1xuICAgIFlVSS5hcHBseUNvbmZpZyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy9JZiB0aGVyZSBpcyBhIEdsb2JhbENvbmZpZywgYXBwbHkgaXQgZmlyc3QgdG8gc2V0IHRoZSBkZWZhdWx0c1xuICAgICAgICBpZiAoWVVJLkdsb2JhbENvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5wcm90b3R5cGUuYXBwbHlDb25maWcuY2FsbCh0aGlzLCBZVUkuR2xvYmFsQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICAvL0FwcGx5IHRoaXMgY29uZmlnIHRvIGl0XG4gICAgICAgIHRoaXMucHJvdG90eXBlLmFwcGx5Q29uZmlnLmNhbGwodGhpcywgbyk7XG4gICAgICAgIC8vUmVzZXQgR2xvYmFsQ29uZmlnIHRvIHRoZSBjb21iaW5lZCBjb25maWdcbiAgICAgICAgWVVJLkdsb2JhbENvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIH07XG5cbiAgICAvLyBzZXQgdXAgdGhlIGVudmlyb25tZW50XG4gICAgWVVJLl9pbml0KCk7XG5cbiAgICBpZiAoaGFzV2luKSB7XG4gICAgICAgIGFkZChkb2MsICdET01Db250ZW50TG9hZGVkJywgaGFuZGxlUmVhZHkpO1xuXG4gICAgICAgIC8vIGFkZCBhIHdpbmRvdyBsb2FkIGV2ZW50IGF0IGxvYWQgdGltZSBzbyB3ZSBjYW4gY2FwdHVyZVxuICAgICAgICAvLyB0aGUgY2FzZSB3aGVyZSBpdCBmaXJlcyBiZWZvcmUgZHluYW1pYyBsb2FkaW5nIGlzXG4gICAgICAgIC8vIGNvbXBsZXRlLlxuICAgICAgICBhZGQod2luZG93LCAnbG9hZCcsIGhhbmRsZUxvYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZVJlYWR5KCk7XG4gICAgICAgIGhhbmRsZUxvYWQoKTtcbiAgICB9XG5cbiAgICBZVUkuRW52LmFkZCA9IGFkZDtcbiAgICBZVUkuRW52LnJlbW92ZSA9IHJlbW92ZTtcblxuICAgIC8qZ2xvYmFsIGV4cG9ydHMqL1xuICAgIC8vIFN1cHBvcnQgdGhlIENvbW1vbkpTIG1ldGhvZCBmb3IgZXhwb3J0aW5nIG91ciBzaW5nbGUgZ2xvYmFsXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnKSB7XG4gICAgICAgIGV4cG9ydHMuWVVJID0gbW9kdWxlLmV4cG9ydHMgPSBZVUk7XG4gICAgICAgIC8qKlxuICAgICAgICAqIFNldCBhIG1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBgR2V0LnNjcmlwdGAgaXMgY2FsbGVkIGluIE5vZGUuanNcbiAgICAgICAgKiBgR2V0YCB3aWxsIG9wZW4gdGhlIGZpbGUsIHRoZW4gcGFzcyBpdCdzIGNvbnRlbnQgYW5kIGl0J3MgcGF0aFxuICAgICAgICAqIHRvIHRoaXMgbWV0aG9kIGJlZm9yZSBhdHRhY2hpbmcgaXQuIENvbW1vbmx5IHVzZWQgZm9yIGNvZGUgY292ZXJhZ2VcbiAgICAgICAgKiBpbnN0cnVtZW50YXRpb24uIDxzdHJvbmc+Q2FsbGluZyB0aGlzIG11bHRpcGxlIHRpbWVzIHdpbGwgb25seVxuICAgICAgICAqIGF0dGFjaCB0aGUgbGFzdCBob29rIG1ldGhvZDwvc3Ryb25nPi4gVGhpcyBtZXRob2QgaXMgb25seVxuICAgICAgICAqIGF2YWlsYWJsZSBpbiBOb2RlLmpzLlxuICAgICAgICAqIEBtZXRob2Qgc2V0TG9hZEhvb2tcbiAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHNldFxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmbi5kYXRhIFRoZSBjb250ZW50IG9mIHRoZSBmaWxlXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZuLnBhdGggVGhlIGZpbGUgcGF0aCBvZiB0aGUgZmlsZVxuICAgICAgICAqL1xuICAgICAgICBZVUkuc2V0TG9hZEhvb2sgPSBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgWVVJLl9nZXRMb2FkSG9vayA9IGZuO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBMb2FkIGhvb2sgZm9yIGBZLkdldC5zY3JpcHRgIGluIE5vZGUuanMsIHNlZSBgWVVJLnNldExvYWRIb29rYFxuICAgICAgICAqIEBtZXRob2QgX2dldExvYWRIb29rXG4gICAgICAgICogQHByaXZhdGVcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgY29udGVudCBvZiB0aGUgZmlsZVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBmaWxlIHBhdGggb2YgdGhlIGZpbGVcbiAgICAgICAgKi9cbiAgICAgICAgWVVJLl9nZXRMb2FkSG9vayA9IG51bGw7XG4gICAgfVxuXG4gICAgWVVJLkVudltWRVJTSU9OXSA9IHt9O1xufSgpKTtcblxuXG4vKipcbkNvbmZpZyBvYmplY3QgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3JcbnRoaXMgYFlVSWAgaW5zdGFuY2UuXG5cblRoaXMgb2JqZWN0IGlzIHN1cHBsaWVkIGJ5IHRoZSBpbXBsZW1lbnRlciB3aGVuIGluc3RhbnRpYXRpbmcgWVVJLiBTb21lXG5wcm9wZXJ0aWVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMgaWYgdGhleSBhcmUgbm90IHN1cHBsaWVkIGJ5IHRoZSBpbXBsZW1lbnRlci5cblxuVGhpcyBvYmplY3Qgc2hvdWxkIG5vdCBiZSB1cGRhdGVkIGRpcmVjdGx5IGJlY2F1c2Ugc29tZSB2YWx1ZXMgYXJlIGNhY2hlZC4gVXNlXG5gYXBwbHlDb25maWcoKWAgdG8gdXBkYXRlIHRoZSBjb25maWcgb2JqZWN0IG9uIGEgWVVJIGluc3RhbmNlIHRoYXQgaGFzIGFscmVhZHlcbmJlZW4gY29uZmlndXJlZC5cblxuQGNsYXNzIGNvbmZpZ1xuQHN0YXRpY1xuKiovXG5cbi8qKlxuSWYgYHRydWVgICh0aGUgZGVmYXVsdCksIFlVSSB3aWxsIFwiYm9vdHN0cmFwXCIgdGhlIFlVSSBMb2FkZXIgYW5kIG1vZHVsZSBtZXRhZGF0YVxuaWYgdGhleSdyZSBuZWVkZWQgdG8gbG9hZCBhZGRpdGlvbmFsIGRlcGVuZGVuY2llcyBhbmQgYXJlbid0IGFscmVhZHkgYXZhaWxhYmxlLlxuXG5TZXR0aW5nIHRoaXMgdG8gYGZhbHNlYCB3aWxsIHByZXZlbnQgWVVJIGZyb20gYXV0b21hdGljYWxseSBsb2FkaW5nIHRoZSBMb2FkZXJcbmFuZCBtb2R1bGUgbWV0YWRhdGEsIHNvIHlvdSB3aWxsIG5lZWQgdG8gbWFudWFsbHkgZW5zdXJlIHRoYXQgdGhleSdyZSBhdmFpbGFibGVcbm9yIGhhbmRsZSBkZXBlbmRlbmN5IHJlc29sdXRpb24geW91cnNlbGYuXG5cbkBwcm9wZXJ0eSB7Qm9vbGVhbn0gYm9vdHN0cmFwXG5AZGVmYXVsdCB0cnVlXG4qKi9cblxuLyoqXG5cbkBwcm9wZXJ0eSB7T2JqZWN0fSBmaWx0ZXJzXG4qKi9cblxuLyoqXG5JZiBgdHJ1ZWAsIFlVSSB3aWxsIHVzZSBhIGNvbWJvIGhhbmRsZXIgdG8gbG9hZCBtdWx0aXBsZSBtb2R1bGVzIGluIGFzIGZld1xucmVxdWVzdHMgYXMgcG9zc2libGUuXG5cblRoZSBZVUkgQ0ROICh3aGljaCBZVUkgdXNlcyBieSBkZWZhdWx0KSBzdXBwb3J0cyBjb21ibyBoYW5kbGluZywgYnV0IG90aGVyXG5zZXJ2ZXJzIG1heSBub3QuIElmIHRoZSBzZXJ2ZXIgZnJvbSB3aGljaCB5b3UncmUgbG9hZGluZyBZVUkgZG9lcyBub3Qgc3VwcG9ydFxuY29tYm8gaGFuZGxpbmcsIHNldCB0aGlzIHRvIGBmYWxzZWAuXG5cblByb3ZpZGluZyBhIHZhbHVlIGZvciB0aGUgYGJhc2VgIGNvbmZpZyBwcm9wZXJ0eSB3aWxsIGNhdXNlIGBjb21iaW5lYCB0byBkZWZhdWx0XG50byBgZmFsc2VgIGluc3RlYWQgb2YgYHRydWVgLlxuXG5AcHJvcGVydHkge0Jvb2xlYW59IGNvbWJpbmVcbkBkZWZhdWx0IHRydWVcbiovXG5cbi8qKlxuQXJyYXkgb2YgbW9kdWxlIG5hbWVzIHRoYXQgc2hvdWxkIG5ldmVyIGJlIGR5bmFtaWNhbGx5IGxvYWRlZC5cblxuQHByb3BlcnR5IHtTdHJpbmdbXX0gaWdub3JlXG4qKi9cblxuLyoqXG5BcnJheSBvZiBtb2R1bGUgbmFtZXMgdGhhdCBzaG91bGQgYWx3YXlzIGJlIGxvYWRlZCB3aGVuIHJlcXVpcmVkLCBldmVuIGlmXG5hbHJlYWR5IHByZXNlbnQgb24gdGhlIHBhZ2UuXG5cbkBwcm9wZXJ0eSB7U3RyaW5nW119IGZvcmNlXG4qKi9cblxuLyoqXG5ET00gZWxlbWVudCBvciBpZCB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIGR5bmFtaWNhbGx5XG5hZGRlZCBgPHNjcmlwdD5gIGFuZCBgPGxpbms+YCBub2Rlcy5cblxuQHByb3BlcnR5IHtIVE1MRWxlbWVudHxTdHJpbmd9IGluc2VydEJlZm9yZVxuKiovXG5cbi8qKlxuT2JqZWN0IGhhc2ggY29udGFpbmluZyBhdHRyaWJ1dGVzIHRvIGFkZCB0byBkeW5hbWljYWxseSBhZGRlZCBgPHNjcmlwdD5gIG5vZGVzLlxuXG5AcHJvcGVydHkge09iamVjdH0ganNBdHRyaWJ1dGVzXG4qKi9cblxuLyoqXG5PYmplY3QgaGFzaCBjb250YWluaW5nIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIGR5bmFtaWNhbGx5IGFkZGVkIGA8bGluaz5gIG5vZGVzLlxuXG5AcHJvcGVydHkge09iamVjdH0gY3NzQXR0cmlidXRlc1xuKiovXG5cbi8qKlxuVGltZW91dCBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIGEgZHluYW1pYyBKUyBvciBDU1MgcmVxdWVzdCB3aWxsIGJlIGNvbnNpZGVyZWQgYVxuZmFpbHVyZS4gSWYgbm90IHNldCwgbm8gdGltZW91dCB3aWxsIGJlIGVuZm9yY2VkLlxuXG5AcHJvcGVydHkge051bWJlcn0gdGltZW91dFxuKiovXG5cbi8qKlxuQSBoYXNoIG9mIG1vZHVsZSBkZWZpbml0aW9ucyB0byBhZGQgdG8gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIFlVSSBtb2R1bGVzLiBUaGVzZVxubW9kdWxlcyBjYW4gdGhlbiBiZSBkeW5hbWljYWxseSBsb2FkZWQgdmlhIHRoZSBgdXNlKClgIG1ldGhvZC5cblxuVGhpcyBpcyBhIGhhc2ggaW4gd2hpY2gga2V5cyBhcmUgbW9kdWxlIG5hbWVzIGFuZCB2YWx1ZXMgYXJlIG9iamVjdHMgY29udGFpbmluZ1xubW9kdWxlIG1ldGFkYXRhLlxuXG5TZWUgYExvYWRlci5hZGRNb2R1bGUoKWAgZm9yIHRoZSBzdXBwb3J0ZWQgbW9kdWxlIG1ldGFkYXRhIGZpZWxkcy4gQWxzbyBzZWVcbmBncm91cHNgLCB3aGljaCBwcm92aWRlcyBhIHdheSB0byBjb25maWd1cmUgdGhlIGJhc2UgYW5kIGNvbWJvIHNwZWMgZm9yIGEgc2V0IG9mXG5tb2R1bGVzLlxuXG5AZXhhbXBsZVxuXG4gICAgbW9kdWxlczoge1xuICAgICAgICBteW1vZDE6IHtcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbJ25vZGUnXSxcbiAgICAgICAgICAgIGZ1bGxwYXRoOiAnL215bW9kMS9teW1vZDEuanMnXG4gICAgICAgIH0sXG5cbiAgICAgICAgbXltb2QyOiB7XG4gICAgICAgICAgICByZXF1aXJlczogWydteW1vZDEnXSxcbiAgICAgICAgICAgIGZ1bGxwYXRoOiAnL215bW9kMi9teW1vZDIuanMnXG4gICAgICAgIH0sXG5cbiAgICAgICAgbXltb2QzOiAnL2pzL215bW9kMy5qcycsXG4gICAgICAgIG15Y3NzbW9kOiAnL2Nzcy9teWNzc21vZC5jc3MnXG4gICAgfVxuXG5AcHJvcGVydHkge09iamVjdH0gbW9kdWxlc1xuKiovXG5cbi8qKlxuQWxpYXNlcyBhcmUgZHluYW1pYyBncm91cHMgb2YgbW9kdWxlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIHNob3J0Y3V0cy5cblxuQGV4YW1wbGVcblxuICAgIFlVSSh7XG4gICAgICAgIGFsaWFzZXM6IHtcbiAgICAgICAgICAgIGRhdmdsYXNzOiBbICdub2RlJywgJ3lxbCcsICdkZCcgXSxcbiAgICAgICAgICAgIG1pbmU6IFsgJ2RhdmdsYXNzJywgJ2F1dG9jb21wbGV0ZSddXG4gICAgICAgIH1cbiAgICB9KS51c2UoJ21pbmUnLCBmdW5jdGlvbiAoWSkge1xuICAgICAgICAvLyBOb2RlLCBZUUwsIEREICYgQXV0b0NvbXBsZXRlIGF2YWlsYWJsZSBoZXJlLlxuICAgIH0pO1xuXG5AcHJvcGVydHkge09iamVjdH0gYWxpYXNlc1xuKiovXG5cbi8qKlxuQSBoYXNoIG9mIG1vZHVsZSBncm91cCBkZWZpbml0aW9ucy5cblxuRm9yIGVhY2ggZ3JvdXAgeW91IGNhbiBzcGVjaWZ5IGEgbGlzdCBvZiBtb2R1bGVzIGFuZCB0aGUgYmFzZSBwYXRoIGFuZFxuY29tYm8gc3BlYyB0byB1c2Ugd2hlbiBkeW5hbWljYWxseSBsb2FkaW5nIHRoZSBtb2R1bGVzLlxuXG5AZXhhbXBsZVxuXG4gICAgZ3JvdXBzOiB7XG4gICAgICAgIHl1aTI6IHtcbiAgICAgICAgICAgIC8vIHNwZWNpZnkgd2hldGhlciBvciBub3QgdGhpcyBncm91cCBoYXMgYSBjb21ibyBzZXJ2aWNlXG4gICAgICAgICAgICBjb21iaW5lOiB0cnVlLFxuXG4gICAgICAgICAgICAvLyBUaGUgY29tYm9TZXBlcmF0b3IgdG8gdXNlIHdpdGggdGhpcyBncm91cCdzIGNvbWJvIGhhbmRsZXJcbiAgICAgICAgICAgIGNvbWJvU2VwOiAnOycsXG5cbiAgICAgICAgICAgIC8vIFRoZSBtYXhVUkxMZW5ndGggZm9yIHRoaXMgc2VydmVyXG4gICAgICAgICAgICBtYXhVUkxMZW5ndGg6IDUwMCxcblxuICAgICAgICAgICAgLy8gdGhlIGJhc2UgcGF0aCBmb3Igbm9uLWNvbWJvIHBhdGhzXG4gICAgICAgICAgICBiYXNlOiAnaHR0cDovL3l1aS55YWhvb2FwaXMuY29tLzIuOC4wcjQvYnVpbGQvJyxcblxuICAgICAgICAgICAgLy8gdGhlIHBhdGggdG8gdGhlIGNvbWJvIHNlcnZpY2VcbiAgICAgICAgICAgIGNvbWJvQmFzZTogJ2h0dHA6Ly95dWkueWFob29hcGlzLmNvbS9jb21ibz8nLFxuXG4gICAgICAgICAgICAvLyBhIGZyYWdtZW50IHRvIHByZXBlbmQgdG8gdGhlIHBhdGggYXR0cmlidXRlIHdoZW5cbiAgICAgICAgICAgIC8vIHdoZW4gYnVpbGRpbmcgY29tYm8gdXJsc1xuICAgICAgICAgICAgcm9vdDogJzIuOC4wcjQvYnVpbGQvJyxcblxuICAgICAgICAgICAgLy8gdGhlIG1vZHVsZSBkZWZpbml0aW9uc1xuICAgICAgICAgICAgbW9kdWxlczogIHtcbiAgICAgICAgICAgICAgICB5dWkyX3lkZToge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBcInlhaG9vLWRvbS1ldmVudC95YWhvby1kb20tZXZlbnQuanNcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeXVpMl9hbmltOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IFwiYW5pbWF0aW9uL2FuaW1hdGlvbi5qc1wiLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlczogWyd5dWkyX3lkZSddXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5AcHJvcGVydHkge09iamVjdH0gZ3JvdXBzXG4qKi9cblxuLyoqXG5QYXRoIHRvIHRoZSBMb2FkZXIgSlMgZmlsZSwgcmVsYXRpdmUgdG8gdGhlIGBiYXNlYCBwYXRoLlxuXG5UaGlzIGlzIHVzZWQgdG8gZHluYW1pY2FsbHkgYm9vdHN0cmFwIHRoZSBMb2FkZXIgd2hlbiBpdCdzIG5lZWRlZCBhbmQgaXNuJ3QgeWV0XG5hdmFpbGFibGUuXG5cbkBwcm9wZXJ0eSB7U3RyaW5nfSBsb2FkZXJQYXRoXG5AZGVmYXVsdCBcImxvYWRlci9sb2FkZXItbWluLmpzXCJcbioqL1xuXG4vKipcbklmIGB0cnVlYCwgWVVJIHdpbGwgYXR0ZW1wdCB0byBsb2FkIENTUyBkZXBlbmRlbmNpZXMgYW5kIHNraW5zLiBTZXQgdGhpcyB0b1xuYGZhbHNlYCB0byBwcmV2ZW50IFlVSSBmcm9tIGxvYWRpbmcgYW55IENTUywgb3Igc2V0IGl0IHRvIHRoZSBzdHJpbmcgYFwiZm9yY2VcImBcbnRvIGZvcmNlIENTUyBkZXBlbmRlbmNpZXMgdG8gYmUgbG9hZGVkIGV2ZW4gaWYgdGhlaXIgYXNzb2NpYXRlZCBKUyBtb2R1bGVzIGFyZVxuYWxyZWFkeSBsb2FkZWQuXG5cbkBwcm9wZXJ0eSB7Qm9vbGVhbnxTdHJpbmd9IGZldGNoQ1NTXG5AZGVmYXVsdCB0cnVlXG4qKi9cblxuLyoqXG5EZWZhdWx0IGdhbGxlcnkgdmVyc2lvbiB1c2VkIHRvIGJ1aWxkIGdhbGxlcnkgbW9kdWxlIHVybHMuXG5cbkBwcm9wZXJ0eSB7U3RyaW5nfSBnYWxsZXJ5XG5Ac2luY2UgMy4xLjBcbioqL1xuXG4vKipcbkRlZmF1bHQgWVVJIDIgdmVyc2lvbiB1c2VkIHRvIGJ1aWxkIFlVSSAyIG1vZHVsZSB1cmxzLlxuXG5UaGlzIGlzIHVzZWQgZm9yIGludHJpbnNpYyBZVUkgMiBzdXBwb3J0IHZpYSB0aGUgMmluMyBwcm9qZWN0LiBBbHNvIHNlZSB0aGVcbmAyaW4zYCBjb25maWcgZm9yIHB1bGxpbmcgZGlmZmVyZW50IHJldmlzaW9ucyBvZiB0aGUgd3JhcHBlZCBZVUkgMiBtb2R1bGVzLlxuXG5AcHJvcGVydHkge1N0cmluZ30geXVpMlxuQGRlZmF1bHQgXCIyLjkuMFwiXG5Ac2luY2UgMy4xLjBcbioqL1xuXG4vKipcblJldmlzaW9uIG51bWJlciBvZiBZVUkgMmluMyBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBsb2FkaW5nIFlVSSAyaW4zLlxuXG5AcHJvcGVydHkge1N0cmluZ30gMmluM1xuQGRlZmF1bHQgXCI0XCJcbkBzaW5jZSAzLjEuMFxuKiovXG5cbi8qKlxuQWx0ZXJuYXRlIGNvbnNvbGUgbG9nIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIHVzZWQgaW4gZW52aXJvbm1lbnRzIHdpdGhvdXQgYVxuc3VwcG9ydGVkIG5hdGl2ZSBjb25zb2xlLiBUaGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIFlVSSBpbnN0YW5jZSBhcyBpdHNcbmB0aGlzYCBvYmplY3QuXG5cbkBwcm9wZXJ0eSB7RnVuY3Rpb259IGxvZ0ZuXG5Ac2luY2UgMy4xLjBcbioqL1xuXG4vKipcblRoZSBtaW5pbXVtIGxvZyBsZXZlbCB0byBsb2cgbWVzc2FnZXMgZm9yLiBMb2cgbGV2ZWxzIGFyZSBkZWZpbmVkXG5pbmNyZW1lbnRhbGx5LiBNZXNzYWdlcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxldmVsIHNwZWNpZmllZCB3aWxsXG5iZSBzaG93bi4gQWxsIG90aGVycyB3aWxsIGJlIGRpc2NhcmRlZC4gVGhlIG9yZGVyIG9mIGxvZyBsZXZlbHMgaW5cbmluY3JlYXNpbmcgcHJpb3JpdHkgaXM6XG5cbiAgICBkZWJ1Z1xuICAgIGluZm9cbiAgICB3YXJuXG4gICAgZXJyb3JcblxuQHByb3BlcnR5IHtTdHJpbmd9IGxvZ0xldmVsXG5AZGVmYXVsdCAnZGVidWcnXG5Ac2luY2UgMy4xMC4wXG4qKi9cblxuLyoqXG5DYWxsYmFjayB0byBleGVjdXRlIHdoZW4gYFkuZXJyb3IoKWAgaXMgY2FsbGVkLiBJdCByZWNlaXZlcyB0aGUgZXJyb3IgbWVzc2FnZVxuYW5kIGEgSmF2YVNjcmlwdCBlcnJvciBvYmplY3QgaWYgb25lIHdhcyBwcm92aWRlZC5cblxuVGhpcyBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBZVUkgaW5zdGFuY2UgYXMgaXRzIGB0aGlzYCBvYmplY3QuXG5cblJldHVybmluZyBgdHJ1ZWAgZnJvbSB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJldmVudCBhbiBleGNlcHRpb24gZnJvbSBiZWluZyB0aHJvd24uXG5cbkBwcm9wZXJ0eSB7RnVuY3Rpb259IGVycm9yRm5cbkBwYXJhbSB7U3RyaW5nfSBlcnJvckZuLm1zZyBFcnJvciBtZXNzYWdlXG5AcGFyYW0ge09iamVjdH0gW2Vycm9yRm4uZXJyXSBFcnJvciBvYmplY3QgKGlmIG9uZSB3YXMgcHJvdmlkZWQpLlxuQHNpbmNlIDMuMi4wXG4qKi9cblxuLyoqXG5BIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBMb2FkZXIgZmFpbHMgdG8gbG9hZCBvbmUgb3IgbW9yZSByZXNvdXJjZXMuXG5cblRoaXMgY291bGQgYmUgYmVjYXVzZSBvZiBhIHNjcmlwdCBsb2FkIGZhaWx1cmUuIEl0IGNvdWxkIGFsc28gYmUgYmVjYXVzZSBhXG5tb2R1bGUgZmFpbHMgdG8gcmVnaXN0ZXIgaXRzZWxmIHdoZW4gdGhlIGByZXF1aXJlUmVnaXN0cmF0aW9uYCBjb25maWcgaXMgYHRydWVgLlxuXG5JZiB0aGlzIGZ1bmN0aW9uIGlzIGRlZmluZWQsIHRoZSBgdXNlKClgIGNhbGxiYWNrIHdpbGwgb25seSBiZSBjYWxsZWQgd2hlbiB0aGVcbmxvYWRlciBzdWNjZWVkcy4gT3RoZXJ3aXNlLCBgdXNlKClgIHdpbGwgYWx3YXlzIGV4ZWN1dGVzIHVubGVzcyB0aGVyZSB3YXMgYVxuSmF2YVNjcmlwdCBlcnJvciB3aGVuIGF0dGFjaGluZyBhIG1vZHVsZS5cblxuQHByb3BlcnR5IHtGdW5jdGlvbn0gbG9hZEVycm9yRm5cbkBzaW5jZSAzLjMuMFxuKiovXG5cbi8qKlxuSWYgYHRydWVgLCBMb2FkZXIgd2lsbCBleHBlY3QgYWxsIGxvYWRlZCBzY3JpcHRzIHRvIGJlIGZpcnN0LWNsYXNzIFlVSSBtb2R1bGVzXG50aGF0IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCB0aGUgWVVJIGdsb2JhbCwgYW5kIHdpbGwgdHJpZ2dlciBhIGZhaWx1cmUgaWYgYVxubG9hZGVkIHNjcmlwdCBkb2VzIG5vdCByZWdpc3RlciBhIFlVSSBtb2R1bGUuXG5cbkBwcm9wZXJ0eSB7Qm9vbGVhbn0gcmVxdWlyZVJlZ2lzdHJhdGlvblxuQGRlZmF1bHQgZmFsc2VcbkBzaW5jZSAzLjMuMFxuKiovXG5cbi8qKlxuQ2FjaGUgc2VydmljZWQgdXNlKCkgcmVxdWVzdHMuXG5cbkBwcm9wZXJ0eSB7Qm9vbGVhbn0gY2FjaGVVc2VcbkBkZWZhdWx0IHRydWVcbkBzaW5jZSAzLjMuMFxuQGRlcHJlY2F0ZWQgTm8gbG9uZ2VyIHVzZWQuXG4qKi9cblxuLyoqXG5XaGV0aGVyIG9yIG5vdCBZVUkgc2hvdWxkIHVzZSBuYXRpdmUgRVM1IGZ1bmN0aW9uYWxpdHkgd2hlbiBhdmFpbGFibGUgZm9yXG5mZWF0dXJlcyBsaWtlIGBZLkFycmF5LmVhY2goKWAsIGBZLk9iamVjdCgpYCwgZXRjLlxuXG5XaGVuIGBmYWxzZWAsIFlVSSB3aWxsIGFsd2F5cyB1c2UgaXRzIG93biBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbnMgaW5zdGVhZCBvZlxucmVseWluZyBvbiBFUzUgZnVuY3Rpb25hbGl0eSwgZXZlbiB3aGVuIEVTNSBmdW5jdGlvbmFsaXR5IGlzIGF2YWlsYWJsZS5cblxuQHByb3BlcnR5IHtCb29sZWFufSB1c2VOYXRpdmVFUzVcbkBkZWZhdWx0IHRydWVcbkBzaW5jZSAzLjUuMFxuKiovXG5cbi8qKlxuICogTGV2ZXJhZ2UgbmF0aXZlIEpTT04gc3RyaW5naWZ5IGlmIHRoZSBicm93c2VyIGhhcyBhIG5hdGl2ZVxuICogaW1wbGVtZW50YXRpb24uICBJbiBnZW5lcmFsLCB0aGlzIGlzIGEgZ29vZCBpZGVhLiAgU2VlIHRoZSBLbm93biBJc3N1ZXNcbiAqIHNlY3Rpb24gaW4gdGhlIEpTT04gdXNlciBndWlkZSBmb3IgY2F2ZWF0cy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAqIGZvciBicm93c2VycyB3aXRoIG5hdGl2ZSBKU09OIHN1cHBvcnQuXG4gKlxuICogQHByb3BlcnR5IHVzZU5hdGl2ZUpTT05TdHJpbmdpZnlcbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0IHRydWVcbiAqIEBzaW5jZSAzLjguMFxuICovXG5cbiAvKipcbiAqIExldmVyYWdlIG5hdGl2ZSBKU09OIHBhcnNlIGlmIHRoZSBicm93c2VyIGhhcyBhIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAqIEluIGdlbmVyYWwsIHRoaXMgaXMgYSBnb29kIGlkZWEuICBTZWUgdGhlIEtub3duIElzc3VlcyBzZWN0aW9uIGluIHRoZVxuICogSlNPTiB1c2VyIGd1aWRlIGZvciBjYXZlYXRzLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZSBmb3IgYnJvd3NlcnMgd2l0aFxuICogbmF0aXZlIEpTT04gc3VwcG9ydC5cbiAqXG4gKiBAcHJvcGVydHkgdXNlTmF0aXZlSlNPTlBhcnNlXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdCB0cnVlXG4gKiBAc2luY2UgMy44LjBcbiAqL1xuXG4vKipcbkRlbGF5IHRoZSBgdXNlYCBjYWxsYmFjayB1bnRpbCBhIHNwZWNpZmljIGV2ZW50IGhhcyBwYXNzZWQgKGBsb2FkYCwgYGRvbXJlYWR5YCwgYGNvbnRlbnRyZWFkeWAgb3IgYGF2YWlsYWJsZWApXG5cbkBwcm9wZXJ0eSB7T2JqZWN0fFN0cmluZ30gZGVsYXlVbnRpbFxuQHNpbmNlIDMuNi4wXG5AZXhhbXBsZVxuXG5Zb3UgY2FuIHVzZSBgbG9hZGAgb3IgYGRvbXJlYWR5YCBzdHJpbmdzIGJ5IGRlZmF1bHQ6XG5cbiAgICBZVUkoe1xuICAgICAgICBkZWxheVVudGlsOiAnZG9tcmVhZHknXG4gICAgfSwgZnVuY3Rpb24gKFkpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIG5vdCBleGVjdXRlIHVudGlsICdkb21lcmVhZHknIG9jY3Vycy5cbiAgICB9KTtcblxuT3IgeW91IGNhbiBkZWxheSB1bnRpbCBhIG5vZGUgaXMgYXZhaWxhYmxlICh3aXRoIGBhdmFpbGFibGVgIG9yIGBjb250ZW50cmVhZHlgKTpcblxuICAgIFlVSSh7XG4gICAgICAgIGRlbGF5VW50aWw6IHtcbiAgICAgICAgICAgIGV2ZW50OiAnYXZhaWxhYmxlJyxcbiAgICAgICAgICAgIGFyZ3MgOiAnI2ZvbydcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBub3QgZXhlY3V0ZSB1bnRpbCBhIG5vZGUgbWF0Y2hpbmcgdGhlIHNlbGVjdG9yIFwiI2Zvb1wiIGlzXG4gICAgICAgIC8vIGF2YWlsYWJsZSBpbiB0aGUgRE9NLlxuICAgIH0pO1xuXG4qKi9cbllVSS5hZGQoJ3l1aS1iYXNlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLypcbiAqIFlVSSBzdHViXG4gKiBAbW9kdWxlIHl1aVxuICogQHN1Ym1vZHVsZSB5dWktYmFzZVxuICovXG4vKipcbiAqIFRoZSBZVUkgbW9kdWxlIGNvbnRhaW5zIHRoZSBjb21wb25lbnRzIHJlcXVpcmVkIGZvciBidWlsZGluZyB0aGUgWVVJXG4gKiBzZWVkIGZpbGUuICBUaGlzIGluY2x1ZGVzIHRoZSBzY3JpcHQgbG9hZGluZyBtZWNoYW5pc20sIGEgc2ltcGxlIHF1ZXVlLFxuICogYW5kIHRoZSBjb3JlIHV0aWxpdGllcyBmb3IgdGhlIGxpYnJhcnkuXG4gKiBAbW9kdWxlIHl1aVxuICogQHN1Ym1vZHVsZSB5dWktYmFzZVxuICovXG5cbi8qKlxuICogUHJvdmlkZXMgY29yZSBsYW5ndWFnZSB1dGlsaXRlcyBhbmQgZXh0ZW5zaW9ucyB1c2VkIHRocm91Z2hvdXQgWVVJLlxuICpcbiAqIEBjbGFzcyBMYW5nXG4gKiBAc3RhdGljXG4gKi9cblxudmFyIEwgPSBZLkxhbmcgfHwgKFkuTGFuZyA9IHt9KSxcblxuU1RSSU5HX1BST1RPID0gU3RyaW5nLnByb3RvdHlwZSxcblRPU1RSSU5HICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cblRZUEVTID0ge1xuICAgICd1bmRlZmluZWQnICAgICAgICA6ICd1bmRlZmluZWQnLFxuICAgICdudW1iZXInICAgICAgICAgICA6ICdudW1iZXInLFxuICAgICdib29sZWFuJyAgICAgICAgICA6ICdib29sZWFuJyxcbiAgICAnc3RyaW5nJyAgICAgICAgICAgOiAnc3RyaW5nJyxcbiAgICAnW29iamVjdCBGdW5jdGlvbl0nOiAnZnVuY3Rpb24nLFxuICAgICdbb2JqZWN0IFJlZ0V4cF0nICA6ICdyZWdleHAnLFxuICAgICdbb2JqZWN0IEFycmF5XScgICA6ICdhcnJheScsXG4gICAgJ1tvYmplY3QgRGF0ZV0nICAgIDogJ2RhdGUnLFxuICAgICdbb2JqZWN0IEVycm9yXScgICA6ICdlcnJvcidcbn0sXG5cblNVQlJFR0VYICAgICAgICAgPSAvXFx7XFxzKihbXnx9XSs/KVxccyooPzpcXHwoW159XSopKT9cXHMqXFx9L2csXG5cbldISVRFU1BBQ0UgICAgICAgPSBcIlxceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMjhcXHUyMDI5XFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1RkVGRlwiLFxuV0hJVEVTUEFDRV9DTEFTUyA9IFwiW1xceDA5LVxceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGXStcIixcblRSSU1fTEVGVF9SRUdFWCAgPSBuZXcgUmVnRXhwKFwiXlwiICsgV0hJVEVTUEFDRV9DTEFTUyksXG5UUklNX1JJR0hUX1JFR0VYID0gbmV3IFJlZ0V4cChXSElURVNQQUNFX0NMQVNTICsgXCIkXCIpLFxuVFJJTVJFR0VYICAgICAgICA9IG5ldyBSZWdFeHAoVFJJTV9MRUZUX1JFR0VYLnNvdXJjZSArIFwifFwiICsgVFJJTV9SSUdIVF9SRUdFWC5zb3VyY2UsIFwiZ1wiKSxcblxuTkFUSVZFX0ZOX1JFR0VYICA9IC9cXHtcXHMqXFxbKD86bmF0aXZlIGNvZGV8ZnVuY3Rpb24pXFxdXFxzKlxcfS9pO1xuXG4vLyAtLSBQcm90ZWN0ZWQgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcblJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBmdW5jdGlvbiBhcHBlYXJzIHRvIGJlIGltcGxlbWVudGVkIGluIG5hdGl2ZSBjb2RlLFxuYGZhbHNlYCBvdGhlcndpc2UuIFdpbGwgYWx3YXlzIHJldHVybiBgZmFsc2VgIC0tIGV2ZW4gaW4gRVM1LWNhcGFibGUgYnJvd3NlcnMgLS1cbmlmIHRoZSBgdXNlTmF0aXZlRVM1YCBZVUkgY29uZmlnIG9wdGlvbiBpcyBzZXQgdG8gYGZhbHNlYC5cblxuVGhpcyBpc24ndCBndWFyYW50ZWVkIHRvIGJlIDEwMCUgYWNjdXJhdGUgYW5kIHdvbid0IHdvcmsgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbmZ1bmN0aW9ucywgYnV0IGl0IGNhbiBiZSB1c2VmdWwgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgYSBmdW5jdGlvbiBsaWtlXG5gQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIGlzIG5hdGl2ZSBvciBhIEpTIHNoaW0gcHJvdmlkZWQgYnkgYW5vdGhlciBsaWJyYXJ5LlxuXG5UaGVyZSdzIGEgZ3JlYXQgYXJ0aWNsZSBieSBAa2FuZ2F4IGRpc2N1c3NpbmcgY2VydGFpbiBmbGF3cyB3aXRoIHRoaXMgdGVjaG5pcXVlOlxuPGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2RldGVjdGluZy1idWlsdC1pbi1ob3N0LW1ldGhvZHMvPlxuXG5XaGlsZSBoaXMgcG9pbnRzIGFyZSB2YWxpZCwgaXQncyBzdGlsbCBwb3NzaWJsZSB0byBiZW5lZml0IGZyb20gdGhpcyBmdW5jdGlvblxuYXMgbG9uZyBhcyBpdCdzIHVzZWQgY2FyZWZ1bGx5IGFuZCBzcGFyaW5nbHksIGFuZCBpbiBzdWNoIGEgd2F5IHRoYXQgZmFsc2Vcbm5lZ2F0aXZlcyBoYXZlIG1pbmltYWwgY29uc2VxdWVuY2VzLiBJdCdzIHVzZWQgaW50ZXJuYWxseSB0byBhdm9pZCB1c2luZ1xucG90ZW50aWFsbHkgYnJva2VuIG5vbi1uYXRpdmUgRVM1IHNoaW1zIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBwYWdlIGJ5XG5vdGhlciBsaWJyYXJpZXMuXG5cbkBtZXRob2QgX2lzTmF0aXZlXG5AcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byB0ZXN0LlxuQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIF9mbl8gYXBwZWFycyB0byBiZSBuYXRpdmUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuQHN0YXRpY1xuQHByb3RlY3RlZFxuQHNpbmNlIDMuNS4wXG4qKi9cbkwuX2lzTmF0aXZlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuICEhKFkuY29uZmlnLnVzZU5hdGl2ZUVTNSAmJiBmbiAmJiBOQVRJVkVfRk5fUkVHRVgudGVzdChmbikpO1xufTtcblxuLy8gLS0gUHVibGljIE1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlZCBpdGVtIGlzIGFuIGFycmF5LlxuICpcbiAqIFJldHVybnMgYGZhbHNlYCBmb3IgYXJyYXktbGlrZSBjb2xsZWN0aW9ucyBzdWNoIGFzIHRoZSBmdW5jdGlvbiBgYXJndW1lbnRzYFxuICogY29sbGVjdGlvbiBvciBgSFRNTEVsZW1lbnRgIGNvbGxlY3Rpb25zLiBVc2UgYFkuQXJyYXkudGVzdCgpYCBpZiB5b3Ugd2FudCB0b1xuICogdGVzdCBmb3IgYW4gYXJyYXktbGlrZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBtZXRob2QgaXNBcnJheVxuICogQHBhcmFtIG8gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBvIGlzIGFuIGFycmF5LlxuICogQHN0YXRpY1xuICovXG5MLmlzQXJyYXkgPSBMLl9pc05hdGl2ZShBcnJheS5pc0FycmF5KSA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBMLnR5cGUobykgPT09ICdhcnJheSc7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIGl0ZW0gaXMgYSBib29sZWFuLlxuICogQG1ldGhvZCBpc0Jvb2xlYW5cbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBvIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbyBpcyBhIGJvb2xlYW4uXG4gKi9cbkwuaXNCb29sZWFuID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ2Jvb2xlYW4nO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBzdXBwbGllZCBpdGVtIGlzIGEgZGF0ZSBpbnN0YW5jZS5cbiAqIEBtZXRob2QgaXNEYXRlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gbyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG8gaXMgYSBkYXRlLlxuICovXG5MLmlzRGF0ZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gTC50eXBlKG8pID09PSAnZGF0ZScgJiYgby50b1N0cmluZygpICE9PSAnSW52YWxpZCBEYXRlJyAmJiAhaXNOYU4obyk7XG59O1xuXG4vKipcbiAqIDxwPlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaXRlbSBpcyBhIGZ1bmN0aW9uLlxuICogTm90ZTogSW50ZXJuZXQgRXhwbG9yZXIgdGhpbmtzIGNlcnRhaW4gZnVuY3Rpb25zIGFyZSBvYmplY3RzOlxuICogPC9wPlxuICpcbiAqIDxwcmU+XG4gKiB2YXIgb2JqID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9iamVjdFwiKTtcbiAqIFkuTGFuZy5pc0Z1bmN0aW9uKG9iai5nZXRBdHRyaWJ1dGUpIC8vIHJlcG9ydHMgZmFsc2UgaW4gSUVcbiAqICZuYnNwO1xuICogdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpOyAvLyBhcHBlbmQgdG8gYm9keVxuICogWS5MYW5nLmlzRnVuY3Rpb24oaW5wdXQuZm9jdXMpIC8vIHJlcG9ydHMgZmFsc2UgaW4gSUVcbiAqIDwvcHJlPlxuICpcbiAqIDxwPlxuICogWW91IHdpbGwgaGF2ZSB0byBpbXBsZW1lbnQgYWRkaXRpb25hbCB0ZXN0cyBpZiB0aGVzZSBmdW5jdGlvbnNcbiAqIG1hdHRlciB0byB5b3UuXG4gKiA8L3A+XG4gKlxuICogQG1ldGhvZCBpc0Z1bmN0aW9uXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gbyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG8gaXMgYSBmdW5jdGlvbi5cbiAqL1xuTC5pc0Z1bmN0aW9uID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBMLnR5cGUobykgPT09ICdmdW5jdGlvbic7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIGl0ZW0gaXMgbnVsbC5cbiAqIEBtZXRob2QgaXNOdWxsXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gbyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG8gaXMgbnVsbC5cbiAqL1xuTC5pc051bGwgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIG8gPT09IG51bGw7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIGl0ZW0gaXMgYSBsZWdhbCBudW1iZXIuXG4gKiBAbWV0aG9kIGlzTnVtYmVyXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gbyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG8gaXMgYSBudW1iZXIuXG4gKi9cbkwuaXNOdW1iZXIgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShvKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaXRlbSBpcyBvZiB0eXBlIG9iamVjdFxuICogb3IgZnVuY3Rpb24uIE5vdGUgdGhhdCBhcnJheXMgYXJlIGFsc28gb2JqZWN0cywgc29cbiAqIDxjb2RlPlkuTGFuZy5pc09iamVjdChbXSkgPT09IHRydWU8L2NvZGU+LlxuICogQG1ldGhvZCBpc09iamVjdFxuICogQHN0YXRpY1xuICogQHBhcmFtIG8gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHBhcmFtIGZhaWxmbiB7Ym9vbGVhbn0gZmFpbCBpZiB0aGUgaW5wdXQgaXMgYSBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbyBpcyBhbiBvYmplY3QuXG4gKiBAc2VlIGlzUGxhaW5PYmplY3RcbiAqL1xuTC5pc09iamVjdCA9IGZ1bmN0aW9uKG8sIGZhaWxmbikge1xuICAgIHZhciB0ID0gdHlwZW9mIG87XG4gICAgcmV0dXJuIChvICYmICh0ID09PSAnb2JqZWN0JyB8fFxuICAgICAgICAoIWZhaWxmbiAmJiAodCA9PT0gJ2Z1bmN0aW9uJyB8fCBMLmlzRnVuY3Rpb24obykpKSkpIHx8IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIHJlZ2V4cC5cbiAqIEBtZXRob2QgaXNSZWdFeHBcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb3Igb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHZhbHVlIGlzIGEgcmVnZXhwLlxuICovXG5MLmlzUmVnRXhwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gTC50eXBlKHZhbHVlKSA9PT0gJ3JlZ2V4cCc7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIGl0ZW0gaXMgYSBzdHJpbmcuXG4gKiBAbWV0aG9kIGlzU3RyaW5nXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gbyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG8gaXMgYSBzdHJpbmcuXG4gKi9cbkwuaXNTdHJpbmcgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaXRlbSBpcyB1bmRlZmluZWQuXG4gKiBAbWV0aG9kIGlzVW5kZWZpbmVkXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gbyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG8gaXMgdW5kZWZpbmVkLlxuICovXG5MLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCc7XG59O1xuXG4vKipcbiAqIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBkZXRlY3RpbmcgYSBsZWdpdGltYXRlIG5vbi1udWxsIHZhbHVlLlxuICogUmV0dXJucyBmYWxzZSBmb3IgbnVsbC91bmRlZmluZWQvTmFOLCB0cnVlIGZvciBvdGhlciB2YWx1ZXMsXG4gKiBpbmNsdWRpbmcgMC9mYWxzZS8nJ1xuICogQG1ldGhvZCBpc1ZhbHVlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gbyBUaGUgaXRlbSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdCBpcyBub3QgbnVsbC91bmRlZmluZWQvTmFOIHx8IGZhbHNlLlxuICovXG5MLmlzVmFsdWUgPSBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHQgPSBMLnR5cGUobyk7XG5cbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZShvKTtcblxuICAgICAgICBjYXNlICdudWxsJzogLy8gZmFsbHRocnVcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICEhdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKlxuICogQG1ldGhvZCBub3dcbiAqIEByZXR1cm4ge051bWJlcn0gQ3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAzLjMuMFxuICovXG5MLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGB7cGxhY2Vob2xkZXJ9YCBzdWJzdGl0dXRpb24gb24gYSBzdHJpbmcuIFRoZSBvYmplY3QgcGFzc2VkIGFzIHRoZVxuICogc2Vjb25kIHBhcmFtZXRlciBwcm92aWRlcyB2YWx1ZXMgdG8gcmVwbGFjZSB0aGUgYHtwbGFjZWhvbGRlcn1gcy5cbiAqIGB7cGxhY2Vob2xkZXJ9YCB0b2tlbiBuYW1lcyBtdXN0IG1hdGNoIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBvYmplY3QuIEZvciBleGFtcGxlLFxuICpcbiAqYHZhciBncmVldGluZyA9IFkuTGFuZy5zdWIoXCJIZWxsbywge3dob30hXCIsIHsgd2hvOiBcIldvcmxkXCIgfSk7YFxuICpcbiAqIGB7cGxhY2Vob2xkZXJ9YCB0b2tlbnMgdGhhdCBhcmUgdW5kZWZpbmVkIG9uIHRoZSBvYmplY3QgbWFwIHdpbGwgYmUgbGVmdFxuICogaW4gdGFjdCAobGVhdmluZyB1bnNpZ2h0bHkgYHtwbGFjZWhvbGRlcn1gJ3MgaW4gdGhlIG91dHB1dCBzdHJpbmcpLlxuICpcbiAqIEBtZXRob2Qgc3ViXG4gKiBAcGFyYW0ge3N0cmluZ30gcyBTdHJpbmcgdG8gYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gbyBPYmplY3QgY29udGFpbmluZyByZXBsYWNlbWVudCB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBzdWJzdGl0dXRlIHJlc3VsdC5cbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAzLjIuMFxuICovXG5MLnN1YiA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlID8gcy5yZXBsYWNlKFNVQlJFR0VYLCBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgICAgICByZXR1cm4gTC5pc1VuZGVmaW5lZChvW2tleV0pID8gbWF0Y2ggOiBvW2tleV07XG4gICAgfSkgOiBzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGhvdXQgYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZS4gIElmXG4gKiB0aGUgaW5wdXQgaXMgbm90IGEgc3RyaW5nLCB0aGUgaW5wdXQgd2lsbCBiZSByZXR1cm5lZCB1bnRvdWNoZWQuXG4gKiBAbWV0aG9kIHRyaW1cbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBzIHtzdHJpbmd9IHRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHRyaW1tZWQgc3RyaW5nLlxuICovXG5MLnRyaW0gPSBMLl9pc05hdGl2ZShTVFJJTkdfUFJPVE8udHJpbSkgJiYgIVdISVRFU1BBQ0UudHJpbSgpID8gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzICYmIHMudHJpbSA/IHMudHJpbSgpIDogcztcbn0gOiBmdW5jdGlvbiAocykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoVFJJTVJFR0VYLCAnJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgd2l0aG91dCBhbnkgbGVhZGluZyB3aGl0ZXNwYWNlLlxuICogQG1ldGhvZCB0cmltTGVmdFxuICogQHN0YXRpY1xuICogQHBhcmFtIHMge3N0cmluZ30gdGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gKi9cbkwudHJpbUxlZnQgPSBMLl9pc05hdGl2ZShTVFJJTkdfUFJPVE8udHJpbUxlZnQpICYmICFXSElURVNQQUNFLnRyaW1MZWZ0KCkgPyBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnRyaW1MZWZ0KCk7XG59IDogZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKFRSSU1fTEVGVF9SRUdFWCwgJycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGhvdXQgYW55IHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gKiBAbWV0aG9kIHRyaW1SaWdodFxuICogQHN0YXRpY1xuICogQHBhcmFtIHMge3N0cmluZ30gdGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gKi9cbkwudHJpbVJpZ2h0ID0gTC5faXNOYXRpdmUoU1RSSU5HX1BST1RPLnRyaW1SaWdodCkgJiYgIVdISVRFU1BBQ0UudHJpbVJpZ2h0KCkgPyBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnRyaW1SaWdodCgpO1xufSA6IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShUUklNX1JJR0hUX1JFR0VYLCAnJyk7XG59O1xuXG4vKipcblJldHVybnMgb25lIG9mIHRoZSBmb2xsb3dpbmcgc3RyaW5ncywgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRoZSBpdGVtIHBhc3NlZFxuaW46XG5cbiAqIFwiYXJyYXlcIlxuICogXCJib29sZWFuXCJcbiAqIFwiZGF0ZVwiXG4gKiBcImVycm9yXCJcbiAqIFwiZnVuY3Rpb25cIlxuICogXCJudWxsXCJcbiAqIFwibnVtYmVyXCJcbiAqIFwib2JqZWN0XCJcbiAqIFwicmVnZXhwXCJcbiAqIFwic3RyaW5nXCJcbiAqIFwidW5kZWZpbmVkXCJcblxuS25vd24gaXNzdWVzOlxuXG4gKiBgdHlwZW9mIEhUTUxFbGVtZW50Q29sbGVjdGlvbmAgcmV0dXJucyBmdW5jdGlvbiBpbiBTYWZhcmksIGJ1dFxuICAgIGBZLkxhbmcudHlwZSgpYCByZXBvcnRzIFwib2JqZWN0XCIsIHdoaWNoIGNvdWxkIGJlIGEgZ29vZCB0aGluZyAtLVxuICAgIGJ1dCBpdCBhY3R1YWxseSBjYXVzZWQgdGhlIGxvZ2ljIGluIDxjb2RlPlkuTGFuZy5pc09iamVjdDwvY29kZT4gdG8gZmFpbC5cblxuQG1ldGhvZCB0eXBlXG5AcGFyYW0gbyB0aGUgaXRlbSB0byB0ZXN0LlxuQHJldHVybiB7c3RyaW5nfSB0aGUgZGV0ZWN0ZWQgdHlwZS5cbkBzdGF0aWNcbioqL1xuTC50eXBlID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiBUWVBFU1t0eXBlb2Ygb10gfHwgVFlQRVNbVE9TVFJJTkcuY2FsbChvKV0gfHwgKG8gPyAnb2JqZWN0JyA6ICdudWxsJyk7XG59O1xuLyoqXG5AbW9kdWxlIHl1aVxuQHN1Ym1vZHVsZSB5dWktYmFzZVxuKi9cblxudmFyIExhbmcgICA9IFkuTGFuZyxcbiAgICBOYXRpdmUgPSBBcnJheS5wcm90b3R5cGUsXG5cbiAgICBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcblByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIGFycmF5cy4gQWRkaXRpb25hbCBhcnJheSBoZWxwZXJzIGNhblxuYmUgZm91bmQgaW4gdGhlIGBjb2xsZWN0aW9uYCBhbmQgYGFycmF5LWV4dHJhc2AgbW9kdWxlcy5cblxuYFkuQXJyYXkodGhpbmcpYCByZXR1cm5zIGEgbmF0aXZlIGFycmF5IGNyZWF0ZWQgZnJvbSBfdGhpbmdfLiBEZXBlbmRpbmcgb25cbl90aGluZ18ncyB0eXBlLCBvbmUgb2YgdGhlIGZvbGxvd2luZyB3aWxsIGhhcHBlbjpcblxuICAqIEFycmF5cyBhcmUgcmV0dXJuZWQgdW5tb2RpZmllZCB1bmxlc3MgYSBub24temVybyBfc3RhcnRJbmRleF8gaXNcbiAgICBzcGVjaWZpZWQuXG4gICogQXJyYXktbGlrZSBjb2xsZWN0aW9ucyAoc2VlIGBBcnJheS50ZXN0KClgKSBhcmUgY29udmVydGVkIHRvIGFycmF5cy5cbiAgKiBGb3IgZXZlcnl0aGluZyBlbHNlLCBhIG5ldyBhcnJheSBpcyBjcmVhdGVkIHdpdGggX3RoaW5nXyBhcyB0aGUgc29sZVxuICAgIGl0ZW0uXG5cbk5vdGU6IGVsZW1lbnRzIHRoYXQgYXJlIGFsc28gY29sbGVjdGlvbnMsIHN1Y2ggYXMgYDxmb3JtPmAgYW5kIGA8c2VsZWN0PmBcbmVsZW1lbnRzLCBhcmUgbm90IGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFycmF5cy4gVG8gZm9yY2UgYSBjb252ZXJzaW9uLFxucGFzcyBgdHJ1ZWAgYXMgdGhlIHZhbHVlIG9mIHRoZSBfZm9yY2VfIHBhcmFtZXRlci5cblxuQGNsYXNzIEFycmF5XG5AY29uc3RydWN0b3JcbkBwYXJhbSB7QW55fSB0aGluZyBUaGUgdGhpbmcgdG8gYXJyYXlpZnkuXG5AcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXg9MF0gSWYgbm9uLXplcm8gYW5kIF90aGluZ18gaXMgYW4gYXJyYXkgb3IgYXJyYXktbGlrZVxuICBjb2xsZWN0aW9uLCBhIHN1YnNldCBvZiBpdGVtcyBzdGFydGluZyBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHdpbGwgYmVcbiAgcmV0dXJuZWQuXG5AcGFyYW0ge0Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gSWYgYHRydWVgLCBfdGhpbmdfIHdpbGwgYmUgdHJlYXRlZCBhcyBhblxuICBhcnJheS1saWtlIGNvbGxlY3Rpb24gbm8gbWF0dGVyIHdoYXQuXG5AcmV0dXJuIHtBcnJheX0gQSBuYXRpdmUgYXJyYXkgY3JlYXRlZCBmcm9tIF90aGluZ18sIGFjY29yZGluZyB0byB0aGUgcnVsZXNcbiAgZGVzY3JpYmVkIGFib3ZlLlxuKiovXG5mdW5jdGlvbiBZQXJyYXkodGhpbmcsIHN0YXJ0SW5kZXgsIGZvcmNlKSB7XG4gICAgdmFyIGxlbiwgcmVzdWx0O1xuXG4gICAgLypqc2hpbnQgZXhwcjogdHJ1ZSovXG4gICAgc3RhcnRJbmRleCB8fCAoc3RhcnRJbmRleCA9IDApO1xuXG4gICAgaWYgKGZvcmNlIHx8IFlBcnJheS50ZXN0KHRoaW5nKSkge1xuICAgICAgICAvLyBJRSB0aHJvd3Mgd2hlbiB0cnlpbmcgdG8gc2xpY2UgSFRNTEVsZW1lbnQgY29sbGVjdGlvbnMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gTmF0aXZlLnNsaWNlLmNhbGwodGhpbmcsIHN0YXJ0SW5kZXgpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGVuID0gdGhpbmcubGVuZ3RoOyBzdGFydEluZGV4IDwgbGVuOyArK3N0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGluZ1tzdGFydEluZGV4XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3RoaW5nXTtcbn1cblxuWS5BcnJheSA9IFlBcnJheTtcblxuLyoqXG5EZWR1cGVzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHJldHVybmluZyBhbiBhcnJheSB0aGF0J3MgZ3VhcmFudGVlZCB0byBjb250YWluXG5vbmx5IG9uZSBjb3B5IG9mIGEgZ2l2ZW4gc3RyaW5nLlxuXG5UaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYEFycmF5LnVuaXF1ZSgpYCBpbiB0aGF0IGl0J3Mgb3B0aW1pemVkIGZvciB1c2Ugb25seVxud2l0aCBhcnJheXMgY29uc2lzdGluZyBlbnRpcmVseSBvZiBzdHJpbmdzIG9yIGVudGlyZWx5IG9mIG51bWJlcnMsIHdoZXJlYXNcbmB1bmlxdWVgIG1heSBiZSB1c2VkIHdpdGggb3RoZXIgdmFsdWUgdHlwZXMgKGJ1dCBpcyBzbG93ZXIpLlxuXG5Vc2luZyBgZGVkdXBlKClgIHdpdGggdmFsdWVzIG90aGVyIHRoYW4gc3RyaW5ncyBvciBudW1iZXJzLCBvciB3aXRoIGFycmF5c1xuY29udGFpbmluZyBhIG1peCBvZiBzdHJpbmdzIGFuZCBudW1iZXJzLCBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG5cbkBtZXRob2QgZGVkdXBlXG5AcGFyYW0ge1N0cmluZ1tdfE51bWJlcltdfSBhcnJheSBBcnJheSBvZiBzdHJpbmdzIG9yIG51bWJlcnMgdG8gZGVkdXBlLlxuQHJldHVybiB7QXJyYXl9IENvcHkgb2YgX2FycmF5XyBjb250YWluaW5nIG5vIGR1cGxpY2F0ZSB2YWx1ZXMuXG5Ac3RhdGljXG5Ac2luY2UgMy40LjBcbioqL1xuWUFycmF5LmRlZHVwZSA9IExhbmcuX2lzTmF0aXZlKE9iamVjdC5jcmVhdGUpID8gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIGhhc2ggICAgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICByZXN1bHRzID0gW10sXG4gICAgICAgIGksIGl0ZW0sIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGl0ZW0gPSBhcnJheVtpXTtcblxuICAgICAgICBpZiAoIWhhc2hbaXRlbV0pIHtcbiAgICAgICAgICAgIGhhc2hbaXRlbV0gPSAxO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59IDogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIGhhc2ggICAgPSB7fSxcbiAgICAgICAgcmVzdWx0cyA9IFtdLFxuICAgICAgICBpLCBpdGVtLCBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpdGVtID0gYXJyYXlbaV07XG5cbiAgICAgICAgaWYgKCFoYXNPd24uY2FsbChoYXNoLCBpdGVtKSkge1xuICAgICAgICAgICAgaGFzaFtpdGVtXSA9IDE7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuRXhlY3V0ZXMgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIG9uIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuIFRoaXMgbWV0aG9kIHdyYXBzXG50aGUgbmF0aXZlIEVTNSBgQXJyYXkuZm9yRWFjaCgpYCBtZXRob2QgaWYgYXZhaWxhYmxlLlxuXG5AbWV0aG9kIGVhY2hcbkBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUuXG5AcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuIFRoZSBmdW5jdGlvblxuICB3aWxsIHJlY2VpdmUgdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gICAgQHBhcmFtIHtBbnl9IGZuLml0ZW0gQ3VycmVudCBhcnJheSBpdGVtLlxuICAgIEBwYXJhbSB7TnVtYmVyfSBmbi5pbmRleCBDdXJyZW50IGFycmF5IGluZGV4LlxuICAgIEBwYXJhbSB7QXJyYXl9IGZuLmFycmF5IEFycmF5IGJlaW5nIGl0ZXJhdGVkLlxuQHBhcmFtIHtPYmplY3R9IFt0aGlzT2JqXSBgdGhpc2Agb2JqZWN0IHRvIHVzZSB3aGVuIGNhbGxpbmcgX2ZuXy5cbkByZXR1cm4ge1lVSX0gVGhlIFlVSSBpbnN0YW5jZS5cbkBzdGF0aWNcbioqL1xuWUFycmF5LmVhY2ggPSBZQXJyYXkuZm9yRWFjaCA9IExhbmcuX2lzTmF0aXZlKE5hdGl2ZS5mb3JFYWNoKSA/IGZ1bmN0aW9uIChhcnJheSwgZm4sIHRoaXNPYmopIHtcbiAgICBOYXRpdmUuZm9yRWFjaC5jYWxsKGFycmF5IHx8IFtdLCBmbiwgdGhpc09iaiB8fCBZKTtcbiAgICByZXR1cm4gWTtcbn0gOiBmdW5jdGlvbiAoYXJyYXksIGZuLCB0aGlzT2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IChhcnJheSAmJiBhcnJheS5sZW5ndGgpIHx8IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoaSBpbiBhcnJheSkge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzT2JqIHx8IFksIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gWTtcbn07XG5cbi8qKlxuQWxpYXMgZm9yIGBlYWNoKClgLlxuXG5AbWV0aG9kIGZvckVhY2hcbkBzdGF0aWNcbioqL1xuXG4vKipcblJldHVybnMgYW4gb2JqZWN0IHVzaW5nIHRoZSBmaXJzdCBhcnJheSBhcyBrZXlzIGFuZCB0aGUgc2Vjb25kIGFzIHZhbHVlcy4gSWZcbnRoZSBzZWNvbmQgYXJyYXkgaXMgbm90IHByb3ZpZGVkLCBvciBpZiBpdCBkb2Vzbid0IGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mXG52YWx1ZXMgYXMgdGhlIGZpcnN0IGFycmF5LCB0aGVuIGB0cnVlYCB3aWxsIGJlIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIG1pc3NpbmdcbnZhbHVlcy5cblxuQGV4YW1wbGVcblxuICAgIFkuQXJyYXkuaGFzaChbJ2EnLCAnYicsICdjJ10sIFsnZm9vJywgJ2JhciddKTtcbiAgICAvLyA9PiB7YTogJ2ZvbycsIGI6ICdiYXInLCBjOiB0cnVlfVxuXG5AbWV0aG9kIGhhc2hcbkBwYXJhbSB7U3RyaW5nW119IGtleXMgQXJyYXkgb2Ygc3RyaW5ncyB0byB1c2UgYXMga2V5cy5cbkBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIEFycmF5IHRvIHVzZSBhcyB2YWx1ZXMuXG5AcmV0dXJuIHtPYmplY3R9IEhhc2ggdXNpbmcgdGhlIGZpcnN0IGFycmF5IGFzIGtleXMgYW5kIHRoZSBzZWNvbmQgYXMgdmFsdWVzLlxuQHN0YXRpY1xuKiovXG5ZQXJyYXkuaGFzaCA9IGZ1bmN0aW9uIChrZXlzLCB2YWx1ZXMpIHtcbiAgICB2YXIgaGFzaCA9IHt9LFxuICAgICAgICB2bGVuID0gKHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKSB8fCAwLFxuICAgICAgICBpLCBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmIChpIGluIGtleXMpIHtcbiAgICAgICAgICAgIGhhc2hba2V5c1tpXV0gPSB2bGVuID4gaSAmJiBpIGluIHZhbHVlcyA/IHZhbHVlc1tpXSA6IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbn07XG5cbi8qKlxuUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQncyBlcXVhbCAodXNpbmcgYSBzdHJpY3RcbmVxdWFsaXR5IGNoZWNrKSB0byB0aGUgc3BlY2lmaWVkIF92YWx1ZV8sIG9yIGAtMWAgaWYgdGhlIHZhbHVlIGlzbid0IGZvdW5kLlxuXG5UaGlzIG1ldGhvZCB3cmFwcyB0aGUgbmF0aXZlIEVTNSBgQXJyYXkuaW5kZXhPZigpYCBtZXRob2QgaWYgYXZhaWxhYmxlLlxuXG5AbWV0aG9kIGluZGV4T2ZcbkBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIHNlYXJjaC5cbkBwYXJhbSB7QW55fSB2YWx1ZSBWYWx1ZSB0byBzZWFyY2ggZm9yLlxuQHBhcmFtIHtOdW1iZXJ9IFtmcm9tPTBdIFRoZSBpbmRleCBhdCB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLlxuQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiB0aGUgaXRlbSBzdHJpY3RseSBlcXVhbCB0byBfdmFsdWVfLCBvciBgLTFgIGlmIG5vdFxuICAgIGZvdW5kLlxuQHN0YXRpY1xuKiovXG5ZQXJyYXkuaW5kZXhPZiA9IExhbmcuX2lzTmF0aXZlKE5hdGl2ZS5pbmRleE9mKSA/IGZ1bmN0aW9uIChhcnJheSwgdmFsdWUsIGZyb20pIHtcbiAgICByZXR1cm4gTmF0aXZlLmluZGV4T2YuY2FsbChhcnJheSwgdmFsdWUsIGZyb20pO1xufSA6IGZ1bmN0aW9uIChhcnJheSwgdmFsdWUsIGZyb20pIHtcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgZnJvbSA9ICtmcm9tIHx8IDA7XG4gICAgZnJvbSA9IChmcm9tID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKGZyb20pKTtcblxuICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICBmcm9tICs9IGxlbjtcblxuICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICg7IGZyb20gPCBsZW47ICsrZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSBpbiBhcnJheSAmJiBhcnJheVtmcm9tXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG5OdW1lcmljIHNvcnQgY29udmVuaWVuY2UgZnVuY3Rpb24uXG5cblRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5zb3J0KClgIGZ1bmN0aW9uIGNvbnZlcnRzIHZhbHVlcyB0byBzdHJpbmdzIGFuZFxuc29ydHMgdGhlbSBpbiBsZXhpY29ncmFwaGljIG9yZGVyLCB3aGljaCBpcyB1bnN1aXRhYmxlIGZvciBzb3J0aW5nIG51bWVyaWNcbnZhbHVlcy4gUHJvdmlkZSBgQXJyYXkubnVtZXJpY1NvcnRgIGFzIGEgY3VzdG9tIHNvcnQgZnVuY3Rpb24gd2hlbiB5b3Ugd2FudFxudG8gc29ydCB2YWx1ZXMgaW4gbnVtZXJpYyBvcmRlci5cblxuQGV4YW1wbGVcblxuICAgIFs0MiwgMjMsIDgsIDE2LCA0LCAxNV0uc29ydChZLkFycmF5Lm51bWVyaWNTb3J0KTtcbiAgICAvLyA9PiBbNCwgOCwgMTUsIDE2LCAyMywgNDJdXG5cbkBtZXRob2QgbnVtZXJpY1NvcnRcbkBwYXJhbSB7TnVtYmVyfSBhIEZpcnN0IHZhbHVlIHRvIGNvbXBhcmUuXG5AcGFyYW0ge051bWJlcn0gYiBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbkByZXR1cm4ge051bWJlcn0gRGlmZmVyZW5jZSBiZXR3ZWVuIF9hXyBhbmQgX2JfLlxuQHN0YXRpY1xuKiovXG5ZQXJyYXkubnVtZXJpY1NvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbn07XG5cbi8qKlxuRXhlY3V0ZXMgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIG9uIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuIFJldHVybmluZyBhIHRydXRoeVxudmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24gd2lsbCBzdG9wIHRoZSBwcm9jZXNzaW5nIG9mIHJlbWFpbmluZyBpdGVtcy5cblxuQG1ldGhvZCBzb21lXG5AcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBpdGVyYXRlIG92ZXIuXG5AcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggaXRlbS4gVGhlIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZVxuICB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czpcbiAgICBAcGFyYW0ge0FueX0gZm4udmFsdWUgQ3VycmVudCBhcnJheSBpdGVtLlxuICAgIEBwYXJhbSB7TnVtYmVyfSBmbi5pbmRleCBDdXJyZW50IGFycmF5IGluZGV4LlxuICAgIEBwYXJhbSB7QXJyYXl9IGZuLmFycmF5IEFycmF5IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG5AcGFyYW0ge09iamVjdH0gW3RoaXNPYmpdIGB0aGlzYCBvYmplY3QgdG8gdXNlIHdoZW4gY2FsbGluZyBfZm5fLlxuQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIG9uIGFueSBvZiB0aGVcbiAgaXRlbXMgaW4gdGhlIGFycmF5OyBgZmFsc2VgIG90aGVyd2lzZS5cbkBzdGF0aWNcbioqL1xuWUFycmF5LnNvbWUgPSBMYW5nLl9pc05hdGl2ZShOYXRpdmUuc29tZSkgPyBmdW5jdGlvbiAoYXJyYXksIGZuLCB0aGlzT2JqKSB7XG4gICAgcmV0dXJuIE5hdGl2ZS5zb21lLmNhbGwoYXJyYXksIGZuLCB0aGlzT2JqKTtcbn0gOiBmdW5jdGlvbiAoYXJyYXksIGZuLCB0aGlzT2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmIChpIGluIGFycmF5ICYmIGZuLmNhbGwodGhpc09iaiwgYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbkV2YWx1YXRlcyBfb2JqXyB0byBkZXRlcm1pbmUgaWYgaXQncyBhbiBhcnJheSwgYW4gYXJyYXktbGlrZSBjb2xsZWN0aW9uLCBvclxuc29tZXRoaW5nIGVsc2UuIFRoaXMgaXMgdXNlZnVsIHdoZW4gd29ya2luZyB3aXRoIHRoZSBmdW5jdGlvbiBgYXJndW1lbnRzYFxuY29sbGVjdGlvbiBhbmQgYEhUTUxFbGVtZW50YCBjb2xsZWN0aW9ucy5cblxuTm90ZTogVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IGNvbnNpZGVyIGVsZW1lbnRzIHRoYXQgYXJlIGFsc29cbmNvbGxlY3Rpb25zLCBzdWNoIGFzIGA8Zm9ybT5gIGFuZCBgPHNlbGVjdD5gLCB0byBiZSBhcnJheS1saWtlLlxuXG5AbWV0aG9kIHRlc3RcbkBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRvIHRlc3QuXG5AcmV0dXJuIHtOdW1iZXJ9IEEgbnVtYmVyIGluZGljYXRpbmcgdGhlIHJlc3VsdHMgb2YgdGhlIHRlc3Q6XG5cbiAgKiAwOiBOZWl0aGVyIGFuIGFycmF5IG5vciBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24uXG4gICogMTogUmVhbCBhcnJheS5cbiAgKiAyOiBBcnJheS1saWtlIGNvbGxlY3Rpb24uXG5cbkBzdGF0aWNcbioqL1xuWUFycmF5LnRlc3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG5cbiAgICBpZiAoTGFuZy5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmVzdWx0ID0gMTtcbiAgICB9IGVsc2UgaWYgKExhbmcuaXNPYmplY3Qob2JqKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gaW5kZXhlZCwgYnV0IG5vIHRhZ05hbWUgKGVsZW1lbnQpIG9yIHNjcm9sbFRvL2RvY3VtZW50ICh3aW5kb3cuIEZyb20gRE9NLmlzV2luZG93IHRlc3Qgd2hpY2ggd2UgY2FuJ3QgdXNlIGhlcmUpLFxuICAgICAgICAgICAgLy8gb3IgZnVuY3Rpb25zIHdpdGhvdXQgYXBwbHkvY2FsbCAoU2FmYXJpXG4gICAgICAgICAgICAvLyBIVE1MRWxlbWVudENvbGxlY3Rpb24gYnVnKS5cbiAgICAgICAgICAgIGlmICgnbGVuZ3RoJyBpbiBvYmogJiYgIW9iai50YWdOYW1lICYmICEob2JqLnNjcm9sbFRvICYmIG9iai5kb2N1bWVudCkgJiYgIW9iai5hcHBseSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBUaGUgWVVJIG1vZHVsZSBjb250YWlucyB0aGUgY29tcG9uZW50cyByZXF1aXJlZCBmb3IgYnVpbGRpbmcgdGhlIFlVSVxuICogc2VlZCBmaWxlLiAgVGhpcyBpbmNsdWRlcyB0aGUgc2NyaXB0IGxvYWRpbmcgbWVjaGFuaXNtLCBhIHNpbXBsZSBxdWV1ZSxcbiAqIGFuZCB0aGUgY29yZSB1dGlsaXRpZXMgZm9yIHRoZSBsaWJyYXJ5LlxuICogQG1vZHVsZSB5dWlcbiAqIEBzdWJtb2R1bGUgeXVpLWJhc2VcbiAqL1xuXG4vKipcbiAqIEEgc2ltcGxlIEZJRk8gcXVldWUuICBJdGVtcyBhcmUgYWRkZWQgdG8gdGhlIFF1ZXVlIHdpdGggYWRkKDEuLm4gaXRlbXMpIGFuZFxuICogcmVtb3ZlZCB1c2luZyBuZXh0KCkuXG4gKlxuICogQGNsYXNzIFF1ZXVlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TUlYRUR9IGl0ZW0qIDAuLm4gaXRlbXMgdG8gc2VlZCB0aGUgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIFF1ZXVlKCkge1xuICAgIHRoaXMuX2luaXQoKTtcbiAgICB0aGlzLmFkZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5RdWV1ZS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2luaXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbGxlY3Rpb24gb2YgZW5xdWV1ZWQgaXRlbXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9xXG4gICAgICAgICAqIEB0eXBlIEFycmF5XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3EgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IGl0ZW0gaW4gdGhlIHF1ZXVlLiBGSUZPIHN1cHBvcnRcbiAgICAgKlxuICAgICAqIEBtZXRob2QgbmV4dFxuICAgICAqIEByZXR1cm4ge01JWEVEfSB0aGUgbmV4dCBpdGVtIGluIHRoZSBxdWV1ZS5cbiAgICAgKi9cbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Euc2hpZnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYXN0IGluIHRoZSBxdWV1ZS4gTElGTyBzdXBwb3J0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBsYXN0XG4gICAgICogQHJldHVybiB7TUlYRUR9IHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHF1ZXVlLlxuICAgICAqL1xuICAgIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcS5wb3AoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIDAuLm4gaXRlbXMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAqIEBwYXJhbSB7TUlYRUR9IGl0ZW0qIDAuLm4gaXRlbXMuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSB0aGlzIHF1ZXVlLlxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3EucHVzaC5hcHBseSh0aGlzLl9xLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG51bWJlciBvZiBxdWV1ZWQgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNpemVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzaXplLlxuICAgICAqL1xuICAgIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcS5sZW5ndGg7XG4gICAgfVxufTtcblxuWS5RdWV1ZSA9IFF1ZXVlO1xuXG5ZVUkuRW52Ll9sb2FkZXJRdWV1ZSA9IFlVSS5FbnYuX2xvYWRlclF1ZXVlIHx8IG5ldyBRdWV1ZSgpO1xuXG4vKipcblRoZSBZVUkgbW9kdWxlIGNvbnRhaW5zIHRoZSBjb21wb25lbnRzIHJlcXVpcmVkIGZvciBidWlsZGluZyB0aGUgWVVJIHNlZWQgZmlsZS5cblRoaXMgaW5jbHVkZXMgdGhlIHNjcmlwdCBsb2FkaW5nIG1lY2hhbmlzbSwgYSBzaW1wbGUgcXVldWUsIGFuZCB0aGUgY29yZVxudXRpbGl0aWVzIGZvciB0aGUgbGlicmFyeS5cblxuQG1vZHVsZSB5dWlcbkBzdWJtb2R1bGUgeXVpLWJhc2VcbioqL1xuXG52YXIgQ0FDSEVEX0RFTElNSVRFUiA9ICdfXycsXG5cbiAgICBoYXNPd24gICA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgaXNPYmplY3QgPSBZLkxhbmcuaXNPYmplY3Q7XG5cbi8qKlxuUmV0dXJucyBhIHdyYXBwZXIgZm9yIGEgZnVuY3Rpb24gd2hpY2ggY2FjaGVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhhdCBmdW5jdGlvbixcbmtleWVkIG9mZiBvZiB0aGUgY29tYmluZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWRcbndoZW4gdGhlIHdyYXBwZXIgaXMgY2FsbGVkLlxuXG5DYWxsaW5nIHRoaXMgZnVuY3Rpb24gYWdhaW4gd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgd2lsbCByZXR1cm4gdGhlIGNhY2hlZCB2YWx1ZVxucmF0aGVyIHRoYW4gZXhlY3V0aW5nIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuXG5Ob3RlIHRoYXQgc2luY2UgdGhlIGNhY2hlIGlzIGtleWVkIG9mZiBvZiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFyZ3VtZW50c1xucGFzc2VkIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLCBhcmd1bWVudHMgdGhhdCBhcmVuJ3Qgc3RyaW5ncyBhbmQgZG9uJ3QgcHJvdmlkZVxuYSBtZWFuaW5nZnVsIGB0b1N0cmluZygpYCBtZXRob2QgbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNhY2hpbmcgYmVoYXZpb3IuIEZvclxuZXhhbXBsZSwgdGhlIG9iamVjdHMgYHt9YCBhbmQgYHtmb286ICdiYXInfWAgd291bGQgYm90aCBiZSBjb252ZXJ0ZWQgdG8gdGhlXG5zdHJpbmcgYFtvYmplY3QgT2JqZWN0XWAgd2hlbiB1c2VkIGFzIGEgY2FjaGUga2V5LlxuXG5AbWV0aG9kIGNhY2hlZFxuQHBhcmFtIHtGdW5jdGlvbn0gc291cmNlIFRoZSBmdW5jdGlvbiB0byBtZW1vaXplLlxuQHBhcmFtIHtPYmplY3R9IFtjYWNoZT17fV0gT2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIGNhY2hlZCB2YWx1ZXMuIFlvdSBtYXkgc2VlZFxuICB0aGlzIG9iamVjdCB3aXRoIHByZS1leGlzdGluZyBjYWNoZWQgdmFsdWVzIGlmIGRlc2lyZWQuXG5AcGFyYW0ge2FueX0gW3JlZmV0Y2hdIElmIHN1cHBsaWVkLCB0aGlzIHZhbHVlIGlzIGNvbXBhcmVkIHdpdGggdGhlIGNhY2hlZCB2YWx1ZVxuICB1c2luZyBhIGA9PWAgY29tcGFyaXNvbi4gSWYgdGhlIHZhbHVlcyBhcmUgZXF1YWwsIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIGlzXG4gIGV4ZWN1dGVkIGFnYWluIGV2ZW4gdGhvdWdoIGEgY2FjaGVkIHZhbHVlIGV4aXN0cy5cbkByZXR1cm4ge0Z1bmN0aW9ufSBXcmFwcGVkIGZ1bmN0aW9uLlxuQGZvciBZVUlcbioqL1xuWS5jYWNoZWQgPSBmdW5jdGlvbiAoc291cmNlLCBjYWNoZSwgcmVmZXRjaCkge1xuICAgIC8qanNoaW50IGV4cHI6IHRydWUqL1xuICAgIGNhY2hlIHx8IChjYWNoZSA9IHt9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/XG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsIENBQ0hFRF9ERUxJTUlURVIpIDpcbiAgICAgICAgICAgICAgICBTdHJpbmcoYXJnKTtcblxuICAgICAgICAvKmpzaGludCBlcWVxZXE6IGZhbHNlKi9cbiAgICAgICAgaWYgKCEoa2V5IGluIGNhY2hlKSB8fCAocmVmZXRjaCAmJiBjYWNoZVtrZXldID09IHJlZmV0Y2gpKSB7XG4gICAgICAgICAgICBjYWNoZVtrZXldID0gc291cmNlLmFwcGx5KHNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgIH07XG59O1xuXG4vKipcblJldHVybnMgdGhlIGBsb2NhdGlvbmAgb2JqZWN0IGZyb20gdGhlIHdpbmRvdy9mcmFtZSBpbiB3aGljaCB0aGlzIFlVSSBpbnN0YW5jZVxub3BlcmF0ZXMsIG9yIGB1bmRlZmluZWRgIHdoZW4gZXhlY3V0aW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcbihlLmcuIE5vZGUuanMpLlxuXG5JdCBpcyBfbm90XyByZWNvbW1lbmRlZCB0byBob2xkIHJlZmVyZW5jZXMgdG8gdGhlIGB3aW5kb3cubG9jYXRpb25gIG9iamVjdFxub3V0c2lkZSBvZiB0aGUgc2NvcGUgb2YgYSBmdW5jdGlvbiBpbiB3aGljaCBpdHMgcHJvcGVydGllcyBhcmUgYmVpbmcgYWNjZXNzZWQgb3Jcbml0cyBtZXRob2RzIGFyZSBiZWluZyBjYWxsZWQuIFRoaXMgaXMgYmVjYXVzZSBvZiBhIG5hc3R5IGJ1Zy9pc3N1ZSB0aGF0IGV4aXN0c1xuaW4gYm90aCBTYWZhcmkgYW5kIE1vYmlsZVNhZmFyaSBicm93c2VyczpcbltXZWJLaXQgQnVnIDM0Njc5XShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzQ2NzkpLlxuXG5AbWV0aG9kIGdldExvY2F0aW9uXG5AcmV0dXJuIHtsb2NhdGlvbn0gVGhlIGBsb2NhdGlvbmAgb2JqZWN0IGZyb20gdGhlIHdpbmRvdy9mcmFtZSBpbiB3aGljaCB0aGlzIFlVSVxuICAgIGluc3RhbmNlIG9wZXJhdGVzLlxuQHNpbmNlIDMuNS4wXG4qKi9cblkuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSXQgaXMgc2FmZXIgdG8gbG9vayB0aGlzIHVwIGV2ZXJ5IHRpbWUgYmVjYXVzZSB5dWktYmFzZSBpcyBhdHRhY2hlZCB0byBhXG4gICAgLy8gWVVJIGluc3RhbmNlIGJlZm9yZSBhIHVzZXIncyBjb25maWcgaXMgYXBwbGllZDsgaS5lLiBgWS5jb25maWcud2luYCBkb2VzXG4gICAgLy8gbm90IHBvaW50IHRoZSBjb3JyZWN0IHdpbmRvdyBvYmplY3Qgd2hlbiB0aGlzIGZpbGUgaXMgbG9hZGVkLlxuICAgIHZhciB3aW4gPSBZLmNvbmZpZy53aW47XG5cbiAgICAvLyBJdCBpcyBub3Qgc2FmZSB0byBob2xkIGEgcmVmZXJlbmNlIHRvIHRoZSBgbG9jYXRpb25gIG9iamVjdCBvdXRzaWRlIHRoZVxuICAgIC8vIHNjb3BlIGluIHdoaWNoIGl0IGlzIGJlaW5nIHVzZWQuIFRoZSBXZWJLaXQgZW5naW5lIHVzZWQgaW4gU2FmYXJpIGFuZFxuICAgIC8vIE1vYmlsZVNhZmFyaSB3aWxsIFwiZGlzY29ubmVjdFwiIHRoZSBgbG9jYXRpb25gIG9iamVjdCBmcm9tIHRoZSBgd2luZG93YFxuICAgIC8vIHdoZW4gYSBwYWdlIGlzIHJlc3RvcmVkIGZyb20gYmFjay9mb3J3YXJkIGhpc3RvcnkgY2FjaGUuXG4gICAgcmV0dXJuIHdpbiAmJiB3aW4ubG9jYXRpb247XG59O1xuXG4vKipcblJldHVybnMgYSBuZXcgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCB0aGUgc3VwcGxpZWRcbm9iamVjdHMuIFRoZSBwcm9wZXJ0aWVzIGZyb20gbGF0ZXIgb2JqZWN0cyB3aWxsIG92ZXJ3cml0ZSB0aG9zZSBpbiBlYXJsaWVyXG5vYmplY3RzLlxuXG5QYXNzaW5nIGluIGEgc2luZ2xlIG9iamVjdCB3aWxsIGNyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiBpdC4gRm9yIGEgZGVlcCBjb3B5LFxudXNlIGBjbG9uZSgpYC5cblxuQG1ldGhvZCBtZXJnZVxuQHBhcmFtIHtPYmplY3R9IG9iamVjdHMqIE9uZSBvciBtb3JlIG9iamVjdHMgdG8gbWVyZ2UuXG5AcmV0dXJuIHtPYmplY3R9IEEgbmV3IG1lcmdlZCBvYmplY3QuXG4qKi9cblkubWVyZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgICAgICA9IDAsXG4gICAgICAgIGxlbiAgICA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICBrZXksXG4gICAgICAgIG9iajtcblxuICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgb2JqID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG5NaXhlcyBfc3VwcGxpZXJfJ3MgcHJvcGVydGllcyBpbnRvIF9yZWNlaXZlcl8uXG5cblByb3BlcnRpZXMgb24gX3JlY2VpdmVyXyBvciBfcmVjZWl2ZXJfJ3MgcHJvdG90eXBlIHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIG9yXG5zaGFkb3dlZCB1bmxlc3MgdGhlIF9vdmVyd3JpdGVfIHBhcmFtZXRlciBpcyBgdHJ1ZWAsIGFuZCB3aWxsIG5vdCBiZSBtZXJnZWRcbnVubGVzcyB0aGUgX21lcmdlXyBwYXJhbWV0ZXIgaXMgYHRydWVgLlxuXG5JbiB0aGUgZGVmYXVsdCBtb2RlICgwKSwgb25seSBwcm9wZXJ0aWVzIHRoZSBzdXBwbGllciBvd25zIGFyZSBjb3BpZWQgKHByb3RvdHlwZVxucHJvcGVydGllcyBhcmUgbm90IGNvcGllZCkuIFRoZSBmb2xsb3dpbmcgY29weWluZyBtb2RlcyBhcmUgYXZhaWxhYmxlOlxuXG4gICogYDBgOiBfRGVmYXVsdF8uIE9iamVjdCB0byBvYmplY3QuXG4gICogYDFgOiBQcm90b3R5cGUgdG8gcHJvdG90eXBlLlxuICAqIGAyYDogUHJvdG90eXBlIHRvIHByb3RvdHlwZSBhbmQgb2JqZWN0IHRvIG9iamVjdC5cbiAgKiBgM2A6IFByb3RvdHlwZSB0byBvYmplY3QuXG4gICogYDRgOiBPYmplY3QgdG8gcHJvdG90eXBlLlxuXG5AbWV0aG9kIG1peFxuQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IHJlY2VpdmVyIFRoZSBvYmplY3Qgb3IgZnVuY3Rpb24gdG8gcmVjZWl2ZSB0aGUgbWl4ZWRcbiAgcHJvcGVydGllcy5cbkBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBzdXBwbGllciBUaGUgb2JqZWN0IG9yIGZ1bmN0aW9uIHN1cHBseWluZyB0aGVcbiAgcHJvcGVydGllcyB0byBiZSBtaXhlZC5cbkBwYXJhbSB7Qm9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV0gSWYgYHRydWVgLCBwcm9wZXJ0aWVzIHRoYXQgYWxyZWFkeSBleGlzdFxuICBvbiB0aGUgcmVjZWl2ZXIgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHByb3BlcnRpZXMgZnJvbSB0aGUgc3VwcGxpZXIuXG5AcGFyYW0ge1N0cmluZ1tdfSBbd2hpdGVsaXN0XSBBbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LiBJZlxuICBzcGVjaWZpZWQsIG9ubHkgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQsIGFuZCBhbGwgb3RoZXJzXG4gIHdpbGwgYmUgaWdub3JlZC5cbkBwYXJhbSB7TnVtYmVyfSBbbW9kZT0wXSBNaXggbW9kZSB0byB1c2UuIFNlZSBhYm92ZSBmb3IgYXZhaWxhYmxlIG1vZGVzLlxuQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdIElmIGB0cnVlYCwgb2JqZWN0cyBhbmQgYXJyYXlzIHRoYXQgYWxyZWFkeVxuICBleGlzdCBvbiB0aGUgcmVjZWl2ZXIgd2lsbCBoYXZlIHRoZSBjb3JyZXNwb25kaW5nIG9iamVjdC9hcnJheSBmcm9tIHRoZVxuICBzdXBwbGllciBtZXJnZWQgaW50byB0aGVtLCByYXRoZXIgdGhhbiBiZWluZyBza2lwcGVkIG9yIG92ZXJ3cml0dGVuLiBXaGVuXG4gIGJvdGggX292ZXJ3cml0ZV8gYW5kIF9tZXJnZV8gYXJlIGB0cnVlYCwgX21lcmdlXyB0YWtlcyBwcmVjZWRlbmNlLlxuQHJldHVybiB7RnVuY3Rpb258T2JqZWN0fFlVSX0gVGhlIHJlY2VpdmVyLCBvciB0aGUgWVVJIGluc3RhbmNlIGlmIHRoZVxuICBzcGVjaWZpZWQgcmVjZWl2ZXIgaXMgZmFsc3kuXG4qKi9cblkubWl4ID0gZnVuY3Rpb24ocmVjZWl2ZXIsIHN1cHBsaWVyLCBvdmVyd3JpdGUsIHdoaXRlbGlzdCwgbW9kZSwgbWVyZ2UpIHtcbiAgICB2YXIgYWx3YXlzT3ZlcndyaXRlLCBleGlzdHMsIGZyb20sIGksIGtleSwgbGVuLCB0bztcblxuICAgIC8vIElmIG5vIHN1cHBsaWVyIGlzIGdpdmVuLCB3ZSByZXR1cm4gdGhlIHJlY2VpdmVyLiBJZiBubyByZWNlaXZlciBpcyBnaXZlbixcbiAgICAvLyB3ZSByZXR1cm4gWS4gUmV0dXJuaW5nIFkgZG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgdG8gbWUsIGJ1dCBpdCdzXG4gICAgLy8gZ3JhbmRmYXRoZXJlZCBpbiBmb3IgYmFja2NvbXBhdCByZWFzb25zLlxuICAgIGlmICghcmVjZWl2ZXIgfHwgIXN1cHBsaWVyKSB7XG4gICAgICAgIHJldHVybiByZWNlaXZlciB8fCBZO1xuICAgIH1cblxuICAgIGlmIChtb2RlKSB7XG4gICAgICAgIC8vIEluIG1vZGUgMiAocHJvdG90eXBlIHRvIHByb3RvdHlwZSBhbmQgb2JqZWN0IHRvIG9iamVjdCksIHdlIHJlY3Vyc2VcbiAgICAgICAgLy8gb25jZSB0byBkbyB0aGUgcHJvdG8gdG8gcHJvdG8gbWl4LiBUaGUgb2JqZWN0IHRvIG9iamVjdCBtaXggd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGxhdGVyIG9uLlxuICAgICAgICBpZiAobW9kZSA9PT0gMikge1xuICAgICAgICAgICAgWS5taXgocmVjZWl2ZXIucHJvdG90eXBlLCBzdXBwbGllci5wcm90b3R5cGUsIG92ZXJ3cml0ZSxcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVsaXN0LCAwLCBtZXJnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXBlbmRpbmcgb24gd2hpY2ggbW9kZSBpcyBzcGVjaWZpZWQsIHdlIG1heSBiZSBjb3B5aW5nIGZyb20gb3IgdG9cbiAgICAgICAgLy8gdGhlIHByb3RvdHlwZXMgb2YgdGhlIHN1cHBsaWVyIGFuZCByZWNlaXZlci5cbiAgICAgICAgZnJvbSA9IG1vZGUgPT09IDEgfHwgbW9kZSA9PT0gMyA/IHN1cHBsaWVyLnByb3RvdHlwZSA6IHN1cHBsaWVyO1xuICAgICAgICB0byAgID0gbW9kZSA9PT0gMSB8fCBtb2RlID09PSA0ID8gcmVjZWl2ZXIucHJvdG90eXBlIDogcmVjZWl2ZXI7XG5cbiAgICAgICAgLy8gSWYgZWl0aGVyIHRoZSBzdXBwbGllciBvciByZWNlaXZlciBkb2Vzbid0IGFjdHVhbGx5IGhhdmUgYVxuICAgICAgICAvLyBwcm90b3R5cGUgcHJvcGVydHksIHRoZW4gd2UgY291bGQgZW5kIHVwIHdpdGggYW4gdW5kZWZpbmVkIGBmcm9tYFxuICAgICAgICAvLyBvciBgdG9gLiBJZiB0aGF0IGhhcHBlbnMsIHdlIGFib3J0IGFuZCByZXR1cm4gdGhlIHJlY2VpdmVyLlxuICAgICAgICBpZiAoIWZyb20gfHwgIXRvKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZXI7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tID0gc3VwcGxpZXI7XG4gICAgICAgIHRvICAgPSByZWNlaXZlcjtcbiAgICB9XG5cbiAgICAvLyBJZiBgb3ZlcndyaXRlYCBpcyB0cnV0aHkgYW5kIGBtZXJnZWAgaXMgZmFsc3ksIHRoZW4gd2UgY2FuIHNraXAgYVxuICAgIC8vIHByb3BlcnR5IGV4aXN0ZW5jZSBjaGVjayBvbiBlYWNoIGl0ZXJhdGlvbiBhbmQgc2F2ZSBzb21lIHRpbWUuXG4gICAgYWx3YXlzT3ZlcndyaXRlID0gb3ZlcndyaXRlICYmICFtZXJnZTtcblxuICAgIGlmICh3aGl0ZWxpc3QpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gd2hpdGVsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBrZXkgPSB3aGl0ZWxpc3RbaV07XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbGwgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgIGluc3RlYWQgb2YgY2FsbGluZ1xuICAgICAgICAgICAgLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgb2JqZWN0IGl0c2VsZiwgc2luY2UgdGhlIG9iamVjdCdzXG4gICAgICAgICAgICAvLyBgaGFzT3duUHJvcGVydHlgIG1ldGhvZCBtYXkgaGF2ZSBiZWVuIG92ZXJyaWRkZW4gb3IgcmVtb3ZlZC5cbiAgICAgICAgICAgIC8vIEFsc28sIHNvbWUgbmF0aXZlIG9iamVjdHMgZG9uJ3QgaW1wbGVtZW50IGEgYGhhc093blByb3BlcnR5YFxuICAgICAgICAgICAgLy8gbWV0aG9kLlxuICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBga2V5IGluIHRvYCBjaGVjayBoZXJlIGlzIChzYWRseSkgaW50ZW50aW9uYWwgZm9yIGJhY2t3YXJkc1xuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eSByZWFzb25zLiBJdCBwcmV2ZW50cyB1bmRlc2lyZWQgc2hhZG93aW5nIG9mXG4gICAgICAgICAgICAvLyBwcm90b3R5cGUgbWVtYmVycyBvbiBgdG9gLlxuICAgICAgICAgICAgZXhpc3RzID0gYWx3YXlzT3ZlcndyaXRlID8gZmFsc2UgOiBrZXkgaW4gdG87XG5cbiAgICAgICAgICAgIGlmIChtZXJnZSAmJiBleGlzdHMgJiYgaXNPYmplY3QodG9ba2V5XSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgJiYgaXNPYmplY3QoZnJvbVtrZXldLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIG1lcmdlIG1vZGUsIGFuZCB0aGUga2V5IGlzIHByZXNlbnQgb24gYm90aFxuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMsIGFuZCB0aGUgdmFsdWUgb24gYm90aCBvYmplY3RzIGlzIGVpdGhlciBhbiBvYmplY3Qgb3JcbiAgICAgICAgICAgICAgICAvLyBhbiBhcnJheSAoYnV0IG5vdCBhIGZ1bmN0aW9uKSwgdGhlbiB3ZSByZWN1cnNlIHRvIG1lcmdlIHRoZVxuICAgICAgICAgICAgICAgIC8vIGBmcm9tYCB2YWx1ZSBpbnRvIHRoZSBgdG9gIHZhbHVlIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgaXQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBJdCdzIGludGVudGlvbmFsIHRoYXQgdGhlIHdoaXRlbGlzdCBpc24ndCBwYXNzZWQgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlIGNhbGwgaGVyZS4gVGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgdGhhdCBsb3RzIG9mXG4gICAgICAgICAgICAgICAgLy8gY29kZSBzdGlsbCBkZXBlbmRzIG9uLlxuICAgICAgICAgICAgICAgIFkubWl4KHRvW2tleV0sIGZyb21ba2V5XSwgb3ZlcndyaXRlLCBudWxsLCAwLCBtZXJnZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgbm90IGluIG1lcmdlIG1vZGUsIHNvIHdlJ2xsIG9ubHkgY29weSB0aGUgYGZyb21gIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIGB0b2AgdmFsdWUgaWYgd2UncmUgaW4gb3ZlcndyaXRlIG1vZGUgb3IgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBrZXkgZG9lc24ndCBleGlzdCBvbiB0aGUgYHRvYCBvYmplY3QuXG4gICAgICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoa2V5IGluIGZyb20pIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb2RlIGR1cGxpY2F0aW9uIGhlcmUgaXMgZm9yIHJ1bnRpbWUgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgICAgICAgIC8vIENvbWJpbmluZyB3aGl0ZWxpc3QgYW5kIG5vbi13aGl0ZWxpc3Qgb3BlcmF0aW9ucyBpbnRvIGEgc2luZ2xlXG4gICAgICAgICAgICAvLyBsb29wIG9yIGJyZWFraW5nIHRoZSBzaGFyZWQgbG9naWMgb3V0IGludG8gYSBmdW5jdGlvbiBib3RoIHJlc3VsdFxuICAgICAgICAgICAgLy8gaW4gd29yc2UgcGVyZm9ybWFuY2UsIGFuZCBZLm1peCBpcyBjcml0aWNhbCBlbm91Z2ggdGhhdCB0aGUgYnl0ZVxuICAgICAgICAgICAgLy8gdHJhZGVvZmYgaXMgd29ydGggaXQuXG4gICAgICAgICAgICBpZiAoIWhhc093bi5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGBrZXkgaW4gdG9gIGNoZWNrIGhlcmUgaXMgKHNhZGx5KSBpbnRlbnRpb25hbCBmb3IgYmFja3dhcmRzXG4gICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuIEl0IHByZXZlbnRzIHVuZGVzaXJlZCBzaGFkb3dpbmcgb2ZcbiAgICAgICAgICAgIC8vIHByb3RvdHlwZSBtZW1iZXJzIG9uIGB0b2AuXG4gICAgICAgICAgICBleGlzdHMgPSBhbHdheXNPdmVyd3JpdGUgPyBmYWxzZSA6IGtleSBpbiB0bztcblxuICAgICAgICAgICAgaWYgKG1lcmdlICYmIGV4aXN0cyAmJiBpc09iamVjdCh0b1trZXldLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAmJiBpc09iamVjdChmcm9tW2tleV0sIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgWS5taXgodG9ba2V5XSwgZnJvbVtrZXldLCBvdmVyd3JpdGUsIG51bGwsIDAsIG1lcmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcndyaXRlIHx8ICFleGlzdHMpIHtcbiAgICAgICAgICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBJRSBicm93c2VyIHdpdGggdGhlIEpTY3JpcHQgZW51bWVyYXRpb24gYnVnLCBmb3JjZVxuICAgICAgICAvLyBlbnVtZXJhdGlvbiBvZiB0aGUgYnVnZ3kgcHJvcGVydGllcyBieSBtYWtpbmcgYSByZWN1cnNpdmUgY2FsbCB3aXRoXG4gICAgICAgIC8vIHRoZSBidWdneSBwcm9wZXJ0aWVzIGFzIHRoZSB3aGl0ZWxpc3QuXG4gICAgICAgIGlmIChZLk9iamVjdC5faGFzRW51bUJ1Zykge1xuICAgICAgICAgICAgWS5taXgodG8sIGZyb20sIG92ZXJ3cml0ZSwgWS5PYmplY3QuX2ZvcmNlRW51bSwgbW9kZSwgbWVyZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY2VpdmVyO1xufTtcbi8qKlxuICogVGhlIFlVSSBtb2R1bGUgY29udGFpbnMgdGhlIGNvbXBvbmVudHMgcmVxdWlyZWQgZm9yIGJ1aWxkaW5nIHRoZSBZVUlcbiAqIHNlZWQgZmlsZS4gIFRoaXMgaW5jbHVkZXMgdGhlIHNjcmlwdCBsb2FkaW5nIG1lY2hhbmlzbSwgYSBzaW1wbGUgcXVldWUsXG4gKiBhbmQgdGhlIGNvcmUgdXRpbGl0aWVzIGZvciB0aGUgbGlicmFyeS5cbiAqIEBtb2R1bGUgeXVpXG4gKiBAc3VibW9kdWxlIHl1aS1iYXNlXG4gKi9cblxuLyoqXG4gKiBBZGRzIHV0aWxpdGllcyB0byB0aGUgWVVJIGluc3RhbmNlIGZvciB3b3JraW5nIHdpdGggb2JqZWN0cy5cbiAqXG4gKiBAY2xhc3MgT2JqZWN0XG4gKi9cblxudmFyIExhbmcgICA9IFkuTGFuZyxcbiAgICBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuXG4gICAgVU5ERUZJTkVELCAvLyA8LS0gTm90ZSB0aGUgY29tbWEuIFdlJ3JlIHN0aWxsIGRlY2xhcmluZyB2YXJzLlxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgdXNlcyBfb2JqXyBhcyBpdHMgcHJvdG90eXBlLiBUaGlzIG1ldGhvZCB3cmFwcyB0aGVcbiAqIG5hdGl2ZSBFUzUgYE9iamVjdC5jcmVhdGUoKWAgbWV0aG9kIGlmIGF2YWlsYWJsZSwgYnV0IGRvZXNuJ3QgY3VycmVudGx5XG4gKiBwYXNzIHRocm91Z2ggYE9iamVjdC5jcmVhdGUoKWAncyBzZWNvbmQgYXJndW1lbnQgKHByb3BlcnRpZXMpIGluIG9yZGVyIHRvXG4gKiBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGJyb3dzZXJzLlxuICpcbiAqIEBtZXRob2QgKClcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUHJvdG90eXBlIG9iamVjdC5cbiAqIEByZXR1cm4ge09iamVjdH0gTmV3IG9iamVjdCB1c2luZyBfb2JqXyBhcyBpdHMgcHJvdG90eXBlLlxuICogQHN0YXRpY1xuICovXG5PID0gWS5PYmplY3QgPSBMYW5nLl9pc05hdGl2ZShPYmplY3QuY3JlYXRlKSA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgd3JhcCB0aGUgbmF0aXZlIE9iamVjdC5jcmVhdGUgaW5zdGVhZCBvZiBzaW1wbHkgYWxpYXNpbmcgaXRcbiAgICAvLyB0byBlbnN1cmUgY29uc2lzdGVuY3kgd2l0aCBvdXIgZmFsbGJhY2sgc2hpbSwgd2hpY2ggY3VycmVudGx5IGRvZXNuJ3RcbiAgICAvLyBzdXBwb3J0IE9iamVjdC5jcmVhdGUoKSdzIHNlY29uZCBhcmd1bWVudCAocHJvcGVydGllcykuIE9uY2Ugd2UgaGF2ZSBhXG4gICAgLy8gc2FmZSBmYWxsYmFjayBmb3IgdGhlIHByb3BlcnRpZXMgYXJnLCB3ZSBjYW4gc3RvcCB3cmFwcGluZ1xuICAgIC8vIE9iamVjdC5jcmVhdGUoKS5cbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShvYmopO1xufSA6IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV1c2FibGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBPYmplY3QuY3JlYXRlKCkgc2hpbS5cbiAgICBmdW5jdGlvbiBGKCkge31cblxuICAgIC8vIFRoZSBhY3R1YWwgc2hpbS5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcbiAgICAgICAgcmV0dXJuIG5ldyBGKCk7XG4gICAgfTtcbn0oKSksXG5cbi8qKlxuICogUHJvcGVydHkgbmFtZXMgdGhhdCBJRSBkb2Vzbid0IGVudW1lcmF0ZSBpbiBmb3IuLmluIGxvb3BzLCBldmVuIHdoZW4gdGhleVxuICogc2hvdWxkIGJlIGVudW1lcmFibGUuIFdoZW4gYF9oYXNFbnVtQnVnYCBpcyBgdHJ1ZWAsIGl0J3MgbmVjZXNzYXJ5IHRvXG4gKiBtYW51YWxseSBlbnVtZXJhdGUgdGhlc2UgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJvcGVydHkgX2ZvcmNlRW51bVxuICogQHR5cGUgU3RyaW5nW11cbiAqIEBwcm90ZWN0ZWRcbiAqIEBzdGF0aWNcbiAqL1xuZm9yY2VFbnVtID0gTy5fZm9yY2VFbnVtID0gW1xuICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgJ3RvU3RyaW5nJyxcbiAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICd2YWx1ZU9mJ1xuXSxcblxuLyoqXG4gKiBgdHJ1ZWAgaWYgdGhpcyBicm93c2VyIGhhcyB0aGUgSlNjcmlwdCBlbnVtZXJhdGlvbiBidWcgdGhhdCBwcmV2ZW50c1xuICogZW51bWVyYXRpb24gb2YgdGhlIHByb3BlcnRpZXMgbmFtZWQgaW4gdGhlIGBfZm9yY2VFbnVtYCBhcnJheSwgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIFNlZTpcbiAqICAgLSA8aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRUNNQVNjcmlwdF9Eb250RW51bV9hdHRyaWJ1dGUjSlNjcmlwdF9Eb250RW51bV9CdWc+XG4gKiAgIC0gPGh0dHA6Ly93aGF0dGhlaGVhZHNhaWQuY29tLzIwMTAvMTAvYS1zYWZlci1vYmplY3Qta2V5cy1jb21wYXRpYmlsaXR5LWltcGxlbWVudGF0aW9uPlxuICpcbiAqIEBwcm9wZXJ0eSBfaGFzRW51bUJ1Z1xuICogQHR5cGUgQm9vbGVhblxuICogQHByb3RlY3RlZFxuICogQHN0YXRpY1xuICovXG5oYXNFbnVtQnVnID0gTy5faGFzRW51bUJ1ZyA9ICF7dmFsdWVPZjogMH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3ZhbHVlT2YnKSxcblxuLyoqXG4gKiBgdHJ1ZWAgaWYgdGhpcyBicm93c2VyIGluY29ycmVjdGx5IGNvbnNpZGVycyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2ZcbiAqIGZ1bmN0aW9ucyB0byBiZSBlbnVtZXJhYmxlLiBDdXJyZW50bHkga25vd24gdG8gYWZmZWN0IE9wZXJhIDExLjUwIGFuZCBBbmRyb2lkIDIuMy54LlxuICpcbiAqIEBwcm9wZXJ0eSBfaGFzUHJvdG9FbnVtQnVnXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAcHJvdGVjdGVkXG4gKiBAc3RhdGljXG4gKi9cbmhhc1Byb3RvRW51bUJ1ZyA9IE8uX2hhc1Byb3RvRW51bUJ1ZyA9IChmdW5jdGlvbiAoKSB7fSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3Byb3RvdHlwZScpLFxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIF9rZXlfIGV4aXN0cyBvbiBfb2JqXywgYGZhbHNlYCBpZiBfa2V5XyBkb2Vzbid0IGV4aXN0IG9yXG4gKiBleGlzdHMgb25seSBvbiBfb2JqXydzIHByb3RvdHlwZS4gVGhpcyBpcyBlc3NlbnRpYWxseSBhIHNhZmVyIHZlcnNpb24gb2ZcbiAqIGBvYmouaGFzT3duUHJvcGVydHkoKWAuXG4gKlxuICogQG1ldGhvZCBvd25zXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGxvb2sgZm9yLlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIF9rZXlfIGV4aXN0cyBvbiBfb2JqXywgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAc3RhdGljXG4gKi9cbm93bnMgPSBPLm93bnMgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gISFvYmogJiYgaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufTsgLy8gPC0tIEVuZCBvZiB2YXIgZGVjbGFyYXRpb25zLlxuXG4vKipcbiAqIEFsaWFzIGZvciBgb3ducygpYC5cbiAqXG4gKiBAbWV0aG9kIGhhc0tleVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSB0byBsb29rIGZvci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBfa2V5XyBleGlzdHMgb24gX29ial8sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQHN0YXRpY1xuICovXG5PLmhhc0tleSA9IG93bnM7XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBvYmplY3QncyBlbnVtZXJhYmxlIGtleXMuIERvZXMgbm90IGluY2x1ZGVcbiAqIHByb3RvdHlwZSBrZXlzIG9yIG5vbi1lbnVtZXJhYmxlIGtleXMuXG4gKlxuICogTm90ZSB0aGF0IGtleXMgYXJlIHJldHVybmVkIGluIGVudW1lcmF0aW9uIG9yZGVyICh0aGF0IGlzLCBpbiB0aGUgc2FtZSBvcmRlclxuICogdGhhdCB0aGV5IHdvdWxkIGJlIGVudW1lcmF0ZWQgYnkgYSBgZm9yLWluYCBsb29wKSwgd2hpY2ggbWF5IG5vdCBiZSB0aGUgc2FtZVxuICogYXMgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBkZWZpbmVkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGFuIGFsaWFzIGZvciB0aGUgbmF0aXZlIEVTNSBgT2JqZWN0LmtleXMoKWAgbWV0aG9kIGlmXG4gKiBhdmFpbGFibGUgYW5kIG5vbi1idWdneS4gVGhlIE9wZXJhIDExLjUwIGFuZCBBbmRyb2lkIDIuMy54IHZlcnNpb25zIG9mXG4gKiBgT2JqZWN0LmtleXMoKWAgaGF2ZSBhbiBpbmNvbnNpc3RlbmN5IGFzIHRoZXkgY29uc2lkZXIgYHByb3RvdHlwZWAgdG8gYmVcbiAqIGVudW1lcmFibGUsIHNvIGEgbm9uLW5hdGl2ZSBzaGltIGlzIHVzZWQgdG8gcmVjdGlmeSB0aGUgZGlmZmVyZW5jZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICBZLk9iamVjdC5rZXlzKHthOiAnZm9vJywgYjogJ2JhcicsIGM6ICdiYXonfSk7XG4gKiAgICAgLy8gPT4gWydhJywgJ2InLCAnYyddXG4gKlxuICogQG1ldGhvZCBrZXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIEFuIG9iamVjdC5cbiAqIEByZXR1cm4ge1N0cmluZ1tdfSBBcnJheSBvZiBrZXlzLlxuICogQHN0YXRpY1xuICovXG5PLmtleXMgPSBMYW5nLl9pc05hdGl2ZShPYmplY3Qua2V5cykgJiYgIWhhc1Byb3RvRW51bUJ1ZyA/IE9iamVjdC5rZXlzIDogZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghTGFuZy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IFtdLFxuICAgICAgICBpLCBrZXksIGxlbjtcblxuICAgIGlmIChoYXNQcm90b0VudW1CdWcgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvd25zKG9iaiwga2V5KSAmJiBrZXkgIT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvd25zKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc0VudW1CdWcpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZm9yY2VFbnVtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBrZXkgPSBmb3JjZUVudW1baV07XG5cbiAgICAgICAgICAgIGlmIChvd25zKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIHRoZSBvYmplY3QncyBlbnVtZXJhYmxlIGtleXMuXG4gKlxuICogTm90ZSB0aGF0IHZhbHVlcyBhcmUgcmV0dXJuZWQgaW4gZW51bWVyYXRpb24gb3JkZXIgKHRoYXQgaXMsIGluIHRoZSBzYW1lXG4gKiBvcmRlciB0aGF0IHRoZXkgd291bGQgYmUgZW51bWVyYXRlZCBieSBhIGBmb3ItaW5gIGxvb3ApLCB3aGljaCBtYXkgbm90IGJlIHRoZVxuICogc2FtZSBhcyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGRlZmluZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgWS5PYmplY3QudmFsdWVzKHthOiAnZm9vJywgYjogJ2JhcicsIGM6ICdiYXonfSk7XG4gKiAgICAgLy8gPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gKlxuICogQG1ldGhvZCB2YWx1ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogQW4gb2JqZWN0LlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIHZhbHVlcy5cbiAqIEBzdGF0aWNcbiAqL1xuTy52YWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGtleXMgICA9IE8ua2V5cyhvYmopLFxuICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICBsZW4gICAgPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgdmFsdWVzID0gW107XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVudW1lcmFibGUga2V5cyBvd25lZCBieSBhbiBvYmplY3QuXG4gKlxuICogQG1ldGhvZCBzaXplXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIEFuIG9iamVjdC5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIG9iamVjdCdzIHNpemUuXG4gKiBAc3RhdGljXG4gKi9cbk8uc2l6ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gTy5rZXlzKG9iaikubGVuZ3RoO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiAwOyAvLyBMZWdhY3kgYmVoYXZpb3IgZm9yIG5vbi1vYmplY3RzLlxuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBvd25zIGFuIGVudW1lcmFibGUgcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkXG4gKiB2YWx1ZS5cbiAqXG4gKiBAbWV0aG9kIGhhc1ZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIEFuIG9iamVjdC5cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBfb2JqXyBjb250YWlucyBfdmFsdWVfLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBzdGF0aWNcbiAqL1xuTy5oYXNWYWx1ZSA9IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgcmV0dXJuIFkuQXJyYXkuaW5kZXhPZihPLnZhbHVlcyhvYmopLCB2YWx1ZSkgPiAtMTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBmdW5jdGlvbiBvbiBlYWNoIGVudW1lcmFibGUgcHJvcGVydHkgaW4gX29ial8uIFRoZSBmdW5jdGlvblxuICogcmVjZWl2ZXMgdGhlIHZhbHVlLCB0aGUga2V5LCBhbmQgdGhlIG9iamVjdCBpdHNlbGYgYXMgcGFyYW1ldGVycyAoaW4gdGhhdFxuICogb3JkZXIpLlxuICpcbiAqIEJ5IGRlZmF1bHQsIG9ubHkgcHJvcGVydGllcyBvd25lZCBieSBfb2JqXyBhcmUgZW51bWVyYXRlZC4gVG8gaW5jbHVkZVxuICogcHJvdG90eXBlIHByb3BlcnRpZXMsIHNldCB0aGUgX3Byb3RvXyBwYXJhbWV0ZXIgdG8gYHRydWVgLlxuICpcbiAqIEBtZXRob2QgZWFjaFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gZW51bWVyYXRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIGVudW1lcmFibGUgcHJvcGVydHkuXG4gKiAgIEBwYXJhbSB7bWl4ZWR9IGZuLnZhbHVlIFZhbHVlIG9mIHRoZSBjdXJyZW50IHByb3BlcnR5LlxuICogICBAcGFyYW0ge1N0cmluZ30gZm4ua2V5IEtleSBvZiB0aGUgY3VycmVudCBwcm9wZXJ0eS5cbiAqICAgQHBhcmFtIHtPYmplY3R9IGZuLm9iaiBPYmplY3QgYmVpbmcgZW51bWVyYXRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhpc09ial0gYHRoaXNgIG9iamVjdCB0byB1c2Ugd2hlbiBjYWxsaW5nIF9mbl8uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwcm90bz1mYWxzZV0gSW5jbHVkZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqIEByZXR1cm4ge1lVSX0gdGhlIFlVSSBpbnN0YW5jZS5cbiAqIEBjaGFpbmFibGVcbiAqIEBzdGF0aWNcbiAqL1xuTy5lYWNoID0gZnVuY3Rpb24gKG9iaiwgZm4sIHRoaXNPYmosIHByb3RvKSB7XG4gICAgdmFyIGtleTtcblxuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBpZiAocHJvdG8gfHwgb3ducyhvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpc09iaiB8fCBZLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgZnVuY3Rpb24gb24gZWFjaCBlbnVtZXJhYmxlIHByb3BlcnR5IGluIF9vYmpfLCBidXQgaGFsdHMgaWYgdGhlXG4gKiBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIHZhbHVlLCB0aGUga2V5LFxuICogYW5kIHRoZSBvYmplY3QgaXRzZWxmIGFzIHBhcmFtdGVycyAoaW4gdGhhdCBvcmRlcikuXG4gKlxuICogQnkgZGVmYXVsdCwgb25seSBwcm9wZXJ0aWVzIG93bmVkIGJ5IF9vYmpfIGFyZSBlbnVtZXJhdGVkLiBUbyBpbmNsdWRlXG4gKiBwcm90b3R5cGUgcHJvcGVydGllcywgc2V0IHRoZSBfcHJvdG9fIHBhcmFtZXRlciB0byBgdHJ1ZWAuXG4gKlxuICogQG1ldGhvZCBzb21lXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0byBlbnVtZXJhdGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAqICAgQHBhcmFtIHttaXhlZH0gZm4udmFsdWUgVmFsdWUgb2YgdGhlIGN1cnJlbnQgcHJvcGVydHkuXG4gKiAgIEBwYXJhbSB7U3RyaW5nfSBmbi5rZXkgS2V5IG9mIHRoZSBjdXJyZW50IHByb3BlcnR5LlxuICogICBAcGFyYW0ge09iamVjdH0gZm4ub2JqIE9iamVjdCBiZWluZyBlbnVtZXJhdGVkLlxuICogQHBhcmFtIHtPYmplY3R9IFt0aGlzT2JqXSBgdGhpc2Agb2JqZWN0IHRvIHVzZSB3aGVuIGNhbGxpbmcgX2ZuXy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Byb3RvPWZhbHNlXSBJbmNsdWRlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGFueSBleGVjdXRpb24gb2YgX2ZuXyByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLFxuICogICBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBzdGF0aWNcbiAqL1xuTy5zb21lID0gZnVuY3Rpb24gKG9iaiwgZm4sIHRoaXNPYmosIHByb3RvKSB7XG4gICAgdmFyIGtleTtcblxuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBpZiAocHJvdG8gfHwgb3ducyhvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChmbi5jYWxsKHRoaXNPYmogfHwgWSwgb2JqW2tleV0sIGtleSwgb2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHN1YiB2YWx1ZSBhdCB0aGUgcHJvdmlkZWQgcGF0aCxcbiAqIGZyb20gdGhlIHZhbHVlIG9iamVjdCBwcm92aWRlZC5cbiAqXG4gKiBAbWV0aG9kIGdldFZhbHVlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gbyBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKiBAcGFyYW0gcGF0aCB7QXJyYXl9IEEgcGF0aCBhcnJheSwgc3BlY2lmeWluZyB0aGUgb2JqZWN0IHRyYXZlcnNhbCBwYXRoXG4gKiBmcm9tIHdoaWNoIHRvIG9idGFpbiB0aGUgc3ViIHZhbHVlLlxuICogQHJldHVybiB7QW55fSBUaGUgdmFsdWUgc3RvcmVkIGluIHRoZSBwYXRoLCB1bmRlZmluZWQgaWYgbm90IGZvdW5kLFxuICogdW5kZWZpbmVkIGlmIHRoZSBzb3VyY2UgaXMgbm90IGFuIG9iamVjdC4gIFJldHVybnMgdGhlIHNvdXJjZSBvYmplY3RcbiAqIGlmIGFuIGVtcHR5IHBhdGggaXMgcHJvdmlkZWQuXG4gKi9cbk8uZ2V0VmFsdWUgPSBmdW5jdGlvbihvLCBwYXRoKSB7XG4gICAgaWYgKCFMYW5nLmlzT2JqZWN0KG8pKSB7XG4gICAgICAgIHJldHVybiBVTkRFRklORUQ7XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIHAgPSBZLkFycmF5KHBhdGgpLFxuICAgICAgICBsID0gcC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBvICE9PSBVTkRFRklORUQgJiYgaSA8IGw7IGkrKykge1xuICAgICAgICBvID0gb1twW2ldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc3ViLWF0dHJpYnV0ZSB2YWx1ZSBhdCB0aGUgcHJvdmlkZWQgcGF0aCBvbiB0aGVcbiAqIHZhbHVlIG9iamVjdC4gIFJldHVybnMgdGhlIG1vZGlmaWVkIHZhbHVlIG9iamVjdCwgb3JcbiAqIHVuZGVmaW5lZCBpZiB0aGUgcGF0aCBpcyBpbnZhbGlkLlxuICpcbiAqIEBtZXRob2Qgc2V0VmFsdWVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBvICAgICAgICAgICAgIFRoZSBvYmplY3Qgb24gd2hpY2ggdG8gc2V0IHRoZSBzdWIgdmFsdWUuXG4gKiBAcGFyYW0gcGF0aCB7QXJyYXl9ICBBIHBhdGggYXJyYXksIHNwZWNpZnlpbmcgdGhlIG9iamVjdCB0cmF2ZXJzYWwgcGF0aFxuICogICAgICAgICAgICAgICAgICAgICAgYXQgd2hpY2ggdG8gc2V0IHRoZSBzdWIgdmFsdWUuXG4gKiBAcGFyYW0gdmFsIHtBbnl9ICAgICBUaGUgbmV3IHZhbHVlIGZvciB0aGUgc3ViLWF0dHJpYnV0ZS5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgIFRoZSBtb2RpZmllZCBvYmplY3QsIHdpdGggdGhlIG5ldyBzdWIgdmFsdWUgc2V0LCBvclxuICogICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCBpZiB0aGUgcGF0aCB3YXMgaW52YWxpZC5cbiAqL1xuTy5zZXRWYWx1ZSA9IGZ1bmN0aW9uKG8sIHBhdGgsIHZhbCkge1xuICAgIHZhciBpLFxuICAgICAgICBwID0gWS5BcnJheShwYXRoKSxcbiAgICAgICAgbGVhZklkeCA9IHAubGVuZ3RoIC0gMSxcbiAgICAgICAgcmVmID0gbztcblxuICAgIGlmIChsZWFmSWR4ID49IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgcmVmICE9PSBVTkRFRklORUQgJiYgaSA8IGxlYWZJZHg7IGkrKykge1xuICAgICAgICAgICAgcmVmID0gcmVmW3BbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZiAhPT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICByZWZbcFtpXV0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVU5ERUZJTkVEO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG87XG59O1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBpdHMgb3duLlxuICpcbiAqIEBtZXRob2QgaXNFbXB0eVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBBbiBvYmplY3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBpcyBlbXB0eS5cbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAzLjIuMFxuICovXG5PLmlzRW1wdHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuICFPLmtleXMoT2JqZWN0KG9iaikpLmxlbmd0aDtcbn07XG4vKipcbiAqIFRoZSBZVUkgbW9kdWxlIGNvbnRhaW5zIHRoZSBjb21wb25lbnRzIHJlcXVpcmVkIGZvciBidWlsZGluZyB0aGUgWVVJIHNlZWRcbiAqIGZpbGUuICBUaGlzIGluY2x1ZGVzIHRoZSBzY3JpcHQgbG9hZGluZyBtZWNoYW5pc20sIGEgc2ltcGxlIHF1ZXVlLCBhbmQgdGhlXG4gKiBjb3JlIHV0aWxpdGllcyBmb3IgdGhlIGxpYnJhcnkuXG4gKiBAbW9kdWxlIHl1aVxuICogQHN1Ym1vZHVsZSB5dWktYmFzZVxuICovXG5cbi8qKlxuICogWVVJIHVzZXIgYWdlbnQgZGV0ZWN0aW9uLlxuICogRG8gbm90IGZvcmsgZm9yIGEgYnJvd3NlciBpZiBpdCBjYW4gYmUgYXZvaWRlZC4gIFVzZSBmZWF0dXJlIGRldGVjdGlvbiB3aGVuXG4gKiB5b3UgY2FuLiAgVXNlIHRoZSB1c2VyIGFnZW50IGFzIGEgbGFzdCByZXNvcnQuICBGb3IgYWxsIGZpZWxkcyBsaXN0ZWRcbiAqIGFzIEB0eXBlIGZsb2F0LCBVQSBzdG9yZXMgYSB2ZXJzaW9uIG51bWJlciBmb3IgdGhlIGJyb3dzZXIgZW5naW5lLFxuICogMCBvdGhlcndpc2UuICBUaGlzIHZhbHVlIG1heSBvciBtYXkgbm90IG1hcCB0byB0aGUgdmVyc2lvbiBudW1iZXIgb2ZcbiAqIHRoZSBicm93c2VyIHVzaW5nIHRoZSBlbmdpbmUuICBUaGUgdmFsdWUgaXMgcHJlc2VudGVkIGFzIGEgZmxvYXQgc29cbiAqIHRoYXQgaXQgY2FuIGVhc2lseSBiZSB1c2VkIGZvciBib29sZWFuIGV2YWx1YXRpb24gYXMgd2VsbCBhcyBmb3JcbiAqIGxvb2tpbmcgZm9yIGEgcGFydGljdWxhciByYW5nZSBvZiB2ZXJzaW9ucy4gIEJlY2F1c2Ugb2YgdGhpcyxcbiAqIHNvbWUgb2YgdGhlIGdyYW51bGFyaXR5IG9mIHRoZSB2ZXJzaW9uIGluZm8gbWF5IGJlIGxvc3QuICBUaGUgZmllbGRzIHRoYXRcbiAqIGFyZSBAdHlwZSBzdHJpbmcgZGVmYXVsdCB0byBudWxsLiAgVGhlIEFQSSBkb2NzIGxpc3QgdGhlIHZhbHVlcyB0aGF0XG4gKiB0aGVzZSBmaWVsZHMgY2FuIGhhdmUuXG4gKiBAY2xhc3MgVUFcbiAqIEBzdGF0aWNcbiAqL1xuXG4vKipcbiogU3RhdGljIG1ldGhvZCBvbiBgWVVJLkVudmAgZm9yIHBhcnNpbmcgYSBVQSBzdHJpbmcuICBDYWxsZWQgYXQgaW5zdGFudGlhdGlvblxuKiB0byBwb3B1bGF0ZSBgWS5VQWAuXG4qXG4qIEBzdGF0aWNcbiogQG1ldGhvZCBwYXJzZVVBXG4qIEBwYXJhbSB7U3RyaW5nfSBbc3ViVUE9bmF2aWdhdG9yLnVzZXJBZ2VudF0gVUEgc3RyaW5nIHRvIHBhcnNlXG4qIEByZXR1cm4ge09iamVjdH0gVGhlIFkuVUEgb2JqZWN0XG4qL1xuWVVJLkVudi5wYXJzZVVBID0gZnVuY3Rpb24oc3ViVUEpIHtcblxuICAgIHZhciBudW1iZXJpZnkgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzLnJlcGxhY2UoL1xcLi9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGMrKyA9PT0gMSkgPyAnJyA6ICcuJztcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3aW4gPSBZLmNvbmZpZy53aW4sXG5cbiAgICAgICAgbmF2ID0gd2luICYmIHdpbi5uYXZpZ2F0b3IsXG5cbiAgICAgICAgbyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbiBudW1iZXIgb3IgMC4gIEV4YW1wbGU6IDZcbiAgICAgICAgICogQHByb3BlcnR5IGllXG4gICAgICAgICAqIEB0eXBlIGZsb2F0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGllOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVyYSB2ZXJzaW9uIG51bWJlciBvciAwLiAgRXhhbXBsZTogOS4yXG4gICAgICAgICAqIEBwcm9wZXJ0eSBvcGVyYVxuICAgICAgICAgKiBAdHlwZSBmbG9hdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBvcGVyYTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2Vja28gZW5naW5lIHJldmlzaW9uIG51bWJlci4gIFdpbGwgZXZhbHVhdGUgdG8gMSBpZiBHZWNrb1xuICAgICAgICAgKiBpcyBkZXRlY3RlZCBidXQgdGhlIHJldmlzaW9uIGNvdWxkIG5vdCBiZSBmb3VuZC4gT3RoZXIgYnJvd3NlcnNcbiAgICAgICAgICogd2lsbCBiZSAwLiAgRXhhbXBsZTogMS44XG4gICAgICAgICAqIDxwcmU+XG4gICAgICAgICAqIEZpcmVmb3ggMS4wLjAuNDogMS43LjggICA8LS0gUmVwb3J0cyAxLjdcbiAgICAgICAgICogRmlyZWZveCAxLjUuMC45OiAxLjguMC45IDwtLSAxLjhcbiAgICAgICAgICogRmlyZWZveCAyLjAuMC4zOiAxLjguMS4zIDwtLSAxLjgxXG4gICAgICAgICAqIEZpcmVmb3ggMy4wICAgPC0tIDEuOVxuICAgICAgICAgKiBGaXJlZm94IDMuNSAgIDwtLSAxLjkxXG4gICAgICAgICAqIDwvcHJlPlxuICAgICAgICAgKiBAcHJvcGVydHkgZ2Vja29cbiAgICAgICAgICogQHR5cGUgZmxvYXRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgZ2Vja286IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxlV2ViS2l0IHZlcnNpb24uICBLSFRNTCBicm93c2VycyB0aGF0IGFyZSBub3QgV2ViS2l0IGJyb3dzZXJzXG4gICAgICAgICAqIHdpbGwgZXZhbHVhdGUgdG8gMSwgb3RoZXIgYnJvd3NlcnMgMC4gIEV4YW1wbGU6IDQxOC45XG4gICAgICAgICAqIDxwcmU+XG4gICAgICAgICAqIFNhZmFyaSAxLjMuMiAoMzEyLjYpOiAzMTIuOC4xIDwtLSBSZXBvcnRzIDMxMi44IC0tIGN1cnJlbnRseSB0aGVcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdGVzdCBhdmFpbGFibGUgZm9yIE1hYyBPU1ggMTAuMy5cbiAgICAgICAgICogU2FmYXJpIDIuMC4yOiAgICAgICAgIDQxNiAgICAgPC0tIGhhc093blByb3BlcnR5IGludHJvZHVjZWRcbiAgICAgICAgICogU2FmYXJpIDIuMC40OiAgICAgICAgIDQxOCAgICAgPC0tIHByZXZlbnREZWZhdWx0IGZpeGVkXG4gICAgICAgICAqIFNhZmFyaSAyLjAuNCAoNDE5LjMpOiA0MTguOS4xIDwtLSBPbmUgdmVyc2lvbiBvZiBTYWZhcmkgbWF5IHJ1blxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW50IHZlcnNpb25zIG9mIHdlYmtpdFxuICAgICAgICAgKiBTYWZhcmkgMi4wLjQgKDQxOS4zKTogNDE5ICAgICA8LS0gVGlnZXIgaW5zdGFsbGF0aW9ucyB0aGF0IGhhdmUgYmVlblxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCwgYnV0IG5vdCB1cGRhdGVkXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgbGF0ZXN0IHBhdGNoLlxuICAgICAgICAgKiBXZWJraXQgMjEyIG5pZ2h0bHk6ICAgNTIyKyAgICA8LS0gU2FmYXJpIDMuMCBwcmVjdXJzb3IgKHdpdGggbmF0aXZlXG4gICAgICAgICAqIFNWRyBhbmQgbWFueSBtYWpvciBpc3N1ZXMgZml4ZWQpLlxuICAgICAgICAgKiBTYWZhcmkgMy4wLjQgKDUyMy4xMikgNTIzLjEyICA8LS0gRmlyc3QgVGlnZXIgcmVsZWFzZSAtIGF1dG9tYXRpY1xuICAgICAgICAgKiB1cGRhdGUgZnJvbSAyLnggdmlhIHRoZSAxMC40LjExIE9TIHBhdGNoLlxuICAgICAgICAgKiBXZWJraXQgbmlnaHRseSAxLzIwMDg6NTI1KyAgICA8LS0gU3VwcG9ydHMgRE9NQ29udGVudExvYWRlZCBldmVudC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlhaG9vLmNvbSB1c2VyIGFnZW50IGhhY2sgcmVtb3ZlZC5cbiAgICAgICAgICogPC9wcmU+XG4gICAgICAgICAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2FmYXJpX3ZlcnNpb25faGlzdG9yeVxuICAgICAgICAgKiBAcHJvcGVydHkgd2Via2l0XG4gICAgICAgICAqIEB0eXBlIGZsb2F0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHdlYmtpdDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2FmYXJpIHdpbGwgYmUgZGV0ZWN0ZWQgYXMgd2Via2l0LCBidXQgdGhpcyBwcm9wZXJ0eSB3aWxsIGFsc29cbiAgICAgICAgICogYmUgcG9wdWxhdGVkIHdpdGggdGhlIFNhZmFyaSB2ZXJzaW9uIG51bWJlclxuICAgICAgICAgKiBAcHJvcGVydHkgc2FmYXJpXG4gICAgICAgICAqIEB0eXBlIGZsb2F0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHNhZmFyaTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hyb21lIHdpbGwgYmUgZGV0ZWN0ZWQgYXMgd2Via2l0LCBidXQgdGhpcyBwcm9wZXJ0eSB3aWxsIGFsc29cbiAgICAgICAgICogYmUgcG9wdWxhdGVkIHdpdGggdGhlIENocm9tZSB2ZXJzaW9uIG51bWJlclxuICAgICAgICAgKiBAcHJvcGVydHkgY2hyb21lXG4gICAgICAgICAqIEB0eXBlIGZsb2F0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGNocm9tZTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vYmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHNldCB0byBhIHN0cmluZyBjb250YWluaW5nIGFueSByZWxldmFudFxuICAgICAgICAgKiB1c2VyIGFnZW50IGluZm9ybWF0aW9uIHdoZW4gYSBtb2Rlcm4gbW9iaWxlIGJyb3dzZXIgaXMgZGV0ZWN0ZWQuXG4gICAgICAgICAqIEN1cnJlbnRseSBsaW1pdGVkIHRvIFNhZmFyaSBvbiB0aGUgaVBob25lL2lQb2QgVG91Y2gsIE5va2lhIE4tc2VyaWVzXG4gICAgICAgICAqIGRldmljZXMgd2l0aCB0aGUgV2ViS2l0LWJhc2VkIGJyb3dzZXIsIGFuZCBPcGVyYSBNaW5pLlxuICAgICAgICAgKiBAcHJvcGVydHkgbW9iaWxlXG4gICAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIG1vYmlsZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRvYmUgQUlSIHZlcnNpb24gbnVtYmVyIG9yIDAuICBPbmx5IHBvcHVsYXRlZCBpZiB3ZWJraXQgaXMgZGV0ZWN0ZWQuXG4gICAgICAgICAqIEV4YW1wbGU6IDEuMFxuICAgICAgICAgKiBAcHJvcGVydHkgYWlyXG4gICAgICAgICAqIEB0eXBlIGZsb2F0XG4gICAgICAgICAqL1xuICAgICAgICBhaXI6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQaGFudG9tSlMgdmVyc2lvbiBudW1iZXIgb3IgMC4gIE9ubHkgcG9wdWxhdGVkIGlmIHdlYmtpdCBpcyBkZXRlY3RlZC5cbiAgICAgICAgICogRXhhbXBsZTogMS4wXG4gICAgICAgICAqIEBwcm9wZXJ0eSBwaGFudG9tanNcbiAgICAgICAgICogQHR5cGUgZmxvYXRcbiAgICAgICAgICovXG4gICAgICAgIHBoYW50b21qczogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdHMgQXBwbGUgaVBhZCdzIE9TIHZlcnNpb25cbiAgICAgICAgICogQHByb3BlcnR5IGlwYWRcbiAgICAgICAgICogQHR5cGUgZmxvYXRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgaXBhZDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdHMgQXBwbGUgaVBob25lJ3MgT1MgdmVyc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkgaXBob25lXG4gICAgICAgICAqIEB0eXBlIGZsb2F0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGlwaG9uZTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdHMgQXBwbGVzIGlQb2QncyBPUyB2ZXJzaW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBpcG9kXG4gICAgICAgICAqIEB0eXBlIGZsb2F0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGlwb2Q6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmFsIHRydXRoeSBjaGVjayBmb3IgaVBhZCwgaVBob25lIG9yIGlQb2RcbiAgICAgICAgICogQHByb3BlcnR5IGlvc1xuICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgaW9zOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZWN0cyBHb29nbGVzIEFuZHJvaWQgT1MgdmVyc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkgYW5kcm9pZFxuICAgICAgICAgKiBAdHlwZSBmbG9hdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBhbmRyb2lkOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZWN0cyBLaW5kbGUgU2lsa1xuICAgICAgICAgKiBAcHJvcGVydHkgc2lsa1xuICAgICAgICAgKiBAdHlwZSBmbG9hdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBzaWxrOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZWN0cyBVYnVudHUgdmVyc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkgdWJ1bnR1XG4gICAgICAgICAqIEB0eXBlIGZsb2F0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHVidW50dTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdHMgS2luZGxlIFNpbGsgQWNjZWxlcmF0aW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhY2NlbFxuICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGFjY2VsOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdHMgUGFsbXMgV2ViT1MgdmVyc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkgd2Vib3NcbiAgICAgICAgICogQHR5cGUgZmxvYXRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgd2Vib3M6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdvb2dsZSBDYWphIHZlcnNpb24gbnVtYmVyIG9yIDAuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjYWphXG4gICAgICAgICAqIEB0eXBlIGZsb2F0XG4gICAgICAgICAqL1xuICAgICAgICBjYWphOiBuYXYgJiYgbmF2LmNhamFWZXJzaW9uLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB0aGUgcGFnZSBhcHBlYXJzIHRvIGJlIGluIFNTTFxuICAgICAgICAgKiBAcHJvcGVydHkgc2VjdXJlXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgc2VjdXJlOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wZXJhdGluZyBzeXN0ZW0uICBDdXJyZW50bHkgb25seSBkZXRlY3Rpbmcgd2luZG93cyBvciBtYWNpbnRvc2hcbiAgICAgICAgICogQHByb3BlcnR5IG9zXG4gICAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIG9zOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgTm9kZWpzIFZlcnNpb25cbiAgICAgICAgICogQHByb3BlcnR5IG5vZGVqc1xuICAgICAgICAgKiBAdHlwZSBmbG9hdFxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIG5vZGVqczogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICogV2luZG93OC9JRTEwIEFwcGxpY2F0aW9uIGhvc3QgZW52aXJvbm1lbnRcbiAgICAgICAgKiBAcHJvcGVydHkgd2luanNcbiAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICogQHN0YXRpY1xuICAgICAgICAqL1xuICAgICAgICB3aW5qczogISEoKHR5cGVvZiBXaW5kb3dzICE9PSBcInVuZGVmaW5lZFwiKSAmJiBXaW5kb3dzLlN5c3RlbSksXG4gICAgICAgIC8qKlxuICAgICAgICAqIEFyZSB0b3VjaC9tc1BvaW50ZXIgZXZlbnRzIGF2YWlsYWJsZSBvbiB0aGlzIGRldmljZVxuICAgICAgICAqIEBwcm9wZXJ0eSB0b3VjaEVuYWJsZWRcbiAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICogQHN0YXRpY1xuICAgICAgICAqL1xuICAgICAgICB0b3VjaEVuYWJsZWQ6IGZhbHNlXG4gICAgfSxcblxuICAgIHVhID0gc3ViVUEgfHwgbmF2ICYmIG5hdi51c2VyQWdlbnQsXG5cbiAgICBsb2MgPSB3aW4gJiYgd2luLmxvY2F0aW9uLFxuXG4gICAgaHJlZiA9IGxvYyAmJiBsb2MuaHJlZixcblxuICAgIG07XG5cbiAgICAvKipcbiAgICAqIFRoZSBVc2VyIEFnZW50IHN0cmluZyB0aGF0IHdhcyBwYXJzZWRcbiAgICAqIEBwcm9wZXJ0eSB1c2VyQWdlbnRcbiAgICAqIEB0eXBlIFN0cmluZ1xuICAgICogQHN0YXRpY1xuICAgICovXG4gICAgby51c2VyQWdlbnQgPSB1YTtcblxuXG4gICAgby5zZWN1cmUgPSBocmVmICYmIChocmVmLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaHR0cHMnKSA9PT0gMCk7XG5cbiAgICBpZiAodWEpIHtcblxuICAgICAgICBpZiAoKC93aW5kb3dzfHdpbjMyL2kpLnRlc3QodWEpKSB7XG4gICAgICAgICAgICBvLm9zID0gJ3dpbmRvd3MnO1xuICAgICAgICB9IGVsc2UgaWYgKCgvbWFjaW50b3NofG1hY19wb3dlcnBjL2kpLnRlc3QodWEpKSB7XG4gICAgICAgICAgICBvLm9zID0gJ21hY2ludG9zaCc7XG4gICAgICAgIH0gZWxzZSBpZiAoKC9hbmRyb2lkL2kpLnRlc3QodWEpKSB7XG4gICAgICAgICAgICBvLm9zID0gJ2FuZHJvaWQnO1xuICAgICAgICB9IGVsc2UgaWYgKCgvc3ltYm9zL2kpLnRlc3QodWEpKSB7XG4gICAgICAgICAgICBvLm9zID0gJ3N5bWJvcyc7XG4gICAgICAgIH0gZWxzZSBpZiAoKC9saW51eC9pKS50ZXN0KHVhKSkge1xuICAgICAgICAgICAgby5vcyA9ICdsaW51eCc7XG4gICAgICAgIH0gZWxzZSBpZiAoKC9yaGluby9pKS50ZXN0KHVhKSkge1xuICAgICAgICAgICAgby5vcyA9ICdyaGlubyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb2Rlcm4gS0hUTUwgYnJvd3NlcnMgc2hvdWxkIHF1YWxpZnkgYXMgU2FmYXJpIFgtR3JhZGVcbiAgICAgICAgaWYgKCgvS0hUTUwvKS50ZXN0KHVhKSkge1xuICAgICAgICAgICAgby53ZWJraXQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoL0lFTW9iaWxlfFhCTFdQNy8pLnRlc3QodWEpKSB7XG4gICAgICAgICAgICBvLm1vYmlsZSA9ICd3aW5kb3dzJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKC9GZW5uZWMvKS50ZXN0KHVhKSkge1xuICAgICAgICAgICAgby5tb2JpbGUgPSAnZ2Vja28nO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1vZGVybiBXZWJLaXQgYnJvd3NlcnMgYXJlIGF0IGxlYXN0IFgtR3JhZGVcbiAgICAgICAgbSA9IHVhLm1hdGNoKC9BcHBsZVdlYktpdFxcLyhbXlxcc10qKS8pO1xuICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICBvLndlYmtpdCA9IG51bWJlcmlmeShtWzFdKTtcbiAgICAgICAgICAgIG8uc2FmYXJpID0gby53ZWJraXQ7XG5cbiAgICAgICAgICAgIGlmICgvUGhhbnRvbUpTLy50ZXN0KHVhKSkge1xuICAgICAgICAgICAgICAgIG0gPSB1YS5tYXRjaCgvUGhhbnRvbUpTXFwvKFteXFxzXSopLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBvLnBoYW50b21qcyA9IG51bWJlcmlmeShtWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1vYmlsZSBicm93c2VyIGNoZWNrXG4gICAgICAgICAgICBpZiAoLyBNb2JpbGVcXC8vLnRlc3QodWEpIHx8ICgvaVBhZHxpUG9kfGlQaG9uZS8pLnRlc3QodWEpKSB7XG4gICAgICAgICAgICAgICAgby5tb2JpbGUgPSAnQXBwbGUnOyAvLyBpUGhvbmUgb3IgaVBvZCBUb3VjaFxuXG4gICAgICAgICAgICAgICAgbSA9IHVhLm1hdGNoKC9PUyAoW15cXHNdKikvKTtcbiAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gPSBudW1iZXJpZnkobVsxXS5yZXBsYWNlKCdfJywgJy4nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG8uaW9zID0gbTtcbiAgICAgICAgICAgICAgICBvLm9zID0gJ2lvcyc7XG4gICAgICAgICAgICAgICAgby5pcGFkID0gby5pcG9kID0gby5pcGhvbmUgPSAwO1xuXG4gICAgICAgICAgICAgICAgbSA9IHVhLm1hdGNoKC9pUGFkfGlQb2R8aVBob25lLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0gJiYgbVswXSkge1xuICAgICAgICAgICAgICAgICAgICBvW21bMF0udG9Mb3dlckNhc2UoKV0gPSBvLmlvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG0gPSB1YS5tYXRjaCgvTm9raWFOW15cXC9dKnx3ZWJPU1xcL1xcZFxcLlxcZC8pO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5va2lhIE4tc2VyaWVzLCB3ZWJPUywgZXg6IE5va2lhTjk1XG4gICAgICAgICAgICAgICAgICAgIG8ubW9iaWxlID0gbVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC93ZWJPUy8udGVzdCh1YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgby5tb2JpbGUgPSAnV2ViT1MnO1xuICAgICAgICAgICAgICAgICAgICBtID0gdWEubWF0Y2goL3dlYk9TXFwvKFteXFxzXSopOy8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLndlYm9zID0gbnVtYmVyaWZ5KG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvIEFuZHJvaWQvLnRlc3QodWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvTW9iaWxlLy50ZXN0KHVhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5tb2JpbGUgPSAnQW5kcm9pZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbSA9IHVhLm1hdGNoKC9BbmRyb2lkIChbXlxcc10qKTsvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5hbmRyb2lkID0gbnVtYmVyaWZ5KG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9TaWxrLy50ZXN0KHVhKSkge1xuICAgICAgICAgICAgICAgICAgICBtID0gdWEubWF0Y2goL1NpbGtcXC8oW15cXHNdKikvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5zaWxrID0gbnVtYmVyaWZ5KG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghby5hbmRyb2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmFuZHJvaWQgPSAyLjM0OyAvL0hhY2sgZm9yIGRlc2t0b3AgbW9kZSBpbiBLaW5kbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ub3MgPSAnQW5kcm9pZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKC9BY2NlbGVyYXRlZD10cnVlLy50ZXN0KHVhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5hY2NlbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0gPSB1YS5tYXRjaCgvT1BSXFwvKFxcZCtcXC5cXGQrKS8pO1xuXG4gICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICAgICAgLy8gT3BlcmEgMTUrIHdpdGggQmxpbmsgKHByZXRlbmRzIHRvIGJlIGJvdGggQ2hyb21lIGFuZCBTYWZhcmkpXG4gICAgICAgICAgICAgICAgby5vcGVyYSA9IG51bWJlcmlmeShtWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbSA9IHVhLm1hdGNoKC8oQ2hyb21lfENyTW98Q3JpT1MpXFwvKFteXFxzXSopLyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdICYmIG1bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgby5jaHJvbWUgPSBudW1iZXJpZnkobVsyXSk7IC8vIENocm9tZVxuICAgICAgICAgICAgICAgICAgICBvLnNhZmFyaSA9IDA7IC8vUmVzZXQgc2FmYXJpIGJhY2sgdG8gMFxuICAgICAgICAgICAgICAgICAgICBpZiAobVsxXSA9PT0gJ0NyTW8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLm1vYmlsZSA9ICdjaHJvbWUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbSA9IHVhLm1hdGNoKC9BZG9iZUFJUlxcLyhbXlxcc10qKS8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5haXIgPSBtWzBdOyAvLyBBZG9iZSBBSVIgMS4wIG9yIGJldHRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbSA9IHVhLm1hdGNoKC9VYnVudHVcXCAoXFxkK1xcLlxcZCspLyk7XG4gICAgICAgIGlmIChtICYmIG1bMV0pIHtcblxuICAgICAgICAgICAgby5vcyA9ICdsaW51eCc7XG4gICAgICAgICAgICBvLnVidW50dSA9IG51bWJlcmlmeShtWzFdKTtcblxuICAgICAgICAgICAgbSA9IHVhLm1hdGNoKC9cXCBXZWJLaXRcXC8oW15cXHNdKikvKTtcbiAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgICAgICBvLndlYmtpdCA9IG51bWJlcmlmeShtWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0gPSB1YS5tYXRjaCgvXFwgQ2hyb21pdW1cXC8oW15cXHNdKikvKTtcbiAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgICAgICBvLmNocm9tZSA9IG51bWJlcmlmeShtWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvIE1vYmlsZSQvLnRlc3QodWEpKSB7XG4gICAgICAgICAgICAgICAgby5tb2JpbGUgPSAnVWJ1bnR1JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghby53ZWJraXQpIHsgLy8gbm90IHdlYmtpdFxuLy8gQHRvZG8gY2hlY2sgT3BlcmEvOC4wMSAoSjJNRS9NSURQOyBPcGVyYSBNaW5pLzIuMC40NTA5LzEzMTY7IGZpOyBVOyBzc3IpXG4gICAgICAgICAgICBpZiAoL09wZXJhLy50ZXN0KHVhKSkge1xuICAgICAgICAgICAgICAgIG0gPSB1YS5tYXRjaCgvT3BlcmFbXFxzXFwvXShbXlxcc10qKS8pO1xuICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgby5vcGVyYSA9IG51bWJlcmlmeShtWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHVhLm1hdGNoKC9WZXJzaW9uXFwvKFteXFxzXSopLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBvLm9wZXJhID0gbnVtYmVyaWZ5KG1bMV0pOyAvLyBvcGVyYSAxMCtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoL09wZXJhIE1vYmkvLnRlc3QodWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG8ubW9iaWxlID0gJ29wZXJhJztcbiAgICAgICAgICAgICAgICAgICAgbSA9IHVhLnJlcGxhY2UoJ09wZXJhIE1vYmknLCAnJykubWF0Y2goL09wZXJhIChbXlxcc10qKS8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLm9wZXJhID0gbnVtYmVyaWZ5KG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSB1YS5tYXRjaCgvT3BlcmEgTWluaVteO10qLyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBvLm1vYmlsZSA9IG1bMF07IC8vIGV4OiBPcGVyYSBNaW5pLzIuMC40NTA5LzEzMTZcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBub3Qgb3BlcmEgb3Igd2Via2l0XG4gICAgICAgICAgICAgICAgbSA9IHVhLm1hdGNoKC9NU0lFIChbXjtdKil8VHJpZGVudC4qOyBydjooWzAtOS5dKykvKTtcblxuICAgICAgICAgICAgICAgIGlmIChtICYmIChtWzFdIHx8IG1bMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG8uaWUgPSBudW1iZXJpZnkobVsxXSB8fCBtWzJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBub3Qgb3BlcmEsIHdlYmtpdCwgb3IgaWVcbiAgICAgICAgICAgICAgICAgICAgbSA9IHVhLm1hdGNoKC9HZWNrb1xcLyhbXlxcc10qKS8pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmdlY2tvID0gMTsgLy8gR2Vja28gZGV0ZWN0ZWQsIGxvb2sgZm9yIHJldmlzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gdWEubWF0Y2goL3J2OihbXlxcc1xcKV0qKS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uZ2Vja28gPSBudW1iZXJpZnkobVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9Nb2JpbGV8VGFibGV0Ly50ZXN0KHVhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLm1vYmlsZSA9IFwiZmZvc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vQ2hlY2sgZm9yIGtub3duIHByb3BlcnRpZXMgdG8gdGVsbCBpZiB0b3VjaCBldmVudHMgYXJlIGVuYWJsZWQgb24gdGhpcyBkZXZpY2Ugb3IgaWZcbiAgICAvL3RoZSBudW1iZXIgb2YgTVNQb2ludGVyIHRvdWNocG9pbnRzIG9uIHRoaXMgZGV2aWNlIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICAgIGlmICh3aW4gJiYgbmF2ICYmICEoby5jaHJvbWUgJiYgby5jaHJvbWUgPCA2KSkge1xuICAgICAgICBvLnRvdWNoRW5hYmxlZCA9ICgoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW4pIHx8ICgoXCJtc01heFRvdWNoUG9pbnRzXCIgaW4gbmF2KSAmJiAobmF2Lm1zTWF4VG91Y2hQb2ludHMgPiAwKSkpO1xuICAgIH1cblxuICAgIC8vSXQgd2FzIGEgcGFyc2VkIFVBLCBkbyBub3QgYXNzaWduIHRoZSBnbG9iYWwgdmFsdWUuXG4gICAgaWYgKCFzdWJVQSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSB7XG4gICAgICAgICAgICAgICAgLy9Ob2RlSlNcbiAgICAgICAgICAgICAgICBvLm9zID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbiAgICAgICAgICAgICAgICBvLm5vZGVqcyA9IG51bWJlcmlmeShwcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgWVVJLkVudi5VQSA9IG87XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbztcbn07XG5cblxuWS5VQSA9IFlVSS5FbnYuVUEgfHwgWVVJLkVudi5wYXJzZVVBKCk7XG5cbi8qKlxuUGVyZm9ybXMgYSBzaW1wbGUgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2ZXJzaW9uIG51bWJlcnMsIGFjY291bnRpbmcgZm9yXG5zdGFuZGFyZCB2ZXJzaW9uaW5nIGxvZ2ljIHN1Y2ggYXMgdGhlIGZhY3QgdGhhdCBcIjUzNS44XCIgaXMgYSBsb3dlciB2ZXJzaW9uIHRoYW5cblwiNTM1LjI0XCIsIGV2ZW4gdGhvdWdoIGEgc2ltcGxlIG51bWVyaWNhbCBjb21wYXJpc29uIHdvdWxkIGluZGljYXRlIHRoYXQgaXQnc1xuZ3JlYXRlci4gQWxzbyBhY2NvdW50cyBmb3IgY2FzZXMgc3VjaCBhcyBcIjEuMVwiIHZzLiBcIjEuMS4wXCIsIHdoaWNoIGFyZVxuY29uc2lkZXJlZCBlcXVpdmFsZW50LlxuXG5SZXR1cm5zIC0xIGlmIHZlcnNpb24gX2FfIGlzIGxvd2VyIHRoYW4gdmVyc2lvbiBfYl8sIDAgaWYgdGhleSdyZSBlcXVpdmFsZW50LFxuMSBpZiBfYV8gaXMgaGlnaGVyIHRoYW4gX2JfLlxuXG5WZXJzaW9ucyBtYXkgYmUgbnVtYmVycyBvciBzdHJpbmdzIGNvbnRhaW5pbmcgbnVtYmVycyBhbmQgZG90cy4gRm9yIGV4YW1wbGUsXG5ib3RoIGA1MzVgIGFuZCBgXCI1MzUuOC4xMFwiYCBhcmUgYWNjZXB0YWJsZS4gQSB2ZXJzaW9uIHN0cmluZyBjb250YWluaW5nXG5ub24tbnVtZXJpYyBjaGFyYWN0ZXJzLCBsaWtlIGBcIjUzNS44LmJldGFcImAsIG1heSBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cblxuQG1ldGhvZCBjb21wYXJlVmVyc2lvbnNcbkBwYXJhbSB7TnVtYmVyfFN0cmluZ30gYSBGaXJzdCB2ZXJzaW9uIG51bWJlciB0byBjb21wYXJlLlxuQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBiIFNlY29uZCB2ZXJzaW9uIG51bWJlciB0byBjb21wYXJlLlxuQHJldHVybiAtMSBpZiBfYV8gaXMgbG93ZXIgdGhhbiBfYl8sIDAgaWYgdGhleSdyZSBlcXVpdmFsZW50LCAxIGlmIF9hXyBpc1xuICAgIGhpZ2hlciB0aGFuIF9iXy5cbioqL1xuWS5VQS5jb21wYXJlVmVyc2lvbnMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhUGFydCwgYVBhcnRzLCBiUGFydCwgYlBhcnRzLCBpLCBsZW47XG5cbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBhUGFydHMgPSAoYSArICcnKS5zcGxpdCgnLicpO1xuICAgIGJQYXJ0cyA9IChiICsgJycpLnNwbGl0KCcuJyk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBNYXRoLm1heChhUGFydHMubGVuZ3RoLCBiUGFydHMubGVuZ3RoKTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGFQYXJ0ID0gcGFyc2VJbnQoYVBhcnRzW2ldLCAxMCk7XG4gICAgICAgIGJQYXJ0ID0gcGFyc2VJbnQoYlBhcnRzW2ldLCAxMCk7XG5cbiAgICAgICAgLypqc2hpbnQgZXhwcjogdHJ1ZSovXG4gICAgICAgIGlzTmFOKGFQYXJ0KSAmJiAoYVBhcnQgPSAwKTtcbiAgICAgICAgaXNOYU4oYlBhcnQpICYmIChiUGFydCA9IDApO1xuXG4gICAgICAgIGlmIChhUGFydCA8IGJQYXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYVBhcnQgPiBiUGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5ZVUkuRW52LmFsaWFzZXMgPSB7XG4gICAgXCJhbmltXCI6IFtcImFuaW0tYmFzZVwiLFwiYW5pbS1jb2xvclwiLFwiYW5pbS1jdXJ2ZVwiLFwiYW5pbS1lYXNpbmdcIixcImFuaW0tbm9kZS1wbHVnaW5cIixcImFuaW0tc2Nyb2xsXCIsXCJhbmltLXh5XCJdLFxuICAgIFwiYW5pbS1zaGFwZS10cmFuc2Zvcm1cIjogW1wiYW5pbS1zaGFwZVwiXSxcbiAgICBcImFwcFwiOiBbXCJhcHAtYmFzZVwiLFwiYXBwLWNvbnRlbnRcIixcImFwcC10cmFuc2l0aW9uc1wiLFwibGF6eS1tb2RlbC1saXN0XCIsXCJtb2RlbFwiLFwibW9kZWwtbGlzdFwiLFwibW9kZWwtc3luYy1yZXN0XCIsXCJtb2RlbC1zeW5jLWxvY2FsXCIsXCJyb3V0ZXJcIixcInZpZXdcIixcInZpZXctbm9kZS1tYXBcIl0sXG4gICAgXCJhdHRyaWJ1dGVcIjogW1wiYXR0cmlidXRlLWJhc2VcIixcImF0dHJpYnV0ZS1jb21wbGV4XCJdLFxuICAgIFwiYXR0cmlidXRlLWV2ZW50c1wiOiBbXCJhdHRyaWJ1dGUtb2JzZXJ2YWJsZVwiXSxcbiAgICBcImF1dG9jb21wbGV0ZVwiOiBbXCJhdXRvY29tcGxldGUtYmFzZVwiLFwiYXV0b2NvbXBsZXRlLXNvdXJjZXNcIixcImF1dG9jb21wbGV0ZS1saXN0XCIsXCJhdXRvY29tcGxldGUtcGx1Z2luXCJdLFxuICAgIFwiYXhlc1wiOiBbXCJheGlzLW51bWVyaWNcIixcImF4aXMtY2F0ZWdvcnlcIixcImF4aXMtdGltZVwiLFwiYXhpcy1zdGFja2VkXCJdLFxuICAgIFwiYXhlcy1iYXNlXCI6IFtcImF4aXMtbnVtZXJpYy1iYXNlXCIsXCJheGlzLWNhdGVnb3J5LWJhc2VcIixcImF4aXMtdGltZS1iYXNlXCIsXCJheGlzLXN0YWNrZWQtYmFzZVwiXSxcbiAgICBcImJhc2VcIjogW1wiYmFzZS1iYXNlXCIsXCJiYXNlLXBsdWdpbmhvc3RcIixcImJhc2UtYnVpbGRcIl0sXG4gICAgXCJjYWNoZVwiOiBbXCJjYWNoZS1iYXNlXCIsXCJjYWNoZS1vZmZsaW5lXCIsXCJjYWNoZS1wbHVnaW5cIl0sXG4gICAgXCJjaGFydHNcIjogW1wiY2hhcnRzLWJhc2VcIl0sXG4gICAgXCJjb2xsZWN0aW9uXCI6IFtcImFycmF5LWV4dHJhc1wiLFwiYXJyYXlsaXN0XCIsXCJhcnJheWxpc3QtYWRkXCIsXCJhcnJheWxpc3QtZmlsdGVyXCIsXCJhcnJheS1pbnZva2VcIl0sXG4gICAgXCJjb2xvclwiOiBbXCJjb2xvci1iYXNlXCIsXCJjb2xvci1oc2xcIixcImNvbG9yLWhhcm1vbnlcIl0sXG4gICAgXCJjb250cm9sbGVyXCI6IFtcInJvdXRlclwiXSxcbiAgICBcImRhdGFzY2hlbWFcIjogW1wiZGF0YXNjaGVtYS1iYXNlXCIsXCJkYXRhc2NoZW1hLWpzb25cIixcImRhdGFzY2hlbWEteG1sXCIsXCJkYXRhc2NoZW1hLWFycmF5XCIsXCJkYXRhc2NoZW1hLXRleHRcIl0sXG4gICAgXCJkYXRhc291cmNlXCI6IFtcImRhdGFzb3VyY2UtbG9jYWxcIixcImRhdGFzb3VyY2UtaW9cIixcImRhdGFzb3VyY2UtZ2V0XCIsXCJkYXRhc291cmNlLWZ1bmN0aW9uXCIsXCJkYXRhc291cmNlLWNhY2hlXCIsXCJkYXRhc291cmNlLWpzb25zY2hlbWFcIixcImRhdGFzb3VyY2UteG1sc2NoZW1hXCIsXCJkYXRhc291cmNlLWFycmF5c2NoZW1hXCIsXCJkYXRhc291cmNlLXRleHRzY2hlbWFcIixcImRhdGFzb3VyY2UtcG9sbGluZ1wiXSxcbiAgICBcImRhdGF0YWJsZVwiOiBbXCJkYXRhdGFibGUtY29yZVwiLFwiZGF0YXRhYmxlLXRhYmxlXCIsXCJkYXRhdGFibGUtaGVhZFwiLFwiZGF0YXRhYmxlLWJvZHlcIixcImRhdGF0YWJsZS1iYXNlXCIsXCJkYXRhdGFibGUtY29sdW1uLXdpZHRoc1wiLFwiZGF0YXRhYmxlLW1lc3NhZ2VcIixcImRhdGF0YWJsZS1tdXRhYmxlXCIsXCJkYXRhdGFibGUtc29ydFwiLFwiZGF0YXRhYmxlLWRhdGFzb3VyY2VcIl0sXG4gICAgXCJkYXRhdHlwZVwiOiBbXCJkYXRhdHlwZS1kYXRlXCIsXCJkYXRhdHlwZS1udW1iZXJcIixcImRhdGF0eXBlLXhtbFwiXSxcbiAgICBcImRhdGF0eXBlLWRhdGVcIjogW1wiZGF0YXR5cGUtZGF0ZS1wYXJzZVwiLFwiZGF0YXR5cGUtZGF0ZS1mb3JtYXRcIixcImRhdGF0eXBlLWRhdGUtbWF0aFwiXSxcbiAgICBcImRhdGF0eXBlLW51bWJlclwiOiBbXCJkYXRhdHlwZS1udW1iZXItcGFyc2VcIixcImRhdGF0eXBlLW51bWJlci1mb3JtYXRcIl0sXG4gICAgXCJkYXRhdHlwZS14bWxcIjogW1wiZGF0YXR5cGUteG1sLXBhcnNlXCIsXCJkYXRhdHlwZS14bWwtZm9ybWF0XCJdLFxuICAgIFwiZGRcIjogW1wiZGQtZGRtLWJhc2VcIixcImRkLWRkbVwiLFwiZGQtZGRtLWRyb3BcIixcImRkLWRyYWdcIixcImRkLXByb3h5XCIsXCJkZC1jb25zdHJhaW5cIixcImRkLWRyb3BcIixcImRkLXNjcm9sbFwiLFwiZGQtZGVsZWdhdGVcIl0sXG4gICAgXCJkb21cIjogW1wiZG9tLWJhc2VcIixcImRvbS1zY3JlZW5cIixcImRvbS1zdHlsZVwiLFwic2VsZWN0b3ItbmF0aXZlXCIsXCJzZWxlY3RvclwiXSxcbiAgICBcImVkaXRvclwiOiBbXCJmcmFtZVwiLFwiZWRpdG9yLXNlbGVjdGlvblwiLFwiZXhlYy1jb21tYW5kXCIsXCJlZGl0b3ItYmFzZVwiLFwiZWRpdG9yLXBhcmFcIixcImVkaXRvci1iclwiLFwiZWRpdG9yLWJpZGlcIixcImVkaXRvci10YWJcIixcImNyZWF0ZWxpbmstYmFzZVwiXSxcbiAgICBcImV2ZW50XCI6IFtcImV2ZW50LWJhc2VcIixcImV2ZW50LWRlbGVnYXRlXCIsXCJldmVudC1zeW50aGV0aWNcIixcImV2ZW50LW1vdXNld2hlZWxcIixcImV2ZW50LW1vdXNlZW50ZXJcIixcImV2ZW50LWtleVwiLFwiZXZlbnQtZm9jdXNcIixcImV2ZW50LXJlc2l6ZVwiLFwiZXZlbnQtaG92ZXJcIixcImV2ZW50LW91dHNpZGVcIixcImV2ZW50LXRvdWNoXCIsXCJldmVudC1tb3ZlXCIsXCJldmVudC1mbGlja1wiLFwiZXZlbnQtdmFsdWVjaGFuZ2VcIixcImV2ZW50LXRhcFwiXSxcbiAgICBcImV2ZW50LWN1c3RvbVwiOiBbXCJldmVudC1jdXN0b20tYmFzZVwiLFwiZXZlbnQtY3VzdG9tLWNvbXBsZXhcIl0sXG4gICAgXCJldmVudC1nZXN0dXJlc1wiOiBbXCJldmVudC1mbGlja1wiLFwiZXZlbnQtbW92ZVwiXSxcbiAgICBcImhhbmRsZWJhcnNcIjogW1wiaGFuZGxlYmFycy1jb21waWxlclwiXSxcbiAgICBcImhpZ2hsaWdodFwiOiBbXCJoaWdobGlnaHQtYmFzZVwiLFwiaGlnaGxpZ2h0LWFjY2VudGZvbGRcIl0sXG4gICAgXCJoaXN0b3J5XCI6IFtcImhpc3RvcnktYmFzZVwiLFwiaGlzdG9yeS1oYXNoXCIsXCJoaXN0b3J5LWh0bWw1XCJdLFxuICAgIFwiaW9cIjogW1wiaW8tYmFzZVwiLFwiaW8teGRyXCIsXCJpby1mb3JtXCIsXCJpby11cGxvYWQtaWZyYW1lXCIsXCJpby1xdWV1ZVwiXSxcbiAgICBcImpzb25cIjogW1wianNvbi1wYXJzZVwiLFwianNvbi1zdHJpbmdpZnlcIl0sXG4gICAgXCJsb2FkZXJcIjogW1wibG9hZGVyLWJhc2VcIixcImxvYWRlci1yb2xsdXBcIixcImxvYWRlci15dWkzXCJdLFxuICAgIFwibm9kZVwiOiBbXCJub2RlLWJhc2VcIixcIm5vZGUtZXZlbnQtZGVsZWdhdGVcIixcIm5vZGUtcGx1Z2luaG9zdFwiLFwibm9kZS1zY3JlZW5cIixcIm5vZGUtc3R5bGVcIl0sXG4gICAgXCJwbHVnaW5ob3N0XCI6IFtcInBsdWdpbmhvc3QtYmFzZVwiLFwicGx1Z2luaG9zdC1jb25maWdcIl0sXG4gICAgXCJxdWVyeXN0cmluZ1wiOiBbXCJxdWVyeXN0cmluZy1wYXJzZVwiLFwicXVlcnlzdHJpbmctc3RyaW5naWZ5XCJdLFxuICAgIFwicmVjb3Jkc2V0XCI6IFtcInJlY29yZHNldC1iYXNlXCIsXCJyZWNvcmRzZXQtc29ydFwiLFwicmVjb3Jkc2V0LWZpbHRlclwiLFwicmVjb3Jkc2V0LWluZGV4ZXJcIl0sXG4gICAgXCJyZXNpemVcIjogW1wicmVzaXplLWJhc2VcIixcInJlc2l6ZS1wcm94eVwiLFwicmVzaXplLWNvbnN0cmFpblwiXSxcbiAgICBcInNsaWRlclwiOiBbXCJzbGlkZXItYmFzZVwiLFwic2xpZGVyLXZhbHVlLXJhbmdlXCIsXCJjbGlja2FibGUtcmFpbFwiLFwicmFuZ2Utc2xpZGVyXCJdLFxuICAgIFwidGVtcGxhdGVcIjogW1widGVtcGxhdGUtYmFzZVwiLFwidGVtcGxhdGUtbWljcm9cIl0sXG4gICAgXCJ0ZXh0XCI6IFtcInRleHQtYWNjZW50Zm9sZFwiLFwidGV4dC13b3JkYnJlYWtcIl0sXG4gICAgXCJ3aWRnZXRcIjogW1wid2lkZ2V0LWJhc2VcIixcIndpZGdldC1odG1scGFyc2VyXCIsXCJ3aWRnZXQtc2tpblwiLFwid2lkZ2V0LXVpZXZlbnRzXCJdXG59O1xuXG5cbn0sICczLjE3LjInLCB7XCJ1c2VcIjogW1wiZ2V0XCIsIFwiZmVhdHVyZXNcIiwgXCJpbnRsLWJhc2VcIiwgXCJ5dWktbG9nXCIsIFwieXVpLWxhdGVyXCJdfSk7XG5ZVUkuYWRkKCdnZXQnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKmpzbGludCBib3NzOnRydWUsIGV4cHI6dHJ1ZSwgbGF4YnJlYWs6IHRydWUgKi9cblxuLyoqXG5Qcm92aWRlcyBkeW5hbWljIGxvYWRpbmcgb2YgcmVtb3RlIEphdmFTY3JpcHQgYW5kIENTUyByZXNvdXJjZXMuXG5cbkBtb2R1bGUgZ2V0XG5AY2xhc3MgR2V0XG5Ac3RhdGljXG4qKi9cblxudmFyIExhbmcgPSBZLkxhbmcsXG5cbiAgICBDVVNUT01fQVRUUlMsIC8vIGRlZmluZWQgbGF6aWx5IGluIFkuR2V0LlRyYW5zYWN0aW9uLl9jcmVhdGVOb2RlKClcblxuICAgIEdldCwgVHJhbnNhY3Rpb247XG5cblkuR2V0ID0gR2V0ID0ge1xuICAgIC8vIC0tIFB1YmxpYyBQcm9wZXJ0aWVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgIERlZmF1bHQgb3B0aW9ucyBmb3IgQ1NTIHJlcXVlc3RzLiBPcHRpb25zIHNwZWNpZmllZCBoZXJlIHdpbGwgb3ZlcnJpZGVcbiAgICBnbG9iYWwgZGVmYXVsdHMgZm9yIENTUyByZXF1ZXN0cy5cblxuICAgIFNlZSB0aGUgYG9wdGlvbnNgIHByb3BlcnR5IGZvciBhbGwgYXZhaWxhYmxlIG9wdGlvbnMuXG5cbiAgICBAcHJvcGVydHkgY3NzT3B0aW9uc1xuICAgIEB0eXBlIE9iamVjdFxuICAgIEBzdGF0aWNcbiAgICBAc2luY2UgMy41LjBcbiAgICAqKi9cbiAgICBjc3NPcHRpb25zOiB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHJlbDogJ3N0eWxlc2hlZXQnXG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9jICAgICAgICAgOiBZLmNvbmZpZy5saW5rRG9jIHx8IFkuY29uZmlnLmRvYyxcbiAgICAgICAgcG9sbEludGVydmFsOiA1MFxuICAgIH0sXG5cbiAgICAvKipcbiAgICBEZWZhdWx0IG9wdGlvbnMgZm9yIEpTIHJlcXVlc3RzLiBPcHRpb25zIHNwZWNpZmllZCBoZXJlIHdpbGwgb3ZlcnJpZGUgZ2xvYmFsXG4gICAgZGVmYXVsdHMgZm9yIEpTIHJlcXVlc3RzLlxuXG4gICAgU2VlIHRoZSBgb3B0aW9uc2AgcHJvcGVydHkgZm9yIGFsbCBhdmFpbGFibGUgb3B0aW9ucy5cblxuICAgIEBwcm9wZXJ0eSBqc09wdGlvbnNcbiAgICBAdHlwZSBPYmplY3RcbiAgICBAc3RhdGljXG4gICAgQHNpbmNlIDMuNS4wXG4gICAgKiovXG4gICAganNPcHRpb25zOiB7XG4gICAgICAgIGF1dG9wdXJnZTogdHJ1ZSxcbiAgICAgICAgZG9jICAgICAgOiBZLmNvbmZpZy5zY3JpcHREb2MgfHwgWS5jb25maWcuZG9jXG4gICAgfSxcblxuICAgIC8qKlxuICAgIERlZmF1bHQgb3B0aW9ucyB0byB1c2UgZm9yIGFsbCByZXF1ZXN0cy5cblxuICAgIE5vdGUgdGhhdCB3aGlsZSBhbGwgYXZhaWxhYmxlIG9wdGlvbnMgYXJlIGRvY3VtZW50ZWQgaGVyZSBmb3IgZWFzZSBvZlxuICAgIGRpc2NvdmVyeSwgc29tZSBvcHRpb25zIChsaWtlIGNhbGxiYWNrIGZ1bmN0aW9ucykgb25seSBtYWtlIHNlbnNlIGF0IHRoZVxuICAgIHRyYW5zYWN0aW9uIGxldmVsLlxuXG4gICAgQ2FsbGJhY2sgZnVuY3Rpb25zIHNwZWNpZmllZCB2aWEgdGhlIG9wdGlvbnMgb2JqZWN0IG9yIHRoZSBgb3B0aW9uc2BcbiAgICBwYXJhbWV0ZXIgb2YgdGhlIGBjc3MoKWAsIGBqcygpYCwgb3IgYGxvYWQoKWAgbWV0aG9kcyB3aWxsIHJlY2VpdmUgdGhlXG4gICAgdHJhbnNhY3Rpb24gb2JqZWN0IGFzIGEgcGFyYW1ldGVyLiBTZWUgYFkuR2V0LlRyYW5zYWN0aW9uYCBmb3IgZGV0YWlscyBvblxuICAgIHRoZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGF2YWlsYWJsZSBvbiB0cmFuc2FjdGlvbnMuXG5cbiAgICBAc3RhdGljXG4gICAgQHNpbmNlIDMuNS4wXG4gICAgQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcblxuICAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW29wdGlvbnMuYXN5bmM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGxvYWQgc2NyaXB0c1xuICAgICAgICBhc3luY2hyb25vdXNseSwgbWVhbmluZyB0aGV5J3JlIHJlcXVlc3RlZCBpbiBwYXJhbGxlbCBhbmQgZXhlY3V0aW9uXG4gICAgICAgIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkLiBIYXMgbm8gZWZmZWN0IG9uIENTUywgc2luY2UgQ1NTIGlzIGFsd2F5c1xuICAgICAgICBsb2FkZWQgYXN5bmNocm9ub3VzbHkuXG5cbiAgICBAcHJvcGVydHkge09iamVjdH0gW29wdGlvbnMuYXR0cmlidXRlc10gSFRNTCBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyB0aGF0XG4gICAgICAgIHNob3VsZCBiZSBhZGRlZCB0byBpbnNlcnRlZCBub2Rlcy4gQnkgZGVmYXVsdCwgdGhlIGBjaGFyc2V0YCBhdHRyaWJ1dGVcbiAgICAgICAgd2lsbCBiZSBzZXQgdG8gXCJ1dGYtOFwiIGFuZCBub2RlcyB3aWxsIGJlIGdpdmVuIGFuIGF1dG8tZ2VuZXJhdGVkIGBpZGBcbiAgICAgICAgYXR0cmlidXRlLCBidXQgeW91IGNhbiBvdmVycmlkZSB0aGVzZSB3aXRoIHlvdXIgb3duIHZhbHVlcyBpZiBkZXNpcmVkLlxuXG4gICAgQHByb3BlcnR5IHtCb29sZWFufSBbb3B0aW9ucy5hdXRvcHVyZ2VdIFdoZXRoZXIgb3Igbm90IHRvIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgcHVyZ2UgaW5zZXJ0ZWQgbm9kZXMgYWZ0ZXIgdGhlIHB1cmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLiBUaGlzIGlzXG4gICAgICAgIGB0cnVlYCBieSBkZWZhdWx0IGZvciBKYXZhU2NyaXB0LCBidXQgYGZhbHNlYCBmb3IgQ1NTIHNpbmNlIHB1cmdpbmcgYVxuICAgICAgICBDU1Mgbm9kZSB3aWxsIGFsc28gcmVtb3ZlIGFueSBzdHlsaW5nIGFwcGxpZWQgYnkgdGhlIHJlZmVyZW5jZWQgZmlsZS5cblxuICAgIEBwcm9wZXJ0eSB7T2JqZWN0fSBbb3B0aW9ucy5jb250ZXh0XSBgdGhpc2Agb2JqZWN0IHRvIHVzZSB3aGVuIGNhbGxpbmdcbiAgICAgICAgY2FsbGJhY2sgZnVuY3Rpb25zLiBEZWZhdWx0cyB0byB0aGUgdHJhbnNhY3Rpb24gb2JqZWN0LlxuXG4gICAgQHByb3BlcnR5IHtNaXhlZH0gW29wdGlvbnMuZGF0YV0gQXJiaXRyYXJ5IGRhdGEgb2JqZWN0IHRvIHBhc3MgdG8gXCJvbipcIlxuICAgICAgICBjYWxsYmFja3MuXG5cbiAgICBAcHJvcGVydHkge0RvY3VtZW50fSBbb3B0aW9ucy5kb2NdIERvY3VtZW50IGludG8gd2hpY2ggbm9kZXMgc2hvdWxkIGJlXG4gICAgICAgIGluc2VydGVkLiBCeSBkZWZhdWx0LCB0aGUgY3VycmVudCBkb2N1bWVudCBpcyB1c2VkLlxuXG4gICAgQHByb3BlcnR5IHtIVE1MRWxlbWVudHxTdHJpbmd9IFtvcHRpb25zLmluc2VydEJlZm9yZV0gSFRNTCBlbGVtZW50IG9yIGlkXG4gICAgICAgIHN0cmluZyBvZiBhbiBlbGVtZW50IGJlZm9yZSB3aGljaCBhbGwgZ2VuZXJhdGVkIG5vZGVzIHNob3VsZCBiZVxuICAgICAgICBpbnNlcnRlZC4gSWYgbm90IHNwZWNpZmllZCwgR2V0IHdpbGwgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgdGhlIGJlc3RcbiAgICAgICAgcGxhY2UgdG8gaW5zZXJ0IG5vZGVzIGZvciBtYXhpbXVtIGNvbXBhdGliaWxpdHkuXG5cbiAgICBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkVuZF0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBhZnRlciBhIHRyYW5zYWN0aW9uXG4gICAgICAgIGlzIGNvbXBsZXRlLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQgc3VjY2VlZGVkIG9yIGZhaWxlZC5cblxuICAgIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtvcHRpb25zLm9uRmFpbHVyZV0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBhZnRlciBhXG4gICAgICAgIHRyYW5zYWN0aW9uIGZhaWxzLCB0aW1lcyBvdXQsIG9yIGlzIGFib3J0ZWQuXG5cbiAgICBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb3B0aW9ucy5vblByb2dyZXNzXSBDYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIGVhY2hcbiAgICAgICAgaW5kaXZpZHVhbCByZXF1ZXN0IGluIGEgdHJhbnNhY3Rpb24gZWl0aGVyIHN1Y2NlZWRzIG9yIGZhaWxzLlxuXG4gICAgQHByb3BlcnR5IHtGdW5jdGlvbn0gW29wdGlvbnMub25TdWNjZXNzXSBDYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIGFcbiAgICAgICAgdHJhbnNhY3Rpb24gY29tcGxldGVzIHN1Y2Nlc3NmdWxseSB3aXRoIG5vIGVycm9ycy4gTm90ZSB0aGF0IGluIGJyb3dzZXJzXG4gICAgICAgIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgYGVycm9yYCBldmVudCBvbiBDU1MgYDxsaW5rPmAgbm9kZXMsIGEgZmFpbGVkIENTU1xuICAgICAgICByZXF1ZXN0IG1heSBzdGlsbCBiZSByZXBvcnRlZCBhcyBhIHN1Y2Nlc3MgYmVjYXVzZSBpbiB0aGVzZSBicm93c2Vyc1xuICAgICAgICBpdCBjYW4gYmUgZGlmZmljdWx0IG9yIGltcG9zc2libGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBzdWNjZXNzIGFuZFxuICAgICAgICBmYWlsdXJlIGZvciBDU1MgcmVzb3VyY2VzLlxuXG4gICAgQHByb3BlcnR5IHtGdW5jdGlvbn0gW29wdGlvbnMub25UaW1lb3V0XSBDYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIGFcbiAgICAgICAgdHJhbnNhY3Rpb24gdGltZXMgb3V0LlxuXG4gICAgQHByb3BlcnR5IHtOdW1iZXJ9IFtvcHRpb25zLnBvbGxJbnRlcnZhbD01MF0gUG9sbGluZyBpbnRlcnZhbCAoaW5cbiAgICAgICAgbWlsbGlzZWNvbmRzKSBmb3IgZGV0ZWN0aW5nIENTUyBsb2FkIGNvbXBsZXRpb24gaW4gYnJvd3NlcnMgdGhhdCBkb24ndFxuICAgICAgICBzdXBwb3J0IHRoZSBgbG9hZGAgZXZlbnQgb24gYDxsaW5rPmAgbm9kZXMuIFRoaXMgaXNuJ3QgdXNlZCBmb3JcbiAgICAgICAgSmF2YVNjcmlwdC5cblxuICAgIEBwcm9wZXJ0eSB7TnVtYmVyfSBbb3B0aW9ucy5wdXJnZXRocmVzaG9sZD0yMF0gTnVtYmVyIG9mIG5vZGVzIHRvIGluc2VydFxuICAgICAgICBiZWZvcmUgdHJpZ2dlcmluZyBhbiBhdXRvbWF0aWMgcHVyZ2Ugd2hlbiBgYXV0b3B1cmdlYCBpcyBgdHJ1ZWAuXG5cbiAgICBAcHJvcGVydHkge051bWJlcn0gW29wdGlvbnMudGltZW91dF0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZVxuICAgICAgICBhYm9ydGluZyBhIHRyYW5zYWN0aW9uLiBXaGVuIGEgdGltZW91dCBvY2N1cnMsIHRoZSBgb25UaW1lb3V0YCBjYWxsYmFja1xuICAgICAgICBpcyBjYWxsZWQsIGZvbGxvd2VkIGJ5IGBvbkZhaWx1cmVgIGFuZCBmaW5hbGx5IGBvbkVuZGAuIEJ5IGRlZmF1bHQsXG4gICAgICAgIHRoZXJlIGlzIG5vIHRpbWVvdXQuXG5cbiAgICBAcHJvcGVydHkge1N0cmluZ30gW29wdGlvbnMudHlwZV0gUmVzb3VyY2UgdHlwZSAoXCJjc3NcIiBvciBcImpzXCIpLiBUaGlzIG9wdGlvblxuICAgICAgICBpcyBzZXQgYXV0b21hdGljYWxseSBieSB0aGUgYGNzcygpYCBhbmQgYGpzKClgIGZ1bmN0aW9ucyBhbmQgd2lsbCBiZVxuICAgICAgICBpZ25vcmVkIHRoZXJlLCBidXQgbWF5IGJlIHVzZWZ1bCB3aGVuIHVzaW5nIHRoZSBgbG9hZCgpYCBmdW5jdGlvbi4gSWZcbiAgICAgICAgbm90IHNwZWNpZmllZCwgdGhlIHR5cGUgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZSBVUkwsIGRlZmF1bHRpbmcgdG9cbiAgICAgICAgXCJqc1wiIGlmIHRoZSBVUkwgZG9lc24ndCBjb250YWluIGEgcmVjb2duaXphYmxlIGZpbGUgZXh0ZW5zaW9uLlxuICAgICoqL1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgY2hhcnNldDogJ3V0Zi04J1xuICAgICAgICB9LFxuXG4gICAgICAgIHB1cmdldGhyZXNob2xkOiAyMFxuICAgIH0sXG5cbiAgICAvLyAtLSBQcm90ZWN0ZWQgUHJvcGVydGllcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICBSZWdleCB0aGF0IG1hdGNoZXMgYSBDU1MgVVJMLiBVc2VkIHRvIGd1ZXNzIHRoZSBmaWxlIHR5cGUgd2hlbiBpdCdzIG5vdFxuICAgIHNwZWNpZmllZC5cblxuICAgIEBwcm9wZXJ0eSBSRUdFWF9DU1NcbiAgICBAdHlwZSBSZWdFeHBcbiAgICBAZmluYWxcbiAgICBAcHJvdGVjdGVkXG4gICAgQHN0YXRpY1xuICAgIEBzaW5jZSAzLjUuMFxuICAgICoqL1xuICAgIFJFR0VYX0NTUzogL1xcLmNzcyg/Ols/O10uKik/JC9pLFxuXG4gICAgLyoqXG4gICAgUmVnZXggdGhhdCBtYXRjaGVzIGEgSlMgVVJMLiBVc2VkIHRvIGd1ZXNzIHRoZSBmaWxlIHR5cGUgd2hlbiBpdCdzIG5vdFxuICAgIHNwZWNpZmllZC5cblxuICAgIEBwcm9wZXJ0eSBSRUdFWF9KU1xuICAgIEB0eXBlIFJlZ0V4cFxuICAgIEBmaW5hbFxuICAgIEBwcm90ZWN0ZWRcbiAgICBAc3RhdGljXG4gICAgQHNpbmNlIDMuNS4wXG4gICAgKiovXG4gICAgUkVHRVhfSlMgOiAvXFwuanMoPzpbPztdLiopPyQvaSxcblxuICAgIC8qKlxuICAgIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGVudmlyb25tZW50LCBzdWNoIGFzIHdoYXQgc2NyaXB0IGFuZFxuICAgIGxpbmsgaW5qZWN0aW9uIGZlYXR1cmVzIGl0IHN1cHBvcnRzLlxuXG4gICAgVGhpcyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcG9wdWxhdGVkIHRoZSBmaXJzdCB0aW1lIHRoZSBgX2dldEVudigpYCBtZXRob2RcbiAgICBpcyBjYWxsZWQuXG5cbiAgICBAcHJvcGVydHkgX2VudlxuICAgIEB0eXBlIE9iamVjdFxuICAgIEBwcm90ZWN0ZWRcbiAgICBAc3RhdGljXG4gICAgQHNpbmNlIDMuNS4wXG4gICAgKiovXG5cbiAgICAvKipcbiAgICBNYXBwaW5nIG9mIGRvY3VtZW50IF95dWlkIHN0cmluZ3MgdG8gPGhlYWQ+IG9yIDxiYXNlPiBub2RlIHJlZmVyZW5jZXMgc28gd2VcbiAgICBkb24ndCBoYXZlIHRvIGxvb2sgdGhlIG5vZGUgdXAgZWFjaCB0aW1lIHdlIHdhbnQgdG8gaW5zZXJ0IGEgcmVxdWVzdCBub2RlLlxuXG4gICAgQHByb3BlcnR5IF9pbnNlcnRDYWNoZVxuICAgIEB0eXBlIE9iamVjdFxuICAgIEBwcm90ZWN0ZWRcbiAgICBAc3RhdGljXG4gICAgQHNpbmNlIDMuNS4wXG4gICAgKiovXG4gICAgX2luc2VydENhY2hlOiB7fSxcblxuICAgIC8qKlxuICAgIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50bHkgcGVuZGluZyB0cmFuc2FjdGlvbiwgaWYgYW55LlxuXG4gICAgVGhpcyBpcyBhY3R1YWxseSBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczogYGNhbGxiYWNrYCwgY29udGFpbmluZyB0aGVcbiAgICBvcHRpb25hbCBjYWxsYmFjayBwYXNzZWQgdG8gYGNzcygpYCwgYGxvYWQoKWAsIG9yIGBqcygpYDsgYW5kIGB0cmFuc2FjdGlvbmAsXG4gICAgY29udGFpbmluZyB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uIGluc3RhbmNlLlxuXG4gICAgQHByb3BlcnR5IF9wZW5kaW5nXG4gICAgQHR5cGUgT2JqZWN0XG4gICAgQHByb3RlY3RlZFxuICAgIEBzdGF0aWNcbiAgICBAc2luY2UgMy41LjBcbiAgICAqKi9cbiAgICBfcGVuZGluZzogbnVsbCxcblxuICAgIC8qKlxuICAgIEhUTUwgbm9kZXMgZWxpZ2libGUgdG8gYmUgcHVyZ2VkIG5leHQgdGltZSBhdXRvcHVyZ2UgaXMgdHJpZ2dlcmVkLlxuXG4gICAgQHByb3BlcnR5IF9wdXJnZU5vZGVzXG4gICAgQHR5cGUgSFRNTEVsZW1lbnRbXVxuICAgIEBwcm90ZWN0ZWRcbiAgICBAc3RhdGljXG4gICAgQHNpbmNlIDMuNS4wXG4gICAgKiovXG4gICAgX3B1cmdlTm9kZXM6IFtdLFxuXG4gICAgLyoqXG4gICAgUXVldWVkIHRyYW5zYWN0aW9ucyBhbmQgYXNzb2NpYXRlZCBjYWxsYmFja3MuXG5cbiAgICBAcHJvcGVydHkgX3F1ZXVlXG4gICAgQHR5cGUgT2JqZWN0W11cbiAgICBAcHJvdGVjdGVkXG4gICAgQHN0YXRpY1xuICAgIEBzaW5jZSAzLjUuMFxuICAgICoqL1xuICAgIF9xdWV1ZTogW10sXG5cbiAgICAvLyAtLSBQdWJsaWMgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICBBYm9ydHMgdGhlIHNwZWNpZmllZCB0cmFuc2FjdGlvbi5cblxuICAgIFRoaXMgd2lsbCBjYXVzZSB0aGUgdHJhbnNhY3Rpb24ncyBgb25GYWlsdXJlYCBjYWxsYmFjayB0byBiZSBjYWxsZWQgYW5kXG4gICAgd2lsbCBwcmV2ZW50IGFueSBuZXcgc2NyaXB0IGFuZCBsaW5rIG5vZGVzIGZyb20gYmVpbmcgYWRkZWQgdG8gdGhlIGRvY3VtZW50LFxuICAgIGJ1dCBhbnkgcmVzb3VyY2VzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkIHdpbGwgY29udGludWUgbG9hZGluZ1xuICAgICh0aGVyZSdzIG5vIHNhZmUgd2F5IHRvIHByZXZlbnQgdGhpcywgdW5mb3J0dW5hdGVseSkuXG5cbiAgICAqTm90ZToqIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYXMgb2YgMy41LjAsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYVxuICAgIGZ1dHVyZSB2ZXJzaW9uIG9mIFlVSS4gVXNlIHRoZSB0cmFuc2FjdGlvbi1sZXZlbCBgYWJvcnQoKWAgbWV0aG9kIGluc3RlYWQuXG5cbiAgICBAbWV0aG9kIGFib3J0XG4gICAgQHBhcmFtIHtHZXQuVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIGFib3J0LlxuICAgIEBkZXByZWNhdGVkIFVzZSB0aGUgYGFib3J0KClgIG1ldGhvZCBvbiB0aGUgdHJhbnNhY3Rpb24gaW5zdGVhZC5cbiAgICBAc3RhdGljXG4gICAgKiovXG4gICAgYWJvcnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgaSwgaWQsIGl0ZW0sIGxlbiwgcGVuZGluZztcblxuXG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uYWJvcnQpIHtcbiAgICAgICAgICAgIGlkICAgICAgICAgID0gdHJhbnNhY3Rpb247XG4gICAgICAgICAgICBwZW5kaW5nICAgICA9IHRoaXMuX3BlbmRpbmc7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChwZW5kaW5nICYmIHBlbmRpbmcudHJhbnNhY3Rpb24uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gICA9IHBlbmRpbmcudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLl9xdWV1ZVtpXS50cmFuc2FjdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNhY3Rpb24gJiYgdHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgTG9hZHMgb25lIG9yIG1vcmUgQ1NTIGZpbGVzLlxuXG4gICAgVGhlIF91cmxzXyBwYXJhbWV0ZXIgbWF5IGJlIHByb3ZpZGVkIGFzIGEgVVJMIHN0cmluZywgYSByZXF1ZXN0IG9iamVjdCxcbiAgICBvciBhbiBhcnJheSBvZiBVUkwgc3RyaW5ncyBhbmQvb3IgcmVxdWVzdCBvYmplY3RzLlxuXG4gICAgQSByZXF1ZXN0IG9iamVjdCBpcyBqdXN0IGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgYHVybGAgcHJvcGVydHkgYW5kIHplcm9cbiAgICBvciBtb3JlIG9wdGlvbnMgdGhhdCBzaG91bGQgYXBwbHkgc3BlY2lmaWNhbGx5IHRvIHRoYXQgcmVxdWVzdC5cbiAgICBSZXF1ZXN0LXNwZWNpZmljIG9wdGlvbnMgdGFrZSBwcmlvcml0eSBvdmVyIHRyYW5zYWN0aW9uLWxldmVsIG9wdGlvbnMgYW5kXG4gICAgZGVmYXVsdCBvcHRpb25zLlxuXG4gICAgVVJMcyBtYXkgYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUsIGFuZCBkbyBub3QgaGF2ZSB0byBoYXZlIHRoZSBzYW1lIG9yaWdpblxuICAgIGFzIHRoZSBjdXJyZW50IHBhZ2UuXG5cbiAgICBUaGUgYG9wdGlvbnNgIHBhcmFtZXRlciBtYXkgYmUgb21pdHRlZCBjb21wbGV0ZWx5IGFuZCBhIGNhbGxiYWNrIHBhc3NlZCBpblxuICAgIGl0cyBwbGFjZSwgaWYgZGVzaXJlZC5cblxuICAgIEBleGFtcGxlXG5cbiAgICAgICAgLy8gTG9hZCBhIHNpbmdsZSBDU1MgZmlsZSBhbmQgbG9nIGEgbWVzc2FnZSBvbiBjb21wbGV0aW9uLlxuICAgICAgICBZLkdldC5jc3MoJ2Zvby5jc3MnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMb2FkIG11bHRpcGxlIENTUyBmaWxlcyBhbmQgbG9nIGEgbWVzc2FnZSB3aGVuIGFsbCBoYXZlIGZpbmlzaGVkXG4gICAgICAgIC8vIGxvYWRpbmcuXG4gICAgICAgIHZhciB1cmxzID0gWydmb28uY3NzJywgJ2h0dHA6Ly9leGFtcGxlLmNvbS9iYXIuY3NzJywgJ2Jhei9xdXV4LmNzcyddO1xuXG4gICAgICAgIFkuR2V0LmNzcyh1cmxzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTcGVjaWZ5IHRyYW5zYWN0aW9uLWxldmVsIG9wdGlvbnMsIHdoaWNoIHdpbGwgYXBwbHkgdG8gYWxsIHJlcXVlc3RzXG4gICAgICAgIC8vIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIFkuR2V0LmNzcyh1cmxzLCB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7J2NsYXNzJzogJ215LWNzcyd9LFxuICAgICAgICAgICAgdGltZW91dCAgIDogNTAwMFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTcGVjaWZ5IHBlci1yZXF1ZXN0IG9wdGlvbnMsIHdoaWNoIG92ZXJyaWRlIHRyYW5zYWN0aW9uLWxldmVsIGFuZFxuICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICAgIFkuR2V0LmNzcyhbXG4gICAgICAgICAgICB7dXJsOiAnZm9vLmNzcycsIGF0dHJpYnV0ZXM6IHtpZDogJ2Zvbyd9fSxcbiAgICAgICAgICAgIHt1cmw6ICdiYXIuY3NzJywgYXR0cmlidXRlczoge2lkOiAnYmFyJywgY2hhcnNldDogJ2lzby04ODU5LTEnfX1cbiAgICAgICAgXSk7XG5cbiAgICBAbWV0aG9kIGNzc1xuICAgIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheX0gdXJscyBVUkwgc3RyaW5nLCByZXF1ZXN0IG9iamVjdCwgb3IgYXJyYXlcbiAgICAgICAgb2YgVVJMcyBhbmQvb3IgcmVxdWVzdCBvYmplY3RzIHRvIGxvYWQuXG4gICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGlzIHRyYW5zYWN0aW9uLiBTZWUgdGhlXG4gICAgICAgIGBZLkdldC5vcHRpb25zYCBwcm9wZXJ0eSBmb3IgYSBjb21wbGV0ZSBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zLlxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGNvbXBsZXRpb24uXG4gICAgICAgIFRoaXMgaXMgYSBnZW5lcmFsIGNhbGxiYWNrIGFuZCB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgYW55IG1vcmUgZ3JhbnVsYXJcbiAgICAgICAgY2FsbGJhY2tzIChgb25TdWNjZXNzYCwgYG9uRmFpbHVyZWAsIGV0Yy4pIHNwZWNpZmllZCBpbiB0aGUgYG9wdGlvbnNgXG4gICAgICAgIG9iamVjdC5cblxuICAgICAgICBAcGFyYW0ge0FycmF5fG51bGx9IGNhbGxiYWNrLmVyciBBcnJheSBvZiBlcnJvcnMgdGhhdCBvY2N1cnJlZCBkdXJpbmdcbiAgICAgICAgICAgIHRoZSB0cmFuc2FjdGlvbiwgb3IgYG51bGxgIG9uIHN1Y2Nlc3MuXG4gICAgICAgIEBwYXJhbSB7R2V0LlRyYW5zYWN0aW9ufSBjYWxsYmFjay50cmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBvYmplY3QuXG5cbiAgICBAcmV0dXJuIHtHZXQuVHJhbnNhY3Rpb259IFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICBAc3RhdGljXG4gICAgKiovXG4gICAgY3NzOiBmdW5jdGlvbiAodXJscywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQoJ2NzcycsIHVybHMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgTG9hZHMgb25lIG9yIG1vcmUgSmF2YVNjcmlwdCByZXNvdXJjZXMuXG5cbiAgICBUaGUgX3VybHNfIHBhcmFtZXRlciBtYXkgYmUgcHJvdmlkZWQgYXMgYSBVUkwgc3RyaW5nLCBhIHJlcXVlc3Qgb2JqZWN0LFxuICAgIG9yIGFuIGFycmF5IG9mIFVSTCBzdHJpbmdzIGFuZC9vciByZXF1ZXN0IG9iamVjdHMuXG5cbiAgICBBIHJlcXVlc3Qgb2JqZWN0IGlzIGp1c3QgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBgdXJsYCBwcm9wZXJ0eSBhbmQgemVyb1xuICAgIG9yIG1vcmUgb3B0aW9ucyB0aGF0IHNob3VsZCBhcHBseSBzcGVjaWZpY2FsbHkgdG8gdGhhdCByZXF1ZXN0LlxuICAgIFJlcXVlc3Qtc3BlY2lmaWMgb3B0aW9ucyB0YWtlIHByaW9yaXR5IG92ZXIgdHJhbnNhY3Rpb24tbGV2ZWwgb3B0aW9ucyBhbmRcbiAgICBkZWZhdWx0IG9wdGlvbnMuXG5cbiAgICBVUkxzIG1heSBiZSByZWxhdGl2ZSBvciBhYnNvbHV0ZSwgYW5kIGRvIG5vdCBoYXZlIHRvIGhhdmUgdGhlIHNhbWUgb3JpZ2luXG4gICAgYXMgdGhlIGN1cnJlbnQgcGFnZS5cblxuICAgIFRoZSBgb3B0aW9uc2AgcGFyYW1ldGVyIG1heSBiZSBvbWl0dGVkIGNvbXBsZXRlbHkgYW5kIGEgY2FsbGJhY2sgcGFzc2VkIGluXG4gICAgaXRzIHBsYWNlLCBpZiBkZXNpcmVkLlxuXG4gICAgU2NyaXB0cyB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5J3JlIHNwZWNpZmllZCB1bmxlc3MgdGhlIGBhc3luY2BcbiAgICBvcHRpb24gaXMgYHRydWVgLCBpbiB3aGljaCBjYXNlIHRoZXknbGwgYmUgbG9hZGVkIGluIHBhcmFsbGVsIGFuZCBleGVjdXRlZFxuICAgIGluIHdoYXRldmVyIG9yZGVyIHRoZXkgZmluaXNoIGxvYWRpbmcuXG5cbiAgICBAZXhhbXBsZVxuXG4gICAgICAgIC8vIExvYWQgYSBzaW5nbGUgSlMgZmlsZSBhbmQgbG9nIGEgbWVzc2FnZSBvbiBjb21wbGV0aW9uLlxuICAgICAgICBZLkdldC5qcygnZm9vLmpzJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTG9hZCBtdWx0aXBsZSBKUyBmaWxlcywgZXhlY3V0ZSB0aGVtIGluIG9yZGVyLCBhbmQgbG9nIGEgbWVzc2FnZSB3aGVuXG4gICAgICAgIC8vIGFsbCBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgIHZhciB1cmxzID0gWydmb28uanMnLCAnaHR0cDovL2V4YW1wbGUuY29tL2Jhci5qcycsICdiYXovcXV1eC5qcyddO1xuXG4gICAgICAgIFkuR2V0LmpzKHVybHMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNwZWNpZnkgdHJhbnNhY3Rpb24tbGV2ZWwgb3B0aW9ucywgd2hpY2ggd2lsbCBhcHBseSB0byBhbGwgcmVxdWVzdHNcbiAgICAgICAgLy8gd2l0aGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgWS5HZXQuanModXJscywge1xuICAgICAgICAgICAgYXR0cmlidXRlczogeydjbGFzcyc6ICdteS1qcyd9LFxuICAgICAgICAgICAgdGltZW91dCAgIDogNTAwMFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTcGVjaWZ5IHBlci1yZXF1ZXN0IG9wdGlvbnMsIHdoaWNoIG92ZXJyaWRlIHRyYW5zYWN0aW9uLWxldmVsIGFuZFxuICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICAgIFkuR2V0LmpzKFtcbiAgICAgICAgICAgIHt1cmw6ICdmb28uanMnLCBhdHRyaWJ1dGVzOiB7aWQ6ICdmb28nfX0sXG4gICAgICAgICAgICB7dXJsOiAnYmFyLmpzJywgYXR0cmlidXRlczoge2lkOiAnYmFyJywgY2hhcnNldDogJ2lzby04ODU5LTEnfX1cbiAgICAgICAgXSk7XG5cbiAgICBAbWV0aG9kIGpzXG4gICAgQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEFycmF5fSB1cmxzIFVSTCBzdHJpbmcsIHJlcXVlc3Qgb2JqZWN0LCBvciBhcnJheVxuICAgICAgICBvZiBVUkxzIGFuZC9vciByZXF1ZXN0IG9iamVjdHMgdG8gbG9hZC5cbiAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoaXMgdHJhbnNhY3Rpb24uIFNlZSB0aGVcbiAgICAgICAgYFkuR2V0Lm9wdGlvbnNgIHByb3BlcnR5IGZvciBhIGNvbXBsZXRlIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbnMuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gY29tcGxldGlvbi5cbiAgICAgICAgVGhpcyBpcyBhIGdlbmVyYWwgY2FsbGJhY2sgYW5kIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBhbnkgbW9yZSBncmFudWxhclxuICAgICAgICBjYWxsYmFja3MgKGBvblN1Y2Nlc3NgLCBgb25GYWlsdXJlYCwgZXRjLikgc3BlY2lmaWVkIGluIHRoZSBgb3B0aW9uc2BcbiAgICAgICAgb2JqZWN0LlxuXG4gICAgICAgIEBwYXJhbSB7QXJyYXl8bnVsbH0gY2FsbGJhY2suZXJyIEFycmF5IG9mIGVycm9ycyB0aGF0IG9jY3VycmVkIGR1cmluZ1xuICAgICAgICAgICAgdGhlIHRyYW5zYWN0aW9uLCBvciBgbnVsbGAgb24gc3VjY2Vzcy5cbiAgICAgICAgQHBhcmFtIHtHZXQuVHJhbnNhY3Rpb259IGNhbGxiYWNrLnRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIG9iamVjdC5cblxuICAgIEByZXR1cm4ge0dldC5UcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgIEBzaW5jZSAzLjUuMFxuICAgIEBzdGF0aWNcbiAgICAqKi9cbiAgICBqczogZnVuY3Rpb24gKHVybHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkKCdqcycsIHVybHMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgTG9hZHMgb25lIG9yIG1vcmUgQ1NTIGFuZC9vciBKYXZhU2NyaXB0IHJlc291cmNlcyBpbiB0aGUgc2FtZSB0cmFuc2FjdGlvbi5cblxuICAgIFVzZSB0aGlzIG1ldGhvZCB3aGVuIHlvdSB3YW50IHRvIGxvYWQgYm90aCBDU1MgYW5kIEphdmFTY3JpcHQgaW4gYSBzaW5nbGVcbiAgICB0cmFuc2FjdGlvbiBhbmQgYmUgbm90aWZpZWQgd2hlbiBhbGwgcmVxdWVzdGVkIFVSTHMgaGF2ZSBmaW5pc2hlZCBsb2FkaW5nLFxuICAgIHJlZ2FyZGxlc3Mgb2YgdHlwZS5cblxuICAgIEJlaGF2aW9yIGFuZCBvcHRpb25zIGFyZSB0aGUgc2FtZSBhcyBmb3IgdGhlIGBjc3MoKWAgYW5kIGBqcygpYCBtZXRob2RzLiBJZlxuICAgIGEgcmVzb3VyY2UgdHlwZSBpc24ndCBzcGVjaWZpZWQgaW4gcGVyLXJlcXVlc3Qgb3B0aW9ucyBvciB0cmFuc2FjdGlvbi1sZXZlbFxuICAgIG9wdGlvbnMsIEdldCB3aWxsIGd1ZXNzIHRoZSBmaWxlIHR5cGUgYmFzZWQgb24gdGhlIFVSTCdzIGV4dGVuc2lvbiAoYC5jc3NgXG4gICAgb3IgYC5qc2AsIHdpdGggb3Igd2l0aG91dCBhIGZvbGxvd2luZyBxdWVyeSBzdHJpbmcpLiBJZiB0aGUgZmlsZSB0eXBlIGNhbid0XG4gICAgYmUgZ3Vlc3NlZCBmcm9tIHRoZSBVUkwsIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZCBhbmQgR2V0IHdpbGwgYXNzdW1lIHRoZVxuICAgIFVSTCBpcyBhIEphdmFTY3JpcHQgcmVzb3VyY2UuXG5cbiAgICBAZXhhbXBsZVxuXG4gICAgICAgIC8vIExvYWQgYm90aCBDU1MgYW5kIEpTIGZpbGVzIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uLCBhbmQgbG9nIGEgbWVzc2FnZVxuICAgICAgICAvLyB3aGVuIGFsbCBmaWxlcyBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgIFkuR2V0LmxvYWQoWydmb28uY3NzJywgJ2Jhci5qcycsICdiYXouY3NzJ10sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgQG1ldGhvZCBsb2FkXG4gICAgQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEFycmF5fSB1cmxzIFVSTCBzdHJpbmcsIHJlcXVlc3Qgb2JqZWN0LCBvciBhcnJheVxuICAgICAgICBvZiBVUkxzIGFuZC9vciByZXF1ZXN0IG9iamVjdHMgdG8gbG9hZC5cbiAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoaXMgdHJhbnNhY3Rpb24uIFNlZSB0aGVcbiAgICAgICAgYFkuR2V0Lm9wdGlvbnNgIHByb3BlcnR5IGZvciBhIGNvbXBsZXRlIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbnMuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gY29tcGxldGlvbi5cbiAgICAgICAgVGhpcyBpcyBhIGdlbmVyYWwgY2FsbGJhY2sgYW5kIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBhbnkgbW9yZSBncmFudWxhclxuICAgICAgICBjYWxsYmFja3MgKGBvblN1Y2Nlc3NgLCBgb25GYWlsdXJlYCwgZXRjLikgc3BlY2lmaWVkIGluIHRoZSBgb3B0aW9uc2BcbiAgICAgICAgb2JqZWN0LlxuXG4gICAgICAgIEBwYXJhbSB7QXJyYXl8bnVsbH0gZXJyIEFycmF5IG9mIGVycm9ycyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGVcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBvciBgbnVsbGAgb24gc3VjY2Vzcy5cbiAgICAgICAgQHBhcmFtIHtHZXQuVHJhbnNhY3Rpb259IFRyYW5zYWN0aW9uIG9iamVjdC5cblxuICAgIEByZXR1cm4ge0dldC5UcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgIEBzaW5jZSAzLjUuMFxuICAgIEBzdGF0aWNcbiAgICAqKi9cbiAgICBsb2FkOiBmdW5jdGlvbiAodXJscywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQobnVsbCwgdXJscywgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvLyAtLSBQcm90ZWN0ZWQgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICBUcmlnZ2VycyBhbiBhdXRvbWF0aWMgcHVyZ2UgaWYgdGhlIHB1cmdlIHRocmVzaG9sZCBoYXMgYmVlbiByZWFjaGVkLlxuXG4gICAgQG1ldGhvZCBfYXV0b1B1cmdlXG4gICAgQHBhcmFtIHtOdW1iZXJ9IHRocmVzaG9sZCBQdXJnZSB0aHJlc2hvbGQgdG8gdXNlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgQHByb3RlY3RlZFxuICAgIEBzaW5jZSAzLjUuMFxuICAgIEBzdGF0aWNcbiAgICAqKi9cbiAgICBfYXV0b1B1cmdlOiBmdW5jdGlvbiAodGhyZXNob2xkKSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGQgJiYgdGhpcy5fcHVyZ2VOb2Rlcy5sZW5ndGggPj0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICB0aGlzLl9wdXJnZSh0aGlzLl9wdXJnZU5vZGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICBQb3B1bGF0ZXMgdGhlIGBfZW52YCBwcm9wZXJ0eSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50XG4gICAgZW52aXJvbm1lbnQuXG5cbiAgICBAbWV0aG9kIF9nZXRFbnZcbiAgICBAcmV0dXJuIHtPYmplY3R9IEVudmlyb25tZW50IGluZm9ybWF0aW9uLlxuICAgIEBwcm90ZWN0ZWRcbiAgICBAc2luY2UgMy41LjBcbiAgICBAc3RhdGljXG4gICAgKiovXG4gICAgX2dldEVudjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9jID0gWS5jb25maWcuZG9jLFxuICAgICAgICAgICAgdWEgID0gWS5VQTtcblxuICAgICAgICAvLyBOb3RlOiBzb21lIG9mIHRoZXNlIGNoZWNrcyByZXF1aXJlIGJyb3dzZXIgc25pZmZzIHNpbmNlIGl0J3Mgbm90XG4gICAgICAgIC8vIGZlYXNpYmxlIHRvIGxvYWQgdGVzdCBmaWxlcyBvbiBldmVyeSBwYWdldmlldyBqdXN0IHRvIHBlcmZvcm0gYVxuICAgICAgICAvLyBmZWF0dXJlIHRlc3QuIEknbSBzb3JyeSBpZiB0aGlzIG1ha2VzIHlvdSBzYWQuXG4gICAgICAgIHJldHVybiAodGhpcy5fZW52ID0ge1xuXG4gICAgICAgICAgICAvLyBUcnVlIGlmIHRoaXMgaXMgYSBicm93c2VyIHRoYXQgc3VwcG9ydHMgZGlzYWJsaW5nIGFzeW5jIG1vZGUgb25cbiAgICAgICAgICAgIC8vIGR5bmFtaWNhbGx5IGNyZWF0ZWQgc2NyaXB0IG5vZGVzLiBTZWVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL0VuL0hUTUwvRWxlbWVudC9TY3JpcHQjQXR0cmlidXRlc1xuXG4gICAgICAgICAgICAvLyBJRTEwIGRvZXNuJ3QgcmV0dXJuIHRydWUgZm9yIHRoZSBNRE4gZmVhdHVyZSB0ZXN0LCBzbyBzZXR0aW5nIGl0IGV4cGxpY2l0bHksXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIGFzeW5jIGJ5IGRlZmF1bHQsIGFuZCBhbGxvd3MgeW91IHRvIGRpc2FibGUgYXN5bmMgYnkgc2V0dGluZyBpdCB0byBmYWxzZVxuICAgICAgICAgICAgYXN5bmM6IChkb2MgJiYgZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLmFzeW5jID09PSB0cnVlKSB8fCAodWEuaWUgPj0gMTApLFxuXG4gICAgICAgICAgICAvLyBUcnVlIGlmIHRoaXMgYnJvd3NlciBmaXJlcyBhbiBldmVudCB3aGVuIGEgZHluYW1pY2FsbHkgaW5qZWN0ZWRcbiAgICAgICAgICAgIC8vIGxpbmsgbm9kZSBmYWlscyB0byBsb2FkLiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGZvciBGaXJlZm94IDkrXG4gICAgICAgICAgICAvLyBhbmQgV2ViS2l0IDUzNS4yNCtcbiAgICAgICAgICAgIGNzc0ZhaWw6IHVhLmdlY2tvID49IDkgfHwgdWEuY29tcGFyZVZlcnNpb25zKHVhLndlYmtpdCwgNTM1LjI0KSA+PSAwLFxuXG4gICAgICAgICAgICAvLyBUcnVlIGlmIHRoaXMgYnJvd3NlciBmaXJlcyBhbiBldmVudCB3aGVuIGEgZHluYW1pY2FsbHkgaW5qZWN0ZWRcbiAgICAgICAgICAgIC8vIGxpbmsgbm9kZSBmaW5pc2hlcyBsb2FkaW5nLiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGZvciBJRSwgT3BlcmEsXG4gICAgICAgICAgICAvLyBGaXJlZm94IDkrLCBhbmQgV2ViS2l0IDUzNS4yNCsuIE5vdGUgdGhhdCBJRSB2ZXJzaW9ucyA8OSBmaXJlIHRoZVxuICAgICAgICAgICAgLy8gRE9NIDAgXCJvbmxvYWRcIiBldmVudCwgYnV0IG5vdCBcImxvYWRcIi4gQWxsIHZlcnNpb25zIG9mIElFIGZpcmVcbiAgICAgICAgICAgIC8vIFwib25sb2FkXCIuXG4gICAgICAgICAgICAvLyBkYXZnbGFzczogU2VlbXMgdGhhdCBDaHJvbWUgb24gQW5kcm9pZCBuZWVkcyB0aGlzIHRvIGJlIGZhbHNlLlxuICAgICAgICAgICAgY3NzTG9hZDogKFxuICAgICAgICAgICAgICAgICAgICAoIXVhLmdlY2tvICYmICF1YS53ZWJraXQpIHx8IHVhLmdlY2tvID49IDkgfHxcbiAgICAgICAgICAgICAgICAgICAgdWEuY29tcGFyZVZlcnNpb25zKHVhLndlYmtpdCwgNTM1LjI0KSA+PSAwXG4gICAgICAgICAgICAgICAgKSAmJiAhKHVhLmNocm9tZSAmJiB1YS5jaHJvbWUgPD0gMTgpLFxuXG4gICAgICAgICAgICAvLyBUcnVlIGlmIHRoaXMgYnJvd3NlciBwcmVzZXJ2ZXMgc2NyaXB0IGV4ZWN1dGlvbiBvcmRlciB3aGlsZVxuICAgICAgICAgICAgLy8gbG9hZGluZyBzY3JpcHRzIGluIHBhcmFsbGVsIGFzIGxvbmcgYXMgdGhlIHNjcmlwdCBub2RlJ3MgYGFzeW5jYFxuICAgICAgICAgICAgLy8gYXR0cmlidXRlIGlzIHNldCB0byBmYWxzZSB0byBleHBsaWNpdGx5IGRpc2FibGUgYXN5bmMgZXhlY3V0aW9uLlxuICAgICAgICAgICAgcHJlc2VydmVzU2NyaXB0T3JkZXI6ICEhKHVhLmdlY2tvIHx8IHVhLm9wZXJhIHx8ICh1YS5pZSAmJiB1YS5pZSA+PSAxMCkpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0VHJhbnNhY3Rpb246IGZ1bmN0aW9uICh1cmxzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0cyA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCByZXEsIHVybDtcblxuICAgICAgICBpZiAoIUxhbmcuaXNBcnJheSh1cmxzKSkge1xuICAgICAgICAgICAgdXJscyA9IFt1cmxzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBZLm1lcmdlKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gQ2xvbmUgdGhlIGF0dHJpYnV0ZXMgb2JqZWN0IHNvIHdlIGRvbid0IGVuZCB1cCBtb2RpZnlpbmcgaXQgYnkgcmVmLlxuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBZLm1lcmdlKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdXJscy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdXJsID0gdXJsc1tpXTtcbiAgICAgICAgICAgIHJlcSA9IHthdHRyaWJ1dGVzOiB7fX07XG5cbiAgICAgICAgICAgIC8vIElmIGB1cmxgIGlzIGEgc3RyaW5nLCB3ZSBjcmVhdGUgYSBVUkwgb2JqZWN0IGZvciBpdCwgdGhlbiBtaXggaW5cbiAgICAgICAgICAgIC8vIGdsb2JhbCBvcHRpb25zIGFuZCByZXF1ZXN0LXNwZWNpZmljIG9wdGlvbnMuIElmIGl0J3MgYW4gb2JqZWN0XG4gICAgICAgICAgICAvLyB3aXRoIGEgXCJ1cmxcIiBwcm9wZXJ0eSwgd2UgYXNzdW1lIGl0J3MgYSByZXF1ZXN0IG9iamVjdCBjb250YWluaW5nXG4gICAgICAgICAgICAvLyBVUkwtc3BlY2lmaWMgb3B0aW9ucy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlcS51cmwgPSB1cmw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC51cmwpIHtcbiAgICAgICAgICAgICAgICAvLyBVUkwtc3BlY2lmaWMgb3B0aW9ucyBvdmVycmlkZSBib3RoIGdsb2JhbCBkZWZhdWx0cyBhbmRcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0LXNwZWNpZmljIG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgWS5taXgocmVxLCB1cmwsIGZhbHNlLCBudWxsLCAwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwudXJsOyAvLyBNYWtlIHVybCBhIHN0cmluZyBzbyB3ZSBjYW4gdXNlIGl0IGxhdGVyLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgWS5taXgocmVxLCBvcHRpb25zLCBmYWxzZSwgbnVsbCwgMCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBnZXQgYW4gZXhwbGljaXQgdHlwZSBmb3IgdGhpcyBVUkwgZWl0aGVyIGluIHRoZVxuICAgICAgICAgICAgLy8gcmVxdWVzdCBvcHRpb25zIG9yIHRoZSBVUkwtc3BlY2lmaWMgb3B0aW9ucywgdHJ5IHRvIGRldGVybWluZVxuICAgICAgICAgICAgLy8gb25lIGZyb20gdGhlIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAgICAgICAgaWYgKCFyZXEudHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLlJFR0VYX0NTUy50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLnR5cGUgPSAnY3NzJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuUkVHRVhfSlMudGVzdCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXEudHlwZSA9ICdqcyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNaXggaW4gdHlwZS1zcGVjaWZpYyBkZWZhdWx0IG9wdGlvbnMsIGJ1dCBkb24ndCBvdmVyd3JpdGUgYW55XG4gICAgICAgICAgICAvLyBvcHRpb25zIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0LlxuICAgICAgICAgICAgWS5taXgocmVxLCByZXEudHlwZSA9PT0gJ2pzJyA/IHRoaXMuanNPcHRpb25zIDogdGhpcy5jc3NPcHRpb25zLFxuICAgICAgICAgICAgICAgIGZhbHNlLCBudWxsLCAwLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gR2l2ZSB0aGUgbm9kZSBhbiBpZCBhdHRyaWJ1dGUgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgb25lLlxuICAgICAgICAgICAgcmVxLmF0dHJpYnV0ZXMuaWQgfHwgKHJlcS5hdHRyaWJ1dGVzLmlkID0gWS5ndWlkKCkpO1xuXG4gICAgICAgICAgICAvLyBCYWNrY29tcGF0IGZvciA8My41LjAgYmVoYXZpb3IuXG4gICAgICAgICAgICBpZiAocmVxLndpbikge1xuICAgICAgICAgICAgICAgIHJlcS5kb2MgPSByZXEud2luLmRvY3VtZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXEud2luID0gcmVxLmRvYy5kZWZhdWx0VmlldyB8fCByZXEuZG9jLnBhcmVudFdpbmRvdztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlcS5jaGFyc2V0KSB7XG4gICAgICAgICAgICAgICAgcmVxLmF0dHJpYnV0ZXMuY2hhcnNldCA9IHJlcS5jaGFyc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0cy5wdXNoKHJlcSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHJlcXVlc3RzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgX2xvYWQ6IGZ1bmN0aW9uICh0eXBlLCB1cmxzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdHJhbnNhY3Rpb247XG5cbiAgICAgICAgLy8gQWxsb3cgY2FsbGJhY2sgYXMgdGhpcmQgcGFyYW0uXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyAgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgIG9wdGlvbnMudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgb3B0aW9ucy5fb25GaW5pc2ggPSBHZXQuX29uVHJhbnNhY3Rpb25GaW5pc2g7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbnYpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldEVudigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNhY3Rpb24gPSB0aGlzLl9nZXRUcmFuc2FjdGlvbih1cmxzLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGNhbGxiYWNrICAgOiBjYWxsYmFjayxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9uZXh0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH0sXG5cbiAgICBfb25UcmFuc2FjdGlvbkZpbmlzaCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBHZXQuX3BlbmRpbmcgPSBudWxsO1xuICAgICAgICBHZXQuX25leHQoKTtcbiAgICB9LFxuXG4gICAgX25leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZW07XG5cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0gPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gaXRlbTtcbiAgICAgICAgICAgIGl0ZW0udHJhbnNhY3Rpb24uZXhlY3V0ZShpdGVtLmNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcHVyZ2U6IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgcHVyZ2VOb2RlcyAgICA9IHRoaXMuX3B1cmdlTm9kZXMsXG4gICAgICAgICAgICBpc1RyYW5zYWN0aW9uID0gbm9kZXMgIT09IHB1cmdlTm9kZXMsXG4gICAgICAgICAgICBpbmRleCwgbm9kZTtcblxuICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7IC8vIGFzc2lnbm1lbnRcbiAgICAgICAgICAgIC8vIERvbid0IHB1cmdlIG5vZGVzIHRoYXQgaGF2ZW4ndCBmaW5pc2hlZCBsb2FkaW5nIChvciBlcnJvcmVkIG91dCksXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGlzIGNhbiBoYW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgIGlmICghbm9kZS5feXVpZ2V0X2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB0cmFuc2FjdGlvbi1sZXZlbCBwdXJnZSBhbmQgdGhpcyBub2RlIGFsc28gZXhpc3RzIGluXG4gICAgICAgICAgICAvLyB0aGUgR2V0LWxldmVsIF9wdXJnZU5vZGVzIGFycmF5LCB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tXG4gICAgICAgICAgICAvLyBfcHVyZ2VOb2RlcyB0byBhdm9pZCBjcmVhdGluZyBhIG1lbW9yeSBsZWFrLiBUaGUgaW5kZXhPZiBsb29rdXBcbiAgICAgICAgICAgIC8vIHN1Y2tzLCBidXQgdW50aWwgd2UgZ2V0IFdlYWtNYXBzLCB0aGlzIGlzIHRoZSBsZWFzdCB0cm91Ymxlc29tZVxuICAgICAgICAgICAgLy8gd2F5IHRvIGRvIHRoaXMgKHdlIGNhbid0IGp1c3QgaG9sZCBvbnRvIG5vZGUgaWRzIGJlY2F1c2UgdGhleSBtYXlcbiAgICAgICAgICAgIC8vIG5vdCBiZSBpbiB0aGUgc2FtZSBkb2N1bWVudCkuXG4gICAgICAgICAgICBpZiAoaXNUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gWS5BcnJheS5pbmRleE9mKHB1cmdlTm9kZXMsIG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVyZ2VOb2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuQWxpYXMgZm9yIGBqcygpYC5cblxuQG1ldGhvZCBzY3JpcHRcbkBzdGF0aWNcbioqL1xuR2V0LnNjcmlwdCA9IEdldC5qcztcblxuLyoqXG5SZXByZXNlbnRzIGEgR2V0IHRyYW5zYWN0aW9uLCB3aGljaCBtYXkgY29udGFpbiByZXF1ZXN0cyBmb3Igb25lIG9yIG1vcmUgSlMgb3JcbkNTUyBmaWxlcy5cblxuVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBtYW51YWxseS4gSW5zdGFuY2VzIHdpbGwgYmUgY3JlYXRlZCBhbmRcbnJldHVybmVkIGFzIG5lZWRlZCBieSBZLkdldCdzIGBjc3MoKWAsIGBqcygpYCwgYW5kIGBsb2FkKClgIG1ldGhvZHMuXG5cbkBjbGFzcyBHZXQuVHJhbnNhY3Rpb25cbkBjb25zdHJ1Y3RvclxuQHNpbmNlIDMuNS4wXG4qKi9cbkdldC5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHJlcXVlc3RzLCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi5pZCAgICAgICA9IFRyYW5zYWN0aW9uLl9sYXN0SWQgKz0gMTtcbiAgICBzZWxmLmRhdGEgICAgID0gb3B0aW9ucy5kYXRhO1xuICAgIHNlbGYuZXJyb3JzICAgPSBbXTtcbiAgICBzZWxmLm5vZGVzICAgID0gW107XG4gICAgc2VsZi5vcHRpb25zICA9IG9wdGlvbnM7XG4gICAgc2VsZi5yZXF1ZXN0cyA9IHJlcXVlc3RzO1xuXG4gICAgc2VsZi5fY2FsbGJhY2tzID0gW107IC8vIGNhbGxiYWNrcyB0byBjYWxsIGFmdGVyIGV4ZWN1dGlvbiBmaW5pc2hlc1xuICAgIHNlbGYuX3F1ZXVlICAgICA9IFtdO1xuICAgIHNlbGYuX3JlcXNXYWl0aW5nICAgPSAwO1xuXG4gICAgLy8gRGVwcmVjYXRlZCBwcmUtMy41LjAgcHJvcGVydGllcy5cbiAgICBzZWxmLnRJZCA9IHNlbGYuaWQ7IC8vIFVzZSBgaWRgIGluc3RlYWQuXG4gICAgc2VsZi53aW4gPSBvcHRpb25zLndpbiB8fCBZLmNvbmZpZy53aW47XG59O1xuXG4vKipcbkFyYml0cmFyeSBkYXRhIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyB0cmFuc2FjdGlvbi5cblxuVGhpcyBvYmplY3QgY29tZXMgZnJvbSB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gYEdldC5jc3MoKWAsIGBHZXQuanMoKWAsIG9yXG5gR2V0LmxvYWQoKWAsIGFuZCB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIG5vIGRhdGEgb2JqZWN0IHdhcyBzcGVjaWZpZWQuXG5cbkBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhXG4qKi9cblxuLyoqXG5BcnJheSBvZiBlcnJvcnMgdGhhdCBoYXZlIG9jY3VycmVkIGR1cmluZyB0aGlzIHRyYW5zYWN0aW9uLCBpZiBhbnkuIEVhY2ggZXJyb3Jcbm9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuYGVycm9ycy5lcnJvcmA6IEVycm9yIG1lc3NhZ2UuXG5gZXJyb3JzLnJlcXVlc3RgOiBSZXF1ZXN0IG9iamVjdCByZWxhdGVkIHRvIHRoZSBlcnJvci5cblxuQHNpbmNlIDMuNS4wXG5AcHJvcGVydHkge09iamVjdFtdfSBlcnJvcnNcbioqL1xuXG4vKipcbk51bWVyaWMgaWQgZm9yIHRoaXMgdHJhbnNhY3Rpb24sIHVuaXF1ZSBhbW9uZyBhbGwgdHJhbnNhY3Rpb25zIHdpdGhpbiB0aGUgc2FtZVxuWVVJIHNhbmRib3ggaW4gdGhlIGN1cnJlbnQgcGFnZXZpZXcuXG5cbkBwcm9wZXJ0eSB7TnVtYmVyfSBpZFxuQHNpbmNlIDMuNS4wXG4qKi9cblxuLyoqXG5IVE1MRWxlbWVudCBub2RlcyAobmF0aXZlIG9uZXMsIG5vdCBZVUkgTm9kZSBpbnN0YW5jZXMpIHRoYXQgaGF2ZSBiZWVuIGluc2VydGVkXG5kdXJpbmcgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24uXG5cbkBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gbm9kZXNcbioqL1xuXG4vKipcbk9wdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdHJhbnNhY3Rpb24uXG5cblNlZSBgR2V0Lm9wdGlvbnNgIGZvciB0aGUgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zLlxuXG5AcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xuQHNpbmNlIDMuNS4wXG4qKi9cblxuLyoqXG5SZXF1ZXN0IG9iamVjdHMgY29udGFpbmVkIGluIHRoaXMgdHJhbnNhY3Rpb24uIEVhY2ggcmVxdWVzdCBvYmplY3QgcmVwcmVzZW50c1xub25lIENTUyBvciBKUyBVUkwgdGhhdCB3aWxsIGJlIChvciBoYXMgYmVlbikgcmVxdWVzdGVkIGFuZCBsb2FkZWQgaW50byB0aGUgcGFnZS5cblxuQHByb3BlcnR5IHtPYmplY3R9IHJlcXVlc3RzXG5Ac2luY2UgMy41LjBcbioqL1xuXG4vKipcbklkIG9mIHRoZSBtb3N0IHJlY2VudCB0cmFuc2FjdGlvbi5cblxuQHByb3BlcnR5IF9sYXN0SWRcbkB0eXBlIE51bWJlclxuQHByb3RlY3RlZFxuQHN0YXRpY1xuKiovXG5UcmFuc2FjdGlvbi5fbGFzdElkID0gMDtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8vIC0tIFB1YmxpYyBQcm9wZXJ0aWVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgIEN1cnJlbnQgc3RhdGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4gT25lIG9mIFwibmV3XCIsIFwiZXhlY3V0aW5nXCIsIG9yIFwiZG9uZVwiLlxuXG4gICAgQHByb3BlcnR5IF9zdGF0ZVxuICAgIEB0eXBlIFN0cmluZ1xuICAgIEBwcm90ZWN0ZWRcbiAgICAqKi9cbiAgICBfc3RhdGU6ICduZXcnLCAvLyBcIm5ld1wiLCBcImV4ZWN1dGluZ1wiLCBvciBcImRvbmVcIlxuXG4gICAgLy8gLS0gUHVibGljIE1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgQWJvcnRzIHRoaXMgdHJhbnNhY3Rpb24uXG5cbiAgICBUaGlzIHdpbGwgY2F1c2UgdGhlIHRyYW5zYWN0aW9uJ3MgYG9uRmFpbHVyZWAgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFuZFxuICAgIHdpbGwgcHJldmVudCBhbnkgbmV3IHNjcmlwdCBhbmQgbGluayBub2RlcyBmcm9tIGJlaW5nIGFkZGVkIHRvIHRoZSBkb2N1bWVudCxcbiAgICBidXQgYW55IHJlc291cmNlcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZCB3aWxsIGNvbnRpbnVlIGxvYWRpbmdcbiAgICAodGhlcmUncyBubyBzYWZlIHdheSB0byBwcmV2ZW50IHRoaXMsIHVuZm9ydHVuYXRlbHkpLlxuXG4gICAgQG1ldGhvZCBhYm9ydFxuICAgIEBwYXJhbSB7U3RyaW5nfSBbbXNnPVwiQWJvcnRlZC5cIl0gT3B0aW9uYWwgbWVzc2FnZSB0byB1c2UgaW4gdGhlIGBlcnJvcnNgXG4gICAgICAgIGFycmF5IGRlc2NyaWJpbmcgd2h5IHRoZSB0cmFuc2FjdGlvbiB3YXMgYWJvcnRlZC5cbiAgICAqKi9cbiAgICBhYm9ydDogZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLl9wZW5kaW5nICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NTUyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BvbGxUaW1lciAgPSBjbGVhclRpbWVvdXQodGhpcy5fcG9sbFRpbWVyKTtcbiAgICAgICAgdGhpcy5fcXVldWUgICAgICA9IFtdO1xuICAgICAgICB0aGlzLl9yZXFzV2FpdGluZyAgICA9IDA7XG5cbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCh7ZXJyb3I6IG1zZyB8fCAnQWJvcnRlZCd9KTtcbiAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIEJlZ2lucyBleGVjdGluZyB0aGUgdHJhbnNhY3Rpb24uXG5cbiAgICBUaGVyZSdzIHVzdWFsbHkgbm8gcmVhc29uIHRvIGNhbGwgdGhpcyBtYW51YWxseSwgc2luY2UgR2V0IHdpbGwgY2FsbCBpdFxuICAgIGF1dG9tYXRpY2FsbHkgd2hlbiBvdGhlciBwZW5kaW5nIHRyYW5zYWN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJZiB5b3UgcmVhbGx5XG4gICAgd2FudCB0byBleGVjdXRlIHlvdXIgdHJhbnNhY3Rpb24gYmVmb3JlIEdldCBkb2VzLCB5b3UgY2FuLCBidXQgYmUgYXdhcmUgdGhhdFxuICAgIHRoaXMgdHJhbnNhY3Rpb24ncyBzY3JpcHRzIG1heSBlbmQgdXAgZXhlY3V0aW5nIGJlZm9yZSB0aGUgc2NyaXB0cyBpbiBvdGhlclxuICAgIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuXG4gICAgSWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFscmVhZHkgZXhlY3V0aW5nLCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIChpZiBhbnkpXG4gICAgd2lsbCBiZSBxdWV1ZWQgYW5kIGNhbGxlZCBhZnRlciBleGVjdXRpb24gZmluaXNoZXMuIElmIHRoZSB0cmFuc2FjdGlvbiBoYXNcbiAgICBhbHJlYWR5IGZpbmlzaGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgKHRoZSB0cmFuc2FjdGlvblxuICAgIHdpbGwgbm90IGJlIGV4ZWN1dGVkIGFnYWluKS5cblxuICAgIEBtZXRob2QgZXhlY3V0ZVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgYWxsIHJlcXVlc3RzXG4gICAgICAgIGluIHRoZSB0cmFuc2FjdGlvbiBhcmUgY29tcGxldGUsIG9yIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBpcyBhYm9ydGVkLlxuICAgICoqL1xuICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZiAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVxdWVzdHMgPSBzZWxmLnJlcXVlc3RzLFxuICAgICAgICAgICAgc3RhdGUgICAgPSBzZWxmLl9zdGF0ZSxcbiAgICAgICAgICAgIGksIGxlbiwgcXVldWUsIHJlcTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09ICdkb25lJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soc2VsZi5lcnJvcnMubGVuZ3RoID8gc2VsZi5lcnJvcnMgOiBudWxsLCBzZWxmKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIHNlbGYuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZXhlY3V0aW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX3N0YXRlID0gJ2V4ZWN1dGluZyc7XG4gICAgICAgIHNlbGYuX3F1ZXVlID0gcXVldWUgPSBbXTtcblxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHNlbGYuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFib3J0KCdUaW1lb3V0Jyk7XG4gICAgICAgICAgICB9LCBzZWxmLm9wdGlvbnMudGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9yZXFzV2FpdGluZyA9IHJlcXVlc3RzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZXF1ZXN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcmVxID0gcmVxdWVzdHNbaV07XG5cbiAgICAgICAgICAgIGlmIChyZXEuYXN5bmMgfHwgcmVxLnR5cGUgPT09ICdjc3MnKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBxdWV1ZSBDU1Mgb3IgZnVsbHkgYXN5bmMgSlMuXG4gICAgICAgICAgICAgICAgc2VsZi5faW5zZXJ0KHJlcSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocmVxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX25leHQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgTWFudWFsbHkgcHVyZ2VzIGFueSBgPHNjcmlwdD5gIG9yIGA8bGluaz5gIG5vZGVzIHRoaXMgdHJhbnNhY3Rpb24gaGFzXG4gICAgY3JlYXRlZC5cblxuICAgIEJlIGNhcmVmdWwgd2hlbiBwdXJnaW5nIGEgdHJhbnNhY3Rpb24gdGhhdCBjb250YWlucyBDU1MgcmVxdWVzdHMsIHNpbmNlXG4gICAgcmVtb3ZpbmcgYDxsaW5rPmAgbm9kZXMgd2lsbCBhbHNvIHJlbW92ZSBhbnkgc3R5bGVzIHRoZXkgYXBwbGllZC5cblxuICAgIEBtZXRob2QgcHVyZ2VcbiAgICAqKi9cbiAgICBwdXJnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBHZXQuX3B1cmdlKHRoaXMubm9kZXMpO1xuICAgIH0sXG5cbiAgICAvLyAtLSBQcm90ZWN0ZWQgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgX2NyZWF0ZU5vZGU6IGZ1bmN0aW9uIChuYW1lLCBhdHRycywgZG9jKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSksXG4gICAgICAgICAgICBhdHRyLCB0ZXN0RWw7XG5cbiAgICAgICAgaWYgKCFDVVNUT01fQVRUUlMpIHtcbiAgICAgICAgICAgIC8vIElFNiBhbmQgSUU3IGV4cGVjdCBwcm9wZXJ0eSBuYW1lcyByYXRoZXIgdGhhbiBhdHRyaWJ1dGUgbmFtZXMgZm9yXG4gICAgICAgICAgICAvLyBjZXJ0YWluIGF0dHJpYnV0ZXMuIFJhdGhlciB0aGFuIHNuaWZmaW5nLCB3ZSBkbyBhIHF1aWNrIGZlYXR1cmVcbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIGZpcnN0IHRpbWUgX2NyZWF0ZU5vZGUoKSBydW5zIHRvIGRldGVybWluZSB3aGV0aGVyIHdlXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHByb3ZpZGUgYSB3b3JrYXJvdW5kLlxuICAgICAgICAgICAgdGVzdEVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGVzdEVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnYScpO1xuXG4gICAgICAgICAgICBDVVNUT01fQVRUUlMgPSB0ZXN0RWwuY2xhc3NOYW1lID09PSAnYScgPyB7fSA6IHtcbiAgICAgICAgICAgICAgICAnZm9yJyAgOiAnaHRtbEZvcicsXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2NsYXNzTmFtZSdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKENVU1RPTV9BVFRSU1thdHRyXSB8fCBhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXJyb3JzICA9IHRoaXMuZXJyb3JzLmxlbmd0aCA/IHRoaXMuZXJyb3JzIDogbnVsbCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB0aGlzT2JqID0gb3B0aW9ucy5jb250ZXh0IHx8IHRoaXMsXG4gICAgICAgICAgICBkYXRhLCBpLCBsZW47XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAnZG9uZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXRlID0gJ2RvbmUnO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW2ldLmNhbGwodGhpc09iaiwgZXJyb3JzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSB0aGlzLl9nZXRFdmVudERhdGEoKTtcblxuICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vblRpbWVvdXQgJiYgZXJyb3JzW2Vycm9ycy5sZW5ndGggLSAxXS5lcnJvciA9PT0gJ1RpbWVvdXQnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblRpbWVvdXQuY2FsbCh0aGlzT2JqLCBkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbkZhaWx1cmUuY2FsbCh0aGlzT2JqLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9uU3VjY2Vzcykge1xuICAgICAgICAgICAgb3B0aW9ucy5vblN1Y2Nlc3MuY2FsbCh0aGlzT2JqLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm9uRW5kKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uRW5kLmNhbGwodGhpc09iaiwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5fb25GaW5pc2gpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuX29uRmluaXNoKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldEV2ZW50RGF0YTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG1lcmdlIGlzIG5lY2Vzc2FyeSBmb3IgYmFja2NvbXBhdC4gSSBoYXRlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIFkubWVyZ2UodGhpcywge1xuICAgICAgICAgICAgICAgIGFib3J0ICA6IHRoaXMuYWJvcnQsIC8vIGhhdmUgdG8gY29weSB0aGVzZSBiZWNhdXNlIHRoZSBwcm90b3R5cGUgaXNuJ3QgcHJlc2VydmVkXG4gICAgICAgICAgICAgICAgcHVyZ2UgIDogdGhpcy5wdXJnZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXEsXG4gICAgICAgICAgICAgICAgdXJsICAgIDogcmVxLnVybCxcbiAgICAgICAgICAgICAgICB3aW4gICAgOiByZXEud2luXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRJbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgdmFyIGRvYyA9IHJlcS5kb2MsXG4gICAgICAgICAgICBlbCAgPSByZXEuaW5zZXJ0QmVmb3JlLFxuICAgICAgICAgICAgY2FjaGUsIGRvY1N0YW1wO1xuXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCA9PT0gJ3N0cmluZycgPyBkb2MuZ2V0RWxlbWVudEJ5SWQoZWwpIDogZWw7XG4gICAgICAgIH1cblxuICAgICAgICBjYWNoZSAgICA9IEdldC5faW5zZXJ0Q2FjaGU7XG4gICAgICAgIGRvY1N0YW1wID0gWS5zdGFtcChkb2MpO1xuXG4gICAgICAgIGlmICgoZWwgPSBjYWNoZVtkb2NTdGFtcF0pKSB7IC8vIGFzc2lnbm1lbnRcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluc2VydGluZyBiZWZvcmUgYSA8YmFzZT4gdGFnIGFwcGFyZW50bHkgd29ya3MgYXJvdW5kIGFuIElFIGJ1Z1xuICAgICAgICAvLyAoYWNjb3JkaW5nIHRvIGEgY29tbWVudCBmcm9tIHByZS0zLjUuMCBZLkdldCksIGJ1dCBJJ20gbm90IHN1cmUgd2hhdFxuICAgICAgICAvLyBidWcgdGhhdCBpcywgZXhhY3RseS4gQmV0dGVyIHNhZmUgdGhhbiBzb3JyeT9cbiAgICAgICAgaWYgKChlbCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmFzZScpWzBdKSkgeyAvLyBhc3NpZ25tZW50XG4gICAgICAgICAgICByZXR1cm4gKGNhY2hlW2RvY1N0YW1wXSA9IGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb2sgZm9yIGEgPGhlYWQ+IGVsZW1lbnQuXG4gICAgICAgIGVsID0gZG9jLmhlYWQgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBtYXJrZXIgbm9kZSBhdCB0aGUgZW5kIG9mIDxoZWFkPiB0byB1c2UgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAgICAgICAvLyBwb2ludC4gSW5zZXJ0aW5nIGJlZm9yZSB0aGlzIG5vZGUgd2lsbCBlbnN1cmUgdGhhdCBhbGwgb3VyIENTU1xuICAgICAgICAgICAgLy8gZ2V0cyBpbnNlcnRlZCBpbiB0aGUgY29ycmVjdCBvcmRlciwgdG8gbWFpbnRhaW4gc3R5bGUgcHJlY2VkZW5jZS5cbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSgnJykpO1xuICAgICAgICAgICAgcmV0dXJuIChjYWNoZVtkb2NTdGFtcF0gPSBlbC5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIGp1c3QgaW5zZXJ0IGJlZm9yZSB0aGUgZmlyc3Qgc2NyaXB0IG5vZGUgb24gdGhlXG4gICAgICAgIC8vIHBhZ2UsIHdoaWNoIGlzIHZpcnR1YWxseSBndWFyYW50ZWVkIHRvIGV4aXN0LlxuICAgICAgICByZXR1cm4gKGNhY2hlW2RvY1N0YW1wXSA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF0pO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHZhciBlbnYgICAgICAgICAgPSBHZXQuX2VudixcbiAgICAgICAgICAgIGluc2VydEJlZm9yZSA9IHRoaXMuX2dldEluc2VydEJlZm9yZShyZXEpLFxuICAgICAgICAgICAgaXNTY3JpcHQgICAgID0gcmVxLnR5cGUgPT09ICdqcycsXG4gICAgICAgICAgICBub2RlICAgICAgICAgPSByZXEubm9kZSxcbiAgICAgICAgICAgIHNlbGYgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB1YSAgICAgICAgICAgPSBZLlVBLFxuICAgICAgICAgICAgY3NzVGltZW91dCwgbm9kZVR5cGU7XG5cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBpZiAoaXNTY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBub2RlVHlwZSA9ICdzY3JpcHQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZW52LmNzc0xvYWQgJiYgdWEuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICBub2RlVHlwZSA9ICdzdHlsZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gJ2xpbmsnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gcmVxLm5vZGUgPSB0aGlzLl9jcmVhdGVOb2RlKG5vZGVUeXBlLCByZXEuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICByZXEuZG9jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoKSB7XG4gICAgICAgICAgICBzZWxmLl9wcm9ncmVzcygnRmFpbGVkIHRvIGxvYWQgJyArIHJlcS51cmwsIHJlcSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICAgICAgICAgICBpZiAoY3NzVGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjc3NUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MobnVsbCwgcmVxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlYWwgd2l0aCBzY3JpcHQgYXN5bmNocm9uaWNpdHkuXG4gICAgICAgIGlmIChpc1NjcmlwdCkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHJlcS51cmwpO1xuXG4gICAgICAgICAgICBpZiAocmVxLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBpbmRpY2F0ZSB0aGF0IHdlIHdhbnQgdGhlIGJyb3dzZXIgdG8gZXhlY3V0ZSB0aGlzXG4gICAgICAgICAgICAgICAgLy8gc2NyaXB0IGFzeW5jaHJvbm91c2x5LiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICAvLyBsaWtlIEZpcmVmb3ggPDQuXG4gICAgICAgICAgICAgICAgbm9kZS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlbnYuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBicm93c2VyIHRyZWF0cyBpbmplY3RlZCBzY3JpcHRzIGFzIGFzeW5jIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gKHN0YW5kYXJkIEhUTUw1IGJlaGF2aW9yKSBidXQgYXN5bmNocm9ub3VzIGxvYWRpbmcgaXNuJ3RcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVzaXJlZCwgc28gdGVsbCB0aGUgYnJvd3NlciBub3QgdG8gbWFyayB0aGlzIHNjcmlwdCBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhc3luYy5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hc3luYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHByZXNlcnZlIHNjcmlwdCBleGVjdXRpb24gb3JkZXIgYmFzZWRcbiAgICAgICAgICAgICAgICAvLyBvbiBpbnNlcnRpb24gb3JkZXIsIHdlJ2xsIG5lZWQgdG8gYXZvaWQgaW5zZXJ0aW5nIG90aGVyXG4gICAgICAgICAgICAgICAgLy8gc2NyaXB0cyB1bnRpbCB0aGlzIG9uZSBmaW5pc2hlcyBsb2FkaW5nLlxuICAgICAgICAgICAgICAgIGlmICghZW52LnByZXNlcnZlc1NjcmlwdE9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcgPSByZXE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFlbnYuY3NzTG9hZCAmJiB1YS5nZWNrbykge1xuICAgICAgICAgICAgICAgIC8vIEluIEZpcmVmb3ggPDksIHdlIGNhbiBpbXBvcnQgdGhlIHJlcXVlc3RlZCBVUkwgaW50byBhIDxzdHlsZT5cbiAgICAgICAgICAgICAgICAvLyBub2RlIGFuZCBwb2xsIGZvciB0aGUgZXhpc3RlbmNlIG9mIG5vZGUuc2hlZXQuY3NzUnVsZXMuIFRoaXNcbiAgICAgICAgICAgICAgICAvLyBnaXZlcyB1cyBhIHJlbGlhYmxlIHdheSB0byBkZXRlcm1pbmUgQ1NTIGxvYWQgY29tcGxldGlvbiB0aGF0XG4gICAgICAgICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgY3Jvc3MtZG9tYWluIHN0eWxlc2hlZXRzLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gUHJvcHMgdG8gWmFjaCBMZWF0aGVybWFuIGZvciBjYWxsaW5nIG15IGF0dGVudGlvbiB0byB0aGlzXG4gICAgICAgICAgICAgICAgLy8gdGVjaG5pcXVlLlxuICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gKHJlcS5hdHRyaWJ1dGVzLmNoYXJzZXQgP1xuICAgICAgICAgICAgICAgICAgICAnQGNoYXJzZXQgXCInICsgcmVxLmF0dHJpYnV0ZXMuY2hhcnNldCArICdcIjsnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ0BpbXBvcnQgXCInICsgcmVxLnVybCArICdcIjsnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHJlcS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5qZWN0IHRoZSBub2RlLlxuICAgICAgICBpZiAoaXNTY3JpcHQgJiYgdWEuaWUgJiYgKHVhLmllIDwgOSB8fCAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDkpKSkge1xuICAgICAgICAgICAgLy8gU2NyaXB0IG9uIElFIDwgOSwgYW5kIElFIDkrIHdoZW4gaW4gSUUgOCBvciBvbGRlciBtb2RlcywgaW5jbHVkaW5nIHF1aXJrcyBtb2RlLlxuICAgICAgICAgICAgbm9kZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKC9sb2FkZWR8Y29tcGxldGUvLnRlc3Qobm9kZS5yZWFkeVN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU2NyaXB0ICYmICFlbnYuY3NzTG9hZCkge1xuICAgICAgICAgICAgLy8gQ1NTIG9uIEZpcmVmb3ggPDkgb3IgV2ViS2l0LlxuICAgICAgICAgICAgdGhpcy5fcG9sbChyZXEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2NyaXB0IG9yIENTUyBvbiBldmVyeXRoaW5nIGVsc2UuIFVzaW5nIERPTSAwIGV2ZW50cyBiZWNhdXNlIHRoYXRcbiAgICAgICAgICAgIC8vIGV2ZW5zIHRoZSBwbGF5aW5nIGZpZWxkIHdpdGggb2xkZXIgSUVzLlxuXG4gICAgICAgICAgICBpZiAodWEuaWUgPj0gMTApIHtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGN1cnJlbnRseSBuZWVkIHRvIGludHJvZHVjZSBhIHRpbWVvdXQgZm9yIElFMTAsIHNpbmNlIGl0XG4gICAgICAgICAgICAgICAgLy8gY2FsbHMgb25lcnJvci9vbmxvYWQgc3luY2hyb25vdXNseSBmb3IgMzA0cyAtIG1lc3NpbmcgdXAgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAvLyBwcm9ncmFtIGZsb3cuXG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBibG9jayBpZiB0aGUgZm9sbG93aW5nIGJ1ZyBnZXRzIGZpeGVkIGJ5IEdBXG4gICAgICAgICAgICAgICAgLypqc2hpbnQgbWF4bGVuOiAxNTAwICovXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy83NjM4NzEvZHluYW1pY2FsbHktbG9hZGVkLXNjcmlwdHMtd2l0aC0zMDRzLXJlc3BvbnNlcy1pbnRlcnJ1cHQtdGhlLWN1cnJlbnRseS1leGVjdXRpbmctanMtdGhyZWFkLW9ubG9hZFxuICAgICAgICAgICAgICAgIG5vZGUub25lcnJvciA9IGZ1bmN0aW9uKCkgeyBzZXRUaW1lb3V0KG9uRXJyb3IsIDApOyB9O1xuICAgICAgICAgICAgICAgIG5vZGUub25sb2FkICA9IGZ1bmN0aW9uKCkgeyBzZXRUaW1lb3V0KG9uTG9hZCwgMCk7IH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUub25lcnJvciA9IG9uRXJyb3I7XG4gICAgICAgICAgICAgICAgbm9kZS5vbmxvYWQgID0gb25Mb2FkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGJyb3dzZXIgZG9lc24ndCBmaXJlIGFuIGV2ZW50IHdoZW4gQ1NTIGZhaWxzIHRvIGxvYWQsXG4gICAgICAgICAgICAvLyBmYWlsIGFmdGVyIGEgdGltZW91dCB0byBhdm9pZCBibG9ja2luZyB0aGUgdHJhbnNhY3Rpb24gcXVldWUuXG4gICAgICAgICAgICBpZiAoIWVudi5jc3NGYWlsICYmICFpc1NjcmlwdCkge1xuICAgICAgICAgICAgICAgIGNzc1RpbWVvdXQgPSBzZXRUaW1lb3V0KG9uRXJyb3IsIHJlcS50aW1lb3V0IHx8IDMwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBpbnNlcnRCZWZvcmUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgaW5zZXJ0QmVmb3JlKTtcbiAgICB9LFxuXG4gICAgX25leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSByZXF1ZXN0cyBpbiB0aGUgcXVldWUsIGluc2VydCB0aGUgbmV4dCBxdWV1ZWQgcmVxdWVzdC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSdyZSB3YWl0aW5nIG9uIGFscmVhZHktaW5zZXJ0ZWQgcmVxdWVzdHMgdG8gZmluaXNoLFxuICAgICAgICAvLyB3YWl0IGxvbmdlci4gSWYgdGhlcmUgYXJlIG5vIHF1ZXVlZCByZXF1ZXN0cyBhbmQgd2UncmUgbm90IHdhaXRpbmdcbiAgICAgICAgLy8gZm9yIGFueXRoaW5nIHRvIGxvYWQsIHRoZW4gd2UncmUgZG9uZSFcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KHRoaXMuX3F1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9yZXFzV2FpdGluZykge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BvbGw6IGZ1bmN0aW9uIChuZXdSZXEpIHtcbiAgICAgICAgdmFyIHNlbGYgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcGVuZGluZ0NTUyA9IHNlbGYuX3BlbmRpbmdDU1MsXG4gICAgICAgICAgICBpc1dlYktpdCAgID0gWS5VQS53ZWJraXQsXG4gICAgICAgICAgICBpLCBoYXNSdWxlcywgaiwgbm9kZUhyZWYsIHJlcSwgc2hlZXRzO1xuXG4gICAgICAgIGlmIChuZXdSZXEpIHtcbiAgICAgICAgICAgIHBlbmRpbmdDU1MgfHwgKHBlbmRpbmdDU1MgPSBzZWxmLl9wZW5kaW5nQ1NTID0gW10pO1xuICAgICAgICAgICAgcGVuZGluZ0NTUy5wdXNoKG5ld1JlcSk7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLl9wb2xsVGltZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHBvbGwgdGltZW91dCBpcyBhbHJlYWR5IHBlbmRpbmcsIHNvIG5vIG5lZWQgdG8gY3JlYXRlIGFcbiAgICAgICAgICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX3BvbGxUaW1lciA9IG51bGw7XG5cbiAgICAgICAgLy8gTm90ZTogaW4gYm90aCB0aGUgV2ViS2l0IGFuZCBHZWNrbyBoYWNrcyBiZWxvdywgYSBDU1MgVVJMIHRoYXQgNDA0c1xuICAgICAgICAvLyB3aWxsIHN0aWxsIGJlIHRyZWF0ZWQgYXMgYSBzdWNjZXNzLiBUaGVyZSdzIG5vIGdvb2Qgd29ya2Fyb3VuZCBmb3JcbiAgICAgICAgLy8gdGhpcy5cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGVuZGluZ0NTUy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVxID0gcGVuZGluZ0NTU1tpXTtcblxuICAgICAgICAgICAgaWYgKGlzV2ViS2l0KSB7XG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYSBzdHlsZXNoZWV0IG1hdGNoaW5nIHRoZSBwZW5kaW5nIFVSTC5cbiAgICAgICAgICAgICAgICBzaGVldHMgICA9IHJlcS5kb2Muc3R5bGVTaGVldHM7XG4gICAgICAgICAgICAgICAgaiAgICAgICAgPSBzaGVldHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5vZGVIcmVmID0gcmVxLm5vZGUuaHJlZjtcblxuICAgICAgICAgICAgICAgIHdoaWxlICgtLWogPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hlZXRzW2pdLmhyZWYgPT09IG5vZGVIcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQ1NTLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKG51bGwsIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFueSB0aGFua3MgdG8gWmFjaCBMZWF0aGVybWFuIGZvciBjYWxsaW5nIG15IGF0dGVudGlvbiB0b1xuICAgICAgICAgICAgICAgIC8vIHRoZSBAaW1wb3J0LWJhc2VkIGNyb3NzLWRvbWFpbiB0ZWNobmlxdWUgdXNlZCBoZXJlLCBhbmQgdG9cbiAgICAgICAgICAgICAgICAvLyBPbGVnIFNsb2JvZHNrb2kgZm9yIGFuIGVhcmxpZXIgc2FtZS1kb21haW4gaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTZWUgWmFjaCdzIGJsb2cgZm9yIG1vcmUgZGV0YWlsczpcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnphY2hsZWF0LmNvbS93ZWIvMjAxMC8wNy8yOS9sb2FkLWNzcy1keW5hbWljYWxseS9cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCByZWFsbHkgbmVlZCB0byBzdG9yZSB0aGlzIHZhbHVlIHNpbmNlIHdlIG5ldmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBpdCBhZ2FpbiwgYnV0IGlmIHdlIGRvbid0IHN0b3JlIGl0LCBDbG9zdXJlIENvbXBpbGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZXMgdGhlIGNvZGUgaXMgdXNlbGVzcyBhbmQgcmVtb3ZlcyBpdC5cbiAgICAgICAgICAgICAgICAgICAgaGFzUnVsZXMgPSAhIXJlcS5ub2RlLnNoZWV0LmNzc1J1bGVzO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB0aGUgc3R5bGVzaGVldCBoYXMgbG9hZGVkLlxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQ1NTLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wcm9ncmVzcyhudWxsLCByZXEpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuIGV4Y2VwdGlvbiBtZWFucyB0aGUgc3R5bGVzaGVldCBpcyBzdGlsbCBsb2FkaW5nLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwZW5kaW5nQ1NTLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5fcG9sbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcG9sbC5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgfSwgc2VsZi5vcHRpb25zLnBvbGxJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Byb2dyZXNzOiBmdW5jdGlvbiAoZXJyLCByZXEpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVxLmVycm9yID0gZXJyO1xuXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlcnJvciAgOiBlcnIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmVxLm5vZGUuX3l1aWdldF9maW5pc2hlZCA9IHJlcS5maW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub25Qcm9ncmVzcykge1xuICAgICAgICAgICAgb3B0aW9ucy5vblByb2dyZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0IHx8IHRoaXMsXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0RXZlbnREYXRhKHJlcSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcS5hdXRvcHVyZ2UpIHtcbiAgICAgICAgICAgIC8vIFByZS0zLjUuMCBHZXQgYWx3YXlzIGV4Y2x1ZGVzIHRoZSBtb3N0IHJlY2VudCBub2RlIGZyb20gYW5cbiAgICAgICAgICAgIC8vIGF1dG9wdXJnZS4gSSBmaW5kIHRoaXMgb2RkLCBidXQgSSdtIGtlZXBpbmcgdGhhdCBiZWhhdmlvciBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBzYWtlIG9mIGJhY2tjb21wYXQuXG4gICAgICAgICAgICBHZXQuX2F1dG9QdXJnZSh0aGlzLm9wdGlvbnMucHVyZ2V0aHJlc2hvbGQpO1xuICAgICAgICAgICAgR2V0Ll9wdXJnZU5vZGVzLnB1c2gocmVxLm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmcgPT09IHJlcSkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZXFzV2FpdGluZyAtPSAxO1xuXG4gICAgICAgIHRoaXMuX25leHQoKTtcbiAgICB9XG59O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJ5dWktYmFzZVwiXX0pO1xuWVVJLmFkZCgnZmVhdHVyZXMnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG52YXIgZmVhdHVyZV90ZXN0cyA9IHt9O1xuXG4vKipcbkNvbnRhaW5zIHRoZSBjb3JlIG9mIFlVSSdzIGZlYXR1cmUgdGVzdCBhcmNoaXRlY3R1cmUuXG5AbW9kdWxlIGZlYXR1cmVzXG4qL1xuXG4vKipcbiogRmVhdHVyZSBkZXRlY3Rpb25cbiogQGNsYXNzIEZlYXR1cmVzXG4qIEBzdGF0aWNcbiovXG5cblkubWl4KFkubmFtZXNwYWNlKCdGZWF0dXJlcycpLCB7XG5cbiAgICAvKipcbiAgICAqIE9iamVjdCBoYXNoIG9mIGFsbCByZWdpc3RlcmVkIGZlYXR1cmUgdGVzdHNcbiAgICAqIEBwcm9wZXJ0eSB0ZXN0c1xuICAgICogQHR5cGUgT2JqZWN0XG4gICAgKi9cbiAgICB0ZXN0czogZmVhdHVyZV90ZXN0cyxcblxuICAgIC8qKlxuICAgICogQWRkIGEgdGVzdCB0byB0aGUgc3lzdGVtXG4gICAgKlxuICAgICogICBgYGBcbiAgICAqICAgWS5GZWF0dXJlcy5hZGQoXCJsb2FkXCIsIFwiMVwiLCB7fSk7XG4gICAgKiAgIGBgYFxuICAgICpcbiAgICAqIEBtZXRob2QgYWRkXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gY2F0IFRoZSBjYXRlZ29yeSwgcmlnaHQgbm93IG9ubHkgJ2xvYWQnIGlzIHN1cHBvcnRlZFxuICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG51bWJlciBzZXF1ZW5jZSBvZiB0aGUgdGVzdCwgaG93IGl0J3MgcmVwb3J0ZWQgaW4gdGhlIFVSTCBvciBjb25maWc6IDEsIDIsIDNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvIE9iamVjdCBjb250YWluaW5nIHRlc3QgcHJvcGVydGllc1xuICAgICogQHBhcmFtIHtTdHJpbmd9IG8ubmFtZSBUaGUgbmFtZSBvZiB0aGUgdGVzdFxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gby50ZXN0IFRoZSB0ZXN0IGZ1bmN0aW9uIHRvIGV4ZWN1dGUsIHRoZSBvbmx5IGFyZ3VtZW50IHRvIHRoZSBmdW5jdGlvbiBpcyB0aGUgYFlgIGluc3RhbmNlXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gby50cmlnZ2VyIFRoZSBtb2R1bGUgdGhhdCB0cmlnZ2VycyB0aGlzIHRlc3QuXG4gICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKGNhdCwgbmFtZSwgbykge1xuICAgICAgICBmZWF0dXJlX3Rlc3RzW2NhdF0gPSBmZWF0dXJlX3Rlc3RzW2NhdF0gfHwge307XG4gICAgICAgIGZlYXR1cmVfdGVzdHNbY2F0XVtuYW1lXSA9IG87XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEV4ZWN1dGUgYWxsIHRlc3RzIG9mIGEgZ2l2ZW4gY2F0ZWdvcnkgYW5kIHJldHVybiB0aGUgc2VyaWFsaXplZCByZXN1bHRzXG4gICAgKlxuICAgICogICBgYGBcbiAgICAqICAgY2Fwcz0xOjE7MjoxOzM6MFxuICAgICogICBgYGBcbiAgICAqIEBtZXRob2QgYWxsXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gY2F0IFRoZSBjYXRlZ29yeSB0byBleGVjdXRlXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgdGVzdCBmdW5jdGlvblxuICAgICogQHJldHVybiB7U3RyaW5nfSBBIHNlbWktY29sb24gc2VwYXJhdGVkIHN0cmluZyBvZiB0ZXN0cyBhbmQgdGhlaXIgc3VjY2Vzcy9mYWlsdXJlOiAxOjE7MjoxOzM6MFxuICAgICovXG4gICAgYWxsOiBmdW5jdGlvbihjYXQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGNhdF9vID0gZmVhdHVyZV90ZXN0c1tjYXRdLFxuICAgICAgICAgICAgLy8gcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChjYXRfbykge1xuICAgICAgICAgICAgWS5PYmplY3QuZWFjaChjYXRfbywgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGsgKyAnOicgKyAoWS5GZWF0dXJlcy50ZXN0KGNhdCwgaywgYXJncykgPyAxIDogMCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHJlc3VsdC5sZW5ndGgpID8gcmVzdWx0LmpvaW4oJzsnKSA6ICcnO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBSdW4gYSBzcGVjaWZpYyB0ZXN0IGFuZCByZXR1cm4gYSBCb29sZWFuIHJlc3BvbnNlLlxuICAgICpcbiAgICAqICAgYGBgXG4gICAgKiAgIFkuRmVhdHVyZXMudGVzdChcImxvYWRcIiwgXCIxXCIpO1xuICAgICogICBgYGBcbiAgICAqXG4gICAgKiBAbWV0aG9kIHRlc3RcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYXQgVGhlIGNhdGVnb3J5IG9mIHRoZSB0ZXN0IHRvIHJ1blxuICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRlc3QgdG8gcnVuXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgdGVzdCBmdW5jdGlvblxuICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBvciBmYWxzZSBpZiB0aGUgdGVzdCBwYXNzZWQvZmFpbGVkLlxuICAgICovXG4gICAgdGVzdDogZnVuY3Rpb24oY2F0LCBuYW1lLCBhcmdzKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgICAgICB2YXIgcmVzdWx0LCB1YSwgdGVzdCxcbiAgICAgICAgICAgIGNhdF9vID0gZmVhdHVyZV90ZXN0c1tjYXRdLFxuICAgICAgICAgICAgZmVhdHVyZSA9IGNhdF9vICYmIGNhdF9vW25hbWVdO1xuXG4gICAgICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXN1bHQgPSBmZWF0dXJlLnJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKFkuTGFuZy5pc1VuZGVmaW5lZChyZXN1bHQpKSB7XG5cbiAgICAgICAgICAgICAgICB1YSA9IGZlYXR1cmUudWE7XG4gICAgICAgICAgICAgICAgaWYgKHVhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChZLlVBW3VhXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGVzdCA9IGZlYXR1cmUudGVzdDtcbiAgICAgICAgICAgICAgICBpZiAodGVzdCAmJiAoKCF1YSkgfHwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0ZXN0LmFwcGx5KFksIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZlYXR1cmUucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59KTtcblxuLy8gWS5GZWF0dXJlcy5hZGQoXCJsb2FkXCIsIFwiMVwiLCB7fSk7XG4vLyBZLkZlYXR1cmVzLnRlc3QoXCJsb2FkXCIsIFwiMVwiKTtcbi8vIGNhcHM9MToxOzI6MDszOjE7XG5cbi8qIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZCBieSAoeW9naS5qcyBsb2FkZXIgLS1taXggLS15ZXMpICovXG4vKmpzaGludCBtYXhsZW46OTAwLCBlcWVxZXE6IGZhbHNlICovXG52YXIgYWRkID0gWS5GZWF0dXJlcy5hZGQ7XG4vLyBhcHAtdHJhbnNpdGlvbnMtbmF0aXZlXG5hZGQoJ2xvYWQnLCAnMCcsIHtcbiAgICBcIm5hbWVcIjogXCJhcHAtdHJhbnNpdGlvbnMtbmF0aXZlXCIsXG4gICAgXCJ0ZXN0XCI6IGZ1bmN0aW9uIChZKSB7XG4gICAgdmFyIGRvYyAgPSBZLmNvbmZpZy5kb2MsXG4gICAgICAgIG5vZGUgPSBkb2MgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogbnVsbDtcblxuICAgIGlmIChub2RlICYmIG5vZGUuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuICgnTW96VHJhbnNpdGlvbicgaW4gbm9kZS5zdHlsZSB8fCAnV2Via2l0VHJhbnNpdGlvbicgaW4gbm9kZS5zdHlsZSB8fCAndHJhbnNpdGlvbicgaW4gbm9kZS5zdHlsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufSxcbiAgICBcInRyaWdnZXJcIjogXCJhcHAtdHJhbnNpdGlvbnNcIlxufSk7XG4vLyBhdXRvY29tcGxldGUtbGlzdC1rZXlzXG5hZGQoJ2xvYWQnLCAnMScsIHtcbiAgICBcIm5hbWVcIjogXCJhdXRvY29tcGxldGUtbGlzdC1rZXlzXCIsXG4gICAgXCJ0ZXN0XCI6IGZ1bmN0aW9uIChZKSB7XG4gICAgLy8gT25seSBhZGQga2V5Ym9hcmQgc3VwcG9ydCB0byBhdXRvY29tcGxldGUtbGlzdCBpZiB0aGlzIGRvZXNuJ3QgYXBwZWFyIHRvXG4gICAgLy8gYmUgYW4gaU9TIG9yIEFuZHJvaWQtYmFzZWQgbW9iaWxlIGRldmljZS5cbiAgICAvL1xuICAgIC8vIFRoZXJlJ3MgY3VycmVudGx5IG5vIGZlYXNpYmxlIHdheSB0byBhY3R1YWxseSBkZXRlY3Qgd2hldGhlciBhIGRldmljZSBoYXNcbiAgICAvLyBhIGhhcmR3YXJlIGtleWJvYXJkLCBzbyB0aGlzIHNuaWZmIHdpbGwgaGF2ZSB0byBkby4gSXQgY2FuIGVhc2lseSBiZVxuICAgIC8vIG92ZXJyaWRkZW4gYnkgbWFudWFsbHkgbG9hZGluZyB0aGUgYXV0b2NvbXBsZXRlLWxpc3Qta2V5cyBtb2R1bGUuXG4gICAgLy9cbiAgICAvLyBXb3J0aCBub3Rpbmc6IGV2ZW4gdGhvdWdoIGlPUyBzdXBwb3J0cyBibHVldG9vdGgga2V5Ym9hcmRzLCBNb2JpbGUgU2FmYXJpXG4gICAgLy8gZG9lc24ndCBmaXJlIHRoZSBrZXlib2FyZCBldmVudHMgdXNlZCBieSBBdXRvQ29tcGxldGVMaXN0LCBzbyB0aGVyZSdzXG4gICAgLy8gbm8gcG9pbnQgbG9hZGluZyB0aGUgLWtleXMgbW9kdWxlIGV2ZW4gd2hlbiBhIGJsdWV0b290aCBrZXlib2FyZCBtYXkgYmVcbiAgICAvLyBhdmFpbGFibGUuXG4gICAgcmV0dXJuICEoWS5VQS5pb3MgfHwgWS5VQS5hbmRyb2lkKTtcbn0sXG4gICAgXCJ0cmlnZ2VyXCI6IFwiYXV0b2NvbXBsZXRlLWxpc3RcIlxufSk7XG4vLyBkZC1nZXN0dXJlc1xuYWRkKCdsb2FkJywgJzInLCB7XG4gICAgXCJuYW1lXCI6IFwiZGQtZ2VzdHVyZXNcIixcbiAgICBcInRyaWdnZXJcIjogXCJkZC1kcmFnXCIsXG4gICAgXCJ1YVwiOiBcInRvdWNoRW5hYmxlZFwiXG59KTtcbi8vIGRvbS1zdHlsZS1pZVxuYWRkKCdsb2FkJywgJzMnLCB7XG4gICAgXCJuYW1lXCI6IFwiZG9tLXN0eWxlLWllXCIsXG4gICAgXCJ0ZXN0XCI6IGZ1bmN0aW9uIChZKSB7XG5cbiAgICB2YXIgdGVzdEZlYXR1cmUgPSBZLkZlYXR1cmVzLnRlc3QsXG4gICAgICAgIGFkZEZlYXR1cmUgPSBZLkZlYXR1cmVzLmFkZCxcbiAgICAgICAgV0lORE9XID0gWS5jb25maWcud2luLFxuICAgICAgICBET0NVTUVOVCA9IFkuY29uZmlnLmRvYyxcbiAgICAgICAgRE9DVU1FTlRfRUxFTUVOVCA9ICdkb2N1bWVudEVsZW1lbnQnLFxuICAgICAgICByZXQgPSBmYWxzZTtcblxuICAgIGFkZEZlYXR1cmUoJ3N0eWxlJywgJ2NvbXB1dGVkU3R5bGUnLCB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFdJTkRPVyAmJiAnZ2V0Q29tcHV0ZWRTdHlsZScgaW4gV0lORE9XO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRGZWF0dXJlKCdzdHlsZScsICdvcGFjaXR5Jywge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBET0NVTUVOVCAmJiAnb3BhY2l0eScgaW4gRE9DVU1FTlRbRE9DVU1FTlRfRUxFTUVOVF0uc3R5bGU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldCA9ICAoIXRlc3RGZWF0dXJlKCdzdHlsZScsICdvcGFjaXR5JykgJiZcbiAgICAgICAgICAgICF0ZXN0RmVhdHVyZSgnc3R5bGUnLCAnY29tcHV0ZWRTdHlsZScpKTtcblxuICAgIHJldHVybiByZXQ7XG59LFxuICAgIFwidHJpZ2dlclwiOiBcImRvbS1zdHlsZVwiXG59KTtcbi8vIGVkaXRvci1wYXJhLWllXG5hZGQoJ2xvYWQnLCAnNCcsIHtcbiAgICBcIm5hbWVcIjogXCJlZGl0b3ItcGFyYS1pZVwiLFxuICAgIFwidHJpZ2dlclwiOiBcImVkaXRvci1wYXJhXCIsXG4gICAgXCJ1YVwiOiBcImllXCIsXG4gICAgXCJ3aGVuXCI6IFwiaW5zdGVhZFwiXG59KTtcbi8vIGV2ZW50LWJhc2UtaWVcbmFkZCgnbG9hZCcsICc1Jywge1xuICAgIFwibmFtZVwiOiBcImV2ZW50LWJhc2UtaWVcIixcbiAgICBcInRlc3RcIjogZnVuY3Rpb24oWSkge1xuICAgIHZhciBpbXAgPSBZLmNvbmZpZy5kb2MgJiYgWS5jb25maWcuZG9jLmltcGxlbWVudGF0aW9uO1xuICAgIHJldHVybiAoaW1wICYmICghaW1wLmhhc0ZlYXR1cmUoJ0V2ZW50cycsICcyLjAnKSkpO1xufSxcbiAgICBcInRyaWdnZXJcIjogXCJub2RlLWJhc2VcIlxufSk7XG4vLyBncmFwaGljcy1jYW52YXNcbmFkZCgnbG9hZCcsICc2Jywge1xuICAgIFwibmFtZVwiOiBcImdyYXBoaWNzLWNhbnZhc1wiLFxuICAgIFwidGVzdFwiOiBmdW5jdGlvbihZKSB7XG4gICAgdmFyIERPQ1VNRU5UID0gWS5jb25maWcuZG9jLFxuICAgICAgICB1c2VDYW52YXMgPSBZLmNvbmZpZy5kZWZhdWx0R3JhcGhpY0VuZ2luZSAmJiBZLmNvbmZpZy5kZWZhdWx0R3JhcGhpY0VuZ2luZSA9PSBcImNhbnZhc1wiLFxuXHRcdGNhbnZhcyA9IERPQ1VNRU5UICYmIERPQ1VNRU5ULmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgIHN2ZyA9IChET0NVTUVOVCAmJiBET0NVTUVOVC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZVwiLCBcIjEuMVwiKSk7XG4gICAgcmV0dXJuICghc3ZnIHx8IHVzZUNhbnZhcykgJiYgKGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpKTtcbn0sXG4gICAgXCJ0cmlnZ2VyXCI6IFwiZ3JhcGhpY3NcIlxufSk7XG4vLyBncmFwaGljcy1jYW52YXMtZGVmYXVsdFxuYWRkKCdsb2FkJywgJzcnLCB7XG4gICAgXCJuYW1lXCI6IFwiZ3JhcGhpY3MtY2FudmFzLWRlZmF1bHRcIixcbiAgICBcInRlc3RcIjogZnVuY3Rpb24oWSkge1xuICAgIHZhciBET0NVTUVOVCA9IFkuY29uZmlnLmRvYyxcbiAgICAgICAgdXNlQ2FudmFzID0gWS5jb25maWcuZGVmYXVsdEdyYXBoaWNFbmdpbmUgJiYgWS5jb25maWcuZGVmYXVsdEdyYXBoaWNFbmdpbmUgPT0gXCJjYW52YXNcIixcblx0XHRjYW52YXMgPSBET0NVTUVOVCAmJiBET0NVTUVOVC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICBzdmcgPSAoRE9DVU1FTlQgJiYgRE9DVU1FTlQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmVcIiwgXCIxLjFcIikpO1xuICAgIHJldHVybiAoIXN2ZyB8fCB1c2VDYW52YXMpICYmIChjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSk7XG59LFxuICAgIFwidHJpZ2dlclwiOiBcImdyYXBoaWNzXCJcbn0pO1xuLy8gZ3JhcGhpY3Mtc3ZnXG5hZGQoJ2xvYWQnLCAnOCcsIHtcbiAgICBcIm5hbWVcIjogXCJncmFwaGljcy1zdmdcIixcbiAgICBcInRlc3RcIjogZnVuY3Rpb24oWSkge1xuICAgIHZhciBET0NVTUVOVCA9IFkuY29uZmlnLmRvYyxcbiAgICAgICAgdXNlU1ZHID0gIVkuY29uZmlnLmRlZmF1bHRHcmFwaGljRW5naW5lIHx8IFkuY29uZmlnLmRlZmF1bHRHcmFwaGljRW5naW5lICE9IFwiY2FudmFzXCIsXG5cdFx0Y2FudmFzID0gRE9DVU1FTlQgJiYgRE9DVU1FTlQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgc3ZnID0gKERPQ1VNRU5UICYmIERPQ1VNRU5ULmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlXCIsIFwiMS4xXCIpKTtcblxuICAgIHJldHVybiBzdmcgJiYgKHVzZVNWRyB8fCAhY2FudmFzKTtcbn0sXG4gICAgXCJ0cmlnZ2VyXCI6IFwiZ3JhcGhpY3NcIlxufSk7XG4vLyBncmFwaGljcy1zdmctZGVmYXVsdFxuYWRkKCdsb2FkJywgJzknLCB7XG4gICAgXCJuYW1lXCI6IFwiZ3JhcGhpY3Mtc3ZnLWRlZmF1bHRcIixcbiAgICBcInRlc3RcIjogZnVuY3Rpb24oWSkge1xuICAgIHZhciBET0NVTUVOVCA9IFkuY29uZmlnLmRvYyxcbiAgICAgICAgdXNlU1ZHID0gIVkuY29uZmlnLmRlZmF1bHRHcmFwaGljRW5naW5lIHx8IFkuY29uZmlnLmRlZmF1bHRHcmFwaGljRW5naW5lICE9IFwiY2FudmFzXCIsXG5cdFx0Y2FudmFzID0gRE9DVU1FTlQgJiYgRE9DVU1FTlQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgc3ZnID0gKERPQ1VNRU5UICYmIERPQ1VNRU5ULmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlXCIsIFwiMS4xXCIpKTtcblxuICAgIHJldHVybiBzdmcgJiYgKHVzZVNWRyB8fCAhY2FudmFzKTtcbn0sXG4gICAgXCJ0cmlnZ2VyXCI6IFwiZ3JhcGhpY3NcIlxufSk7XG4vLyBncmFwaGljcy12bWxcbmFkZCgnbG9hZCcsICcxMCcsIHtcbiAgICBcIm5hbWVcIjogXCJncmFwaGljcy12bWxcIixcbiAgICBcInRlc3RcIjogZnVuY3Rpb24oWSkge1xuICAgIHZhciBET0NVTUVOVCA9IFkuY29uZmlnLmRvYyxcblx0XHRjYW52YXMgPSBET0NVTUVOVCAmJiBET0NVTUVOVC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHJldHVybiAoRE9DVU1FTlQgJiYgIURPQ1VNRU5ULmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlXCIsIFwiMS4xXCIpICYmICghY2FudmFzIHx8ICFjYW52YXMuZ2V0Q29udGV4dCB8fCAhY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSkpO1xufSxcbiAgICBcInRyaWdnZXJcIjogXCJncmFwaGljc1wiXG59KTtcbi8vIGdyYXBoaWNzLXZtbC1kZWZhdWx0XG5hZGQoJ2xvYWQnLCAnMTEnLCB7XG4gICAgXCJuYW1lXCI6IFwiZ3JhcGhpY3Mtdm1sLWRlZmF1bHRcIixcbiAgICBcInRlc3RcIjogZnVuY3Rpb24oWSkge1xuICAgIHZhciBET0NVTUVOVCA9IFkuY29uZmlnLmRvYyxcblx0XHRjYW52YXMgPSBET0NVTUVOVCAmJiBET0NVTUVOVC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHJldHVybiAoRE9DVU1FTlQgJiYgIURPQ1VNRU5ULmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlXCIsIFwiMS4xXCIpICYmICghY2FudmFzIHx8ICFjYW52YXMuZ2V0Q29udGV4dCB8fCAhY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSkpO1xufSxcbiAgICBcInRyaWdnZXJcIjogXCJncmFwaGljc1wiXG59KTtcbi8vIGhpc3RvcnktaGFzaC1pZVxuYWRkKCdsb2FkJywgJzEyJywge1xuICAgIFwibmFtZVwiOiBcImhpc3RvcnktaGFzaC1pZVwiLFxuICAgIFwidGVzdFwiOiBmdW5jdGlvbiAoWSkge1xuICAgIHZhciBkb2NNb2RlID0gWS5jb25maWcuZG9jICYmIFkuY29uZmlnLmRvYy5kb2N1bWVudE1vZGU7XG5cbiAgICByZXR1cm4gWS5VQS5pZSAmJiAoISgnb25oYXNoY2hhbmdlJyBpbiBZLmNvbmZpZy53aW4pIHx8XG4gICAgICAgICAgICAhZG9jTW9kZSB8fCBkb2NNb2RlIDwgOCk7XG59LFxuICAgIFwidHJpZ2dlclwiOiBcImhpc3RvcnktaGFzaFwiXG59KTtcbi8vIGlvLW5vZGVqc1xuYWRkKCdsb2FkJywgJzEzJywge1xuICAgIFwibmFtZVwiOiBcImlvLW5vZGVqc1wiLFxuICAgIFwidHJpZ2dlclwiOiBcImlvLWJhc2VcIixcbiAgICBcInVhXCI6IFwibm9kZWpzXCJcbn0pO1xuLy8ganNvbi1wYXJzZS1zaGltXG5hZGQoJ2xvYWQnLCAnMTQnLCB7XG4gICAgXCJuYW1lXCI6IFwianNvbi1wYXJzZS1zaGltXCIsXG4gICAgXCJ0ZXN0XCI6IGZ1bmN0aW9uIChZKSB7XG4gICAgdmFyIF9KU09OID0gWS5jb25maWcuZ2xvYmFsLkpTT04sXG4gICAgICAgIE5hdGl2ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChfSlNPTikgPT09ICdbb2JqZWN0IEpTT05dJyAmJiBfSlNPTixcbiAgICAgICAgbmF0aXZlU3VwcG9ydCA9IFkuY29uZmlnLnVzZU5hdGl2ZUpTT05QYXJzZSAhPT0gZmFsc2UgJiYgISFOYXRpdmU7XG5cbiAgICBmdW5jdGlvbiB3b3JraW5nTmF0aXZlKCBrLCB2ICkge1xuICAgICAgICByZXR1cm4gayA9PT0gXCJva1wiID8gdHJ1ZSA6IHY7XG4gICAgfVxuXG4gICAgLy8gRG91YmxlIGNoZWNrIGJhc2ljIGZ1bmN0aW9uYWxpdHkuICBUaGlzIGlzIG1haW5seSB0byBjYXRjaCBlYXJseSBicm9rZW5cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIEpTT04gQVBJIGluIEZpcmVmb3ggMy4xIGJldGExIGFuZCBiZXRhMlxuICAgIGlmICggbmF0aXZlU3VwcG9ydCApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5hdGl2ZVN1cHBvcnQgPSAoIE5hdGl2ZS5wYXJzZSggJ3tcIm9rXCI6ZmFsc2V9Jywgd29ya2luZ05hdGl2ZSApICkub2s7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKCBlICkge1xuICAgICAgICAgICAgbmF0aXZlU3VwcG9ydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICFuYXRpdmVTdXBwb3J0O1xufSxcbiAgICBcInRyaWdnZXJcIjogXCJqc29uLXBhcnNlXCJcbn0pO1xuLy8ganNvbi1zdHJpbmdpZnktc2hpbVxuYWRkKCdsb2FkJywgJzE1Jywge1xuICAgIFwibmFtZVwiOiBcImpzb24tc3RyaW5naWZ5LXNoaW1cIixcbiAgICBcInRlc3RcIjogZnVuY3Rpb24gKFkpIHtcbiAgICB2YXIgX0pTT04gPSBZLmNvbmZpZy5nbG9iYWwuSlNPTixcbiAgICAgICAgTmF0aXZlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKF9KU09OKSA9PT0gJ1tvYmplY3QgSlNPTl0nICYmIF9KU09OLFxuICAgICAgICBuYXRpdmVTdXBwb3J0ID0gWS5jb25maWcudXNlTmF0aXZlSlNPTlN0cmluZ2lmeSAhPT0gZmFsc2UgJiYgISFOYXRpdmU7XG5cbiAgICAvLyBEb3VibGUgY2hlY2sgYmFzaWMgbmF0aXZlIGZ1bmN0aW9uYWxpdHkuICBUaGlzIGlzIHByaW1hcmlseSB0byBjYXRjaCBicm9rZW5cbiAgICAvLyBlYXJseSBKU09OIEFQSSBpbXBsZW1lbnRhdGlvbnMgaW4gRmlyZWZveCAzLjEgYmV0YTEgYW5kIGJldGEyLlxuICAgIGlmICggbmF0aXZlU3VwcG9ydCApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5hdGl2ZVN1cHBvcnQgPSAoICcwJyA9PT0gTmF0aXZlLnN0cmluZ2lmeSgwKSApO1xuICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgIG5hdGl2ZVN1cHBvcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcmV0dXJuICFuYXRpdmVTdXBwb3J0O1xufSxcbiAgICBcInRyaWdnZXJcIjogXCJqc29uLXN0cmluZ2lmeVwiXG59KTtcbi8vIHNjcm9sbHZpZXctYmFzZS1pZVxuYWRkKCdsb2FkJywgJzE2Jywge1xuICAgIFwibmFtZVwiOiBcInNjcm9sbHZpZXctYmFzZS1pZVwiLFxuICAgIFwidHJpZ2dlclwiOiBcInNjcm9sbHZpZXctYmFzZVwiLFxuICAgIFwidWFcIjogXCJpZVwiXG59KTtcbi8vIHNlbGVjdG9yLWNzczJcbmFkZCgnbG9hZCcsICcxNycsIHtcbiAgICBcIm5hbWVcIjogXCJzZWxlY3Rvci1jc3MyXCIsXG4gICAgXCJ0ZXN0XCI6IGZ1bmN0aW9uIChZKSB7XG4gICAgdmFyIERPQ1VNRU5UID0gWS5jb25maWcuZG9jLFxuICAgICAgICByZXQgPSBET0NVTUVOVCAmJiAhKCdxdWVyeVNlbGVjdG9yQWxsJyBpbiBET0NVTUVOVCk7XG5cbiAgICByZXR1cm4gcmV0O1xufSxcbiAgICBcInRyaWdnZXJcIjogXCJzZWxlY3RvclwiXG59KTtcbi8vIHRyYW5zaXRpb24tdGltZXJcbmFkZCgnbG9hZCcsICcxOCcsIHtcbiAgICBcIm5hbWVcIjogXCJ0cmFuc2l0aW9uLXRpbWVyXCIsXG4gICAgXCJ0ZXN0XCI6IGZ1bmN0aW9uIChZKSB7XG4gICAgdmFyIERPQ1VNRU5UID0gWS5jb25maWcuZG9jLFxuICAgICAgICBub2RlID0gKERPQ1VNRU5UKSA/IERPQ1VNRU5ULmRvY3VtZW50RWxlbWVudDogbnVsbCxcbiAgICAgICAgcmV0ID0gdHJ1ZTtcblxuICAgIGlmIChub2RlICYmIG5vZGUuc3R5bGUpIHtcbiAgICAgICAgcmV0ID0gISgnTW96VHJhbnNpdGlvbicgaW4gbm9kZS5zdHlsZSB8fCAnV2Via2l0VHJhbnNpdGlvbicgaW4gbm9kZS5zdHlsZSB8fCAndHJhbnNpdGlvbicgaW4gbm9kZS5zdHlsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn0sXG4gICAgXCJ0cmlnZ2VyXCI6IFwidHJhbnNpdGlvblwiXG59KTtcbi8vIHdpZGdldC1iYXNlLWllXG5hZGQoJ2xvYWQnLCAnMTknLCB7XG4gICAgXCJuYW1lXCI6IFwid2lkZ2V0LWJhc2UtaWVcIixcbiAgICBcInRyaWdnZXJcIjogXCJ3aWRnZXQtYmFzZVwiLFxuICAgIFwidWFcIjogXCJpZVwiXG59KTtcbi8vIHlxbC1qc29ucFxuYWRkKCdsb2FkJywgJzIwJywge1xuICAgIFwibmFtZVwiOiBcInlxbC1qc29ucFwiLFxuICAgIFwidGVzdFwiOiBmdW5jdGlvbiAoWSkge1xuICAgIC8qIE9ubHkgbG9hZCB0aGUgSlNPTlAgbW9kdWxlIHdoZW4gbm90IGluIG5vZGVqcyBvciB3aW5qc1xuICAgIFRPRE8gTWFrZSB0aGUgd2luanMgbW9kdWxlIGEgQ09SUyBtb2R1bGVcbiAgICAqL1xuICAgIHJldHVybiAoIVkuVUEubm9kZWpzICYmICFZLlVBLndpbmpzKTtcbn0sXG4gICAgXCJ0cmlnZ2VyXCI6IFwieXFsXCJcbn0pO1xuLy8geXFsLW5vZGVqc1xuYWRkKCdsb2FkJywgJzIxJywge1xuICAgIFwibmFtZVwiOiBcInlxbC1ub2RlanNcIixcbiAgICBcInRyaWdnZXJcIjogXCJ5cWxcIixcbiAgICBcInVhXCI6IFwibm9kZWpzXCJcbn0pO1xuLy8geXFsLXdpbmpzXG5hZGQoJ2xvYWQnLCAnMjInLCB7XG4gICAgXCJuYW1lXCI6IFwieXFsLXdpbmpzXCIsXG4gICAgXCJ0cmlnZ2VyXCI6IFwieXFsXCIsXG4gICAgXCJ1YVwiOiBcIndpbmpzXCJcbn0pO1xuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wieXVpLWJhc2VcIl19KTtcbllVSS5hZGQoJ2ludGwtYmFzZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogVGhlIEludGwgdXRpbGl0eSBwcm92aWRlcyBhIGNlbnRyYWwgbG9jYXRpb24gZm9yIG1hbmFnaW5nIHNldHMgb2ZcbiAqIGxvY2FsaXplZCByZXNvdXJjZXMgKHN0cmluZ3MgYW5kIGZvcm1hdHRpbmcgcGF0dGVybnMpLlxuICpcbiAqIEBjbGFzcyBJbnRsXG4gKiBAdXNlcyBFdmVudFRhcmdldFxuICogQHN0YXRpY1xuICovXG5cbnZhciBTUExJVF9SRUdFWCA9IC9bLCBdLztcblxuWS5taXgoWS5uYW1lc3BhY2UoJ0ludGwnKSwge1xuXG4gLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBsYW5ndWFnZSBhbW9uZyB0aG9zZSBhdmFpbGFibGUgdGhhdFxuICAgICogYmVzdCBtYXRjaGVzIHRoZSBwcmVmZXJyZWQgbGFuZ3VhZ2UgbGlzdCwgdXNpbmcgdGhlIExvb2t1cFxuICAgICogYWxnb3JpdGhtIG9mIEJDUCA0Ny5cbiAgICAqIElmIG5vbmUgb2YgdGhlIGF2YWlsYWJsZSBsYW5ndWFnZXMgbWVldHMgdGhlIHVzZXIncyBwcmVmZXJlbmNlcyxcbiAgICAqIHRoZW4gXCJcIiBpcyByZXR1cm5lZC5cbiAgICAqIEV4dGVuZGVkIGxhbmd1YWdlIHJhbmdlcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIGxvb2t1cEJlc3RMYW5nXG4gICAgKiBAcGFyYW0ge1N0cmluZ1tdIHwgU3RyaW5nfSBwcmVmZXJyZWRMYW5ndWFnZXMgVGhlIGxpc3Qgb2YgcHJlZmVycmVkXG4gICAgKiBsYW5ndWFnZXMgaW4gZGVzY2VuZGluZyBwcmVmZXJlbmNlIG9yZGVyLCByZXByZXNlbnRlZCBhcyBCQ1AgNDdcbiAgICAqIGxhbmd1YWdlIHRhZ3MuIEEgc3RyaW5nIGFycmF5IG9yIGEgY29tbWEtc2VwYXJhdGVkIGxpc3QuXG4gICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBhdmFpbGFibGVMYW5ndWFnZXMgVGhlIGxpc3Qgb2YgbGFuZ3VhZ2VzXG4gICAgKiB0aGF0IHRoZSBhcHBsaWNhdGlvbiBzdXBwb3J0cywgcmVwcmVzZW50ZWQgYXMgQkNQIDQ3IGxhbmd1YWdlXG4gICAgKiB0YWdzLlxuICAgICpcbiAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGF2YWlsYWJsZSBsYW5ndWFnZSB0aGF0IGJlc3QgbWF0Y2hlcyB0aGVcbiAgICAqIHByZWZlcnJlZCBsYW5ndWFnZSBsaXN0LCBvciBcIlwiLlxuICAgICogQHNpbmNlIDMuMS4wXG4gICAgKi9cbiAgICBsb29rdXBCZXN0TGFuZzogZnVuY3Rpb24ocHJlZmVycmVkTGFuZ3VhZ2VzLCBhdmFpbGFibGVMYW5ndWFnZXMpIHtcblxuICAgICAgICB2YXIgaSwgbGFuZ3VhZ2UsIHJlc3VsdCwgaW5kZXg7XG5cbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbGFuZ3VhZ2VzIGNvbnRhaW5zIGxhbmd1YWdlO1xuICAgICAgICAvLyBpZiBzbyByZXR1cm4gaXRcbiAgICAgICAgZnVuY3Rpb24gc2NhbihsYW5ndWFnZSkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXZhaWxhYmxlTGFuZ3VhZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlLnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlTGFuZ3VhZ2VzW2ldLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZUxhbmd1YWdlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoWS5MYW5nLmlzU3RyaW5nKHByZWZlcnJlZExhbmd1YWdlcykpIHtcbiAgICAgICAgICAgIHByZWZlcnJlZExhbmd1YWdlcyA9IHByZWZlcnJlZExhbmd1YWdlcy5zcGxpdChTUExJVF9SRUdFWCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJlZmVycmVkTGFuZ3VhZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsYW5ndWFnZSA9IHByZWZlcnJlZExhbmd1YWdlc1tpXTtcbiAgICAgICAgICAgIGlmICghbGFuZ3VhZ2UgfHwgbGFuZ3VhZ2UgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGZhbGxiYWNrIHNlcXVlbmNlIGZvciBvbmUgbGFuZ3VhZ2VcbiAgICAgICAgICAgIHdoaWxlIChsYW5ndWFnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2NhbihsYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbGFuZ3VhZ2UubGFzdEluZGV4T2YoJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlID0gbGFuZ3VhZ2Uuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uZS1jaGFyYWN0ZXIgc3VidGFncyBnZXQgY3V0IGFsb25nIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb2xsb3dpbmcgc3VidGFnXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMiAmJiBsYW5ndWFnZS5jaGFyQXQoaW5kZXggLSAyKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2UgPSBsYW5ndWFnZS5zdWJzdHJpbmcoMCwgaW5kZXggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgYXZhaWxhYmxlIGZvciB0aGlzIGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59KTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wieXVpLWJhc2VcIl19KTtcbllVSS5hZGQoJ3l1aS1sb2cnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIFByb3ZpZGVzIGNvbnNvbGUgbG9nIGNhcGFiaWxpdHkgYW5kIGV4cG9zZXMgYSBjdXN0b20gZXZlbnQgZm9yXG4gKiBjb25zb2xlIGltcGxlbWVudGF0aW9ucy4gVGhpcyBtb2R1bGUgaXMgYSBgY29yZWAgWVVJIG1vZHVsZSxcbiAqIDxhIGhyZWY9XCIuLi9jbGFzc2VzL1lVSS5odG1sI21ldGhvZF9sb2dcIj5pdCdzIGRvY3VtZW50YXRpb24gaXMgbG9jYXRlZCB1bmRlciB0aGUgWVVJIGNsYXNzPC9hPi5cbiAqXG4gKiBAbW9kdWxlIHl1aVxuICogQHN1Ym1vZHVsZSB5dWktbG9nXG4gKi9cblxudmFyIElOU1RBTkNFID0gWSxcbiAgICBMT0dFVkVOVCA9ICd5dWk6bG9nJyxcbiAgICBVTkRFRklORUQgPSAndW5kZWZpbmVkJyxcbiAgICBMRVZFTFMgPSB7IGRlYnVnOiAxLFxuICAgICAgICAgICAgICAgaW5mbzogMixcbiAgICAgICAgICAgICAgIHdhcm46IDQsXG4gICAgICAgICAgICAgICBlcnJvcjogOCB9O1xuXG4vKipcbiAqIElmIHRoZSAnZGVidWcnIGNvbmZpZyBpcyB0cnVlLCBhICd5dWk6bG9nJyBldmVudCB3aWxsIGJlXG4gKiBkaXNwYXRjaGVkLCB3aGljaCB0aGUgQ29uc29sZSB3aWRnZXQgYW5kIGFueXRoaW5nIGVsc2VcbiAqIGNhbiBjb25zdW1lLiAgSWYgdGhlICd1c2VCcm93c2VyQ29uc29sZScgY29uZmlnIGlzIHRydWUsIGl0IHdpbGxcbiAqIHdyaXRlIHRvIHRoZSBicm93c2VyIGNvbnNvbGUgaWYgYXZhaWxhYmxlLiAgWVVJLXNwZWNpZmljIGxvZ1xuICogbWVzc2FnZXMgd2lsbCBvbmx5IGJlIHByZXNlbnQgaW4gdGhlIC1kZWJ1ZyB2ZXJzaW9ucyBvZiB0aGVcbiAqIEpTIGZpbGVzLiAgVGhlIGJ1aWxkIHN5c3RlbSBpcyBzdXBwb3NlZCB0byByZW1vdmUgbG9nIHN0YXRlbWVudHNcbiAqIGZyb20gdGhlIHJhdyBhbmQgbWluaWZpZWQgdmVyc2lvbnMgb2YgdGhlIGZpbGVzLlxuICpcbiAqIEBtZXRob2QgbG9nXG4gKiBAZm9yIFlVSVxuICogQHBhcmFtICB7U3RyaW5nfSAgbXNnICBUaGUgbWVzc2FnZSB0byBsb2cuXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBjYXQgIFRoZSBsb2cgY2F0ZWdvcnkgZm9yIHRoZSBtZXNzYWdlLiAgRGVmYXVsdFxuICogICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzIGFyZSBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIiwgXCJkZWJ1Z1wiLlxuICogICAgICAgICAgICAgICAgICAgICAgICBDdXN0b20gY2F0ZWdvcmllcyBjYW4gYmUgdXNlZCBhcyB3ZWxsLiAob3B0KS5cbiAqIEBwYXJhbSAge1N0cmluZ30gIHNyYyAgVGhlIHNvdXJjZSBvZiB0aGUgdGhlIG1lc3NhZ2UgKG9wdCkuXG4gKiBAcGFyYW0gIHtib29sZWFufSBzaWxlbnQgSWYgdHJ1ZSwgdGhlIGxvZyBldmVudCB3b24ndCBmaXJlLlxuICogQHJldHVybiB7WVVJfSAgICAgIFlVSSBpbnN0YW5jZS5cbiAqL1xuSU5TVEFOQ0UubG9nID0gZnVuY3Rpb24obXNnLCBjYXQsIHNyYywgc2lsZW50KSB7XG4gICAgdmFyIGJhaWwsIGV4Y2wsIGluY2wsIG0sIGYsIG1pbmxldmVsLFxuICAgICAgICBZID0gSU5TVEFOQ0UsXG4gICAgICAgIGMgPSBZLmNvbmZpZyxcbiAgICAgICAgcHVibGlzaGVyID0gKFkuZmlyZSkgPyBZIDogWVVJLkVudi5nbG9iYWxFdmVudHM7XG4gICAgLy8gc3VwcHJlc3MgbG9nIG1lc3NhZ2UgaWYgdGhlIGNvbmZpZyBpcyBvZmYgb3IgdGhlIGV2ZW50IHN0YWNrXG4gICAgLy8gb3IgdGhlIGV2ZW50IGNhbGwgc3RhY2sgY29udGFpbnMgYSBjb25zdW1lciBvZiB0aGUgeXVpOmxvZyBldmVudFxuICAgIGlmIChjLmRlYnVnKSB7XG4gICAgICAgIC8vIGFwcGx5IHNvdXJjZSBmaWx0ZXJzXG4gICAgICAgIHNyYyA9IHNyYyB8fCBcIlwiO1xuICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZXhjbCA9IGMubG9nRXhjbHVkZTtcbiAgICAgICAgICAgIGluY2wgPSBjLmxvZ0luY2x1ZGU7XG4gICAgICAgICAgICBpZiAoaW5jbCAmJiAhKHNyYyBpbiBpbmNsKSkge1xuICAgICAgICAgICAgICAgIGJhaWwgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmNsICYmIChzcmMgaW4gaW5jbCkpIHtcbiAgICAgICAgICAgICAgICBiYWlsID0gIWluY2xbc3JjXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhjbCAmJiAoc3JjIGluIGV4Y2wpKSB7XG4gICAgICAgICAgICAgICAgYmFpbCA9IGV4Y2xbc3JjXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBjYXRlZ29yeSBvZiBpbmZvIGlmIHRoZSBjYXRlZ29yeSB3YXMgbm90IGRlZmluZWQuXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBjYXQgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIGNhdCA9ICdpbmZvJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjdXJyZW50IG1pbmxldmVsIGFzIGRlZmluZWQgaW4gY29uZmlndXJhdGlvblxuICAgICAgICAgICAgWS5jb25maWcubG9nTGV2ZWwgPSBZLmNvbmZpZy5sb2dMZXZlbCB8fCAnZGVidWcnO1xuICAgICAgICAgICAgbWlubGV2ZWwgPSBMRVZFTFNbWS5jb25maWcubG9nTGV2ZWwudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgICAgIGlmIChjYXQgaW4gTEVWRUxTICYmIExFVkVMU1tjYXRdIDwgbWlubGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHRoaXMgbWVzc2FnZSBpZiB0aGUgd2UgZG9uJ3QgbWVldCB0aGUgZGVmaW5lZCBtaW5sZXZlbFxuICAgICAgICAgICAgICAgIGJhaWwgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYmFpbCkge1xuICAgICAgICAgICAgaWYgKGMudXNlQnJvd3NlckNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICBtID0gKHNyYykgPyBzcmMgKyAnOiAnICsgbXNnIDogbXNnO1xuICAgICAgICAgICAgICAgIGlmIChZLkxhbmcuaXNGdW5jdGlvbihjLmxvZ0ZuKSkge1xuICAgICAgICAgICAgICAgICAgICBjLmxvZ0ZuLmNhbGwoWSwgbXNnLCBjYXQsIHNyYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc29sZSAhPT0gVU5ERUZJTkVEICYmIGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSAoY2F0ICYmIGNvbnNvbGVbY2F0XSAmJiAoY2F0IGluIExFVkVMUykpID8gY2F0IDogJ2xvZyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbZl0obSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3BlcmEgIT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYS5wb3N0RXJyb3IobSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHVibGlzaGVyICYmICFzaWxlbnQpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwdWJsaXNoZXIgPT09IFkgJiYgKCFwdWJsaXNoZXIuZ2V0RXZlbnQoTE9HRVZFTlQpKSkge1xuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZXIucHVibGlzaChMT0dFVkVOVCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0OiAyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHB1Ymxpc2hlci5maXJlKExPR0VWRU5ULCB7XG4gICAgICAgICAgICAgICAgICAgIG1zZzogbXNnLFxuICAgICAgICAgICAgICAgICAgICBjYXQ6IGNhdCxcbiAgICAgICAgICAgICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBZO1xufTtcblxuLyoqXG4gKiBXcml0ZSBhIHN5c3RlbSBtZXNzYWdlLiAgVGhpcyBtZXNzYWdlIHdpbGwgYmUgcHJlc2VydmVkIGluIHRoZVxuICogbWluaWZpZWQgYW5kIHJhdyB2ZXJzaW9ucyBvZiB0aGUgWVVJIGZpbGVzLCB1bmxpa2UgbG9nIHN0YXRlbWVudHMuXG4gKiBAbWV0aG9kIG1lc3NhZ2VcbiAqIEBmb3IgWVVJXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBtc2cgIFRoZSBtZXNzYWdlIHRvIGxvZy5cbiAqIEBwYXJhbSAge1N0cmluZ30gIGNhdCAgVGhlIGxvZyBjYXRlZ29yeSBmb3IgdGhlIG1lc3NhZ2UuICBEZWZhdWx0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMgYXJlIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImRlYnVnXCIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIEN1c3RvbSBjYXRlZ29yaWVzIGNhbiBiZSB1c2VkIGFzIHdlbGwuIChvcHQpLlxuICogQHBhcmFtICB7U3RyaW5nfSAgc3JjICBUaGUgc291cmNlIG9mIHRoZSB0aGUgbWVzc2FnZSAob3B0KS5cbiAqIEBwYXJhbSAge2Jvb2xlYW59IHNpbGVudCBJZiB0cnVlLCB0aGUgbG9nIGV2ZW50IHdvbid0IGZpcmUuXG4gKiBAcmV0dXJuIHtZVUl9ICAgICAgWVVJIGluc3RhbmNlLlxuICovXG5JTlNUQU5DRS5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIElOU1RBTkNFLmxvZy5hcHBseShJTlNUQU5DRSwgYXJndW1lbnRzKTtcbn07XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcInl1aS1iYXNlXCJdfSk7XG5ZVUkuYWRkKCd5dWktbGF0ZXInLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgc2V0VGltZW91dC9zZXRJbnRlcnZhbCB3cmFwcGVyLiBUaGlzIG1vZHVsZSBpcyBhIGBjb3JlYCBZVUkgbW9kdWxlLFxuICogPGEgaHJlZj1cIi4uL2NsYXNzZXMvWVVJLmh0bWwjbWV0aG9kX2xhdGVyXCI+aXQncyBkb2N1bWVudGF0aW9uIGlzIGxvY2F0ZWQgdW5kZXIgdGhlIFlVSSBjbGFzczwvYT4uXG4gKlxuICogQG1vZHVsZSB5dWlcbiAqIEBzdWJtb2R1bGUgeXVpLWxhdGVyXG4gKi9cblxudmFyIE5PX0FSR1MgPSBbXTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gaW4gdGhlIGNvbnRleHQgb2YgdGhlIHN1cHBsaWVkXG4gKiBvYmplY3QgJ3doZW4nIG1pbGxpc2Vjb25kcyBsYXRlci4gIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiBhXG4gKiBzaW5nbGUgdGltZSB1bmxlc3MgcGVyaW9kaWMgaXMgc2V0IHRvIHRydWUuXG4gKiBAZm9yIFlVSVxuICogQG1ldGhvZCBsYXRlclxuICogQHBhcmFtIHdoZW4ge051bWJlcn0gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB1bnRpbCB0aGUgZm5cbiAqIGlzIGV4ZWN1dGVkLlxuICogQHBhcmFtIG8gdGhlIGNvbnRleHQgb2JqZWN0LlxuICogQHBhcmFtIGZuIHtGdW5jdGlvbnxTdHJpbmd9IHRoZSBmdW5jdGlvbiB0byBleGVjdXRlIG9yIHRoZSBuYW1lIG9mXG4gKiB0aGUgbWV0aG9kIGluIHRoZSAnbycgb2JqZWN0IHRvIGV4ZWN1dGUuXG4gKiBAcGFyYW0gZGF0YSBbQXJyYXldIGRhdGEgdGhhdCBpcyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24uICBUaGlzXG4gKiBhY2NlcHRzIGVpdGhlciBhIHNpbmdsZSBpdGVtIG9yIGFuIGFycmF5LiAgSWYgYW4gYXJyYXkgaXMgcHJvdmlkZWQsXG4gKiB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCBvbmUgcGFyYW1ldGVyIGZvciBlYWNoIGFycmF5IGl0ZW0uXG4gKiBJZiB5b3UgbmVlZCB0byBwYXNzIGEgc2luZ2xlIGFycmF5IHBhcmFtZXRlciwgaXQgbmVlZHMgdG8gYmUgd3JhcHBlZFxuICogaW4gYW4gYXJyYXkgW215YXJyYXldLlxuICpcbiAqIE5vdGU6IG5hdGl2ZSBtZXRob2RzIGluIElFIG1heSBub3QgaGF2ZSB0aGUgY2FsbCBhbmQgYXBwbHkgbWV0aG9kcy5cbiAqIEluIHRoaXMgY2FzZSwgaXQgd2lsbCB3b3JrLCBidXQgeW91IGFyZSBsaW1pdGVkIHRvIGZvdXIgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSBwZXJpb2RpYyB7Ym9vbGVhbn0gaWYgdHJ1ZSwgZXhlY3V0ZXMgY29udGludW91c2x5IGF0IHN1cHBsaWVkXG4gKiBpbnRlcnZhbCB1bnRpbCBjYW5jZWxlZC5cbiAqIEByZXR1cm4ge29iamVjdH0gYSB0aW1lciBvYmplY3QuIENhbGwgdGhlIGNhbmNlbCgpIG1ldGhvZCBvbiB0aGlzXG4gKiBvYmplY3QgdG8gc3RvcCB0aGUgdGltZXIuXG4gKi9cblkubGF0ZXIgPSBmdW5jdGlvbih3aGVuLCBvLCBmbiwgZGF0YSwgcGVyaW9kaWMpIHtcbiAgICB3aGVuID0gd2hlbiB8fCAwO1xuICAgIGRhdGEgPSAoIVkuTGFuZy5pc1VuZGVmaW5lZChkYXRhKSkgPyBZLkFycmF5KGRhdGEpIDogTk9fQVJHUztcbiAgICBvID0gbyB8fCBZLmNvbmZpZy53aW4gfHwgWTtcblxuICAgIHZhciBjYW5jZWxsZWQgPSBmYWxzZSxcbiAgICAgICAgbWV0aG9kID0gKG8gJiYgWS5MYW5nLmlzU3RyaW5nKGZuKSkgPyBvW2ZuXSA6IGZuLFxuICAgICAgICB3cmFwcGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBJRSA4LSBtYXkgZXhlY3V0ZSBhIHNldEludGVydmFsIGNhbGxiYWNrIG9uZSBsYXN0IHRpbWVcbiAgICAgICAgICAgIC8vIGFmdGVyIGNsZWFySW50ZXJ2YWwgd2FzIGNhbGxlZCwgc28gaW4gb3JkZXIgdG8gcHJlc2VydmVcbiAgICAgICAgICAgIC8vIHRoZSBjYW5jZWwoKSA9PT0gbm8gbW9yZSBydW5ueS1ydW4sIHdlIGhhdmUgdG8ganVtcCB0aHJvdWdoXG4gICAgICAgICAgICAvLyBhbiBleHRyYSBob29wLlxuICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZC5hcHBseSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KG8sIGRhdGEgfHwgTk9fQVJHUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpZCA9IChwZXJpb2RpYykgPyBZLmNvbmZpZy53aW4uc2V0SW50ZXJ2YWwod3JhcHBlciwgd2hlbikgOiBZLmNvbmZpZy53aW4uc2V0VGltZW91dCh3cmFwcGVyLCB3aGVuKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgaW50ZXJ2YWw6IHBlcmlvZGljLFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgWS5jb25maWcud2luLmNsZWFySW50ZXJ2YWwoaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBZLmNvbmZpZy53aW4uY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5ZLkxhbmcubGF0ZXIgPSBZLmxhdGVyO1xuXG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcInl1aS1iYXNlXCJdfSk7XG5ZVUkuYWRkKCd5dWknLCBmdW5jdGlvbiAoWSwgTkFNRSkge30sICczLjE3LjInLCB7XCJ1c2VcIjogW1wiZ2V0XCIsIFwiZmVhdHVyZXNcIiwgXCJpbnRsLWJhc2VcIiwgXCJ5dWktbG9nXCIsIFwieXVpLWxhdGVyXCJdfSk7XG5cbi8qKiogRVhQT1JUUyBGUk9NIGV4cG9ydHMtbG9hZGVyICoqKi9cbmV4cG9ydCB7XG4gIFlVSVxufTtcbiIsInZhciBfX19FWFBPU0VfTE9BREVSX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCItIS4uLy4uLy4uLy4uLy4uLy4uLy4uL2NvbW1vbi90ZW1wL25vZGVfbW9kdWxlcy9leHBvcnRzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1sxMF0udXNlWzFdIS4veXVpLWJhc2UuanNcIik7XG52YXIgX19fRVhQT1NFX0xPQURFUl9HRVRfR0xPQkFMX1RISVNfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vY29tbW9uL3RlbXAvbm9kZV9tb2R1bGVzL2V4cG9zZS1sb2FkZXIvZGlzdC9ydW50aW1lL2dldEdsb2JhbFRoaXMuanNcIik7XG52YXIgX19fRVhQT1NFX0xPQURFUl9HTE9CQUxfVEhJU19fXyA9IF9fX0VYUE9TRV9MT0FERVJfR0VUX0dMT0JBTF9USElTX19fO1xudmFyIF9fX0VYUE9TRV9MT0FERVJfSU1QT1JUX01PRFVMRV9MT0NBTF9OQU1FX19fID0gX19fRVhQT1NFX0xPQURFUl9JTVBPUlRfX18uWVVJXG5fX19FWFBPU0VfTE9BREVSX0dMT0JBTF9USElTX19fW1wiWVVJXCJdID0gX19fRVhQT1NFX0xPQURFUl9JTVBPUlRfTU9EVUxFX0xPQ0FMX05BTUVfX187XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0VYUE9TRV9MT0FERVJfSU1QT1JUX19fO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdhbmltLWJhc2UnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiogVGhlIEFuaW1hdGlvbiBVdGlsaXR5IHByb3ZpZGVzIGFuIEFQSSBmb3IgY3JlYXRpbmcgYWR2YW5jZWQgdHJhbnNpdGlvbnMuXG4qIEBtb2R1bGUgYW5pbVxuKi9cblxuLyoqXG4qIFByb3ZpZGVzIHRoZSBiYXNlIEFuaW0gY2xhc3MsIGZvciBhbmltYXRpbmcgbnVtZXJpYyBwcm9wZXJ0aWVzLlxuKlxuKiBAbW9kdWxlIGFuaW1cbiogQHN1Ym1vZHVsZSBhbmltLWJhc2VcbiovXG5cbiAgICAvKipcbiAgICAgKiBBIGNsYXNzIGZvciBjb25zdHJ1Y3RpbmcgYW5pbWF0aW9uIGluc3RhbmNlcy5cbiAgICAgKiBAY2xhc3MgQW5pbVxuICAgICAqIEBmb3IgQW5pbVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIEJhc2VcbiAgICAgKi9cblxuICAgIHZhciBSVU5OSU5HID0gJ3J1bm5pbmcnLFxuICAgICAgICBTVEFSVF9USU1FID0gJ3N0YXJ0VGltZScsXG4gICAgICAgIEVMQVBTRURfVElNRSA9ICdlbGFwc2VkVGltZScsXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBmb3IgQW5pbVxuICAgICAgICAqIEBldmVudCBzdGFydFxuICAgICAgICAqIEBkZXNjcmlwdGlvbiBmaXJlcyB3aGVuIGFuIGFuaW1hdGlvbiBiZWdpbnMuXG4gICAgICAgICogQHBhcmFtIHtFdmVudH0gZXYgVGhlIHN0YXJ0IGV2ZW50LlxuICAgICAgICAqIEB0eXBlIEV2ZW50LkN1c3RvbVxuICAgICAgICAqL1xuICAgICAgICBTVEFSVCA9ICdzdGFydCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IHR3ZWVuXG4gICAgICAgICogQGRlc2NyaXB0aW9uIGZpcmVzIGV2ZXJ5IGZyYW1lIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICAgICogQHBhcmFtIHtFdmVudH0gZXYgVGhlIHR3ZWVuIGV2ZW50LlxuICAgICAgICAqIEB0eXBlIEV2ZW50LkN1c3RvbVxuICAgICAgICAqL1xuICAgICAgICBUV0VFTiA9ICd0d2VlbicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IGVuZFxuICAgICAgICAqIEBkZXNjcmlwdGlvbiBmaXJlcyBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgZW5kIGV2ZW50LlxuICAgICAgICAqIEB0eXBlIEV2ZW50LkN1c3RvbVxuICAgICAgICAqL1xuICAgICAgICBFTkQgPSAnZW5kJyxcbiAgICAgICAgTk9ERSA9ICdub2RlJyxcbiAgICAgICAgUEFVU0VEID0gJ3BhdXNlZCcsXG4gICAgICAgIFJFVkVSU0UgPSAncmV2ZXJzZScsIC8vIFRPRE86IGNsZWFudXBcbiAgICAgICAgSVRFUkFUSU9OX0NPVU5UID0gJ2l0ZXJhdGlvbkNvdW50JyxcblxuICAgICAgICBOVU0gPSBOdW1iZXI7XG5cbiAgICB2YXIgX3J1bm5pbmcgPSB7fSxcbiAgICAgICAgX3RpbWVyO1xuXG4gICAgWS5BbmltID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFkuQW5pbS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIFkuQW5pbS5faW5zdGFuY2VzW1kuc3RhbXAodGhpcyldID0gdGhpcztcbiAgICB9O1xuXG4gICAgWS5BbmltLk5BTUUgPSAnYW5pbSc7XG5cbiAgICBZLkFuaW0uX2luc3RhbmNlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVnZXggb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCB1c2UgdGhlIGRlZmF1bHQgdW5pdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBSRV9ERUZBVUxUX1VOSVRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgWS5BbmltLlJFX0RFRkFVTFRfVU5JVCA9IC9ed2lkdGh8aGVpZ2h0fHRvcHxyaWdodHxib3R0b218bGVmdHxtYXJnaW4uKnxwYWRkaW5nLip8Ym9yZGVyLiokL2k7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB1bml0IHRvIHVzZSB3aXRoIHByb3BlcnRpZXMgdGhhdCBwYXNzIHRoZSBSRV9ERUZBVUxUX1VOSVQgdGVzdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBERUZBVUxUX1VOSVRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgWS5BbmltLkRFRkFVTFRfVU5JVCA9ICdweCc7XG5cbiAgICBZLkFuaW0uREVGQVVMVF9FQVNJTkcgPSBmdW5jdGlvbiAodCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gYyAqIHQgLyBkICsgYjsgLy8gbGluZWFyIGVhc2luZ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaW1lIGluIG1pbGxpc2Vjb25kcyBwYXNzZWQgdG8gc2V0SW50ZXJ2YWwgZm9yIGZyYW1lIHByb2Nlc3NpbmdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpbnRlcnZhbFRpbWVcbiAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBZLkFuaW0uX2ludGVydmFsVGltZSA9IDIwO1xuXG4gICAgLyoqXG4gICAgICogQnVja2V0IGZvciBjdXN0b20gZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJlaGF2aW9yc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBZLkFuaW0uYmVoYXZpb3JzID0ge1xuICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGFuaW0sIGF0dHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5pbS5fZ2V0T2Zmc2V0KGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFkuQW5pbS5iZWhhdmlvcnMudG9wID0gWS5BbmltLmJlaGF2aW9ycy5sZWZ0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc2V0dGVyIHRvIHVzZSB3aGVuIHNldHRpbmcgb2JqZWN0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgREVGQVVMVF9TRVRURVJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgWS5BbmltLkRFRkFVTFRfU0VUVEVSID0gZnVuY3Rpb24oYW5pbSwgYXR0LCBmcm9tLCB0bywgZWxhcHNlZCwgZHVyYXRpb24sIGZuLCB1bml0KSB7XG4gICAgICAgIHZhciBub2RlID0gYW5pbS5fbm9kZSxcbiAgICAgICAgICAgIGRvbU5vZGUgPSBub2RlLl9ub2RlLFxuICAgICAgICAgICAgdmFsID0gZm4oZWxhcHNlZCwgTlVNKGZyb20pLCBOVU0odG8pIC0gTlVNKGZyb20pLCBkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGRvbU5vZGUpIHtcbiAgICAgICAgICAgIGlmICgnc3R5bGUnIGluIGRvbU5vZGUgJiYgKGF0dCBpbiBkb21Ob2RlLnN0eWxlIHx8IGF0dCBpbiBZLkRPTS5DVVNUT01fU1RZTEVTKSkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSB1bml0IHx8ICcnO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0U3R5bGUoYXR0LCB2YWwgKyB1bml0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ2F0dHJpYnV0ZXMnIGluIGRvbU5vZGUgJiYgYXR0IGluIGRvbU5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dCwgdmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0IGluIGRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlW2F0dF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5zZXQpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0KGF0dCwgdmFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdHQgaW4gbm9kZSkge1xuICAgICAgICAgICAgbm9kZVthdHRdID0gdmFsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGdldHRlciB0byB1c2Ugd2hlbiBnZXR0aW5nIG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IERFRkFVTFRfR0VUVEVSXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIFkuQW5pbS5ERUZBVUxUX0dFVFRFUiA9IGZ1bmN0aW9uKGFuaW0sIGF0dCkge1xuICAgICAgICB2YXIgbm9kZSA9IGFuaW0uX25vZGUsXG4gICAgICAgICAgICBkb21Ob2RlID0gbm9kZS5fbm9kZSxcbiAgICAgICAgICAgIHZhbCA9ICcnO1xuXG4gICAgICAgIGlmIChkb21Ob2RlKSB7XG4gICAgICAgICAgICBpZiAoJ3N0eWxlJyBpbiBkb21Ob2RlICYmIChhdHQgaW4gZG9tTm9kZS5zdHlsZSB8fCBhdHQgaW4gWS5ET00uQ1VTVE9NX1NUWUxFUykpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBub2RlLmdldENvbXB1dGVkU3R5bGUoYXR0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ2F0dHJpYnV0ZXMnIGluIGRvbU5vZGUgJiYgYXR0IGluIGRvbU5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHZhbCA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dCBpbiBkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZG9tTm9kZVthdHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZ2V0KSB7XG4gICAgICAgICAgICB2YWwgPSBub2RlLmdldChhdHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGF0dCBpbiBub2RlKSB7XG4gICAgICAgICAgICB2YWwgPSBub2RlW2F0dF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICBZLkFuaW0uQVRUUlMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb2JqZWN0IHRvIGJlIGFuaW1hdGVkLlxuICAgICAgICAgKiBAYXR0cmlidXRlIG5vZGVcbiAgICAgICAgICogQHR5cGUgTm9kZVxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgc2V0dGVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyB8fCBub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gWS5vbmUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gIERlZmF1bHRzIHRvIFwiMVwiIChzZWNvbmQpLlxuICAgICAgICAgKiBAYXR0cmlidXRlIGR1cmF0aW9uXG4gICAgICAgICAqIEB0eXBlIE5VTVxuICAgICAgICAgKi9cbiAgICAgICAgZHVyYXRpb246IHtcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtZXRob2QgdGhhdCB3aWxsIHByb3ZpZGUgdmFsdWVzIHRvIHRoZSBhdHRyaWJ1dGUocykgZHVyaW5nIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAqIERlZmF1bHRzIHRvIFwiRWFzaW5nLmVhc2VOb25lXCIuXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgZWFzaW5nXG4gICAgICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBlYXNpbmc6IHtcbiAgICAgICAgICAgIHZhbHVlOiBZLkFuaW0uREVGQVVMVF9FQVNJTkcsXG5cbiAgICAgICAgICAgIHNldHRlcjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIFkuRWFzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBZLkVhc2luZ1t2YWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YXJ0aW5nIHZhbHVlcyBmb3IgdGhlIGFuaW1hdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpZWxkcyBtYXkgYmUgc3RyaW5ncywgbnVtYmVycywgb3IgZnVuY3Rpb25zLlxuICAgICAgICAgKiBJZiBhIGZ1bmN0aW9uIGlzIHVzZWQsIHRoZSByZXR1cm4gdmFsdWUgYmVjb21lcyB0aGUgZnJvbSB2YWx1ZS5cbiAgICAgICAgICogSWYgbm8gZnJvbSB2YWx1ZSBpcyBzcGVjaWZpZWQsIHRoZSBERUZBVUxUX0dFVFRFUiB3aWxsIGJlIHVzZWQuXG4gICAgICAgICAqIFN1cHBvcnRzIGFueSB1bml0LCBwcm92aWRlZCBpdCBtYXRjaGVzIHRoZSBcInRvXCIgKG9yIGRlZmF1bHQpXG4gICAgICAgICAqIHVuaXQgKGUuZy4gYHt3aWR0aDogJzEwZW0nLCBjb2xvcjogJ3JnYigwLCAwLCAwKScsIGJvcmRlckNvbG9yOiAnI2NjYyd9YCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHVzaW5nIHRoZSBkZWZhdWx0ICgncHgnIGZvciBsZW5ndGgtYmFzZWQgdW5pdHMpLCB0aGUgdW5pdCBtYXkgYmUgb21pdHRlZFxuICAgICAgICAgKiAoZS5nLiBge3dpZHRoOiAxMDB9LCBib3JkZXJDb2xvcjogJ2NjYyd9YCwgd2hpY2ggZGVmYXVsdHMgdG8gcGl4ZWxzXG4gICAgICAgICAqIGFuZCBoZXgsIHJlc3BlY3RpdmVseSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgZnJvbVxuICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGZyb206IHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZW5kaW5nIHZhbHVlcyBmb3IgdGhlIGFuaW1hdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpZWxkcyBtYXkgYmUgc3RyaW5ncywgbnVtYmVycywgb3IgZnVuY3Rpb25zLlxuICAgICAgICAgKiBTdXBwb3J0cyBhbnkgdW5pdCwgcHJvdmlkZWQgaXQgbWF0Y2hlcyB0aGUgXCJmcm9tXCIgKG9yIGRlZmF1bHQpXG4gICAgICAgICAqIHVuaXQgKGUuZy4gYHt3aWR0aDogJzUwJScsIGNvbG9yOiAncmVkJywgYm9yZGVyQ29sb3I6ICcjY2NjJ31gKS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdXNpbmcgdGhlIGRlZmF1bHQgKCdweCcgZm9yIGxlbmd0aC1iYXNlZCB1bml0cyksIHRoZSB1bml0IG1heSBiZSBvbWl0dGVkXG4gICAgICAgICAqIChlLmcuIGB7d2lkdGg6IDEwMCwgYm9yZGVyQ29sb3I6ICdjY2MnfWAsIHdoaWNoIGRlZmF1bHRzIHRvIHBpeGVsc1xuICAgICAgICAgKiBhbmQgaGV4LCByZXNwZWN0aXZlbHkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0cmlidXRlIHRvXG4gICAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdG86IHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRlIHN0YW1wIGZvciB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICogQGF0dHJpYnV0ZSBzdGFydFRpbWVcbiAgICAgICAgICogQHR5cGUgSW50XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBzdGFydFRpbWU6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCB0aW1lIHRoZSBhbmltYXRpb24gaGFzIGJlZW4gcnVubmluZy5cbiAgICAgICAgICogQGF0dHJpYnV0ZSBlbGFwc2VkVGltZVxuICAgICAgICAgKiBAdHlwZSBJbnRcbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGVsYXBzZWRUaW1lOiB7XG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBhbmltYXRpb24gaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgcnVubmluZ1xuICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgcnVubmluZzoge1xuICAgICAgICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFfcnVubmluZ1tZLnN0YW1wKHRoaXMpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBhbmltYXRpb24gc2hvdWxkIHJ1blxuICAgICAgICAgKiBAYXR0cmlidXRlIGl0ZXJhdGlvbnNcbiAgICAgICAgICogQHR5cGUgSW50XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIGl0ZXJhdGlvbnM6IHtcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0aGF0IGhhdmUgb2NjdXJyZWQuXG4gICAgICAgICAqIFJlc2V0cyB3aGVuIGFuIGFuaW1hdGlvbiBlbmRzIChyZWFjaGVzIGl0ZXJhdGlvbiBjb3VudCBvciBzdG9wKCkgY2FsbGVkKS5cbiAgICAgICAgICogQGF0dHJpYnV0ZSBpdGVyYXRpb25Db3VudFxuICAgICAgICAgKiBAdHlwZSBJbnRcbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGl0ZXJhdGlvbkNvdW50OiB7XG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBpdGVyYXRpb25zIG9mIHRoZSBhbmltYXRpb24gc2hvdWxkIGJlaGF2ZS5cbiAgICAgICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBcIm5vcm1hbFwiIGFuZCBcImFsdGVybmF0ZVwiLlxuICAgICAgICAgKiBOb3JtYWwgd2lsbCByZXBlYXQgdGhlIGFuaW1hdGlvbiwgYWx0ZXJuYXRlIHdpbGwgcmV2ZXJzZSBvbiBldmVyeSBvdGhlciBwYXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICogQGRlZmF1bHQgXCJub3JtYWxcIlxuICAgICAgICAgKi9cbiAgICAgICAgZGlyZWN0aW9uOiB7XG4gICAgICAgICAgICB2YWx1ZTogJ25vcm1hbCcgLy8gfCBhbHRlcm5hdGUgKGZ3ZCBvbiBvZGQsIHJldiBvbiBldmVuIHBlciBzcGVjKVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgYW5pbWF0aW9uIGlzIGN1cnJlbnRseSBwYXVzZWQuXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgcGF1c2VkXG4gICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBwYXVzZWQ6IHtcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSBgZnJvbWAgYW5kIGB0b2AgYXR0cmlidXRlcyBhcmUgc3dhcHBlZCwgXG4gICAgICAgICAqIGFuZCB0aGUgYW5pbWF0aW9uIGlzIHRoZW4gcnVuIHN0YXJ0aW5nIGZyb20gYGZyb21gLlxuICAgICAgICAgKiBAYXR0cmlidXRlIHJldmVyc2VcbiAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmV2ZXJzZToge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cblxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYWxsIGFuaW1hdGlvbiBpbnN0YW5jZXMuXG4gICAgICogQG1ldGhvZCBydW5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgWS5BbmltLnJ1biA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2VzID0gWS5BbmltLl9pbnN0YW5jZXMsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VzW2ldLnJ1bikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlc1tpXS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgYWxsIGFuaW1hdGlvbiBpbnN0YW5jZXMuXG4gICAgICogQG1ldGhvZCBwYXVzZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBZLkFuaW0ucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBfcnVubmluZykgeyAvLyBzdG9wIHRpbWVyIGlmIG5vdGhpbmcgcnVubmluZ1xuICAgICAgICAgICAgaWYgKF9ydW5uaW5nW2ldLnBhdXNlKSB7XG4gICAgICAgICAgICAgICAgX3J1bm5pbmdbaV0ucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFkuQW5pbS5fc3RvcFRpbWVyKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFsbCBhbmltYXRpb24gaW5zdGFuY2VzLlxuICAgICAqIEBtZXRob2Qgc3RvcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBZLkFuaW0uc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpIGluIF9ydW5uaW5nKSB7IC8vIHN0b3AgdGltZXIgaWYgbm90aGluZyBydW5uaW5nXG4gICAgICAgICAgICBpZiAoX3J1bm5pbmdbaV0uc3RvcCkge1xuICAgICAgICAgICAgICAgIF9ydW5uaW5nW2ldLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBZLkFuaW0uX3N0b3BUaW1lcigpO1xuICAgIH07XG5cbiAgICBZLkFuaW0uX3N0YXJ0VGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFfdGltZXIpIHtcbiAgICAgICAgICAgIF90aW1lciA9IHNldEludGVydmFsKFkuQW5pbS5fcnVuRnJhbWUsIFkuQW5pbS5faW50ZXJ2YWxUaW1lKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBZLkFuaW0uX3N0b3BUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhckludGVydmFsKF90aW1lcik7XG4gICAgICAgIF90aW1lciA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBwZXIgSW50ZXJ2YWwgdG8gaGFuZGxlIGVhY2ggYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqIEBtZXRob2QgX3J1bkZyYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgWS5BbmltLl9ydW5GcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9uZSA9IHRydWUsXG4gICAgICAgICAgICBhbmltO1xuICAgICAgICBmb3IgKGFuaW0gaW4gX3J1bm5pbmcpIHtcbiAgICAgICAgICAgIGlmIChfcnVubmluZ1thbmltXS5fcnVuRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3J1bm5pbmdbYW5pbV0uX3J1bkZyYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgWS5BbmltLl9zdG9wVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBZLkFuaW0uUkVfVU5JVFMgPSAvXigtP1xcZCpcXC4/XFxkKil7MX0oZW18ZXh8cHh8aW58Y218bW18cHR8cGN8JSkqJC87XG5cbiAgICB2YXIgcHJvdG8gPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgb3IgcmVzdW1lcyBhbiBhbmltYXRpb24uXG4gICAgICAgICAqIEBtZXRob2QgcnVuXG4gICAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAgICovXG4gICAgICAgIHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoUEFVU0VEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VtZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5nZXQoUlVOTklORykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdXNlcyB0aGUgYW5pbWF0aW9uIGFuZFxuICAgICAgICAgKiBmcmVlemVzIGl0IGluIGl0cyBjdXJyZW50IHN0YXRlIGFuZCB0aW1lLlxuICAgICAgICAgKiBDYWxsaW5nIHJ1bigpIHdpbGwgY29udGludWUgd2hlcmUgaXQgbGVmdCBvZmYuXG4gICAgICAgICAqIEBtZXRob2QgcGF1c2VcbiAgICAgICAgICogQGNoYWluYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFJVTk5JTkcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyB0aGUgYW5pbWF0aW9uIGFuZCByZXNldHMgaXRzIHRpbWUuXG4gICAgICAgICAqIEBtZXRob2Qgc3RvcFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbmlzaCBJZiB0cnVlLCB0aGUgYW5pbWF0aW9uIHdpbGwgbW92ZSB0byB0aGUgbGFzdCBmcmFtZVxuICAgICAgICAgKiBAY2hhaW5hYmxlXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wOiBmdW5jdGlvbihmaW5pc2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChSVU5OSU5HKSB8fCB0aGlzLmdldChQQVVTRUQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kKGZpbmlzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkZWQ6IGZhbHNlLFxuXG4gICAgICAgIF9zdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXQoU1RBUlRfVElNRSwgbmV3IERhdGUoKSAtIHRoaXMuZ2V0KEVMQVBTRURfVElNRSkpO1xuICAgICAgICAgICAgdGhpcy5fYWN0dWFsRnJhbWVzID0gMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXQoUEFVU0VEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRBbmltQXR0cigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3J1bm5pbmdbWS5zdGFtcCh0aGlzKV0gPSB0aGlzO1xuICAgICAgICAgICAgWS5BbmltLl9zdGFydFRpbWVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZShTVEFSVCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldChTVEFSVF9USU1FLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChQQVVTRUQsIHRydWUpO1xuICAgICAgICAgICAgZGVsZXRlIF9ydW5uaW5nW1kuc3RhbXAodGhpcyldO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogQGV2ZW50IHBhdXNlXG4gICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBmaXJlcyB3aGVuIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQuXG4gICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2IFRoZSBwYXVzZSBldmVudC5cbiAgICAgICAgICAgICogQHR5cGUgRXZlbnQuQ3VzdG9tXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5maXJlKCdwYXVzZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZXN1bWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0KFBBVVNFRCwgZmFsc2UpO1xuICAgICAgICAgICAgX3J1bm5pbmdbWS5zdGFtcCh0aGlzKV0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fc2V0KFNUQVJUX1RJTUUsIG5ldyBEYXRlKCkgLSB0aGlzLmdldChFTEFQU0VEX1RJTUUpKTtcbiAgICAgICAgICAgIFkuQW5pbS5fc3RhcnRUaW1lcigpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogQGV2ZW50IHJlc3VtZVxuICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gZmlyZXMgd2hlbiBhbiBhbmltYXRpb24gaXMgcmVzdW1lZCAocnVuIGZyb20gcGF1c2UpLlxuICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgcGF1c2UgZXZlbnQuXG4gICAgICAgICAgICAqIEB0eXBlIEV2ZW50LkN1c3RvbVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZmlyZSgncmVzdW1lJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2VuZDogZnVuY3Rpb24oZmluaXNoKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmdldCgnZHVyYXRpb24nKSAqIDEwMDA7XG4gICAgICAgICAgICBpZiAoZmluaXNoKSB7IC8vIGp1bXAgdG8gbGFzdCBmcmFtZVxuICAgICAgICAgICAgICAgIHRoaXMuX3J1bkF0dHJzKGR1cmF0aW9uLCBkdXJhdGlvbiwgdGhpcy5nZXQoUkVWRVJTRSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zZXQoU1RBUlRfVElNRSwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9zZXQoRUxBUFNFRF9USU1FLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChQQVVTRUQsIGZhbHNlKTtcblxuICAgICAgICAgICAgZGVsZXRlIF9ydW5uaW5nW1kuc3RhbXAodGhpcyldO1xuICAgICAgICAgICAgdGhpcy5maXJlKEVORCwge2VsYXBzZWQ6IHRoaXMuZ2V0KEVMQVBTRURfVElNRSl9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcnVuRnJhbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLl9ydW50aW1lQXR0ci5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0ID0gbmV3IERhdGUoKSAtIHRoaXMuZ2V0KFNUQVJUX1RJTUUpLFxuICAgICAgICAgICAgICAgIHJldmVyc2UgPSB0aGlzLmdldChSRVZFUlNFKSxcbiAgICAgICAgICAgICAgICBkb25lID0gKHQgPj0gZCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3J1bkF0dHJzKHQsIGQsIHJldmVyc2UpO1xuICAgICAgICAgICAgdGhpcy5fYWN0dWFsRnJhbWVzICs9IDE7XG4gICAgICAgICAgICB0aGlzLl9zZXQoRUxBUFNFRF9USU1FLCB0KTtcblxuICAgICAgICAgICAgdGhpcy5maXJlKFRXRUVOKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3J1bkF0dHJzOiBmdW5jdGlvbih0LCBkLCByZXZlcnNlKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHRoaXMuX3J1bnRpbWVBdHRyLFxuICAgICAgICAgICAgICAgIGN1c3RvbUF0dHIgPSBZLkFuaW0uYmVoYXZpb3JzLFxuICAgICAgICAgICAgICAgIGVhc2luZyA9IGF0dHIuZWFzaW5nLFxuICAgICAgICAgICAgICAgIGxhc3RGcmFtZSA9IGQsXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBzZXR0ZXIsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgaWYgKHQgPj0gZCkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIHQgPSBkIC0gdDtcbiAgICAgICAgICAgICAgICBsYXN0RnJhbWUgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgaW4gYXR0cikge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyW2ldLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJbaV07XG4gICAgICAgICAgICAgICAgICAgIHNldHRlciA9IChpIGluIGN1c3RvbUF0dHIgJiYgJ3NldCcgaW4gY3VzdG9tQXR0cltpXSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUF0dHJbaV0uc2V0IDogWS5BbmltLkRFRkFVTFRfU0VUVEVSO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyKHRoaXMsIGksIGF0dHJpYnV0ZS5mcm9tLCBhdHRyaWJ1dGUudG8sIHQsIGQsIGVhc2luZywgYXR0cmlidXRlLnVuaXQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyKHRoaXMsIGksIGF0dHJpYnV0ZS5mcm9tLCBhdHRyaWJ1dGUudG8sIGxhc3RGcmFtZSwgZCwgZWFzaW5nLCBhdHRyaWJ1dGUudW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIF9sYXN0RnJhbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSB0aGlzLmdldCgnaXRlcmF0aW9ucycpLFxuICAgICAgICAgICAgICAgIGl0ZXJDb3VudCA9IHRoaXMuZ2V0KElURVJBVElPTl9DT1VOVCk7XG5cbiAgICAgICAgICAgIGl0ZXJDb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKGl0ZXIgPT09ICdpbmZpbml0ZScgfHwgaXRlckNvdW50IDwgaXRlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldCgnZGlyZWN0aW9uJykgPT09ICdhbHRlcm5hdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KFJFVkVSU0UsICF0aGlzLmdldChSRVZFUlNFKSk7IC8vIGZsaXAgaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBAZXZlbnQgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gZmlyZXMgd2hlbiBhbiBhbmltYXRpb24gYmVnaW5zIGFuIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2IFRoZSBpdGVyYXRpb24gZXZlbnQuXG4gICAgICAgICAgICAgICAgKiBAdHlwZSBFdmVudC5DdXN0b21cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnaXRlcmF0aW9uJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldChTVEFSVF9USU1FLCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChJVEVSQVRJT05fQ09VTlQsIGl0ZXJDb3VudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRBbmltQXR0cjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMuZ2V0KCdmcm9tJykgfHwge30sXG4gICAgICAgICAgICAgICAgdG8gPSB0aGlzLmdldCgndG8nKSB8fCB7fSxcbiAgICAgICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5nZXQoJ2R1cmF0aW9uJykgKiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IHRoaXMuZ2V0KCdlYXNpbmcnKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY3VzdG9tQXR0ciA9IFkuQW5pbS5iZWhhdmlvcnMsXG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuZ2V0KE5PREUpLCAvLyBpbXBsaWNpdCBhdHRyIGluaXRcbiAgICAgICAgICAgICAgICB1bml0LCBiZWdpbiwgZW5kO1xuXG4gICAgICAgICAgICBZLmVhY2godG8sIGZ1bmN0aW9uKHZhbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5jYWxsKHRoaXMsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJlZ2luID0gZnJvbVtuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IChuYW1lIGluIGN1c3RvbUF0dHIgJiYgJ2dldCcgaW4gY3VzdG9tQXR0cltuYW1lXSkgID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21BdHRyW25hbWVdLmdldCh0aGlzLCBuYW1lKSA6IFkuQW5pbS5ERUZBVUxUX0dFVFRFUih0aGlzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IGJlZ2luLmNhbGwodGhpcywgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG1Gcm9tID0gWS5BbmltLlJFX1VOSVRTLmV4ZWMoYmVnaW4pLFxuICAgICAgICAgICAgICAgICAgICBtVG8gPSBZLkFuaW0uUkVfVU5JVFMuZXhlYyh2YWwpO1xuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBtRnJvbSA/IG1Gcm9tWzFdIDogYmVnaW47XG4gICAgICAgICAgICAgICAgZW5kID0gbVRvID8gbVRvWzFdIDogdmFsO1xuICAgICAgICAgICAgICAgIHVuaXQgPSBtVG8gPyBtVG9bMl0gOiBtRnJvbSA/ICBtRnJvbVsyXSA6ICcnOyAvLyBvbmUgbWlnaHQgYmUgemVybyBUT0RPOiBtaXhlZCB1bml0c1xuXG4gICAgICAgICAgICAgICAgaWYgKCF1bml0ICYmIFkuQW5pbS5SRV9ERUZBVUxUX1VOSVQudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0ID0gWS5BbmltLkRFRkFVTFRfVU5JVDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWJlZ2luIHx8ICFlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgWS5lcnJvcignaW52YWxpZCBcImZyb21cIiBvciBcInRvXCIgZm9yIFwiJyArIG5hbWUgKyAnXCInLCAnQW5pbScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXR0cltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogWS5MYW5nLmlzT2JqZWN0KGJlZ2luKSA/IFkuY2xvbmUoYmVnaW4pIDogYmVnaW4sXG4gICAgICAgICAgICAgICAgICAgIHRvOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgIHVuaXQ6IHVuaXRcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5fcnVudGltZUF0dHIgPSBhdHRyO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLy8gVE9ETzogbW92ZSB0byBjb21wdXRlZFN0eWxlPyAoYnJvd3NlcnMgZG9udCBhZ3JlZSBvbiBkZWZhdWx0IGNvbXB1dGVkIG9mZnNldHMpXG4gICAgICAgIF9nZXRPZmZzZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZSxcbiAgICAgICAgICAgICAgICB2YWwgPSBub2RlLmdldENvbXB1dGVkU3R5bGUoYXR0ciksXG4gICAgICAgICAgICAgICAgZ2V0ID0gKGF0dHIgPT09ICdsZWZ0JykgPyAnZ2V0WCc6ICdnZXRZJyxcbiAgICAgICAgICAgICAgICBzZXQgPSAoYXR0ciA9PT0gJ2xlZnQnKSA/ICdzZXRYJzogJ3NldFknLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uO1xuXG4gICAgICAgICAgICBpZiAodmFsID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5vZGUuZ2V0U3R5bGUoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnYWJzb2x1dGUnIHx8IHBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG5vZGVbZ2V0XSgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlW3NldF0odmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBZLkFuaW0uX2luc3RhbmNlc1tZLnN0YW1wKHRoaXMpXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBZLmV4dGVuZChZLkFuaW0sIFkuQmFzZSwgcHJvdG8pO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJiYXNlLWJhc2VcIiwgXCJub2RlLXN0eWxlXCIsIFwiY29sb3ItYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdhbmltLWNvbG9yJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBBZGRzIHN1cHBvcnQgZm9yIGNvbG9yIHByb3BlcnRpZXMgaW4gPGNvZGU+dG88L2NvZGU+XG4gKiBhbmQgPGNvZGU+ZnJvbTwvY29kZT4gYXR0cmlidXRlcy5cbiAqIEBtb2R1bGUgYW5pbVxuICogQHN1Ym1vZHVsZSBhbmltLWNvbG9yXG4gKi9cblxudmFyIE5VTSA9IE51bWJlcjtcblxuWS5BbmltLmdldFVwZGF0ZWRDb2xvclZhbHVlID0gZnVuY3Rpb24oZnJvbUNvbG9yLCB0b0NvbG9yLCBlbGFwc2VkLCBkdXJhdGlvbiwgIGZuKVxue1xuICAgIGZyb21Db2xvciA9IFkuQ29sb3IucmVfUkdCLmV4ZWMoWS5Db2xvci50b1JHQihmcm9tQ29sb3IpKTtcbiAgICB0b0NvbG9yID0gWS5Db2xvci5yZV9SR0IuZXhlYyhZLkNvbG9yLnRvUkdCKHRvQ29sb3IpKTtcblxuICAgIGlmICghZnJvbUNvbG9yIHx8IGZyb21Db2xvci5sZW5ndGggPCAzIHx8ICF0b0NvbG9yIHx8IHRvQ29sb3IubGVuZ3RoIDwgMykge1xuICAgICAgICBZLmVycm9yKCdpbnZhbGlkIGZyb20gb3IgdG8gcGFzc2VkIHRvIGNvbG9yIGJlaGF2aW9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICdyZ2IoJyArIFtcbiAgICAgICAgTWF0aC5mbG9vcihmbihlbGFwc2VkLCBOVU0oZnJvbUNvbG9yWzFdKSwgTlVNKHRvQ29sb3JbMV0pIC0gTlVNKGZyb21Db2xvclsxXSksIGR1cmF0aW9uKSksXG4gICAgICAgIE1hdGguZmxvb3IoZm4oZWxhcHNlZCwgTlVNKGZyb21Db2xvclsyXSksIE5VTSh0b0NvbG9yWzJdKSAtIE5VTShmcm9tQ29sb3JbMl0pLCBkdXJhdGlvbikpLFxuICAgICAgICBNYXRoLmZsb29yKGZuKGVsYXBzZWQsIE5VTShmcm9tQ29sb3JbM10pLCBOVU0odG9Db2xvclszXSkgLSBOVU0oZnJvbUNvbG9yWzNdKSwgZHVyYXRpb24pKVxuICAgIF0uam9pbignLCAnKSArICcpJztcbn07XG5cblkuQW5pbS5iZWhhdmlvcnMuY29sb3IgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihhbmltLCBhdHQsIGZyb20sIHRvLCBlbGFwc2VkLCBkdXJhdGlvbiwgZm4pIHtcbiAgICAgICAgYW5pbS5fbm9kZS5zZXRTdHlsZShhdHQsIFkuQW5pbS5nZXRVcGRhdGVkQ29sb3JWYWx1ZShmcm9tLCB0bywgZWxhcHNlZCwgZHVyYXRpb24sIGZuKSk7XG4gICAgfSxcblxuICAgIC8vIFRPRE86IGRlZmF1bHQgYmdjb2xvciBjb25zdFxuICAgIGdldDogZnVuY3Rpb24oYW5pbSwgYXR0KSB7XG4gICAgICAgIHZhciB2YWwgPSBhbmltLl9ub2RlLmdldENvbXB1dGVkU3R5bGUoYXR0KTtcbiAgICAgICAgdmFsID0gKHZhbCA9PT0gJ3RyYW5zcGFyZW50JykgPyAncmdiKDI1NSwgMjU1LCAyNTUpJyA6IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59O1xuXG5ZLmVhY2goWydiYWNrZ3JvdW5kQ29sb3InLFxuICAgICAgICAnYm9yZGVyQ29sb3InLFxuICAgICAgICAnYm9yZGVyVG9wQ29sb3InLFxuICAgICAgICAnYm9yZGVyUmlnaHRDb2xvcicsXG4gICAgICAgICdib3JkZXJCb3R0b21Db2xvcicsXG4gICAgICAgICdib3JkZXJMZWZ0Q29sb3InXSxcbiAgICAgICAgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgWS5BbmltLmJlaGF2aW9yc1t2XSA9IFkuQW5pbS5iZWhhdmlvcnMuY29sb3I7XG4gICAgICAgIH1cbik7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImFuaW0tYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdhbmltLWN1cnZlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBBZGRzIHN1cHBvcnQgZm9yIHRoZSA8Y29kZT5jdXJ2ZTwvY29kZT4gcHJvcGVydHkgZm9yIHRoZSA8Y29kZT50bzwvY29kZT5cbiAqIGF0dHJpYnV0ZS4gIEEgY3VydmUgaXMgemVybyBvciBtb3JlIGNvbnRyb2wgcG9pbnRzIGFuZCBhbiBlbmQgcG9pbnQuXG4gKiBAbW9kdWxlIGFuaW1cbiAqIEBzdWJtb2R1bGUgYW5pbS1jdXJ2ZVxuICovXG5cblkuQW5pbS5iZWhhdmlvcnMuY3VydmUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihhbmltLCBhdHQsIGZyb20sIHRvLCBlbGFwc2VkLCBkdXJhdGlvbiwgZm4pIHtcbiAgICAgICAgZnJvbSA9IGZyb20uc2xpY2UuY2FsbChmcm9tKTtcbiAgICAgICAgdG8gPSB0by5zbGljZS5jYWxsKHRvKTtcbiAgICAgICAgdmFyIHQgPSBmbihlbGFwc2VkLCAwLCAxMDAsIGR1cmF0aW9uKSAvIDEwMDtcbiAgICAgICAgdG8udW5zaGlmdChmcm9tKTtcbiAgICAgICAgYW5pbS5fbm9kZS5zZXRYWShZLkFuaW0uZ2V0QmV6aWVyKHRvLCB0KSk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oYW5pbSkge1xuICAgICAgICByZXR1cm4gYW5pbS5fbm9kZS5nZXRYWSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBhbmltYXRlZCBlbGVtZW50IGJhc2VkIG9uIHQuXG4gKiBFYWNoIHBvaW50IGlzIGFuIGFycmF5IG9mIFwieFwiIGFuZCBcInlcIiB2YWx1ZXMgKDAgPSB4LCAxID0geSlcbiAqIEF0IGxlYXN0IDIgcG9pbnRzIGFyZSByZXF1aXJlZCAoc3RhcnQgYW5kIGVuZCkuXG4gKiBGaXJzdCBwb2ludCBpcyBzdGFydC4gTGFzdCBwb2ludCBpcyBlbmQuXG4gKiBBZGRpdGlvbmFsIGNvbnRyb2wgcG9pbnRzIGFyZSBvcHRpb25hbC5cbiAqIEBmb3IgQW5pbVxuICogQG1ldGhvZCBnZXRCZXppZXJcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7TnVtYmVyW119IHBvaW50cyBBbiBhcnJheSBjb250YWluaW5nIEJlemllciBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSB3aGljaCBpcyB0aGUgYmFzaXMgZm9yIGRldGVybWluaW5nIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge051bWJlcltdfSBBbiBhcnJheSBjb250YWluaW5nIGludCB4IGFuZCB5IG1lbWJlciBkYXRhXG4gKi9cblkuQW5pbS5nZXRCZXppZXIgPSBmdW5jdGlvbihwb2ludHMsIHQpIHtcbiAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIHRtcCA9IFtdLFxuICAgICAgICBpLFxuICAgICAgICBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSl7XG4gICAgICAgIHRtcFtpXSA9IFtwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXV07IC8vIHNhdmUgaW5wdXRcbiAgICB9XG5cbiAgICBmb3IgKGogPSAxOyBqIDwgbjsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuIC0gajsgKytpKSB7XG4gICAgICAgICAgICB0bXBbaV1bMF0gPSAoMSAtIHQpICogdG1wW2ldWzBdICsgdCAqIHRtcFtwYXJzZUludChpICsgMSwgMTApXVswXTtcbiAgICAgICAgICAgIHRtcFtpXVsxXSA9ICgxIC0gdCkgKiB0bXBbaV1bMV0gKyB0ICogdG1wW3BhcnNlSW50KGkgKyAxLCAxMCldWzFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFsgdG1wWzBdWzBdLCB0bXBbMF1bMV0gXTtcblxufTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiYW5pbS14eVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdhbmltLWVhc2luZycsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qXG5URVJNUyBPRiBVU0UgLSBFQVNJTkcgRVFVQVRJT05TXG5PcGVuIHNvdXJjZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5Db3B5cmlnaHQgMjAwMSBSb2JlcnQgUGVubmVyIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0b1xuICAgIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yXG4gICAgd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuXG5JTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG5JTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORyxcbkJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG5EQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZXG5PRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFXG5PUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRURcbk9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qKlxuICogVGhlIGVhc2luZyBtb2R1bGUgcHJvdmlkZXMgbWV0aG9kcyBmb3IgY3VzdG9taXppbmdcbiAqIGhvdyBhbiBhbmltYXRpb24gYmVoYXZlcyBkdXJpbmcgZWFjaCBydW4uXG4gKiBAY2xhc3MgRWFzaW5nXG4gKiBAbW9kdWxlIGFuaW1cbiAqIEBzdWJtb2R1bGUgYW5pbS1lYXNpbmdcbiAqL1xuXG52YXIgRWFzaW5nID0ge1xuXG4gICAgLyoqXG4gICAgICogVW5pZm9ybSBzcGVlZCBiZXR3ZWVuIHBvaW50cy5cbiAgICAgKiBAZm9yIEVhc2luZ1xuICAgICAqIEBtZXRob2QgZWFzZU5vbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCBUaW1lIHZhbHVlIHVzZWQgdG8gY29tcHV0ZSBjdXJyZW50IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgU3RhcnRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBEZWx0YSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVG90YWwgbGVuZ3RoIG9mIGFuaW1hdGlvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWVcbiAgICAgKi9cbiAgICBlYXNlTm9uZTogZnVuY3Rpb24gKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgcmV0dXJuIGMqdC9kICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmVnaW5zIHNsb3dseSBhbmQgYWNjZWxlcmF0ZXMgdG93YXJkcyBlbmQuIChxdWFkcmF0aWMpXG4gICAgICogQG1ldGhvZCBlYXNlSW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCBUaW1lIHZhbHVlIHVzZWQgdG8gY29tcHV0ZSBjdXJyZW50IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgU3RhcnRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBEZWx0YSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVG90YWwgbGVuZ3RoIG9mIGFuaW1hdGlvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWVcbiAgICAgKi9cbiAgICBlYXNlSW46IGZ1bmN0aW9uICh0LCBiLCBjLCBkKSB7XG4gICAgICAgIHJldHVybiBjKih0Lz1kKSp0ICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmVnaW5zIHF1aWNrbHkgYW5kIGRlY2VsZXJhdGVzIHRvd2FyZHMgZW5kLiAgKHF1YWRyYXRpYylcbiAgICAgKiBAbWV0aG9kIGVhc2VPdXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCBUaW1lIHZhbHVlIHVzZWQgdG8gY29tcHV0ZSBjdXJyZW50IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgU3RhcnRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBEZWx0YSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVG90YWwgbGVuZ3RoIG9mIGFuaW1hdGlvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWVcbiAgICAgKi9cbiAgICBlYXNlT3V0OiBmdW5jdGlvbiAodCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gLWMgKih0Lz1kKSoodC0yKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJlZ2lucyBzbG93bHkgYW5kIGRlY2VsZXJhdGVzIHRvd2FyZHMgZW5kLiAocXVhZHJhdGljKVxuICAgICAqIEBtZXRob2QgZWFzZUJvdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCBUaW1lIHZhbHVlIHVzZWQgdG8gY29tcHV0ZSBjdXJyZW50IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgU3RhcnRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBEZWx0YSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVG90YWwgbGVuZ3RoIG9mIGFuaW1hdGlvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWVcbiAgICAgKi9cbiAgICBlYXNlQm90aDogZnVuY3Rpb24gKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgaWYgKCh0IC89IGQvMikgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy8yKnQqdCArIGI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLWMvMiAqICgoLS10KSoodC0yKSAtIDEpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmVnaW5zIHNsb3dseSBhbmQgYWNjZWxlcmF0ZXMgdG93YXJkcyBlbmQuIChxdWFydGljKVxuICAgICAqIEBtZXRob2QgZWFzZUluU3Ryb25nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgVGltZSB2YWx1ZSB1c2VkIHRvIGNvbXB1dGUgY3VycmVudCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFN0YXJ0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgRGVsdGEgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkIFRvdGFsIGxlbmd0aCBvZiBhbmltYXRpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjb21wdXRlZCB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lXG4gICAgICovXG4gICAgZWFzZUluU3Ryb25nOiBmdW5jdGlvbiAodCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gYyoodC89ZCkqdCp0KnQgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCZWdpbnMgcXVpY2tseSBhbmQgZGVjZWxlcmF0ZXMgdG93YXJkcyBlbmQuICAocXVhcnRpYylcbiAgICAgKiBAbWV0aG9kIGVhc2VPdXRTdHJvbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCBUaW1lIHZhbHVlIHVzZWQgdG8gY29tcHV0ZSBjdXJyZW50IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgU3RhcnRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBEZWx0YSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVG90YWwgbGVuZ3RoIG9mIGFuaW1hdGlvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWVcbiAgICAgKi9cbiAgICBlYXNlT3V0U3Ryb25nOiBmdW5jdGlvbiAodCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gLWMgKiAoKHQ9dC9kLTEpKnQqdCp0IC0gMSkgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCZWdpbnMgc2xvd2x5IGFuZCBkZWNlbGVyYXRlcyB0b3dhcmRzIGVuZC4gKHF1YXJ0aWMpXG4gICAgICogQG1ldGhvZCBlYXNlQm90aFN0cm9uZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0IFRpbWUgdmFsdWUgdXNlZCB0byBjb21wdXRlIGN1cnJlbnQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBTdGFydGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIERlbHRhIGJldHdlZW4gc3RhcnQgYW5kIGVuZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZCBUb3RhbCBsZW5ndGggb2YgYW5pbWF0aW9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY29tcHV0ZWQgdmFsdWUgZm9yIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZVxuICAgICAqL1xuICAgIGVhc2VCb3RoU3Ryb25nOiBmdW5jdGlvbiAodCwgYiwgYywgZCkge1xuICAgICAgICBpZiAoKHQgLz0gZC8yKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBjLzIqdCp0KnQqdCArIGI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLWMvMiAqICgodC09MikqdCp0KnQgLSAyKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNuYXAgaW4gZWxhc3RpYyBlZmZlY3QuXG4gICAgICogQG1ldGhvZCBlbGFzdGljSW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCBUaW1lIHZhbHVlIHVzZWQgdG8gY29tcHV0ZSBjdXJyZW50IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgU3RhcnRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBEZWx0YSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVG90YWwgbGVuZ3RoIG9mIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIEFtcGxpdHVkZSAob3B0aW9uYWwpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHAgUGVyaW9kIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjb21wdXRlZCB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lXG4gICAgICovXG5cbiAgICBlbGFzdGljSW46IGZ1bmN0aW9uICh0LCBiLCBjLCBkLCBhLCBwKSB7XG4gICAgICAgIHZhciBzO1xuICAgICAgICBpZiAodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAodCAvPSBkKSA9PT0gMSApIHtcbiAgICAgICAgICAgIHJldHVybiBiK2M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICBwID0gZCogMC4zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICAgICAgYSA9IGM7XG4gICAgICAgICAgICBzID0gcC80O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4gKGMvYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLShhKk1hdGgucG93KDIsMTAqKHQtPTEpKSAqIE1hdGguc2luKCAodCpkLXMpKigyKk1hdGguUEkpL3AgKSkgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTbmFwIG91dCBlbGFzdGljIGVmZmVjdC5cbiAgICAgKiBAbWV0aG9kIGVsYXN0aWNPdXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCBUaW1lIHZhbHVlIHVzZWQgdG8gY29tcHV0ZSBjdXJyZW50IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgU3RhcnRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBEZWx0YSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVG90YWwgbGVuZ3RoIG9mIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIEFtcGxpdHVkZSAob3B0aW9uYWwpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHAgUGVyaW9kIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjb21wdXRlZCB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lXG4gICAgICovXG4gICAgZWxhc3RpY091dDogZnVuY3Rpb24gKHQsIGIsIGMsIGQsIGEsIHApIHtcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICh0IC89IGQpID09PSAxICkge1xuICAgICAgICAgICAgcmV0dXJuIGIrYztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHA9ZCAqIDAuMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYSB8fCBhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgICAgICAgIGEgPSBjO1xuICAgICAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4gKGMvYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSpNYXRoLnBvdygyLC0xMCp0KSAqIE1hdGguc2luKCAodCpkLXMpKigyKk1hdGguUEkpL3AgKSArIGMgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTbmFwIGJvdGggZWxhc3RpYyBlZmZlY3QuXG4gICAgICogQG1ldGhvZCBlbGFzdGljQm90aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0IFRpbWUgdmFsdWUgdXNlZCB0byBjb21wdXRlIGN1cnJlbnQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBTdGFydGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIERlbHRhIGJldHdlZW4gc3RhcnQgYW5kIGVuZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZCBUb3RhbCBsZW5ndGggb2YgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgQW1wbGl0dWRlIChvcHRpb25hbClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcCBQZXJpb2QgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWVcbiAgICAgKi9cbiAgICBlbGFzdGljQm90aDogZnVuY3Rpb24gKHQsIGIsIGMsIGQsIGEsIHApIHtcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggKHQgLz0gZC8yKSA9PT0gMiApIHtcbiAgICAgICAgICAgIHJldHVybiBiK2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHAgPSBkKigwLjMqMS41KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIWEgfHwgYSA8IE1hdGguYWJzKGMpICkge1xuICAgICAgICAgICAgYSA9IGM7XG4gICAgICAgICAgICBzID0gcC80O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4gKGMvYSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMC41KihhKk1hdGgucG93KDIsMTAqKHQtPTEpKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc2luKCAodCpkLXMpKigyKk1hdGguUEkpL3AgKSkgKyBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhKk1hdGgucG93KDIsLTEwKih0LT0xKSkgKlxuICAgICAgICAgICAgICAgIE1hdGguc2luKCAodCpkLXMpKigyKk1hdGguUEkpL3AgKSowLjUgKyBjICsgYjtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBCYWNrdHJhY2tzIHNsaWdodGx5LCB0aGVuIHJldmVyc2VzIGRpcmVjdGlvbiBhbmQgbW92ZXMgdG8gZW5kLlxuICAgICAqIEBtZXRob2QgYmFja0luXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgVGltZSB2YWx1ZSB1c2VkIHRvIGNvbXB1dGUgY3VycmVudCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFN0YXJ0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgRGVsdGEgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkIFRvdGFsIGxlbmd0aCBvZiBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBPdmVyc2hvb3QgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWVcbiAgICAgKi9cbiAgICBiYWNrSW46IGZ1bmN0aW9uICh0LCBiLCBjLCBkLCBzKSB7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgPSAxLjcwMTU4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ID09PSBkKSB7XG4gICAgICAgICAgICB0IC09IDAuMDAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjKih0Lz1kKSp0KigocysxKSp0IC0gcykgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVyc2hvb3RzIGVuZCwgdGhlbiByZXZlcnNlcyBhbmQgY29tZXMgYmFjayB0byBlbmQuXG4gICAgICogQG1ldGhvZCBiYWNrT3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgVGltZSB2YWx1ZSB1c2VkIHRvIGNvbXB1dGUgY3VycmVudCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFN0YXJ0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgRGVsdGEgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkIFRvdGFsIGxlbmd0aCBvZiBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyBPdmVyc2hvb3QgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWVcbiAgICAgKi9cbiAgICBiYWNrT3V0OiBmdW5jdGlvbiAodCwgYiwgYywgZCwgcykge1xuICAgICAgICBpZiAodHlwZW9mIHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzID0gMS43MDE1ODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYyooKHQ9dC9kLTEpKnQqKChzKzEpKnQgKyBzKSArIDEpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFja3RyYWNrcyBzbGlnaHRseSwgdGhlbiByZXZlcnNlcyBkaXJlY3Rpb24sIG92ZXJzaG9vdHMgZW5kLFxuICAgICAqIHRoZW4gcmV2ZXJzZXMgYW5kIGNvbWVzIGJhY2sgdG8gZW5kLlxuICAgICAqIEBtZXRob2QgYmFja0JvdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCBUaW1lIHZhbHVlIHVzZWQgdG8gY29tcHV0ZSBjdXJyZW50IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgU3RhcnRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyBEZWx0YSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgVG90YWwgbGVuZ3RoIG9mIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzIE92ZXJzaG9vdCAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY29tcHV0ZWQgdmFsdWUgZm9yIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZVxuICAgICAqL1xuICAgIGJhY2tCb3RoOiBmdW5jdGlvbiAodCwgYiwgYywgZCwgcykge1xuICAgICAgICBpZiAodHlwZW9mIHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzID0gMS43MDE1ODtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodCAvPSBkLzIgKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBjLzIqKHQqdCooKChzKj0oMS41MjUpKSsxKSp0IC0gcykpICsgYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYy8yKigodC09MikqdCooKChzKj0oMS41MjUpKSsxKSp0ICsgcykgKyAyKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJvdW5jZSBvZmYgb2Ygc3RhcnQuXG4gICAgICogQG1ldGhvZCBib3VuY2VJblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0IFRpbWUgdmFsdWUgdXNlZCB0byBjb21wdXRlIGN1cnJlbnQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBTdGFydGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIERlbHRhIGJldHdlZW4gc3RhcnQgYW5kIGVuZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZCBUb3RhbCBsZW5ndGggb2YgYW5pbWF0aW9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY29tcHV0ZWQgdmFsdWUgZm9yIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZVxuICAgICAqL1xuICAgIGJvdW5jZUluOiBmdW5jdGlvbiAodCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gYyAtIFkuRWFzaW5nLmJvdW5jZU91dChkLXQsIDAsIGMsIGQpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQm91bmNlcyBvZmYgZW5kLlxuICAgICAqIEBtZXRob2QgYm91bmNlT3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgVGltZSB2YWx1ZSB1c2VkIHRvIGNvbXB1dGUgY3VycmVudCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFN0YXJ0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgRGVsdGEgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkIFRvdGFsIGxlbmd0aCBvZiBhbmltYXRpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjb21wdXRlZCB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lXG4gICAgICovXG4gICAgYm91bmNlT3V0OiBmdW5jdGlvbiAodCwgYiwgYywgZCkge1xuICAgICAgICBpZiAoKHQvPWQpIDwgKDEvMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyooNy41NjI1KnQqdCkgKyBiO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPCAoMi8yLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjKig3LjU2MjUqKHQtPSgxLjUvMi43NSkpKnQgKyAwLjc1KSArIGI7XG4gICAgICAgIH0gZWxzZSBpZiAodCA8ICgyLjUvMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyooNy41NjI1Kih0LT0oMi4yNS8yLjc1KSkqdCArIDAuOTM3NSkgKyBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjKig3LjU2MjUqKHQtPSgyLjYyNS8yLjc1KSkqdCArIDAuOTg0Mzc1KSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJvdW5jZXMgb2ZmIHN0YXJ0IGFuZCBlbmQuXG4gICAgICogQG1ldGhvZCBib3VuY2VCb3RoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgVGltZSB2YWx1ZSB1c2VkIHRvIGNvbXB1dGUgY3VycmVudCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFN0YXJ0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgRGVsdGEgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkIFRvdGFsIGxlbmd0aCBvZiBhbmltYXRpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjb21wdXRlZCB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lXG4gICAgICovXG4gICAgYm91bmNlQm90aDogZnVuY3Rpb24gKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgaWYgKHQgPCBkLzIpIHtcbiAgICAgICAgICAgIHJldHVybiBZLkVhc2luZy5ib3VuY2VJbih0ICogMiwgMCwgYywgZCkgKiAwLjUgKyBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBZLkVhc2luZy5ib3VuY2VPdXQodCAqIDIgLSBkLCAwLCBjLCBkKSAqIDAuNSArIGMgKiAwLjUgKyBiO1xuICAgIH1cbn07XG5cblkuRWFzaW5nID0gRWFzaW5nO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJhbmltLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnYW5pbS1ub2RlLXBsdWdpbicsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogIEJpbmRzIGFuIEFuaW0gaW5zdGFuY2UgdG8gYSBOb2RlIGluc3RhbmNlXG4gKiBAbW9kdWxlIGFuaW1cbiAqIEBjbGFzcyBQbHVnaW4uTm9kZUZYXG4gKiBAZXh0ZW5kcyBBbmltXG4gKiBAc3VibW9kdWxlIGFuaW0tbm9kZS1wbHVnaW5cbiAqL1xuXG52YXIgTm9kZUZYID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgY29uZmlnID0gKGNvbmZpZykgPyBZLm1lcmdlKGNvbmZpZykgOiB7fTtcbiAgICBjb25maWcubm9kZSA9IGNvbmZpZy5ob3N0O1xuICAgIE5vZGVGWC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5Ob2RlRlguTkFNRSA9IFwibm9kZWZ4XCI7XG5Ob2RlRlguTlMgPSBcImZ4XCI7XG5cblkuZXh0ZW5kKE5vZGVGWCwgWS5BbmltKTtcblxuWS5uYW1lc3BhY2UoJ1BsdWdpbicpO1xuWS5QbHVnaW4uTm9kZUZYID0gTm9kZUZYO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJub2RlLXBsdWdpbmhvc3RcIiwgXCJhbmltLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnYW5pbS1zY3JvbGwnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIEFkZHMgc3VwcG9ydCBmb3IgdGhlIDxjb2RlPnNjcm9sbDwvY29kZT4gcHJvcGVydHkgaW4gPGNvZGU+dG88L2NvZGU+XG4gKiBhbmQgPGNvZGU+ZnJvbTwvY29kZT4gYXR0cmlidXRlcy5cbiAqIEBtb2R1bGUgYW5pbVxuICogQHN1Ym1vZHVsZSBhbmltLXNjcm9sbFxuICovXG5cbnZhciBOVU0gPSBOdW1iZXI7XG5cbi8vVE9ETzogZGVwcmVjYXRlIGZvciBzY3JvbGxUb3AvTGVmdCBwcm9wZXJ0aWVzP1xuWS5BbmltLmJlaGF2aW9ycy5zY3JvbGwgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihhbmltLCBhdHQsIGZyb20sIHRvLCBlbGFwc2VkLCBkdXJhdGlvbiwgZm4pIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBub2RlID0gYW5pbS5fbm9kZSxcbiAgICAgICAgICAgIHZhbCA9IChbXG4gICAgICAgICAgICBmbihlbGFwc2VkLCBOVU0oZnJvbVswXSksIE5VTSh0b1swXSkgLSBOVU0oZnJvbVswXSksIGR1cmF0aW9uKSxcbiAgICAgICAgICAgIGZuKGVsYXBzZWQsIE5VTShmcm9tWzFdKSwgTlVNKHRvWzFdKSAtIE5VTShmcm9tWzFdKSwgZHVyYXRpb24pXG4gICAgICAgIF0pO1xuXG4gICAgICAgIGlmICh2YWxbMF0pIHtcbiAgICAgICAgICAgIG5vZGUuc2V0KCdzY3JvbGxMZWZ0JywgdmFsWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxbMV0pIHtcbiAgICAgICAgICAgIG5vZGUuc2V0KCdzY3JvbGxUb3AnLCB2YWxbMV0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGFuaW0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBhbmltLl9ub2RlO1xuICAgICAgICByZXR1cm4gW25vZGUuZ2V0KCdzY3JvbGxMZWZ0JyksIG5vZGUuZ2V0KCdzY3JvbGxUb3AnKV07XG4gICAgfVxufTtcblxuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJhbmltLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnYW5pbS14eScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogQWRkcyBzdXBwb3J0IGZvciB0aGUgPGNvZGU+eHk8L2NvZGU+IHByb3BlcnR5IGluIDxjb2RlPmZyb208L2NvZGU+IGFuZFxuICogPGNvZGU+dG88L2NvZGU+IGF0dHJpYnV0ZXMuXG4gKiBAbW9kdWxlIGFuaW1cbiAqIEBzdWJtb2R1bGUgYW5pbS14eVxuICovXG5cbnZhciBOVU0gPSBOdW1iZXI7XG5cblkuQW5pbS5iZWhhdmlvcnMueHkgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihhbmltLCBhdHQsIGZyb20sIHRvLCBlbGFwc2VkLCBkdXJhdGlvbiwgZm4pIHtcbiAgICAgICAgYW5pbS5fbm9kZS5zZXRYWShbXG4gICAgICAgICAgICBmbihlbGFwc2VkLCBOVU0oZnJvbVswXSksIE5VTSh0b1swXSkgLSBOVU0oZnJvbVswXSksIGR1cmF0aW9uKSxcbiAgICAgICAgICAgIGZuKGVsYXBzZWQsIE5VTShmcm9tWzFdKSwgTlVNKHRvWzFdKSAtIE5VTShmcm9tWzFdKSwgZHVyYXRpb24pXG4gICAgICAgIF0pO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbihhbmltKSB7XG4gICAgICAgIHJldHVybiBhbmltLl9ub2RlLmdldFhZKCk7XG4gICAgfVxufTtcblxuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJhbmltLWJhc2VcIiwgXCJub2RlLXNjcmVlblwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdhcnJheS1leHRyYXMnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbkFkZHMgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgdG8gdGhlIGBZLkFycmF5YCBjbGFzcy5cblxuQG1vZHVsZSBjb2xsZWN0aW9uXG5Ac3VibW9kdWxlIGFycmF5LWV4dHJhc1xuKiovXG5cbnZhciBBICAgICAgICAgID0gWS5BcnJheSxcbiAgICBMICAgICAgICAgID0gWS5MYW5nLFxuICAgIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKlxuUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBjb250YWlucyB0aGUgc3BlY2lmaWVkXG52YWx1ZSwgb3IgYC0xYCBpZiB0aGUgdmFsdWUgaXNuJ3QgZm91bmQuXG5cbkBtZXRob2QgbGFzdEluZGV4T2ZcbkBwYXJhbSB7QXJyYXl9IGEgQXJyYXkgdG8gc2VhcmNoIGluLlxuQHBhcmFtIHtBbnl9IHZhbCBWYWx1ZSB0byBzZWFyY2ggZm9yLlxuQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXhdIEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZyBiYWNrd2FyZHMuXG4gIERlZmF1bHRzIHRvIHRoZSBhcnJheSdzIGxlbmd0aCAtIDEuIElmIG5lZ2F0aXZlLCBpdCB3aWxsIGJlIHRha2VuIGFzIGFuIG9mZnNldFxuICBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LiBJZiB0aGUgY2FsY3VsYXRlZCBpbmRleCBpcyBsZXNzIHRoYW4gMCwgdGhlIGFycmF5XG4gIHdpbGwgbm90IGJlIHNlYXJjaGVkIGFuZCBgLTFgIHdpbGwgYmUgcmV0dXJuZWQuXG5AcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBpdGVtIHRoYXQgY29udGFpbnMgdGhlIHZhbHVlLCBvciBgLTFgIGlmIG5vdFxuICBmb3VuZC5cbkBzdGF0aWNcbkBmb3IgQXJyYXlcbioqL1xuQS5sYXN0SW5kZXhPZiA9IEwuX2lzTmF0aXZlKEFycmF5UHJvdG8ubGFzdEluZGV4T2YpID9cbiAgICBmdW5jdGlvbihhLCB2YWwsIGZyb21JbmRleCkge1xuICAgICAgICAvLyBBbiB1bmRlZmluZWQgZnJvbUluZGV4IGlzIHN0aWxsIGNvbnNpZGVyZWQgYSB2YWx1ZSBieSBzb21lIChhbGw/KVxuICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb25zLCBzbyB3ZSBjYW4ndCBwYXNzIGl0IHVubGVzcyBpdCdzIGFjdHVhbGx5XG4gICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgcmV0dXJuIGZyb21JbmRleCB8fCBmcm9tSW5kZXggPT09IDAgPyBhLmxhc3RJbmRleE9mKHZhbCwgZnJvbUluZGV4KSA6XG4gICAgICAgICAgICAgICAgYS5sYXN0SW5kZXhPZih2YWwpO1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uKGEsIHZhbCwgZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBsZW4gPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIGkgICA9IGxlbiAtIDE7XG5cbiAgICAgICAgaWYgKGZyb21JbmRleCB8fCBmcm9tSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGkgPSBNYXRoLm1pbihmcm9tSW5kZXggPCAwID8gbGVuICsgZnJvbUluZGV4IDogZnJvbUluZGV4LCBsZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPiAtMSAmJiBsZW4gPiAwKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+IC0xOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBhICYmIGFbaV0gPT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuLyoqXG5SZXR1cm5zIGEgY29weSBvZiB0aGUgaW5wdXQgYXJyYXkgd2l0aCBkdXBsaWNhdGUgaXRlbXMgcmVtb3ZlZC5cblxuTm90ZTogSWYgdGhlIGlucHV0IGFycmF5IG9ubHkgY29udGFpbnMgc3RyaW5ncywgdGhlIGBZLkFycmF5LmRlZHVwZSgpYCBtZXRob2QgaXNcbmEgbXVjaCBmYXN0ZXIgYWx0ZXJuYXRpdmUuXG5cbkBtZXRob2QgdW5pcXVlXG5AcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBkZWR1cGUuXG5AcGFyYW0ge0Z1bmN0aW9ufSBbdGVzdEZuXSBDdXN0b20gZnVuY3Rpb24gdG8gdXNlIHRvIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHR3b1xuICAgIHZhbHVlcy4gQSB0cnV0aHkgcmV0dXJuIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSB2YWx1ZXMgYXJlIGVxdWFsLiBBIGZhbHN5XG4gICAgcmV0dXJuIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSB2YWx1ZXMgYXJlIG5vdCBlcXVhbC5cblxuICAgIEBwYXJhbSB7QW55fSB0ZXN0Rm4uYSBGaXJzdCB2YWx1ZSB0byBjb21wYXJlLlxuICAgIEBwYXJhbSB7QW55fSB0ZXN0Rm4uYiBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAgICBAcGFyYW0ge051bWJlcn0gdGVzdEZuLmluZGV4IEluZGV4IG9mIHRoZSBjdXJyZW50IGl0ZW0gaW4gdGhlIG9yaWdpbmFsXG4gICAgICAgIGFycmF5LlxuICAgIEBwYXJhbSB7QXJyYXl9IHRlc3RGbi5hcnJheSBUaGUgb3JpZ2luYWwgYXJyYXkuXG4gICAgQHJldHVybiB7Qm9vbGVhbn0gX3RydWVfIGlmIHRoZSBpdGVtcyBhcmUgZXF1YWwsIF9mYWxzZV8gb3RoZXJ3aXNlLlxuXG5AcmV0dXJuIHtBcnJheX0gQ29weSBvZiB0aGUgaW5wdXQgYXJyYXkgd2l0aCBkdXBsaWNhdGUgaXRlbXMgcmVtb3ZlZC5cbkBzdGF0aWNcbioqL1xuQS51bmlxdWUgPSBmdW5jdGlvbiAoYXJyYXksIHRlc3RGbikge1xuICAgIHZhciBpICAgICAgID0gMCxcbiAgICAgICAgbGVuICAgICA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IFtdLFxuICAgICAgICBqLCByZXN1bHQsIHJlc3VsdExlbiwgdmFsdWU7XG5cbiAgICAvLyBOb3RlIHRoZSBsYWJlbCBoZXJlLiBJdCdzIHVzZWQgdG8ganVtcCBvdXQgb2YgdGhlIGlubmVyIGxvb3Agd2hlbiBhIHZhbHVlXG4gICAgLy8gaXMgbm90IHVuaXF1ZS5cbiAgICBvdXRlckxvb3A6IGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpXTtcblxuICAgICAgICAvLyBGb3IgZWFjaCB2YWx1ZSBpbiB0aGUgaW5wdXQgYXJyYXksIGl0ZXJhdGUgdGhyb3VnaCB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgIC8vIGFuZCBjaGVjayBmb3IgdW5pcXVlbmVzcyBhZ2FpbnN0IGVhY2ggcmVzdWx0IHZhbHVlLlxuICAgICAgICBmb3IgKGogPSAwLCByZXN1bHRMZW4gPSByZXN1bHRzLmxlbmd0aDsgaiA8IHJlc3VsdExlbjsgaisrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzW2pdO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdGVzdCBmdW5jdGlvbiByZXR1cm5zIHRydWUgb3IgdGhlcmUncyBubyB0ZXN0IGZ1bmN0aW9uIGFuZFxuICAgICAgICAgICAgLy8gdGhlIHZhbHVlIGVxdWFscyB0aGUgY3VycmVudCByZXN1bHQgaXRlbSwgc3RvcCBpdGVyYXRpbmcgb3ZlciB0aGVcbiAgICAgICAgICAgIC8vIHJlc3VsdHMgYW5kIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHZhbHVlIGluIHRoZSBpbnB1dCBhcnJheS5cbiAgICAgICAgICAgIGlmICh0ZXN0Rm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdEZuLmNhbGwoYXJyYXksIHZhbHVlLCByZXN1bHQsIGksIGFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlckxvb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXJMb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IHRoaXMgZmFyLCB0aGF0IG1lYW5zIHRoZSBjdXJyZW50IHZhbHVlIGlzIG5vdCBhbHJlYWR5IGluXG4gICAgICAgIC8vIHRoZSByZXN1bHQgYXJyYXksIHNvIGFkZCBpdC5cbiAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuRXhlY3V0ZXMgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIG9uIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuIFJldHVybnMgYSBuZXcgYXJyYXlcbmNvbnRhaW5pbmcgdGhlIGl0ZW1zIGZvciB3aGljaCB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gcmV0dXJuZWQgYSB0cnV0aHkgdmFsdWUuXG5cbkBtZXRob2QgZmlsdGVyXG5AcGFyYW0ge0FycmF5fSBhIEFycmF5IHRvIGZpbHRlci5cbkBwYXJhbSB7RnVuY3Rpb259IGYgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIGl0ZW0uXG5AcGFyYW0ge09iamVjdH0gW29dIE9wdGlvbmFsIGNvbnRleHQgb2JqZWN0LlxuQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGl0ZW1zIGZvciB3aGljaCB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gcmV0dXJuZWQgYVxuICB0cnV0aHkgdmFsdWUgKGVtcHR5IGlmIGl0IG5ldmVyIHJldHVybmVkIGEgdHJ1dGh5IHZhbHVlKS5cbkBzdGF0aWNcbiovXG5BLmZpbHRlciA9IEwuX2lzTmF0aXZlKEFycmF5UHJvdG8uZmlsdGVyKSA/XG4gICAgZnVuY3Rpb24oYSwgZiwgbykge1xuICAgICAgICByZXR1cm4gQXJyYXlQcm90by5maWx0ZXIuY2FsbChhLCBmLCBvKTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbihhLCBmLCBvKSB7XG4gICAgICAgIHZhciBpICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgaW4gYSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBhW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGYuY2FsbChvLCBpdGVtLCBpLCBhKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuLyoqXG5UaGUgaW52ZXJzZSBvZiBgQXJyYXkuZmlsdGVyKClgLiBFeGVjdXRlcyB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gb24gZWFjaCBpdGVtLlxuUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIHRoZSBpdGVtcyBmb3Igd2hpY2ggdGhlIHN1cHBsaWVkIGZ1bmN0aW9uXG5yZXR1cm5lZCBgZmFsc2VgLlxuXG5AbWV0aG9kIHJlamVjdFxuQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgdG8gaXRlcmF0ZS5cbkBwYXJhbSB7RnVuY3Rpb259IGYgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCBpdGVtLlxuQHBhcmFtIHtvYmplY3R9IFtvXSBPcHRpb25hbCBjb250ZXh0IG9iamVjdC5cbkByZXR1cm4ge0FycmF5fSBUaGUgaXRlbXMgZm9yIHdoaWNoIHRoZSBzdXBwbGllZCBmdW5jdGlvbiByZXR1cm5lZCBgZmFsc2VgLlxuQHN0YXRpY1xuKi9cbkEucmVqZWN0ID0gZnVuY3Rpb24oYSwgZiwgbykge1xuICAgIHJldHVybiBBLmZpbHRlcihhLCBmdW5jdGlvbihpdGVtLCBpLCBhKSB7XG4gICAgICAgIHJldHVybiAhZi5jYWxsKG8sIGl0ZW0sIGksIGEpO1xuICAgIH0pO1xufTtcblxuLyoqXG5FeGVjdXRlcyB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gb24gZWFjaCBpdGVtIGluIHRoZSBhcnJheS4gSXRlcmF0aW9uIHN0b3BzIGlmIHRoZVxuc3VwcGxpZWQgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdHJ1dGh5IHZhbHVlLlxuXG5AbWV0aG9kIGV2ZXJ5XG5AcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSB0byBpdGVyYXRlLlxuQHBhcmFtIHtGdW5jdGlvbn0gZiB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIGl0ZW0uXG5AcGFyYW0ge09iamVjdH0gW29dIE9wdGlvbmFsIGNvbnRleHQgb2JqZWN0LlxuQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5IHJldHVybnMgYHRydWVgIGZyb20gdGhlXG4gIHN1cHBsaWVkIGZ1bmN0aW9uLCBgZmFsc2VgIG90aGVyd2lzZS5cbkBzdGF0aWNcbiovXG5BLmV2ZXJ5ID0gTC5faXNOYXRpdmUoQXJyYXlQcm90by5ldmVyeSkgP1xuICAgIGZ1bmN0aW9uKGEsIGYsIG8pIHtcbiAgICAgICAgcmV0dXJuIEFycmF5UHJvdG8uZXZlcnkuY2FsbChhLCBmLCBvKTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbihhLCBmLCBvKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpIGluIGEgJiYgIWYuY2FsbChvLCBhW2ldLCBpLCBhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbi8qKlxuRXhlY3V0ZXMgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIG9uIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkgYW5kIHJldHVybnMgYSBuZXcgYXJyYXlcbmNvbnRhaW5pbmcgYWxsIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLlxuXG5AZXhhbXBsZVxuXG4gICAgLy8gQ29udmVydCBhbiBhcnJheSBvZiBudW1iZXJzIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICBZLkFycmF5Lm1hcChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pO1xuICAgIC8vID0+IFsnMScsICcyJywgJzMnLCAnNCddXG5cbkBtZXRob2QgbWFwXG5AcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSB0byBpdGVyYXRlLlxuQHBhcmFtIHtGdW5jdGlvbn0gZiB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIGl0ZW0uXG5AcGFyYW0ge29iamVjdH0gW29dIE9wdGlvbmFsIGNvbnRleHQgb2JqZWN0LlxuQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgc3VwcGxpZWQgZnVuY3Rpb25cbiAgZm9yIGVhY2ggaXRlbSBpbiB0aGUgb3JpZ2luYWwgYXJyYXkuXG5Ac3RhdGljXG4qL1xuQS5tYXAgPSBMLl9pc05hdGl2ZShBcnJheVByb3RvLm1hcCkgP1xuICAgIGZ1bmN0aW9uKGEsIGYsIG8pIHtcbiAgICAgICAgcmV0dXJuIEFycmF5UHJvdG8ubWFwLmNhbGwoYSwgZiwgbyk7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24oYSwgZiwgbykge1xuICAgICAgICB2YXIgaSAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgID0gYS5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHRzID0gQXJyYXlQcm90by5jb25jYXQuY2FsbChhKTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGYuY2FsbChvLCBhW2ldLCBpLCBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cblxuLyoqXG5FeGVjdXRlcyB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gb24gZWFjaCBpdGVtIGluIHRoZSBhcnJheSwgXCJmb2xkaW5nXCIgdGhlIGFycmF5XG5pbnRvIGEgc2luZ2xlIHZhbHVlLlxuXG5AbWV0aG9kIHJlZHVjZVxuQHBhcmFtIHtBcnJheX0gYSBBcnJheSB0byBpdGVyYXRlLlxuQHBhcmFtIHtBbnl9IGluaXQgSW5pdGlhbCB2YWx1ZSB0byBzdGFydCB3aXRoLlxuQHBhcmFtIHtGdW5jdGlvbn0gZiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggaXRlbS4gVGhpcyBmdW5jdGlvbiBzaG91bGRcbiAgdXBkYXRlIGFuZCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBjb21wdXRhdGlvbi4gSXQgd2lsbCByZWNlaXZlIHRoZSBmb2xsb3dpbmdcbiAgYXJndW1lbnRzOlxuICAgIEBwYXJhbSB7QW55fSBmLnByZXZpb3VzVmFsdWUgVmFsdWUgcmV0dXJuZWQgZnJvbSB0aGUgcHJldmlvdXMgaXRlcmF0aW9uLFxuICAgICAgb3IgdGhlIGluaXRpYWwgdmFsdWUgaWYgdGhpcyBpcyB0aGUgZmlyc3QgaXRlcmF0aW9uLlxuICAgIEBwYXJhbSB7QW55fSBmLmN1cnJlbnRWYWx1ZSBWYWx1ZSBvZiB0aGUgY3VycmVudCBpdGVtIGJlaW5nIGl0ZXJhdGVkLlxuICAgIEBwYXJhbSB7TnVtYmVyfSBmLmluZGV4IEluZGV4IG9mIHRoZSBjdXJyZW50IGl0ZW0uXG4gICAgQHBhcmFtIHtBcnJheX0gZi5hcnJheSBBcnJheSBiZWluZyBpdGVyYXRlZC5cbkBwYXJhbSB7T2JqZWN0fSBbb10gT3B0aW9uYWwgY29udGV4dCBvYmplY3QuXG5AcmV0dXJuIHtBbnl9IEZpbmFsIHJlc3VsdCBmcm9tIGl0ZXJhdGl2ZWx5IGFwcGx5aW5nIHRoZSBnaXZlbiBmdW5jdGlvbiB0byBlYWNoXG4gIGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuQHN0YXRpY1xuKi9cbkEucmVkdWNlID0gTC5faXNOYXRpdmUoQXJyYXlQcm90by5yZWR1Y2UpID9cbiAgICBmdW5jdGlvbihhLCBpbml0LCBmLCBvKSB7XG4gICAgICAgIC8vIEVTNSBBcnJheS5yZWR1Y2UgZG9lc24ndCBzdXBwb3J0IGEgdGhpc09iamVjdCwgc28gd2UgbmVlZCB0b1xuICAgICAgICAvLyBpbXBsZW1lbnQgaXQgbWFudWFsbHkuXG4gICAgICAgIHJldHVybiBBcnJheVByb3RvLnJlZHVjZS5jYWxsKGEsIGZ1bmN0aW9uKGluaXQsIGl0ZW0sIGksIGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmLmNhbGwobywgaW5pdCwgaXRlbSwgaSwgYSk7XG4gICAgICAgIH0sIGluaXQpO1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uKGEsIGluaXQsIGYsIG8pIHtcbiAgICAgICAgdmFyIGkgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IGluaXQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgaW4gYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGYuY2FsbChvLCByZXN1bHQsIGFbaV0sIGksIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4vKipcbkV4ZWN1dGVzIHRoZSBzdXBwbGllZCBmdW5jdGlvbiBvbiBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LCBzZWFyY2hpbmcgZm9yIHRoZVxuZmlyc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLlxuXG5AbWV0aG9kIGZpbmRcbkBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IHRvIHNlYXJjaC5cbkBwYXJhbSB7RnVuY3Rpb259IGYgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCBpdGVtLiBJdGVyYXRpb24gaXMgc3RvcHBlZFxuICBhcyBzb29uIGFzIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAuXG5AcGFyYW0ge09iamVjdH0gW29dIE9wdGlvbmFsIGNvbnRleHQgb2JqZWN0LlxuQHJldHVybiB7T2JqZWN0fSB0aGUgZmlyc3QgaXRlbSB0aGF0IHRoZSBzdXBwbGllZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IsXG4gIG9yIGBudWxsYCBpZiBpdCBuZXZlciByZXR1cm5zIGB0cnVlYC5cbkBzdGF0aWNcbiovXG5BLmZpbmQgPSBmdW5jdGlvbihhLCBmLCBvKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoaSBpbiBhICYmIGYuY2FsbChvLCBhW2ldLCBpLCBhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbkl0ZXJhdGVzIG92ZXIgYW4gYXJyYXksIHJldHVybmluZyBhIG5ldyBhcnJheSBvZiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlXG5zdXBwbGllZCByZWd1bGFyIGV4cHJlc3Npb24uXG5cbkBtZXRob2QgZ3JlcFxuQHBhcmFtIHtBcnJheX0gYSBBcnJheSB0byBpdGVyYXRlIG92ZXIuXG5AcGFyYW0ge1JlZ0V4cH0gcGF0dGVybiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gdGVzdCBhZ2FpbnN0IGVhY2ggaXRlbS5cbkByZXR1cm4ge0FycmF5fSBBbGwgdGhlIGl0ZW1zIGluIHRoZSBhcnJheSB0aGF0IHByb2R1Y2UgYSBtYXRjaCBhZ2FpbnN0IHRoZVxuICBzdXBwbGllZCByZWd1bGFyIGV4cHJlc3Npb24uIElmIG5vIGl0ZW1zIG1hdGNoLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbkBzdGF0aWNcbiovXG5BLmdyZXAgPSBmdW5jdGlvbihhLCBwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIEEuZmlsdGVyKGEsIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoaXRlbSk7XG4gICAgfSk7XG59O1xuXG4vKipcblBhcnRpdGlvbnMgYW4gYXJyYXkgaW50byB0d28gbmV3IGFycmF5cywgb25lIHdpdGggdGhlIGl0ZW1zIGZvciB3aGljaCB0aGVcbnN1cHBsaWVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgLCBhbmQgb25lIHdpdGggdGhlIGl0ZW1zIGZvciB3aGljaCB0aGUgZnVuY3Rpb25cbnJldHVybnMgYGZhbHNlYC5cblxuQG1ldGhvZCBwYXJ0aXRpb25cbkBwYXJhbSB7QXJyYXl9IGEgQXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuQHBhcmFtIHtGdW5jdGlvbn0gZiBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LiBJdCB3aWxsXG4gIHJlY2VpdmUgdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gICAgQHBhcmFtIHtBbnl9IGYuaXRlbSBDdXJyZW50IGl0ZW0uXG4gICAgQHBhcmFtIHtOdW1iZXJ9IGYuaW5kZXggSW5kZXggb2YgdGhlIGN1cnJlbnQgaXRlbS5cbiAgICBAcGFyYW0ge0FycmF5fSBmLmFycmF5IFRoZSBhcnJheSBiZWluZyBpdGVyYXRlZC5cbkBwYXJhbSB7T2JqZWN0fSBbb10gT3B0aW9uYWwgZXhlY3V0aW9uIGNvbnRleHQuXG5AcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiBgbWF0Y2hlc2AgYW5kIGByZWplY3RzYC4gRWFjaCBpc1xuICBhbiBhcnJheSBjb250YWluaW5nIHRoZSBpdGVtcyB0aGF0IHdlcmUgc2VsZWN0ZWQgb3IgcmVqZWN0ZWQgYnkgdGhlIHRlc3RcbiAgZnVuY3Rpb24gKG9yIGFuIGVtcHR5IGFycmF5IGlmIG5vbmUpLlxuQHN0YXRpY1xuKi9cbkEucGFydGl0aW9uID0gZnVuY3Rpb24oYSwgZiwgbykge1xuICAgIHZhciByZXN1bHRzID0ge1xuICAgICAgICBtYXRjaGVzOiBbXSxcbiAgICAgICAgcmVqZWN0czogW11cbiAgICB9O1xuXG4gICAgQS5lYWNoKGEsIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBzZXQgPSBmLmNhbGwobywgaXRlbSwgaW5kZXgsIGEpID8gcmVzdWx0cy5tYXRjaGVzIDogcmVzdWx0cy5yZWplY3RzO1xuICAgICAgICBzZXQucHVzaChpdGVtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG5DcmVhdGVzIGFuIGFycmF5IG9mIGFycmF5cyBieSBwYWlyaW5nIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIG9mIHR3byBhcnJheXNcbnRvZ2V0aGVyIGludG8gYSBuZXcgYXJyYXkuXG5cbkBtZXRob2QgemlwXG5AcGFyYW0ge0FycmF5fSBhIEFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbkBwYXJhbSB7QXJyYXl9IGEyIEFub3RoZXIgYXJyYXkgd2hvc2UgdmFsdWVzIHdpbGwgYmUgcGFpcmVkIHdpdGggdmFsdWVzIG9mIHRoZVxuICBmaXJzdCBhcnJheS5cbkByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBhcnJheXMgZm9ybWVkIGJ5IHBhaXJpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBmaXJzdFxuICBhcnJheSB3aXRoIGFuIGl0ZW0gaW4gdGhlIHNlY29uZCBhcnJheSBoYXZpbmcgdGhlIGNvcnJlc3BvbmRpbmcgaW5kZXguXG5Ac3RhdGljXG4qL1xuQS56aXAgPSBmdW5jdGlvbihhLCBhMikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgQS5lYWNoKGEsIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChbaXRlbSwgYTJbaW5kZXhdXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbkZsYXR0ZW5zIGFuIGFycmF5IG9mIG5lc3RlZCBhcnJheXMgYXQgYW55IGFiaXRyYXJ5IGRlcHRoIGludG8gYSBzaW5nbGUsIGZsYXRcbmFycmF5LlxuXG5AbWV0aG9kIGZsYXR0ZW5cbkBwYXJhbSB7QXJyYXl9IGEgQXJyYXkgd2l0aCBuZXN0ZWQgYXJyYXlzIHRvIGZsYXR0ZW4uXG5AcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgd2hvc2UgbmVzdGVkIGFycmF5cyBoYXZlIGJlZW4gZmxhdHRlbmVkLlxuQHN0YXRpY1xuQHNpbmNlIDMuNy4wXG4qKi9cbkEuZmxhdHRlbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGksIGxlbiwgdmFsO1xuXG4gICAgLy8gQWx3YXlzIHJldHVybiBhbiBhcnJheS5cbiAgICBpZiAoIWEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhbCA9IGFbaV07XG5cbiAgICAgICAgaWYgKEwuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAvLyBSZWN1c2l2ZWx5IGZsYXR0ZW5zIGFueSBuZXN0ZWQgYXJyYXlzLlxuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBBLmZsYXR0ZW4odmFsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcInl1aS1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2FycmF5LWludm9rZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuQG1vZHVsZSBjb2xsZWN0aW9uXG5Ac3VibW9kdWxlIGFycmF5LWludm9rZVxuKi9cblxuLyoqXG5FeGVjdXRlcyBhIG5hbWVkIG1ldGhvZCBvbiBlYWNoIGl0ZW0gaW4gYW4gYXJyYXkgb2Ygb2JqZWN0cy4gSXRlbXMgaW4gdGhlIGFycmF5XG50aGF0IGRvIG5vdCBoYXZlIGEgZnVuY3Rpb24gYnkgdGhhdCBuYW1lIHdpbGwgYmUgc2tpcHBlZC5cblxuQGV4YW1wbGVcblxuICAgIFkuQXJyYXkuaW52b2tlKGFycmF5T2ZEcmFncywgJ3BsdWcnLCBZLlBsdWdpbi5ERFByb3h5KTtcblxuQG1ldGhvZCBpbnZva2VcbkBwYXJhbSB7QXJyYXl9IGl0ZW1zIEFycmF5IG9mIG9iamVjdHMgc3VwcG9ydGluZyB0aGUgbmFtZWQgbWV0aG9kLlxuQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBleGVjdXRlIG9uIGVhY2ggaXRlbS5cbkBwYXJhbSB7QW55fSBbYXJncypdIEFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBhcmdzIGFyZSBwYXNzZWQgYXMgcGFyYW1ldGVycyB0b1xuICB0aGUgZXhlY3V0aW9uIG9mIHRoZSBuYW1lZCBtZXRob2QuXG5AcmV0dXJuIHtBcnJheX0gQWxsIHJldHVybiB2YWx1ZXMsIGluZGV4ZWQgYWNjb3JkaW5nIHRvIHRoZSBpdGVtIGluZGV4LlxuQHN0YXRpY1xuQGZvciBBcnJheVxuKiovXG5ZLkFycmF5Lmludm9rZSA9IGZ1bmN0aW9uKGl0ZW1zLCBuYW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBZLkFycmF5KGFyZ3VtZW50cywgMiwgdHJ1ZSksXG4gICAgICAgIGlzRnVuY3Rpb24gPSBZLkxhbmcuaXNGdW5jdGlvbixcbiAgICAgICAgcmV0ID0gW107XG5cbiAgICBZLkFycmF5LmVhY2goWS5BcnJheShpdGVtcyksIGZ1bmN0aW9uKGl0ZW0sIGkpIHtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXNGdW5jdGlvbihpdGVtW25hbWVdKSkge1xuICAgICAgICAgICAgcmV0W2ldID0gaXRlbVtuYW1lXS5hcHBseShpdGVtLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcInl1aS1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2FycmF5bGlzdCcsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogQ29sbGVjdGlvbiB1dGlsaXRpZXMgYmV5b25kIHdoYXQgaXMgcHJvdmlkZWQgaW4gdGhlIFlVSSBjb3JlXG4gKiBAbW9kdWxlIGNvbGxlY3Rpb25cbiAqIEBzdWJtb2R1bGUgYXJyYXlsaXN0XG4gKi9cblxudmFyIFlBcnJheSAgICAgID0gWS5BcnJheSxcbiAgICBZQXJyYXlfZWFjaCA9IFlBcnJheS5lYWNoLFxuICAgIEFycmF5TGlzdFByb3RvO1xuXG4vKipcbiAqIEdlbmVyaWMgQXJyYXlMaXN0IGNsYXNzIGZvciBtYW5hZ2luZyBsaXN0cyBvZiBpdGVtcyBhbmQgaXRlcmF0aW5nIG9wZXJhdGlvbnNcbiAqIG92ZXIgdGhlbS4gIFRoZSB0YXJnZXRlZCB1c2UgZm9yIHRoaXMgY2xhc3MgaXMgZm9yIGF1Z21lbnRhdGlvbiBvbnRvIGFcbiAqIGNsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIG11bHRpcGxlIGluc3RhbmNlcyBvZiBhbm90aGVyIGNsYXNzXG4gKiAoZS5nLiBOb2RlTGlzdCBmb3IgTm9kZXMpLiAgVGhlIHJlY29tbWVuZGVkIHVzZSBpcyB0byBhdWdtZW50IHlvdXIgY2xhc3Mgd2l0aFxuICogQXJyYXlMaXN0LCB0aGVuIHVzZSBBcnJheUxpc3QuYWRkTWV0aG9kIHRvIG1pcnJvciB0aGUgQVBJIG9mIHRoZSBjb25zdGl0dWVudFxuICogaXRlbXMgb24gdGhlIGxpc3QncyBBUEkuXG4gKlxuICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gY3JlYXRlcyBpbW11dGFibGUgbGlzdHMsIGJ1dCBtdXRhYmlsaXR5IGNhbiBiZVxuICogcHJvdmlkZWQgdmlhIHRoZSBhcnJheWxpc3QtYWRkIHN1Ym1vZHVsZSBvciBieSBpbXBsZW1lbnRpbmcgbXV0YXRpb24gbWV0aG9kc1xuICogZGlyZWN0bHkgb24gdGhlIGF1Z21lbnRlZCBjbGFzcydzIHByb3RvdHlwZS5cbiAqXG4gKiBAY2xhc3MgQXJyYXlMaXN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBpdGVtcyB7IEFycmF5IH0gYXJyYXkgb2YgaXRlbXMgdGhpcyBsaXN0IHdpbGwgYmUgcmVzcG9uc2libGUgZm9yXG4gKi9cbmZ1bmN0aW9uIEFycmF5TGlzdCggaXRlbXMgKSB7XG4gICAgaWYgKCBpdGVtcyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICB0aGlzLl9pdGVtcyA9IFkuTGFuZy5pc0FycmF5KCBpdGVtcyApID8gaXRlbXMgOiBZQXJyYXkoIGl0ZW1zICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gfHw9IHRvIHN1cHBvcnQgbGF6eSBpbml0aWFsaXphdGlvbiBmcm9tIGF1Z21lbnRcbiAgICAgICAgdGhpcy5faXRlbXMgPSB0aGlzLl9pdGVtcyB8fCBbXTtcbiAgICB9XG59XG5cbkFycmF5TGlzdFByb3RvID0ge1xuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVtIGJ5IGluZGV4IGZyb20gdGhlIGxpc3QuICBPdmVycmlkZSB0aGlzIG1ldGhvZCBpZiBtYW5hZ2luZyBhXG4gICAgICogbGlzdCBvZiBvYmplY3RzIHRoYXQgaGF2ZSBhIGRpZmZlcmVudCBwdWJsaWMgcmVwcmVzZW50YXRpb24gKGUuZy4gTm9kZVxuICAgICAqIGluc3RhbmNlcyB2cyBET00gbm9kZXMpLiAgVGhlIGl0ZXJhdGlvbiBtZXRob2RzIHRoYXQgYWNjZXB0IGEgdXNlclxuICAgICAqIGZ1bmN0aW9uIHdpbGwgdXNlIHRoaXMgbWV0aG9kIGZvciBhY2Nlc3MgbGlzdCBpdGVtcyBmb3Igb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpdGVtXG4gICAgICogQHBhcmFtIGkgeyBJbnRlZ2VyIH0gaW5kZXggdG8gZmV0Y2hcbiAgICAgKiBAcmV0dXJuIHsgbWl4ZWQgfSB0aGUgaXRlbSBhdCB0aGUgcmVxdWVzdGVkIGluZGV4XG4gICAgICovXG4gICAgaXRlbTogZnVuY3Rpb24gKCBpICkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbaV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIDxwPkV4ZWN1dGUgYSBmdW5jdGlvbiBvbiBlYWNoIGl0ZW0gb2YgdGhlIGxpc3QsIG9wdGlvbmFsbHkgcHJvdmlkaW5nIGFcbiAgICAgKiBjdXN0b20gZXhlY3V0aW9uIGNvbnRleHQuICBEZWZhdWx0IGNvbnRleHQgaXMgdGhlIGl0ZW0uPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhlIGNhbGxiYWNrIHNpZ25hdHVyZSBpcyA8Y29kZT5jYWxsYmFjayggaXRlbSwgaW5kZXggKTwvY29kZT4uPC9wPlxuICAgICAqXG4gICAgICogQG1ldGhvZCBlYWNoXG4gICAgICogQHBhcmFtIGZuIHsgRnVuY3Rpb24gfSB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IHsgbWl4ZWQgfSBvcHRpb25hbCBvdmVycmlkZSAndGhpcycgaW4gdGhlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7IEFycmF5TGlzdCB9IHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZWFjaDogZnVuY3Rpb24gKCBmbiwgY29udGV4dCApIHtcbiAgICAgICAgWUFycmF5X2VhY2goIHRoaXMuX2l0ZW1zLCBmdW5jdGlvbiAoIGl0ZW0sIGkgKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtKCBpICk7XG5cbiAgICAgICAgICAgIGZuLmNhbGwoIGNvbnRleHQgfHwgaXRlbSwgaXRlbSwgaSwgdGhpcyApO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogPHA+RXhlY3V0ZSBhIGZ1bmN0aW9uIG9uIGVhY2ggaXRlbSBvZiB0aGUgbGlzdCwgb3B0aW9uYWxseSBwcm92aWRpbmcgYVxuICAgICAqIGN1c3RvbSBleGVjdXRpb24gY29udGV4dC4gIERlZmF1bHQgY29udGV4dCBpcyB0aGUgaXRlbS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGUgY2FsbGJhY2sgc2lnbmF0dXJlIGlzIDxjb2RlPmNhbGxiYWNrKCBpdGVtLCBpbmRleCApPC9jb2RlPi48L3A+XG4gICAgICpcbiAgICAgKiA8cD5Vbmxpa2UgPGNvZGU+ZWFjaDwvY29kZT4sIGlmIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWUsIHRoZVxuICAgICAqIGl0ZXJhdGlvbiB3aWxsIHN0b3AuPC9wPlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzb21lXG4gICAgICogQHBhcmFtIGZuIHsgRnVuY3Rpb24gfSB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IHsgbWl4ZWQgfSBvcHRpb25hbCBvdmVycmlkZSAndGhpcycgaW4gdGhlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7IEJvb2xlYW4gfSBUcnVlIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5lZCB0cnVlIG9uIGFuIGl0ZW1cbiAgICAgKi9cbiAgICBzb21lOiBmdW5jdGlvbiAoIGZuLCBjb250ZXh0ICkge1xuICAgICAgICByZXR1cm4gWUFycmF5LnNvbWUoIHRoaXMuX2l0ZW1zLCBmdW5jdGlvbiAoIGl0ZW0sIGkgKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtKCBpICk7XG5cbiAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKCBjb250ZXh0IHx8IGl0ZW0sIGl0ZW0sIGksIHRoaXMgKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBmaXJzdCBpbmRleCBvZiB0aGUgbmVlZGxlIGluIHRoZSBtYW5hZ2VkIGFycmF5IG9mIGl0ZW1zLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbmRleE9mXG4gICAgICogQHBhcmFtIG5lZWRsZSB7IG1peGVkIH0gVGhlIGl0ZW0gdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1cm4geyBJbnRlZ2VyIH0gQXJyYXkgaW5kZXggaWYgZm91bmQuICBPdGhlcndpc2UgLTFcbiAgICAgKi9cbiAgICBpbmRleE9mOiBmdW5jdGlvbiAoIG5lZWRsZSApIHtcbiAgICAgICAgcmV0dXJuIFlBcnJheS5pbmRleE9mKCB0aGlzLl9pdGVtcywgbmVlZGxlICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhvdyBtYW55IGl0ZW1zIGFyZSBpbiB0aGlzIGxpc3Q/XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNpemVcbiAgICAgKiBAcmV0dXJuIHsgSW50ZWdlciB9IE51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICAgICAqL1xuICAgIHNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBpbnN0YW5jZSBtYW5hZ2luZyBhbnkgaXRlbXM/XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzRW1wdHlcbiAgICAgKiBAcmV0dXJuIHsgQm9vbGVhbiB9IHRydWUgaWYgMSBvciBtb3JlIGl0ZW1zIGFyZSBiZWluZyBtYW5hZ2VkXG4gICAgICovXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBhcnJheS1saWtlIHJlcHJlc2VudGF0aW9uIGZvciBKU09OLnN0cmluZ2lmeS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9KU09OXG4gICAgICogQHJldHVybiB7IEFycmF5IH0gYW4gYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIEFycmF5TGlzdFxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxufTtcbi8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBwdWJsaWMgYW5kIHByaXZhdGVcbi8vIGl0ZW0gZ2V0dGVyXG4vKipcbiAqIFByb3RlY3RlZCBtZXRob2QgZm9yIG9wdGltaXphdGlvbnMgdGhhdCBtYXkgYmUgYXBwcm9wcmlhdGUgZm9yIEFQSVxuICogbWlycm9yaW5nLiBTaW1pbGFyIGluIGZ1bmN0aW9uYWxpdHkgdG8gPGNvZGU+aXRlbTwvY29kZT4sIGJ1dCBpcyB1c2VkIGJ5XG4gKiBtZXRob2RzIGFkZGVkIHdpdGggPGNvZGU+QXJyYXlMaXN0LmFkZE1ldGhvZCgpPC9jb2RlPi5cbiAqXG4gKiBAbWV0aG9kIF9pdGVtXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0gaSB7IEludGVnZXIgfSBJbmRleCBvZiBpdGVtIHRvIGZldGNoXG4gKiBAcmV0dXJuIHsgbWl4ZWQgfSBUaGUgaXRlbSBhcHByb3ByaWF0ZSBmb3IgcGFzcyB0aHJvdWdoIEFQSSBtZXRob2RzXG4gKi9cbkFycmF5TGlzdFByb3RvLl9pdGVtID0gQXJyYXlMaXN0UHJvdG8uaXRlbTtcblxuLy8gTWl4ZWQgb250byBleGlzdGluZyBwcm90byB0byBwcmVzZXJ2ZSBjb25zdHJ1Y3RvciBOT1QgYmVpbmcgYW4gb3duIHByb3BlcnR5LlxuLy8gVGhpcyBoYXMgYml0dGVuIG1lIHdoZW4gY29tcG9zaW5nIGNsYXNzZXMgYnkgZW51bWVyYXRpbmcsIGNvcHlpbmcgcHJvdG90eXBlcy5cblkubWl4KEFycmF5TGlzdC5wcm90b3R5cGUsIEFycmF5TGlzdFByb3RvKTtcblxuWS5taXgoIEFycmF5TGlzdCwge1xuXG4gICAgLyoqXG4gICAgICogPHA+QWRkcyBhIHBhc3MgdGhyb3VnaCBtZXRob2QgdG8gZGVzdCAodHlwaWNhbGx5IHRoZSBwcm90b3R5cGUgb2YgYSBsaXN0XG4gICAgICogY2xhc3MpIHRoYXQgY2FsbHMgdGhlIG5hbWVkIG1ldGhvZCBvbiBlYWNoIGl0ZW0gaW4gdGhlIGxpc3Qgd2l0aFxuICAgICAqIHdoYXRldmVyIHBhcmFtZXRlcnMgYXJlIHBhc3NlZCBpbi4gIEFsbG93cyBmb3IgQVBJIGluZGlyZWN0aW9uIHZpYSBsaXN0XG4gICAgICogaW5zdGFuY2VzLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPkFjY2VwdHMgYSBzaW5nbGUgc3RyaW5nIG5hbWUgb3IgYW4gYXJyYXkgb2Ygc3RyaW5nIG5hbWVzLjwvcD5cbiAgICAgKlxuICAgICAqIDxwcmU+PGNvZGU+bGlzdC5lYWNoKCBmdW5jdGlvbiAoIGl0ZW0gKSB7XG4gICAgICogICAgIGl0ZW0ubWV0aG9kTmFtZSggMSwgMiwgMyApO1xuICAgICAqIH0gKTtcbiAgICAgKiAvLyBiZWNvbWVzXG4gICAgICogbGlzdC5tZXRob2ROYW1lKCAxLCAyLCAzICk7PC9jb2RlPjwvcHJlPlxuICAgICAqXG4gICAgICogPHA+QWRkaXRpb25hbGx5LCB0aGUgcGFzcyB0aHJvdWdoIG1ldGhvZHMgdXNlIHRoZSBpdGVtIHJldHJpZXZlZCBieSB0aGVcbiAgICAgKiA8Y29kZT5faXRlbTwvY29kZT4gbWV0aG9kIGluIGNhc2UgdGhlcmUgaXMgYW55IHNwZWNpYWwgYmVoYXZpb3IgdGhhdCBpc1xuICAgICAqIGFwcHJvcHJpYXRlIGZvciBBUEkgbWlycm9yaW5nLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPklmIHRoZSBpdGVyYXRlZCBtZXRob2QgcmV0dXJucyBhIHZhbHVlLCB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlXG4gICAgICogYWRkZWQgbWV0aG9kIHdpbGwgYmUgYW4gYXJyYXkgb2YgdmFsdWVzIHdpdGggZWFjaCB2YWx1ZSBiZWluZyBhdCB0aGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIGluZGV4IGZvciB0aGF0IGl0ZW0uICBJZiB0aGUgaXRlcmF0ZWQgbWV0aG9kIGRvZXMgbm90XG4gICAgICogcmV0dXJuIGEgdmFsdWUsIHRoZSBhZGRlZCBtZXRob2Qgd2lsbCBiZSBjaGFpbmFibGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZE1ldGhvZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gZGVzdCB7T2JqZWN0fSBPYmplY3Qgb3IgcHJvdG90eXBlIHRvIHJlY2VpdmUgdGhlIGl0ZXJhdG9yIG1ldGhvZFxuICAgICAqIEBwYXJhbSBuYW1lIHtTdHJpbmd8U3RyaW5nW119IE5hbWUgb2YgbWV0aG9kIG9mIG1ldGhvZHMgdG8gY3JlYXRlXG4gICAgICovXG4gICAgYWRkTWV0aG9kOiBmdW5jdGlvbiAoIGRlc3QsIG5hbWVzICkge1xuXG4gICAgICAgIG5hbWVzID0gWUFycmF5KCBuYW1lcyApO1xuXG4gICAgICAgIFlBcnJheV9lYWNoKCBuYW1lcywgZnVuY3Rpb24gKCBuYW1lICkge1xuICAgICAgICAgICAgZGVzdFsgbmFtZSBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gWUFycmF5KCBhcmd1bWVudHMsIDAsIHRydWUgKSxcbiAgICAgICAgICAgICAgICAgICAgcmV0ICA9IFtdO1xuXG4gICAgICAgICAgICAgICAgWUFycmF5X2VhY2goIHRoaXMuX2l0ZW1zLCBmdW5jdGlvbiAoIGl0ZW0sIGkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLl9pdGVtKCBpICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZW1bIG5hbWUgXS5hcHBseSggaXRlbSwgYXJncyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBpdGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0Lmxlbmd0aCA/IHJldCA6IHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9ICk7XG4gICAgfVxufSApO1xuXG5ZLkFycmF5TGlzdCA9IEFycmF5TGlzdDtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wieXVpLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnYXN5bmMtcXVldWUnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIDxwPkFzeW5jUXVldWUgYWxsb3dzIHlvdSBjcmVhdGUgYSBjaGFpbiBvZiBmdW5jdGlvbiBjYWxsYmFja3MgZXhlY3V0ZWRcbiAqIHZpYSBzZXRUaW1lb3V0IChvciBzeW5jaHJvbm91c2x5KSB0aGF0IGFyZSBndWFyYW50ZWVkIHRvIHJ1biBpbiBvcmRlci5cbiAqIEl0ZW1zIGluIHRoZSBxdWV1ZSBjYW4gYmUgcHJvbW90ZWQgb3IgcmVtb3ZlZC4gIFN0YXJ0IG9yIHJlc3VtZSB0aGVcbiAqIGV4ZWN1dGlvbiBjaGFpbiB3aXRoIHJ1bigpLiAgcGF1c2UoKSB0byB0ZW1wb3JhcmlseSBkZWxheSBleGVjdXRpb24sIG9yXG4gKiBzdG9wKCkgdG8gaGFsdCBhbmQgY2xlYXIgdGhlIHF1ZXVlLjwvcD5cbiAqXG4gKiBAbW9kdWxlIGFzeW5jLXF1ZXVlXG4gKi9cblxuLyoqXG4gKiA8cD5BIHNwZWNpYWxpemVkIHF1ZXVlIGNsYXNzIHRoYXQgc3VwcG9ydHMgc2NoZWR1bGluZyBjYWxsYmFja3MgdG8gZXhlY3V0ZVxuICogc2VxdWVudGlhbGx5LCBpdGVyYXRpdmVseSwgZXZlbiBhc3luY2hyb25vdXNseS48L3A+XG4gKlxuICogPHA+Q2FsbGJhY2tzIGNhbiBiZSBmdW5jdGlvbiByZWZzIG9yIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIGtleXMuICBPbmx5XG4gKiB0aGUgPGNvZGU+Zm48L2NvZGU+IGtleSBpcyByZXF1aXJlZC48L3A+XG4gKlxuICogPHVsPlxuICogPGxpPjxjb2RlPmZuPC9jb2RlPiAtLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb248L2xpPlxuICogPGxpPjxjb2RlPmNvbnRleHQ8L2NvZGU+IC0tIFRoZSBleGVjdXRpb24gY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrRm4uPC9saT5cbiAqIDxsaT48Y29kZT5hcmdzPC9jb2RlPiAtLSBBcmd1bWVudHMgdG8gcGFzcyB0byBjYWxsYmFja0ZuLjwvbGk+XG4gKiA8bGk+PGNvZGU+dGltZW91dDwvY29kZT4gLS0gTWlsbGlzZWNvbmQgZGVsYXkgYmVmb3JlIGV4ZWN1dGluZyBjYWxsYmFja0ZuLlxuICogICAgICAgICAgICAgICAgICAgICAoQXBwbGllcyB0byBlYWNoIGl0ZXJhdGl2ZSBleGVjdXRpb24gb2YgY2FsbGJhY2spPC9saT5cbiAqIDxsaT48Y29kZT5pdGVyYXRpb25zPC9jb2RlPiAtLSBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBjYWxsYmFjay5cbiAqIDxsaT48Y29kZT51bnRpbDwvY29kZT4gLS0gUmVwZWF0IHRoZSBjYWxsYmFjayB1bnRpbCB0aGlzIGZ1bmN0aW9uIHJldHVybnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUuICBUaGlzIHNldHRpbmcgdHJ1bXBzIGl0ZXJhdGlvbnMuPC9saT5cbiAqIDxsaT48Y29kZT5hdXRvQ29udGludWU8L2NvZGU+IC0tIFNldCB0byBmYWxzZSB0byBwcmV2ZW50IHRoZSBBc3luY1F1ZXVlIGZyb21cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW5nIHRoZSBuZXh0IGNhbGxiYWNrIGluIHRoZSBRdWV1ZSBhZnRlclxuICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgY2FsbGJhY2sgY29tcGxldGVzLjwvbGk+XG4gKiA8bGk+PGNvZGU+aWQ8L2NvZGU+IC0tIE5hbWUgdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQsIHByb21vdGUsIGdldCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhPZiwgb3IgZGVsZXRlIHRoaXMgY2FsbGJhY2suPC9saT5cbiAqIDwvdWw+XG4gKlxuICogQGNsYXNzIEFzeW5jUXVldWVcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBjYWxsYmFjayoge0Z1bmN0aW9ufE9iamVjdH0gMC4ubiBjYWxsYmFja3MgdG8gc2VlZCB0aGUgcXVldWVcbiAqL1xuWS5Bc3luY1F1ZXVlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW5pdCgpO1xuICAgIHRoaXMuYWRkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgUXVldWUgICA9IFkuQXN5bmNRdWV1ZSxcbiAgICBFWEVDVVRFID0gJ2V4ZWN1dGUnLFxuICAgIFNISUZUICAgPSAnc2hpZnQnLFxuICAgIFBST01PVEUgPSAncHJvbW90ZScsXG4gICAgUkVNT1ZFICA9ICdyZW1vdmUnLFxuXG4gICAgaXNPYmplY3QgICA9IFkuTGFuZy5pc09iamVjdCxcbiAgICBpc0Z1bmN0aW9uID0gWS5MYW5nLmlzRnVuY3Rpb247XG5cbi8qKlxuICogPHA+U3RhdGljIGRlZmF1bHQgdmFsdWVzIHVzZWQgdG8gcG9wdWxhdGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLlxuICogUHJlY29uZmlndXJlZCBkZWZhdWx0cyBpbmNsdWRlOjwvcD5cbiAqXG4gKiA8dWw+XG4gKiAgPGxpPjxjb2RlPmF1dG9Db250aW51ZTwvY29kZT46IDxjb2RlPnRydWU8L2NvZGU+PC9saT5cbiAqICA8bGk+PGNvZGU+aXRlcmF0aW9uczwvY29kZT46IDE8L2xpPlxuICogIDxsaT48Y29kZT50aW1lb3V0PC9jb2RlPjogMTAgKDEwbXMgYmV0d2VlbiBjYWxsYmFja3MpPC9saT5cbiAqICA8bGk+PGNvZGU+dW50aWw8L2NvZGU+OiAoZnVuY3Rpb24gdG8gcnVuIHVudGlsIGl0ZXJhdGlvbnMgJmx0Oz0gMCk8L2xpPlxuICogPC91bD5cbiAqXG4gKiBAcHJvcGVydHkgZGVmYXVsdHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKi9cblF1ZXVlLmRlZmF1bHRzID0gWS5taXgoe1xuICAgIGF1dG9Db250aW51ZSA6IHRydWUsXG4gICAgaXRlcmF0aW9ucyAgIDogMSxcbiAgICB0aW1lb3V0ICAgICAgOiAxMCxcbiAgICB1bnRpbCAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9ucyB8PSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRpb25zIDw9IDA7XG4gICAgfVxufSwgWS5jb25maWcucXVldWVEZWZhdWx0cyB8fCB7fSk7XG5cblkuZXh0ZW5kKFF1ZXVlLCBZLkV2ZW50VGFyZ2V0LCB7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBpbmRpY2F0ZSB0aGUgcXVldWUgaXMgY3VycmVudGx5IGV4ZWN1dGluZyBhIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9ydW5uaW5nXG4gICAgICogQHR5cGUge0Jvb2xlYW58T2JqZWN0fSB0cnVlIGZvciBzeW5jaHJvbm91cyBjYWxsYmFjayBleGVjdXRpb24sIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZSBmcm9tIFkubGF0ZXIgZm9yIGFzeW5jIGNhbGxiYWNrcy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyd2lzZSBmYWxzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3J1bm5pbmcgOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBBc3luY1F1ZXVlIGluc3RhbmNlIHByb3BlcnRpZXMgYW5kIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2luaXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFkuRXZlbnRUYXJnZXQuY2FsbCh0aGlzLCB7IHByZWZpeDogJ3F1ZXVlJywgZW1pdEZhY2FkZTogdHJ1ZSB9KTtcblxuICAgICAgICB0aGlzLl9xID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIGRlZmF1bHRzIGZvciB0aGlzIGluc3RhbmNlLiAgU3RhdGljIGRlZmF1bHRzIHRoYXQgYXJlIG5vdFxuICAgICAgICAgKiBvdmVycmlkZGVuIGFyZSBhbHNvIGluY2x1ZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgZGVmYXVsdHNcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7fTtcblxuICAgICAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBpbnN0YW5jZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9pbml0RXZlbnRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0RXZlbnRzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgJ2V4ZWN1dGUnIDogeyBkZWZhdWx0Rm4gOiB0aGlzLl9kZWZFeGVjRm4sICAgIGVtaXRGYWNhZGU6IHRydWUgfSxcbiAgICAgICAgICAgICdzaGlmdCcgICA6IHsgZGVmYXVsdEZuIDogdGhpcy5fZGVmU2hpZnRGbiwgICBlbWl0RmFjYWRlOiB0cnVlIH0sXG4gICAgICAgICAgICAnYWRkJyAgICAgOiB7IGRlZmF1bHRGbiA6IHRoaXMuX2RlZkFkZEZuLCAgICAgZW1pdEZhY2FkZTogdHJ1ZSB9LFxuICAgICAgICAgICAgJ3Byb21vdGUnIDogeyBkZWZhdWx0Rm4gOiB0aGlzLl9kZWZQcm9tb3RlRm4sIGVtaXRGYWNhZGU6IHRydWUgfSxcbiAgICAgICAgICAgICdyZW1vdmUnICA6IHsgZGVmYXVsdEZuIDogdGhpcy5fZGVmUmVtb3ZlRm4sICBlbWl0RmFjYWRlOiB0cnVlIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5leHQgY2FsbGJhY2sgbmVlZGluZyBleGVjdXRpb24uICBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogY29uZmlndXJlZCB0byByZXBlYXQgdmlhIGl0ZXJhdGlvbnMgb3IgdW50aWwsIGl0IHdpbGwgYmUgcmV0dXJuZWQgdW50aWxcbiAgICAgKiB0aGUgY29tcGxldGlvbiBjcml0ZXJpYSBpcyBtZXQuXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBxdWV1ZSBpcyBlbXB0eSwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbmV4dFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZVxuICAgICAqL1xuICAgIG5leHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjaztcblxuICAgICAgICB3aGlsZSAodGhpcy5fcS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGhpcy5fcVswXSA9IHRoaXMuX3ByZXBhcmUodGhpcy5fcVswXSk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2sudW50aWwoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZShTSElGVCwgeyBjYWxsYmFjazogY2FsbGJhY2sgfSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSAmcXVvdDtzaGlmdCZxdW90OyBldmVudC4gIFNoaWZ0cyB0aGVcbiAgICAgKiBjYWxsYmFjayBzdG9yZWQgaW4gdGhlIGV2ZW50IG9iamVjdCdzIDxlbT5jYWxsYmFjazwvZW0+IHByb3BlcnR5IGZyb21cbiAgICAgKiB0aGUgcXVldWUgaWYgaXQgaXMgdGhlIGZpcnN0IGl0ZW0uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kZWZTaGlmdEZuXG4gICAgICogQHBhcmFtIGUge0V2ZW50fSBUaGUgZXZlbnQgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9kZWZTaGlmdEZuIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhPZihlLmNhbGxiYWNrKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrIHVzaW5nIHRoZSBhZ2dyZWdhdGVkXG4gICAgICogY29uZmlndXJhdGlvbiBnZW5lcmF0ZWQgYnkgY29tYmluaW5nIHRoZSBzdGF0aWMgQXN5bmNRdWV1ZS5kZWZhdWx0cywgdGhlXG4gICAgICogaW5zdGFuY2UgZGVmYXVsdHMsIGFuZCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgZnVuY3Rpb24gaXMgZGVjb3JhdGVkIHdpdGggdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24gYXNcbiAgICAgKiBwcm9wZXJ0aWVzIGZvciBydW50aW1lIG1vZGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3ByZXBhcmVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sge09iamVjdHxGdW5jdGlvbn0gdGhlIHJhdyBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGRlY29yYXRlZCBmdW5jdGlvbiB3cmFwcGVyIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9wcmVwYXJlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spICYmIGNhbGxiYWNrLl9wcmVwYXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbmZpZyA9IFkubWVyZ2UoXG4gICAgICAgICAgICBRdWV1ZS5kZWZhdWx0cyxcbiAgICAgICAgICAgIHsgY29udGV4dCA6IHRoaXMsIGFyZ3M6IFtdLCBfcHJlcGFyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMsXG4gICAgICAgICAgICAoaXNGdW5jdGlvbihjYWxsYmFjaykgPyB7IGZuOiBjYWxsYmFjayB9IDogY2FsbGJhY2spKSxcblxuICAgICAgICAgICAgd3JhcHBlciA9IFkuYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3cmFwcGVyLl9ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuaXRlcmF0aW9ucy0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih3cmFwcGVyLmZuKSkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmZuLmFwcGx5KHdyYXBwZXIuY29udGV4dCB8fCBZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFkuQXJyYXkod3JhcHBlci5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIFkubWl4KHdyYXBwZXIsIGNvbmZpZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHF1ZXVlIGluIG1vdGlvbi4gIEFsbCBxdWV1ZWQgY2FsbGJhY2tzIHdpbGwgYmUgZXhlY3V0ZWQgaW5cbiAgICAgKiBvcmRlciB1bmxlc3MgcGF1c2UoKSBvciBzdG9wKCkgaXMgY2FsbGVkIG9yIGlmIG9uZSBvZiB0aGUgY2FsbGJhY2tzIGlzXG4gICAgICogY29uZmlndXJlZCB3aXRoIGF1dG9Db250aW51ZTogZmFsc2UuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJ1blxuICAgICAqIEByZXR1cm4ge0FzeW5jUXVldWV9IHRoZSBBc3luY1F1ZXVlIGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJ1biA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrLFxuICAgICAgICAgICAgY29udCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4ZWN1dGluZykge1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY2FsbGJhY2sgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmICF0aGlzLmlzUnVubmluZygpO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0aGlzLm5leHQoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udCA9IChjYWxsYmFjay50aW1lb3V0IDwgMCkgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGUoY2FsbGJhY2spIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIC8vIEJyZWFrIHRvIGF2b2lkIGFuIGV4dHJhIGNhbGwgdG8gbmV4dCAoZmluYWwtZXhwcmVzc2lvbiBvZiB0aGVcbiAgICAgICAgICAgIC8vICdmb3InIGxvb3ApLCBiZWNhdXNlIHRoZSB1bnRpbCBmdW5jdGlvbiBvZiB0aGUgbmV4dCBjYWxsYmFja1xuICAgICAgICAgICAgLy8gaW4gdGhlIHF1ZXVlIG1heSByZXR1cm4gYSB3cm9uZyByZXN1bHQgaWYgaXQgZGVwZW5kcyBvbiB0aGVcbiAgICAgICAgICAgIC8vIG5vdC15ZXQtZmluaXNoZWQgd29yayBvZiB0aGUgcHJldmlvdXMgY2FsbGJhY2suXG4gICAgICAgICAgICBpZiAoIWNvbnQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGVyZSBpcyBubyByZW1haW5pbmcgY2FsbGJhY2sgaW4gdGhlIHJ1bm5pbmcgcXVldWUuIEFsc28gZmlyZWQgYWZ0ZXIgc3RvcCgpLlxuICAgICAgICAgICAgICogQGV2ZW50IGNvbXBsZXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnY29tcGxldGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBleGVjdXRpb24gb2YgY2FsbGJhY2tzLiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nXG4gICAgICogd2hldGhlciBpdCBpcyBhcHByb3ByaWF0ZSB0byBjb250aW51ZSBydW5uaW5nLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZXhlY3V0ZVxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB7T2JqZWN0fSB0aGUgY2FsbGJhY2sgb2JqZWN0IHRvIGV4ZWN1dGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoZSBydW4gbG9vcCBzaG91bGQgY29udGludWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2V4ZWN1dGUgOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuICAgICAgICB0aGlzLl9ydW5uaW5nICAgPSBjYWxsYmFjay5fcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2V4ZWN1dGluZyA9IGNhbGxiYWNrO1xuXG4gICAgICAgIGNhbGxiYWNrLml0ZXJhdGlvbnMtLTtcbiAgICAgICAgdGhpcy5maXJlKEVYRUNVVEUsIHsgY2FsbGJhY2s6IGNhbGxiYWNrIH0pO1xuXG4gICAgICAgIHZhciBjb250ID0gdGhpcy5fcnVubmluZyAmJiBjYWxsYmFjay5hdXRvQ29udGludWU7XG5cbiAgICAgICAgdGhpcy5fcnVubmluZyAgID0gY2FsbGJhY2suX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXhlY3V0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIGNvbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyB0aGUgZXhlY3V0aW9uIG9mIGFzeW5jaHJvbm91cyBjYWxsYmFja3MuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zY2hlZHVsZVxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB7T2JqZWN0fSB0aGUgY2FsbGJhY2sgb2JqZWN0IHRvIGV4ZWN1dGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoZSBydW4gbG9vcCBzaG91bGQgY29udGludWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3NjaGVkdWxlIDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBZLmxhdGVyKGNhbGxiYWNrLnRpbWVvdXQsIHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9leGVjdXRlKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgcXVldWUgaXMgd2FpdGluZyBmb3IgYSBjYWxsYmFjayB0byBjb21wbGV0ZSBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzUnVubmluZ1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcXVldWUgaXMgd2FpdGluZyBmb3IgYVxuICAgICAqICAgICAgICAgICAgICAgICAgIGZyb20gYW55IGluaXRpYXRlZCB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICBpc1J1bm5pbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3J1bm5pbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZnVuY3Rpb25hbGl0eSBmb3IgdGhlICZxdW90O2V4ZWN1dGUmcXVvdDsgZXZlbnQuICBFeGVjdXRlcyB0aGVcbiAgICAgKiBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZGVmRXhlY0ZuXG4gICAgICogQHBhcmFtIGUge0V2ZW50fSB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9kZWZFeGVjRm4gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmNhbGxiYWNrKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbnkgbnVtYmVyIG9mIGNhbGxiYWNrcyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gQ2FsbGJhY2tzIG1heSBiZVxuICAgICAqIHByb3ZpZGVkIGFzIGZ1bmN0aW9ucyBvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sqIHtGdW5jdGlvbnxPYmplY3R9IDAuLm4gY2FsbGJhY2tzXG4gICAgICogQHJldHVybiB7QXN5bmNRdWV1ZX0gdGhlIEFzeW5jUXVldWUgaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYWRkIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2FkZCcsIHsgY2FsbGJhY2tzOiBZLkFycmF5KGFyZ3VtZW50cywwLHRydWUpIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSAmcXVvdDthZGQmcXVvdDsgZXZlbnQuICBBZGRzIHRoZSBjYWxsYmFja3NcbiAgICAgKiBpbiB0aGUgZXZlbnQgZmFjYWRlIHRvIHRoZSBxdWV1ZS4gQ2FsbGJhY2tzIHN1Y2Nlc3NmdWxseSBhZGRlZCB0byB0aGVcbiAgICAgKiBxdWV1ZSBhcmUgcHJlc2VudCBpbiB0aGUgZXZlbnQncyA8Y29kZT5hZGRlZDwvY29kZT4gcHJvcGVydHkgaW4gdGhlXG4gICAgICogYWZ0ZXIgcGhhc2UuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kZWZBZGRGblxuICAgICAqIEBwYXJhbSBlIHtFdmVudH0gdGhlIGV2ZW50IG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZGVmQWRkRm4gOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBfcSA9IHRoaXMuX3EsXG4gICAgICAgICAgICBhZGRlZCA9IFtdO1xuXG4gICAgICAgIFkuQXJyYXkuZWFjaChlLmNhbGxiYWNrcywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChjKSkge1xuICAgICAgICAgICAgICAgIF9xLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZS5hZGRlZCA9IGFkZGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgZXhlY3V0aW9uIG9mIHRoZSBxdWV1ZSBhZnRlciB0aGUgZXhlY3V0aW9uIG9mIHRoZSBjdXJyZW50XG4gICAgICogY2FsbGJhY2sgY29tcGxldGVzLiAgSWYgY2FsbGVkIGZyb20gY29kZSBvdXRzaWRlIG9mIGEgcXVldWVkIGNhbGxiYWNrLFxuICAgICAqIGNsZWFycyB0aGUgdGltZW91dCBmb3IgdGhlIHBlbmRpbmcgY2FsbGJhY2suIFBhdXNlZCBxdWV1ZSBjYW4gYmVcbiAgICAgKiByZXN0YXJ0ZWQgd2l0aCBxLnJ1bigpXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHBhdXNlXG4gICAgICogQHJldHVybiB7QXN5bmNRdWV1ZX0gdGhlIEFzeW5jUXVldWUgaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmcgJiYgaXNPYmplY3QodGhpcy5fcnVubmluZykpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcuY2FuY2VsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgYW5kIGNsZWFyIHRoZSBxdWV1ZSBhZnRlciB0aGUgY3VycmVudCBleGVjdXRpb24gb2YgdGhlXG4gICAgICogY3VycmVudCBjYWxsYmFjayBjb21wbGV0ZXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHN0b3BcbiAgICAgKiBAcmV0dXJuIHtBc3luY1F1ZXVlfSB0aGUgQXN5bmNRdWV1ZSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzdG9wIDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMuX3EgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5fcnVubmluZyAmJiBpc09iamVjdCh0aGlzLl9ydW5uaW5nKSkge1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZy5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgZG9uJ3Qgc3lzdGVtYXRpY2FsbHkgc2V0IHRoaXMuX3J1bm5pbmcgdG8gZmFsc2UsIGJlY2F1c2UgaWZcbiAgICAgICAgLy8gc3RvcCBoYXMgYmVlbiBjYWxsZWQgZnJvbSBpbnNpZGUgYSBxdWV1ZWQgY2FsbGJhY2ssIHRoZSBfZXhlY3V0ZSBtZXRob2RcbiAgICAgICAgLy8gY3VycmVudHkgcnVubmluZyBuZWVkcyB0byBjYWxsIHJ1bigpIG9uZSBtb3JlIHRpbWUgZm9yIHRoZSAnY29tcGxldGUnXG4gICAgICAgIC8vIGV2ZW50IHRvIGJlIGZpcmVkLlxuXG4gICAgICAgIC8vIGlmIHN0b3AgaXMgY2FsbGVkIGZyb20gb3V0c2lkZSBhIGNhbGxiYWNrLCB3ZSBuZWVkIHRvIGV4cGxpY2l0ZWx5IGNhbGxcbiAgICAgICAgLy8gcnVuKCkgb25jZSBhZ2FpbiB0byBmaXJlIHRoZSAnY29tcGxldGUnIGV2ZW50LlxuICAgICAgICBpZiAoIXRoaXMuX2V4ZWN1dGluZykge1xuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGluZGV4IG9mIGEgY2FsbGJhY2suICBQYXNzIGluIGVpdGhlciB0aGUgaWQgb3JcbiAgICAgKiBjYWxsYmFjayBmdW5jdGlvbiBmcm9tIGdldENhbGxiYWNrLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbmRleE9mXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHtTdHJpbmd8RnVuY3Rpb259IHRoZSBjYWxsYmFjayBvciBpdHMgc3BlY2lmaWVkIGlkXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBpbmRleCBvZiB0aGUgY2FsbGJhY2sgb3IgLTEgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgaW5kZXhPZiA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3EubGVuZ3RoLCBjO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGMgPSB0aGlzLl9xW2ldO1xuICAgICAgICAgICAgaWYgKGMgPT09IGNhbGxiYWNrIHx8IGMuaWQgPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgY2FsbGJhY2sgYnkgaXRzIGlkLiAgVXNlZnVsIHRvIG1vZGlmeSB0aGUgY29uZmlndXJhdGlvblxuICAgICAqIHdoaWxlIHRoZSBxdWV1ZSBpcyBydW5uaW5nLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDYWxsYmFja1xuICAgICAqIEBwYXJhbSBpZCB7U3RyaW5nfSB0aGUgaWQgYXNzaWduZWQgdG8gdGhlIGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgY2FsbGJhY2sgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0Q2FsbGJhY2sgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4T2YoaWQpO1xuXG4gICAgICAgIHJldHVybiAoaSA+IC0xKSA/IHRoaXMuX3FbaV0gOiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9tb3RlcyB0aGUgbmFtZWQgY2FsbGJhY2sgdG8gdGhlIHRvcCBvZiB0aGUgcXVldWUuIElmIGEgY2FsbGJhY2sgaXNcbiAgICAgKiBjdXJyZW50bHkgZXhlY3V0aW5nIG9yIGxvb3BpbmcgKHZpYSB1bnRpbCBvciBpdGVyYXRpb25zKSwgdGhlIHByb21vdGlvblxuICAgICAqIGlzIHNjaGVkdWxlZCB0byBvY2N1ciBhZnRlciB0aGUgY3VycmVudCBjYWxsYmFjayBoYXMgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBwcm9tb3RlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHtTdHJpbmd8T2JqZWN0fSB0aGUgY2FsbGJhY2sgb2JqZWN0IG9yIGEgY2FsbGJhY2sncyBpZFxuICAgICAqIEByZXR1cm4ge0FzeW5jUXVldWV9IHRoZSBBc3luY1F1ZXVlIGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHByb21vdGUgOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB7IGNhbGxiYWNrIDogY2FsbGJhY2sgfSxlO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICBlID0gdGhpcy5hZnRlcihTSElGVCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoUFJPTU9URSwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIGUuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoUFJPTU9URSwgcGF5bG9hZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogPHA+RGVmYXVsdCBmdW5jdGlvbmFsaXR5IGZvciB0aGUgJnF1b3Q7cHJvbW90ZSZxdW90OyBldmVudC4gIFByb21vdGVzIHRoZVxuICAgICAqIG5hbWVkIGNhbGxiYWNrIHRvIHRoZSBoZWFkIG9mIHRoZSBxdWV1ZS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGUgZXZlbnQgb2JqZWN0IHdpbGwgY29udGFpbiBhIHByb3BlcnR5ICZxdW90O2NhbGxiYWNrJnF1b3Q7LCB3aGljaFxuICAgICAqIGhvbGRzIHRoZSBpZCBvZiBhIGNhbGxiYWNrIG9yIHRoZSBjYWxsYmFjayBvYmplY3QgaXRzZWxmLjwvcD5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2RlZlByb21vdGVGblxuICAgICAqIEBwYXJhbSBlIHtFdmVudH0gdGhlIGN1c3RvbSBldmVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZGVmUHJvbW90ZUZuIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4T2YoZS5jYWxsYmFjayksXG4gICAgICAgICAgICBwcm9tb3RlZCA9IChpID4gLTEpID8gdGhpcy5fcS5zcGxpY2UoaSwxKVswXSA6IG51bGw7XG5cbiAgICAgICAgZS5wcm9tb3RlZCA9IHByb21vdGVkO1xuXG4gICAgICAgIGlmIChwcm9tb3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fcS51bnNoaWZ0KHByb21vdGVkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjYWxsYmFjayBmcm9tIHRoZSBxdWV1ZS4gIElmIHRoZSBxdWV1ZSBpcyBhY3RpdmUsIHRoZVxuICAgICAqIHJlbW92YWwgaXMgc2NoZWR1bGVkIHRvIG9jY3VyIGFmdGVyIHRoZSBjdXJyZW50IGNhbGxiYWNrIGhhcyBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB7U3RyaW5nfE9iamVjdH0gdGhlIGNhbGxiYWNrIG9iamVjdCBvciBhIGNhbGxiYWNrJ3MgaWRcbiAgICAgKiBAcmV0dXJuIHtBc3luY1F1ZXVlfSB0aGUgQXN5bmNRdWV1ZSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW1vdmUgOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB7IGNhbGxiYWNrIDogY2FsbGJhY2sgfSxlO1xuXG4gICAgICAgIC8vIENhbid0IHJldHVybiB0aGUgcmVtb3ZlZCBjYWxsYmFjayBiZWNhdXNlIG9mIHRoZSBkZWZlcnJhbCB1bnRpbFxuICAgICAgICAvLyBjdXJyZW50IGNhbGxiYWNrIGlzIGNvbXBsZXRlXG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICBlID0gdGhpcy5hZnRlcihTSElGVCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoUkVNT1ZFLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgZS5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9LHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maXJlKFJFTU9WRSwgcGF5bG9hZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogPHA+RGVmYXVsdCBmdW5jdGlvbmFsaXR5IGZvciB0aGUgJnF1b3Q7cmVtb3ZlJnF1b3Q7IGV2ZW50LiAgUmVtb3ZlcyB0aGVcbiAgICAgKiBjYWxsYmFjayBmcm9tIHRoZSBxdWV1ZS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGUgZXZlbnQgb2JqZWN0IHdpbGwgY29udGFpbiBhIHByb3BlcnR5ICZxdW90O2NhbGxiYWNrJnF1b3Q7LCB3aGljaFxuICAgICAqIGhvbGRzIHRoZSBpZCBvZiBhIGNhbGxiYWNrIG9yIHRoZSBjYWxsYmFjayBvYmplY3QgaXRzZWxmLjwvcD5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2RlZlJlbW92ZUZuXG4gICAgICogQHBhcmFtIGUge0V2ZW50fSB0aGUgY3VzdG9tIGV2ZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9kZWZSZW1vdmVGbiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleE9mKGUuY2FsbGJhY2spO1xuXG4gICAgICAgIGUucmVtb3ZlZCA9IChpID4gLTEpID8gdGhpcy5fcS5zcGxpY2UoaSwxKVswXSA6IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjYWxsYmFja3MgaW4gdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzaXplXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHNpemUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5leHQoKSBmbHVzaGVzIGNhbGxiYWNrcyB0aGF0IGhhdmUgbWV0IHRoZWlyIHVudGlsKCkgY3JpdGVyaWEgYW5kXG4gICAgICAgIC8vIHRoZXJlZm9yZSBzaG91bGRuJ3QgY291bnQgc2luY2UgdGhleSB3b3VsZG4ndCBleGVjdXRlIGFueXdheS5cbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9xLmxlbmd0aDtcbiAgICB9XG59KTtcblxuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJldmVudC1jdXN0b21cIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnYXR0cmlidXRlLWJhc2UnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF0dHJpYnV0ZSBtb2R1bGUgcHJvdmlkZXMgYW4gYXVnbWVudGFibGUgQXR0cmlidXRlIGltcGxlbWVudGF0aW9uLCB3aGljaFxuICAgICAqIGFkZHMgY29uZmlndXJhYmxlIGF0dHJpYnV0ZXMgYW5kIGF0dHJpYnV0ZSBjaGFuZ2UgZXZlbnRzIHRvIHRoZSBjbGFzcyBiZWluZ1xuICAgICAqIGF1Z21lbnRlZC4gSXQgYWxzbyBwcm92aWRlcyBhIFN0YXRlIGNsYXNzLCB3aGljaCBpcyB1c2VkIGludGVybmFsbHkgYnkgQXR0cmlidXRlLFxuICAgICAqIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIGluZGVwZW5kZW50bHkgdG8gcHJvdmlkZSBhIG5hbWUvcHJvcGVydHkvdmFsdWUgZGF0YSBzdHJ1Y3R1cmUgdG9cbiAgICAgKiBzdG9yZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgYXR0cmlidXRlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXR0cmlidXRlLWJhc2Ugc3VibW9kdWxlIHByb3ZpZGVzIGNvcmUgYXR0cmlidXRlIGhhbmRsaW5nIHN1cHBvcnQsIHdpdGggZXZlcnl0aGluZ1xuICAgICAqIGFzaWRlIGZyb20gY29tcGxleCBhdHRyaWJ1dGUgaGFuZGxpbmcgaW4gdGhlIHByb3ZpZGVyJ3MgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIGF0dHJpYnV0ZVxuICAgICAqIEBzdWJtb2R1bGUgYXR0cmlidXRlLWJhc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIDxwPlxuICAgICAqIEF0dHJpYnV0ZSBwcm92aWRlcyBjb25maWd1cmFibGUgYXR0cmlidXRlIHN1cHBvcnQgYWxvbmcgd2l0aCBhdHRyaWJ1dGUgY2hhbmdlIGV2ZW50cy4gSXQgaXMgZGVzaWduZWQgdG8gYmVcbiAgICAgKiBhdWdtZW50ZWQgb24gdG8gYSBob3N0IGNsYXNzLCBhbmQgcHJvdmlkZXMgdGhlIGhvc3Qgd2l0aCB0aGUgYWJpbGl0eSB0byBjb25maWd1cmUgYXR0cmlidXRlcyB0byBzdG9yZSBhbmQgcmV0cmlldmUgc3RhdGUsXG4gICAgICogYWxvbmcgd2l0aCBhdHRyaWJ1dGUgY2hhbmdlIGV2ZW50cy5cbiAgICAgKiA8L3A+XG4gICAgICogPHA+Rm9yIGV4YW1wbGUsIGF0dHJpYnV0ZXMgYWRkZWQgdG8gdGhlIGhvc3QgY2FuIGJlIGNvbmZpZ3VyZWQ6PC9wPlxuICAgICAqIDx1bD5cbiAgICAgKiAgICAgPGxpPkFzIHJlYWQgb25seS48L2xpPlxuICAgICAqICAgICA8bGk+QXMgd3JpdGUgb25jZS48L2xpPlxuICAgICAqICAgICA8bGk+V2l0aCBhIHNldHRlciBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZVxuICAgICAqICAgICB2YWx1ZXMgcGFzc2VkIHRvIEF0dHJpYnV0ZSdzIDxhIGhyZWY9XCIjbWV0aG9kX3NldFwiPnNldDwvYT4gbWV0aG9kLCBiZWZvcmUgdGhleSBhcmUgc3RvcmVkLjwvbGk+XG4gICAgICogICAgIDxsaT5XaXRoIGEgZ2V0dGVyIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCB0byBtYW5pcHVsYXRlIHN0b3JlZCB2YWx1ZXMsXG4gICAgICogICAgIGJlZm9yZSB0aGV5IGFyZSByZXR1cm5lZCBieSBBdHRyaWJ1dGUncyA8YSBocmVmPVwiI21ldGhvZF9nZXRcIj5nZXQ8L2E+IG1ldGhvZC48L2xpPlxuICAgICAqICAgICA8bGk+V2l0aCBhIHZhbGlkYXRvciBmdW5jdGlvbiwgdG8gdmFsaWRhdGUgdmFsdWVzIGJlZm9yZSB0aGV5IGFyZSBzdG9yZWQuPC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqXG4gICAgICogPHA+U2VlIHRoZSA8YSBocmVmPVwiI21ldGhvZF9hZGRBdHRyXCI+YWRkQXR0cjwvYT4gbWV0aG9kLCBmb3IgdGhlIGNvbXBsZXRlIHNldCBvZiBjb25maWd1cmF0aW9uXG4gICAgICogb3B0aW9ucyBhdmFpbGFibGUgZm9yIGF0dHJpYnV0ZXMuPC9wPlxuICAgICAqXG4gICAgICogPHA+PHN0cm9uZz5OT1RFOjwvc3Ryb25nPiBNb3N0IGltcGxlbWVudGF0aW9ucyB3aWxsIGJlIGJldHRlciBvZmYgZXh0ZW5kaW5nIHRoZSA8YSBocmVmPVwiQmFzZS5odG1sXCI+QmFzZTwvYT4gY2xhc3MsXG4gICAgICogaW5zdGVhZCBvZiBhdWdtZW50aW5nIEF0dHJpYnV0ZSBkaXJlY3RseS4gQmFzZSBhdWdtZW50cyBBdHRyaWJ1dGUgYW5kIHdpbGwgaGFuZGxlIHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBvZiBhdHRyaWJ1dGVzIGZvciBkZXJpdmVkIGNsYXNzZXMsIGFjY291bnRpbmcgZm9yIHZhbHVlcyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3IuPC9wPlxuICAgICAqXG4gICAgICogQGNsYXNzIEF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSBhdHRycyB7T2JqZWN0fSBUaGUgYXR0cmlidXRlcyB0byBhZGQgZHVyaW5nIGNvbnN0cnVjdGlvbiAocGFzc2VkIHRocm91Z2ggdG8gPGEgaHJlZj1cIiNtZXRob2RfYWRkQXR0cnNcIj5hZGRBdHRyczwvYT4pLlxuICAgICAqICAgICAgICBUaGVzZSBjYW4gYWxzbyBiZSBkZWZpbmVkIG9uIHRoZSBjb25zdHJ1Y3RvciBiZWluZyBhdWdtZW50ZWQgd2l0aCBBdHRyaWJ1dGUgYnkgZGVmaW5pbmcgdGhlIEFUVFJTIHByb3BlcnR5IG9uIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIHtPYmplY3R9IFRoZSBpbml0aWFsIGF0dHJpYnV0ZSB2YWx1ZXMgdG8gYXBwbHkgKHBhc3NlZCB0aHJvdWdoIHRvIDxhIGhyZWY9XCIjbWV0aG9kX2FkZEF0dHJzXCI+YWRkQXR0cnM8L2E+KS5cbiAgICAgKiAgICAgICAgVGhlc2UgYXJlIG5vdCBtZXJnZWQvY2xvbmVkLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBpc29sYXRpbmcgdXNlciBwcm92aWRlZCB2YWx1ZXMgaWYgcmVxdWlyZWQuXG4gICAgICogQHBhcmFtIGxhenkge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRvIGFkZCBhdHRyaWJ1dGVzIGxhemlseSAocGFzc2VkIHRocm91Z2ggdG8gPGEgaHJlZj1cIiNtZXRob2RfYWRkQXR0cnNcIj5hZGRBdHRyczwvYT4pLlxuICAgICAqIEB1c2VzIEF0dHJpYnV0ZUNvcmVcbiAgICAgKiBAdXNlcyBBdHRyaWJ1dGVPYnNlcnZhYmxlXG4gICAgICogQHVzZXMgRXZlbnRUYXJnZXRcbiAgICAgKiBAdXNlcyBBdHRyaWJ1dGVFeHRyYXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGUoKSB7XG4gICAgICAgIFkuQXR0cmlidXRlQ29yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBZLkF0dHJpYnV0ZU9ic2VydmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgWS5BdHRyaWJ1dGVFeHRyYXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBZLm1peChBdHRyaWJ1dGUsIFkuQXR0cmlidXRlQ29yZSwgZmFsc2UsIG51bGwsIDEpO1xuICAgIFkubWl4KEF0dHJpYnV0ZSwgWS5BdHRyaWJ1dGVFeHRyYXMsIGZhbHNlLCBudWxsLCAxKTtcblxuICAgIC8vIE5lZWRzIHRvIGJlIGB0cnVlYCwgdG8gb3ZlcndyaXRlIG1ldGhvZHMgZnJvbSBBdHRyaWJ1dGVDb3JlXG4gICAgWS5taXgoQXR0cmlidXRlLCBZLkF0dHJpYnV0ZU9ic2VydmFibGUsIHRydWUsIG51bGwsIDEpO1xuXG4gICAgLyoqXG4gICAgICogPHA+VGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIGFuIGF0dHJpYnV0ZSBzZXR0ZXIgaW4gb3JkZXIgdG8gcHJldmVudCB0aGUgc2V0IGZyb20gZ29pbmcgdGhyb3VnaC48L3A+XG4gICAgICpcbiAgICAgKiA8cD5Zb3UgY2FuIHJldHVybiB0aGlzIHZhbHVlIGZyb20geW91ciBzZXR0ZXIgaWYgeW91IHdpc2ggdG8gY29tYmluZSB2YWxpZGF0b3IgYW5kIHNldHRlclxuICAgICAqIGZ1bmN0aW9uYWxpdHkgaW50byBhIHNpbmdsZSBzZXR0ZXIgZnVuY3Rpb24sIHdoaWNoIGVpdGhlciByZXR1cm5zIHRoZSBtYXNzYWdlZCB2YWx1ZSB0byBiZSBzdG9yZWQgb3JcbiAgICAgKiBBdHRyaWJ1dGVDb3JlLklOVkFMSURfVkFMVUUgdG8gcHJldmVudCBpbnZhbGlkIHZhbHVlcyBmcm9tIGJlaW5nIHN0b3JlZC48L3A+XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgSU5WQUxJRF9WQUxVRVxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGUuSU5WQUxJRF9WQUxVRSA9IFkuQXR0cmlidXRlQ29yZS5JTlZBTElEX1ZBTFVFO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgcHJvcGVydGllcyB3aGljaCBjYW4gYmUgY29uZmlndXJlZCBmb3JcbiAgICAgKiBlYWNoIGF0dHJpYnV0ZSAoZS5nLiBzZXR0ZXIsIGdldHRlciwgd3JpdGVPbmNlIGV0Yy4pLlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGludGVybmFsbHkgYXMgYSB3aGl0ZWxpc3QgZm9yIGZhc3RlclxuICAgICAqIFkubWl4IG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX0FUVFJfQ0ZHXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIEF0dHJpYnV0ZS5fQVRUUl9DRkcgPSBZLkF0dHJpYnV0ZUNvcmUuX0FUVFJfQ0ZHLmNvbmNhdChZLkF0dHJpYnV0ZU9ic2VydmFibGUuX0FUVFJfQ0ZHKTtcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kIHRvIHByb3RlY3QgYW4gYXR0cmlidXRlIGNvbmZpZ3VyYXRpb24gaGFzaCwgYnkgbWVyZ2luZyB0aGVcbiAgICAgKiBlbnRpcmUgb2JqZWN0IGFuZCB0aGUgaW5kaXZpZHVhbCBhdHRyIGNvbmZpZyBvYmplY3RzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBwcm90ZWN0QXR0cnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIEEgaGFzaCBvZiBhdHRyaWJ1dGUgdG8gY29uZmlndXJhdGlvbiBvYmplY3QgcGFpcnMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHByb3RlY3RlZCB2ZXJzaW9uIG9mIHRoZSBgYXR0cnNgIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIEF0dHJpYnV0ZS5wcm90ZWN0QXR0cnMgPSBZLkF0dHJpYnV0ZUNvcmUucHJvdGVjdEF0dHJzO1xuXG4gICAgWS5BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImF0dHJpYnV0ZS1jb3JlXCIsIFwiYXR0cmlidXRlLW9ic2VydmFibGVcIiwgXCJhdHRyaWJ1dGUtZXh0cmFzXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2F0dHJpYnV0ZS1jb21wbGV4JywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgc3VwcG9ydCBmb3IgYXR0cmlidXRlIHByb3ZpZGVycyB0byBoYW5kbGUgY29tcGxleCBhdHRyaWJ1dGVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQG1vZHVsZSBhdHRyaWJ1dGVcbiAgICAgKiBAc3VibW9kdWxlIGF0dHJpYnV0ZS1jb21wbGV4XG4gICAgICogQGZvciBBdHRyaWJ1dGVcbiAgICAgKiBAZGVwcmVjYXRlZCBBdHRyaWJ1dGVDb21wbGV4J3Mgb3ZlcnJpZGVzIGFyZSBub3cgcGFydCBvZiBBdHRyaWJ1dGVDb3JlLlxuICAgICAqL1xuXG4gICAgdmFyIEF0dHJpYnV0ZSA9IFkuQXR0cmlidXRlO1xuXG4gICAgQXR0cmlidXRlLkNvbXBsZXggPSBmdW5jdGlvbigpIHt9O1xuICAgIEF0dHJpYnV0ZS5Db21wbGV4LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXRpbGl0eSBtZXRob2QgdG8gc3BsaXQgb3V0IHNpbXBsZSBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyAoXCJ4XCIpXG4gICAgICAgICAqIGZyb20gY29tcGxleCBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyAoXCJ4LnkuelwiKSwgc28gdGhhdCBjb21wbGV4XG4gICAgICAgICAqIGF0dHJpYnV0ZXMgY2FuIGJlIGtleWVkIGJ5IHRoZSB0b3AgbGV2ZWwgYXR0cmlidXRlIG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX25vcm1BdHRyVmFsc1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVIYXNoIEFuIG9iamVjdCB3aXRoIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGxpdGVyYWwgd2l0aCAyIHByb3BlcnRpZXMgLSBcInNpbXBsZVwiIGFuZCBcImNvbXBsZXhcIixcbiAgICAgICAgICogY29udGFpbmluZyBzaW1wbGUgYW5kIGNvbXBsZXggYXR0cmlidXRlIHZhbHVlcyByZXNwZWN0aXZlbHkga2V5ZWRcbiAgICAgICAgICogYnkgdGhlIHRvcCBsZXZlbCBhdHRyaWJ1dGUgbmFtZSwgb3IgbnVsbCwgaWYgdmFsdWVIYXNoIGlzIGZhbHNleS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9ub3JtQXR0clZhbHMgOiBBdHRyaWJ1dGUucHJvdG90eXBlLl9ub3JtQXR0clZhbHMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGdpdmVuIGF0dHJpYnV0ZSBmcm9tXG4gICAgICAgICAqIGVpdGhlciB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHByb3ZpZGVkLCBvciB0aGVcbiAgICAgICAgICogb3Zlci1yaWRkZW4gdmFsdWUgaWYgaXQgZXhpc3RzIGluIHRoZSBzZXQgb2YgaW5pdFZhbHVlc1xuICAgICAgICAgKiBwcm92aWRlZCBhbmQgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcmVhZC1vbmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgVGhlIGF0dHJpYnV0ZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdFZhbHVlcyBUaGUgb2JqZWN0IHdpdGggc2ltcGxlIGFuZCBjb21wbGV4IGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIHJldHVybmVkIGZyb20gX25vcm1BdHRyVmFsc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtBbnl9IFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2dldEF0dHJJbml0VmFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0QXR0ckluaXRWYWwgOiBBdHRyaWJ1dGUucHJvdG90eXBlLl9nZXRBdHRySW5pdFZhbFxuXG4gICAgfTtcblxuICAgIC8vIENvbnNpc3RlbmN5IHdpdGggdGhlIHJlc3Qgb2YgdGhlIEF0dHJpYnV0ZSBhZGRvbnMgZm9yIG5vdy5cbiAgICBZLkF0dHJpYnV0ZUNvbXBsZXggPSBBdHRyaWJ1dGUuQ29tcGxleDtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiYXR0cmlidXRlLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnYXR0cmlidXRlLWNvcmUnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIFN0YXRlIGNsYXNzIG1haW50YWlucyBzdGF0ZSBmb3IgYSBjb2xsZWN0aW9uIG9mIG5hbWVkIGl0ZW1zLCB3aXRoXG4gICAgICogYSB2YXJ5aW5nIG51bWJlciBvZiBwcm9wZXJ0aWVzIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBJdCBhdm9pZHMgdGhlIG5lZWQgdG8gY3JlYXRlIGEgc2VwYXJhdGUgY2xhc3MgZm9yIHRoZSBpdGVtLCBhbmQgc2VwYXJhdGUgaW5zdGFuY2VzXG4gICAgICogb2YgdGhlc2UgY2xhc3NlcyBmb3IgZWFjaCBpdGVtLCBieSBzdG9yaW5nIHRoZSBzdGF0ZSBpbiBhIDIgbGV2ZWwgaGFzaCB0YWJsZSxcbiAgICAgKiBpbXByb3ZpbmcgcGVyZm9ybWFuY2Ugd2hlbiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGlzIGxpa2VseSB0byBiZSBsYXJnZS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjbGFzcyBTdGF0ZVxuICAgICAqL1xuICAgIFkuU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhc2ggb2YgYXR0cmlidXRlc1xuICAgICAgICAgKiBAcHJvcGVydHkgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgfTtcblxuICAgIFkuU3RhdGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgcHJvcGVydHkgdG8gYW4gaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhZGRcbiAgICAgICAgICogQHBhcmFtIG5hbWUge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGl0ZW0uXG4gICAgICAgICAqIEBwYXJhbSBrZXkge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICAgICAgICAgKiBAcGFyYW0gdmFsIHtBbnl9IFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKG5hbWUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZGF0YVtuYW1lXTtcblxuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuZGF0YVtuYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtW2tleV0gPSB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgbXVsdGlwbGUgcHJvcGVydGllcyB0byBhbiBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGFkZEFsbFxuICAgICAgICAgKiBAcGFyYW0gbmFtZSB7U3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgaXRlbS5cbiAgICAgICAgICogQHBhcmFtIG9iaiB7T2JqZWN0fSBBIGhhc2ggb2YgcHJvcGVydHkvdmFsdWUgcGFpcnMuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRBbGw6IGZ1bmN0aW9uKG5hbWUsIG9iaikge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmRhdGFbbmFtZV0sXG4gICAgICAgICAgICAgICAga2V5O1xuXG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5kYXRhW25hbWVdID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBwcm9wZXJ0eSBmcm9tIGFuIGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBpdGVtLlxuICAgICAgICAgKiBAcGFyYW0ga2V5IHtTdHJpbmd9IFRoZSBwcm9wZXJ0eSB0byByZW1vdmUuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUsIGtleSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmRhdGFbbmFtZV07XG5cbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBtdWx0aXBsZSBwcm9wZXJ0aWVzIGZyb20gYW4gaXRlbSwgb3IgcmVtb3ZlcyB0aGUgaXRlbSBjb21wbGV0ZWx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUFsbFxuICAgICAgICAgKiBAcGFyYW0gbmFtZSB7U3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgaXRlbS5cbiAgICAgICAgICogQHBhcmFtIG9iaiB7T2JqZWN0fEFycmF5fSBDb2xsZWN0aW9uIG9mIHByb3BlcnRpZXMgdG8gZGVsZXRlLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBlbnRpcmUgaXRlbSBpcyByZW1vdmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbihuYW1lLCBvYmopIHtcbiAgICAgICAgICAgIHZhciBkYXRhO1xuXG4gICAgICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgWS5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShuYW1lLCB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IGtleSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGEgZ2l2ZW4gaXRlbSwgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHJlcXVlc3RlZCwgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBnZXRcbiAgICAgICAgICogQHBhcmFtIG5hbWUge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGl0ZW1cbiAgICAgICAgICogQHBhcmFtIGtleSB7U3RyaW5nfSBPcHRpb25hbC4gVGhlIHByb3BlcnR5IHZhbHVlIHRvIHJldHJpZXZlLlxuICAgICAgICAgKiBAcmV0dXJuIHtBbnl9IFRoZSB2YWx1ZSBvZiB0aGUgc3VwcGxpZWQgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUsIGtleSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmRhdGFbbmFtZV07XG5cbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIHRoZSBnaXZlbiBpdGVtLCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGFsbCBvZiB0aGVcbiAgICAgICAgICogaXRlbSdzIHByb3BlcnR5L3ZhbHVlIHBhaXJzLiBCeSBkZWZhdWx0IHRoZSBvYmplY3QgcmV0dXJuZWRcbiAgICAgICAgICogaXMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIHN0b3JlZCBkYXRhLCBidXQgcGFzc2luZyBpbiB0cnVlXG4gICAgICAgICAqIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdpbGwgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBzdG9yZWRcbiAgICAgICAgICogZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBnZXRBbGxcbiAgICAgICAgICogQHBhcmFtIG5hbWUge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGl0ZW1cbiAgICAgICAgICogQHBhcmFtIHJlZmVyZW5jZSB7Ym9vbGVhbn0gdHJ1ZSwgaWYgeW91IHdhbnQgYSByZWZlcmVuY2UgdG8gdGhlIHN0b3JlZFxuICAgICAgICAgKiBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBwcm9wZXJ0eS92YWx1ZSBwYWlycyBmb3IgdGhlIGl0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRBbGwgOiBmdW5jdGlvbihuYW1lLCByZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5kYXRhW25hbWVdLFxuICAgICAgICAgICAgICAgIGtleSwgb2JqO1xuXG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGl0ZW1ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLypGb3IgbG9nIGxpbmVzKi9cbiAgICAvKmpzaGludCBtYXhsZW46MjAwKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBhdHRyaWJ1dGUgbW9kdWxlIHByb3ZpZGVzIGFuIGF1Z21lbnRhYmxlIEF0dHJpYnV0ZSBpbXBsZW1lbnRhdGlvbiwgd2hpY2hcbiAgICAgKiBhZGRzIGNvbmZpZ3VyYWJsZSBhdHRyaWJ1dGVzIGFuZCBhdHRyaWJ1dGUgY2hhbmdlIGV2ZW50cyB0byB0aGUgY2xhc3MgYmVpbmdcbiAgICAgKiBhdWdtZW50ZWQuIEl0IGFsc28gcHJvdmlkZXMgYSBTdGF0ZSBjbGFzcywgd2hpY2ggaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEF0dHJpYnV0ZSxcbiAgICAgKiBidXQgY2FuIGFsc28gYmUgdXNlZCBpbmRlcGVuZGVudGx5IHRvIHByb3ZpZGUgYSBuYW1lL3Byb3BlcnR5L3ZhbHVlIGRhdGEgc3RydWN0dXJlIHRvXG4gICAgICogc3RvcmUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIGF0dHJpYnV0ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF0dHJpYnV0ZS1jb3JlIHN1Ym1vZHVsZSBwcm92aWRlcyB0aGUgbGlnaHRlc3QgbGV2ZWwgb2YgYXR0cmlidXRlIGhhbmRsaW5nIHN1cHBvcnRcbiAgICAgKiB3aXRob3V0IEF0dHJpYnV0ZSBjaGFuZ2UgZXZlbnRzLCBvciBsZXNzZXIgdXNlZCBtZXRob2RzIHN1Y2ggYXMgcmVzZXQoKSwgbW9kaWZ5QXR0cnMoKSxcbiAgICAgKiBhbmQgcmVtb3ZlQXR0cigpLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBhdHRyaWJ1dGVcbiAgICAgKiBAc3VibW9kdWxlIGF0dHJpYnV0ZS1jb3JlXG4gICAgICovXG4gICAgdmFyIE8gPSBZLk9iamVjdCxcbiAgICAgICAgTGFuZyA9IFkuTGFuZyxcblxuICAgICAgICBET1QgPSBcIi5cIixcblxuICAgICAgICAvLyBFeHRlcm5hbGx5IGNvbmZpZ3VyYWJsZSBwcm9wc1xuICAgICAgICBHRVRURVIgPSBcImdldHRlclwiLFxuICAgICAgICBTRVRURVIgPSBcInNldHRlclwiLFxuICAgICAgICBSRUFEX09OTFkgPSBcInJlYWRPbmx5XCIsXG4gICAgICAgIFdSSVRFX09OQ0UgPSBcIndyaXRlT25jZVwiLFxuICAgICAgICBJTklUX09OTFkgPSBcImluaXRPbmx5XCIsXG4gICAgICAgIFZBTElEQVRPUiA9IFwidmFsaWRhdG9yXCIsXG4gICAgICAgIFZBTFVFID0gXCJ2YWx1ZVwiLFxuICAgICAgICBWQUxVRV9GTiA9IFwidmFsdWVGblwiLFxuICAgICAgICBMQVpZX0FERCA9IFwibGF6eUFkZFwiLFxuXG4gICAgICAgIC8vIFVzZWQgZm9yIGludGVybmFsIHN0YXRlIG1hbmFnZW1lbnRcbiAgICAgICAgQURERUQgPSBcImFkZGVkXCIsXG4gICAgICAgIEJZUEFTU19QUk9YWSA9IFwiX2J5cGFzc1Byb3h5XCIsXG4gICAgICAgIElOSVRfVkFMVUUgPSBcImluaXRWYWx1ZVwiLFxuICAgICAgICBMQVpZID0gXCJsYXp5XCIsXG5cbiAgICAgICAgSU5WQUxJRF9WQUxVRTtcblxuICAgIC8qKlxuICAgICAqIDxwPlxuICAgICAqIEF0dHJpYnV0ZUNvcmUgcHJvdmlkZXMgdGhlIGxpZ2h0ZXN0IGxldmVsIG9mIGNvbmZpZ3VyYWJsZSBhdHRyaWJ1dGUgc3VwcG9ydC4gSXQgaXMgZGVzaWduZWQgdG8gYmVcbiAgICAgKiBhdWdtZW50ZWQgb24gdG8gYSBob3N0IGNsYXNzLCBhbmQgcHJvdmlkZXMgdGhlIGhvc3Qgd2l0aCB0aGUgYWJpbGl0eSB0byBjb25maWd1cmVcbiAgICAgKiBhdHRyaWJ1dGVzIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBzdGF0ZSwgPHN0cm9uZz5idXQgd2l0aG91dCBzdXBwb3J0IGZvciBhdHRyaWJ1dGUgY2hhbmdlIGV2ZW50czwvc3Ryb25nPi5cbiAgICAgKiA8L3A+XG4gICAgICogPHA+Rm9yIGV4YW1wbGUsIGF0dHJpYnV0ZXMgYWRkZWQgdG8gdGhlIGhvc3QgY2FuIGJlIGNvbmZpZ3VyZWQ6PC9wPlxuICAgICAqIDx1bD5cbiAgICAgKiAgICAgPGxpPkFzIHJlYWQgb25seS48L2xpPlxuICAgICAqICAgICA8bGk+QXMgd3JpdGUgb25jZS48L2xpPlxuICAgICAqICAgICA8bGk+V2l0aCBhIHNldHRlciBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZVxuICAgICAqICAgICB2YWx1ZXMgcGFzc2VkIHRvIEF0dHJpYnV0ZSdzIDxhIGhyZWY9XCIjbWV0aG9kX3NldFwiPnNldDwvYT4gbWV0aG9kLCBiZWZvcmUgdGhleSBhcmUgc3RvcmVkLjwvbGk+XG4gICAgICogICAgIDxsaT5XaXRoIGEgZ2V0dGVyIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCB0byBtYW5pcHVsYXRlIHN0b3JlZCB2YWx1ZXMsXG4gICAgICogICAgIGJlZm9yZSB0aGV5IGFyZSByZXR1cm5lZCBieSBBdHRyaWJ1dGUncyA8YSBocmVmPVwiI21ldGhvZF9nZXRcIj5nZXQ8L2E+IG1ldGhvZC48L2xpPlxuICAgICAqICAgICA8bGk+V2l0aCBhIHZhbGlkYXRvciBmdW5jdGlvbiwgdG8gdmFsaWRhdGUgdmFsdWVzIGJlZm9yZSB0aGV5IGFyZSBzdG9yZWQuPC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqXG4gICAgICogPHA+U2VlIHRoZSA8YSBocmVmPVwiI21ldGhvZF9hZGRBdHRyXCI+YWRkQXR0cjwvYT4gbWV0aG9kLCBmb3IgdGhlIGNvbXBsZXRlIHNldCBvZiBjb25maWd1cmF0aW9uXG4gICAgICogb3B0aW9ucyBhdmFpbGFibGUgZm9yIGF0dHJpYnV0ZXMuPC9wPlxuICAgICAqXG4gICAgICogPHA+T2JqZWN0L0NsYXNzZXMgYmFzZWQgb24gQXR0cmlidXRlQ29yZSBjYW4gYXVnbWVudCA8YSBocmVmPVwiQXR0cmlidXRlT2JzZXJ2YWJsZS5odG1sXCI+QXR0cmlidXRlT2JzZXJ2YWJsZTwvYT5cbiAgICAgKiAod2l0aCB0cnVlIGZvciBvdmVyd3JpdGUpIGFuZCA8YSBocmVmPVwiQXR0cmlidXRlRXh0cmFzLmh0bWxcIj5BdHRyaWJ1dGVFeHRyYXM8L2E+IHRvIGFkZCBhdHRyaWJ1dGUgZXZlbnQgYW5kXG4gICAgICogYWRkaXRpb25hbCwgbGVzcyBjb21tb25seSB1c2VkIGF0dHJpYnV0ZSBtZXRob2RzLCBzdWNoIGFzIGBtb2RpZnlBdHRyYCwgYHJlbW92ZUF0dHJgIGFuZCBgcmVzZXRgLjwvcD5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBBdHRyaWJ1dGVDb3JlXG4gICAgICogQHBhcmFtIGF0dHJzIHtPYmplY3R9IFRoZSBhdHRyaWJ1dGVzIHRvIGFkZCBkdXJpbmcgY29uc3RydWN0aW9uIChwYXNzZWQgdGhyb3VnaCB0byA8YSBocmVmPVwiI21ldGhvZF9hZGRBdHRyc1wiPmFkZEF0dHJzPC9hPikuXG4gICAgICogICAgICAgIFRoZXNlIGNhbiBhbHNvIGJlIGRlZmluZWQgb24gdGhlIGNvbnN0cnVjdG9yIGJlaW5nIGF1Z21lbnRlZCB3aXRoIEF0dHJpYnV0ZSBieSBkZWZpbmluZyB0aGUgQVRUUlMgcHJvcGVydHkgb24gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMge09iamVjdH0gVGhlIGluaXRpYWwgYXR0cmlidXRlIHZhbHVlcyB0byBhcHBseSAocGFzc2VkIHRocm91Z2ggdG8gPGEgaHJlZj1cIiNtZXRob2RfYWRkQXR0cnNcIj5hZGRBdHRyczwvYT4pLlxuICAgICAqICAgICAgICBUaGVzZSBhcmUgbm90IG1lcmdlZC9jbG9uZWQuIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGlzb2xhdGluZyB1c2VyIHByb3ZpZGVkIHZhbHVlcyBpZiByZXF1aXJlZC5cbiAgICAgKiBAcGFyYW0gbGF6eSB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdG8gYWRkIGF0dHJpYnV0ZXMgbGF6aWx5IChwYXNzZWQgdGhyb3VnaCB0byA8YSBocmVmPVwiI21ldGhvZF9hZGRBdHRyc1wiPmFkZEF0dHJzPC9hPikuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXR0cmlidXRlQ29yZShhdHRycywgdmFsdWVzLCBsYXp5KSB7XG4gICAgICAgIC8vIEhBQ0s6IEZpeCAjMjUzMTkyOVxuICAgICAgICAvLyBDb21wbGV0ZSBoYWNrLCB0byBtYWtlIHN1cmUgdGhlIGZpcnN0IGNsb25lIG9mIGEgbm9kZSB2YWx1ZSBpbiBJRSBkb2Vzbid0IGRvZXNuJ3QgaHVydCBzdGF0ZSAtIG1haW50YWlucyAzLjQuMSBiZWhhdmlvci5cbiAgICAgICAgLy8gVG9vIGxhdGUgaW4gdGhlIHJlbGVhc2UgY3ljbGUgdG8gZG8gYW55dGhpbmcgYWJvdXQgdGhlIGNvcmUgcHJvYmxlbS5cbiAgICAgICAgLy8gVGhlIHJvb3QgaXNzdWUgaXMgdGhhdCBjbG9uaW5nIGEgWS5Ob2RlIGluc3RhbmNlIHJlc3VsdHMgaW4gYW4gb2JqZWN0IHdoaWNoIGJhcmZzIGluIElFLCB3aGVuIHlvdSBhY2Nlc3MgaXQncyBwcm9wZXJ0aWVzIChzaW5jZSAzLjMuMCkuXG4gICAgICAgIHRoaXMuX3l1aWV2dCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5faW5pdEF0dHJIb3N0KGF0dHJzLCB2YWx1ZXMsIGxhenkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPlRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSBhbiBhdHRyaWJ1dGUgc2V0dGVyIGluIG9yZGVyIHRvIHByZXZlbnQgdGhlIHNldCBmcm9tIGdvaW5nIHRocm91Z2guPC9wPlxuICAgICAqXG4gICAgICogPHA+WW91IGNhbiByZXR1cm4gdGhpcyB2YWx1ZSBmcm9tIHlvdXIgc2V0dGVyIGlmIHlvdSB3aXNoIHRvIGNvbWJpbmUgdmFsaWRhdG9yIGFuZCBzZXR0ZXJcbiAgICAgKiBmdW5jdGlvbmFsaXR5IGludG8gYSBzaW5nbGUgc2V0dGVyIGZ1bmN0aW9uLCB3aGljaCBlaXRoZXIgcmV0dXJucyB0aGUgbWFzc2FnZWQgdmFsdWUgdG8gYmUgc3RvcmVkIG9yXG4gICAgICogQXR0cmlidXRlQ29yZS5JTlZBTElEX1ZBTFVFIHRvIHByZXZlbnQgaW52YWxpZCB2YWx1ZXMgZnJvbSBiZWluZyBzdG9yZWQuPC9wPlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IElOVkFMSURfVkFMVUVcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgQXR0cmlidXRlQ29yZS5JTlZBTElEX1ZBTFVFID0ge307XG4gICAgSU5WQUxJRF9WQUxVRSA9IEF0dHJpYnV0ZUNvcmUuSU5WQUxJRF9WQUxVRTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIHByb3BlcnRpZXMgd2hpY2ggY2FuIGJlIGNvbmZpZ3VyZWQgZm9yXG4gICAgICogZWFjaCBhdHRyaWJ1dGUgKGUuZy4gc2V0dGVyLCBnZXR0ZXIsIHdyaXRlT25jZSBldGMuKS5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBpbnRlcm5hbGx5IGFzIGEgd2hpdGVsaXN0IGZvciBmYXN0ZXJcbiAgICAgKiBZLm1peCBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9BVFRSX0NGR1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVDb3JlLl9BVFRSX0NGRyA9IFtTRVRURVIsIEdFVFRFUiwgVkFMSURBVE9SLCBWQUxVRSwgVkFMVUVfRk4sIFdSSVRFX09OQ0UsIFJFQURfT05MWSwgTEFaWV9BREQsIEJZUEFTU19QUk9YWV07XG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCB0byBwcm90ZWN0IGFuIGF0dHJpYnV0ZSBjb25maWd1cmF0aW9uIGhhc2gsIGJ5IG1lcmdpbmcgdGhlXG4gICAgICogZW50aXJlIG9iamVjdCBhbmQgdGhlIGluZGl2aWR1YWwgYXR0ciBjb25maWcgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcHJvdGVjdEF0dHJzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBBIGhhc2ggb2YgYXR0cmlidXRlIHRvIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHBhaXJzLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBwcm90ZWN0ZWQgdmVyc2lvbiBvZiB0aGUgYGF0dHJzYCBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBBdHRyaWJ1dGVDb3JlLnByb3RlY3RBdHRycyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGF0dHJzID0gWS5tZXJnZShhdHRycyk7XG4gICAgICAgICAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2F0dHJdID0gWS5tZXJnZShhdHRyc1thdHRyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH07XG5cbiAgICBBdHRyaWJ1dGVDb3JlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0b3IgbG9naWMgZm9yIGF0dHJpYnV0ZXMuIEluaXRpYWxpemVzIHRoZSBob3N0IHN0YXRlLCBhbmQgc2V0cyB1cCB0aGUgaW5pdGFsIGF0dHJpYnV0ZXMgcGFzc2VkIHRvIHRoZVxuICAgICAgICAgKiBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfaW5pdEF0dHJIb3N0XG4gICAgICAgICAqIEBwYXJhbSBhdHRycyB7T2JqZWN0fSBUaGUgYXR0cmlidXRlcyB0byBhZGQgZHVyaW5nIGNvbnN0cnVjdGlvbiAocGFzc2VkIHRocm91Z2ggdG8gPGEgaHJlZj1cIiNtZXRob2RfYWRkQXR0cnNcIj5hZGRBdHRyczwvYT4pLlxuICAgICAgICAgKiAgICAgICAgVGhlc2UgY2FuIGFsc28gYmUgZGVmaW5lZCBvbiB0aGUgY29uc3RydWN0b3IgYmVpbmcgYXVnbWVudGVkIHdpdGggQXR0cmlidXRlIGJ5IGRlZmluaW5nIHRoZSBBVFRSUyBwcm9wZXJ0eSBvbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZXMge09iamVjdH0gVGhlIGluaXRpYWwgYXR0cmlidXRlIHZhbHVlcyB0byBhcHBseSAocGFzc2VkIHRocm91Z2ggdG8gPGEgaHJlZj1cIiNtZXRob2RfYWRkQXR0cnNcIj5hZGRBdHRyczwvYT4pLlxuICAgICAgICAgKiAgICAgICAgVGhlc2UgYXJlIG5vdCBtZXJnZWQvY2xvbmVkLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBpc29sYXRpbmcgdXNlciBwcm92aWRlZCB2YWx1ZXMgaWYgcmVxdWlyZWQuXG4gICAgICAgICAqIEBwYXJhbSBsYXp5IHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0byBhZGQgYXR0cmlidXRlcyBsYXppbHkgKHBhc3NlZCB0aHJvdWdoIHRvIDxhIGhyZWY9XCIjbWV0aG9kX2FkZEF0dHJzXCI+YWRkQXR0cnM8L2E+KS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9pbml0QXR0ckhvc3QgOiBmdW5jdGlvbihhdHRycywgdmFsdWVzLCBsYXp5KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBZLlN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9pbml0QXR0cnMoYXR0cnMsIHZhbHVlcywgbGF6eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBBZGRzIGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uIHRvIHRoZSBob3N0IG9iamVjdC5cbiAgICAgICAgICogPC9wPlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogVGhlIGNvbmZpZyBhcmd1bWVudCBvYmplY3Qgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnZhbHVlICYjNjA7QW55JiM2Mjs8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+VGhlIGluaXRpYWwgdmFsdWUgdG8gc2V0IG9uIHRoZSBhdHRyaWJ1dGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dmFsdWVGbiAmIzYwO0Z1bmN0aW9uIHwgU3RyaW5nJiM2Mjs8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgIDxwPkEgZnVuY3Rpb24sIHdoaWNoIHdpbGwgcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIHRvIHNldCBvbiB0aGUgYXR0cmlidXRlLiBUaGlzIGlzIHVzZWZ1bFxuICAgICAgICAgKiAgICBmb3IgY2FzZXMgd2hlcmUgdGhlIGF0dHJpYnV0ZSBjb25maWd1cmF0aW9uIGlzIGRlZmluZWQgc3RhdGljYWxseSwgYnV0IG5lZWRzIHRvXG4gICAgICAgICAqICAgIHJlZmVyZW5jZSB0aGUgaG9zdCBpbnN0YW5jZSAoXCJ0aGlzXCIpIHRvIG9idGFpbiBhbiBpbml0aWFsIHZhbHVlLiBJZiBib3RoIHRoZSB2YWx1ZSBhbmQgdmFsdWVGbiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLFxuICAgICAgICAgKiAgICB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIHZhbHVlRm4gaGFzIHByZWNlZGVuY2Ugb3ZlciB0aGUgdmFsdWUgcHJvcGVydHksIHVubGVzcyBpdCByZXR1cm5zIHVuZGVmaW5lZCwgaW4gd2hpY2hcbiAgICAgICAgICogICAgY2FzZSB0aGUgdmFsdWUgcHJvcGVydHkgaXMgdXNlZC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxwPnZhbHVlRm4gY2FuIGFsc28gYmUgc2V0IHRvIGEgc3RyaW5nLCByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGluc3RhbmNlIG1ldGhvZCB0byBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSB2YWx1ZS48L3A+XG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5yZWFkT25seSAmIzYwO2Jvb2xlYW4mIzYyOzwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5XaGV0aGVyIG9yIG5vdCB0aGUgYXR0cmlidXRlIGlzIHJlYWQgb25seS4gQXR0cmlidXRlcyBoYXZpbmcgcmVhZE9ubHkgc2V0IHRvIHRydWVcbiAgICAgICAgICogICAgICAgIGNhbm5vdCBiZSBtb2RpZmllZCBieSBpbnZva2luZyB0aGUgc2V0IG1ldGhvZC48L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+d3JpdGVPbmNlICYjNjA7Ym9vbGVhbiYjNjI7IG9yICYjNjA7c3RyaW5nJiM2Mjs8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgYXR0cmlidXRlIGlzIFwid3JpdGUgb25jZVwiLiBBdHRyaWJ1dGVzIGhhdmluZyB3cml0ZU9uY2Ugc2V0IHRvIHRydWUsXG4gICAgICAgICAqICAgICAgICBjYW4gb25seSBoYXZlIHRoZWlyIHZhbHVlcyBzZXQgb25jZSwgYmUgaXQgdGhyb3VnaCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLFxuICAgICAgICAgKiAgICAgICAgY29uc3RydWN0b3IgY29uZmlndXJhdGlvbiBhcmd1bWVudHMsIG9yIGJ5IGludm9raW5nIHNldC5cbiAgICAgICAgICogICAgICAgIDxwPlRoZSB3cml0ZU9uY2UgYXR0cmlidXRlIGNhbiBhbHNvIGJlIHNldCB0byB0aGUgc3RyaW5nIFwiaW5pdE9ubHlcIixcbiAgICAgICAgICogICAgICAgICBpbiB3aGljaCBjYXNlIHRoZSBhdHRyaWJ1dGUgY2FuIG9ubHkgYmUgc2V0IGR1cmluZyBpbml0aWFsaXphdGlvblxuICAgICAgICAgKiAgICAgICAgKHdoZW4gdXNlZCB3aXRoIEJhc2UsIHRoaXMgbWVhbnMgaXQgY2FuIG9ubHkgYmUgc2V0IGR1cmluZyBjb25zdHJ1Y3Rpb24pPC9wPlxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c2V0dGVyICYjNjA7RnVuY3Rpb24gfCBTdHJpbmcmIzYyOzwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgPHA+VGhlIHNldHRlciBmdW5jdGlvbiB1c2VkIHRvIG1hc3NhZ2Ugb3Igbm9ybWFsaXplIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhlIHNldCBtZXRob2QgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqICAgIFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgc2V0dGVyIHdpbGwgYmUgdGhlIGZpbmFsIHN0b3JlZCB2YWx1ZS4gUmV0dXJuaW5nXG4gICAgICAgICAqICAgIDxhIGhyZWY9XCIjcHJvcGVydHlfQXR0cmlidXRlLklOVkFMSURfVkFMVUVcIj5BdHRyaWJ1dGUuSU5WQUxJRF9WQUxVRTwvYT4sIGZyb20gdGhlIHNldHRlciB3aWxsIHByZXZlbnRcbiAgICAgICAgICogICAgdGhlIHZhbHVlIGZyb20gYmVpbmcgc3RvcmVkLlxuICAgICAgICAgKiAgICA8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxwPnNldHRlciBjYW4gYWxzbyBiZSBzZXQgdG8gYSBzdHJpbmcsIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgaW5zdGFuY2UgbWV0aG9kIHRvIGJlIHVzZWQgYXMgdGhlIHNldHRlciBmdW5jdGlvbi48L3A+XG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5nZXR0ZXIgJiM2MDtGdW5jdGlvbiB8IFN0cmluZyYjNjI7PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICA8cD5cbiAgICAgICAgICogICAgVGhlIGdldHRlciBmdW5jdGlvbiB1c2VkIHRvIG1hc3NhZ2Ugb3Igbm9ybWFsaXplIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZ2V0IG1ldGhvZCBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAgICogICAgVGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBnZXR0ZXIgZnVuY3Rpb24gaXMgdGhlIHZhbHVlIHdoaWNoIHdpbGwgYmUgcmV0dXJuZWQgdG8gdGhlIHVzZXIgd2hlbiB0aGV5XG4gICAgICAgICAqICAgIGludm9rZSBnZXQuXG4gICAgICAgICAqICAgIDwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPHA+Z2V0dGVyIGNhbiBhbHNvIGJlIHNldCB0byBhIHN0cmluZywgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSBpbnN0YW5jZSBtZXRob2QgdG8gYmUgdXNlZCBhcyB0aGUgZ2V0dGVyIGZ1bmN0aW9uLjwvcD5cbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnZhbGlkYXRvciAmIzYwO0Z1bmN0aW9uIHwgU3RyaW5nJiM2Mjs8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgIDxwPlxuICAgICAgICAgKiAgICBUaGUgdmFsaWRhdG9yIGZ1bmN0aW9uIGludm9rZWQgcHJpb3IgdG8gc2V0dGluZyB0aGUgc3RvcmVkIHZhbHVlLiBSZXR1cm5pbmdcbiAgICAgICAgICogICAgZmFsc2UgZnJvbSB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uIHdpbGwgcHJldmVudCB0aGUgdmFsdWUgZnJvbSBiZWluZyBzdG9yZWQuXG4gICAgICAgICAqICAgIDwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPHA+dmFsaWRhdG9yIGNhbiBhbHNvIGJlIHNldCB0byBhIHN0cmluZywgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSBpbnN0YW5jZSBtZXRob2QgdG8gYmUgdXNlZCBhcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uLjwvcD5cbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmxhenlBZGQgJiM2MDtib29sZWFuJiM2Mjs8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+V2hldGhlciBvciBub3QgdG8gZGVsYXkgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGF0dHJpYnV0ZSB1bnRpbCB0aGUgZmlyc3QgY2FsbCB0byBnZXQvc2V0IGl0LlxuICAgICAgICAgKiAgICBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgdG8gb3Zlci1yaWRlIGxhenkgaW5pdGlhbGl6YXRpb24gb24gYSBwZXIgYXR0cmlidXRlIGJhc2lzLCB3aGVuIGFkZGluZyBtdWx0aXBsZSBhdHRyaWJ1dGVzIHRocm91Z2hcbiAgICAgICAgICogICAgdGhlIDxhIGhyZWY9XCIjbWV0aG9kX2FkZEF0dHJzXCI+YWRkQXR0cnM8L2E+IG1ldGhvZC48L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5UaGUgc2V0dGVyLCBnZXR0ZXIgYW5kIHZhbGlkYXRvciBhcmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBhbmQgbmFtZSBwYXNzZWQgaW4gYXMgdGhlIGZpcnN0IGFuZCBzZWNvbmQgYXJndW1lbnRzLCBhbmQgd2l0aFxuICAgICAgICAgKiB0aGUgY29udGV4dCAoXCJ0aGlzXCIpIHNldCB0byB0aGUgaG9zdCBvYmplY3QuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5Db25maWd1cmF0aW9uIHByb3BlcnRpZXMgb3V0c2lkZSBvZiB0aGUgbGlzdCBtZW50aW9uZWQgYWJvdmUgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZSBwcm9wZXJ0aWVzIHVzZWQgaW50ZXJuYWxseSBieSBhdHRyaWJ1dGUsXG4gICAgICAgICAqIGFuZCBhcmUgbm90IGludGVuZGVkIGZvciBwdWJsaWMgdXNlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhZGRBdHRyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQW4gb2JqZWN0IHdpdGggYXR0cmlidXRlIGNvbmZpZ3VyYXRpb24gcHJvcGVydHkvdmFsdWUgcGFpcnMsIHNwZWNpZnlpbmcgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiA8c3Ryb25nPk5PVEU6PC9zdHJvbmc+IFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBpcyBtb2RpZmllZCB3aGVuIGFkZGluZyBhbiBhdHRyaWJ1dGUsIHNvIGlmIHlvdSBuZWVkXG4gICAgICAgICAqIHRvIHByb3RlY3QgdGhlIG9yaWdpbmFsIHZhbHVlcywgeW91IHdpbGwgbmVlZCB0byBtZXJnZSB0aGUgb2JqZWN0LlxuICAgICAgICAgKiA8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGF6eSAob3B0aW9uYWwpIFdoZXRoZXIgb3Igbm90IHRvIGFkZCB0aGlzIGF0dHJpYnV0ZSBsYXppbHkgKG9uIHRoZSBmaXJzdCBjYWxsIHRvIGdldC9zZXQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVmZXJlbmNlIHRvIHRoZSBob3N0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGNoYWluYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQXR0ciA6IGZ1bmN0aW9uKG5hbWUsIGNvbmZpZywgbGF6eSkge1xuXG5cbiAgICAgICAgICAgIHZhciBob3N0ID0gdGhpcywgLy8gaGVscCBjb21wcmVzc2lvblxuICAgICAgICAgICAgICAgIHN0YXRlID0gaG9zdC5fc3RhdGUsXG4gICAgICAgICAgICAgICAgZGF0YSA9IHN0YXRlLmRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgYWRkZWQsXG4gICAgICAgICAgICAgICAgaGFzVmFsdWU7XG5cbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKExBWllfQUREIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGxhenkgPSBjb25maWdbTEFaWV9BRERdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRlZCA9IHN0YXRlLmdldChuYW1lLCBBRERFRCk7XG5cbiAgICAgICAgICAgIGlmIChsYXp5ICYmICFhZGRlZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmRhdGFbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGxhenkgOiBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkIDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoIWFkZGVkIHx8IGNvbmZpZy5pc0xhenlBZGQpIHtcblxuICAgICAgICAgICAgICAgICAgICBoYXNWYWx1ZSA9IChWQUxVRSBpbiBjb25maWcpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1ZhbHVlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGdvIHRocm91Z2ggc2V0LCBkb24ndCB3YW50IHRvIHNldCB2YWx1ZSBpbiBjb25maWcgZGlyZWN0bHlcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUEVSRiBUT0RPOiBWQUxJREFURTogU2VlIGlmIHNldHRpbmcgdGhpcyB0byB1bmRlZmluZWQgaXMgc3VmZmljaWVudC4gV2UgdXNlIHRvIGRlbGV0ZSBiZWZvcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjZXJ0YWluIGNvZGUgcGF0aHMvdXNlIGNhc2VzLCB1bmRlZmluZWQgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyBub3QgcHJlc2VudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgd2UgY2FuIHNldCBpdCB0byBzb21lIGtub3duIGZpeGVkIHZhbHVlIChsaWtlIElOVkFMSURfVkFMVUUsIHNheSBJTklUSUFMSVpJTkdfVkFMVUUpIGZvciBwZXJmb3JtYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGEgZGVsZXRlIHdoaWNoIHNlZW1zIHRvIGhlbHAgYSBsb3QuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29uZmlnLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmluaXRpYWxpemluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtuYW1lXSA9IGNvbmZpZztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggc2V0LCBzbyB0aGF0IHJhdyB2YWx1ZXMgZ2V0IG5vcm1hbGl6ZWQvdmFsaWRhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0LnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25maWcuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaG9zdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGUgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGhvc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhdHRyQWRkZWRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjaGVjay5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbiBhdHRyaWJ1dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBoYXMgYmVlbiBhZGRlZCwgZmFsc2UgaWYgaXQgaGFzbid0LlxuICAgICAgICAgKiAgICAgICAgIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRydWUgZm9yIGxhemlseSBhZGRlZCBhdHRyaWJ1dGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgYXR0ckFkZGVkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gISEodGhpcy5fc3RhdGUuZ2V0KG5hbWUsIEFEREVEKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS4gSWYgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgKiBoYXMgYmVlbiBjb25maWd1cmVkIHdpdGggYSAnZ2V0dGVyJyBmdW5jdGlvbiwgdGhpcyBtZXRob2Qgd2lsbCBkZWxlZ2F0ZVxuICAgICAgICAgKiB0byB0aGUgJ2dldHRlcicgdG8gb2J0YWluIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGdldFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlLiBJZiB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBpcyBhbiBPYmplY3QsXG4gICAgICAgICAqIGRvdCBub3RhdGlvbiBjYW4gYmUgdXNlZCB0byBvYnRhaW4gdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgb2YgdGhlIG9iamVjdCAoZS5nLiA8Y29kZT5nZXQoXCJ4LnkuelwiKTwvY29kZT4pXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FueX0gVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBdHRyKG5hbWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhlIGF0dHJpYnV0ZSBpcyBvbmUgd2hpY2ggaGFzIGJlZW5cbiAgICAgICAgICogYWRkZWQgbGF6aWx5IGFuZCBzdGlsbCByZXF1aXJlcyBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfaXNMYXp5QXR0clxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgaXQncyBhIGxhemlseSBhZGRlZCBhdHRyaWJ1dGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIF9pc0xhenlBdHRyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0KG5hbWUsIExBWlkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5pc2hlcyBpbml0aWFsaXppbmcgYW4gYXR0cmlidXRlIHdoaWNoIGhhcyBiZWVuIGxhemlseSBhZGRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfYWRkTGF6eUF0dHJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xhenlDZmddIE9wdGlvbmFsIGNvbmZpZyBoYXNoIGZvciB0aGUgYXR0cmlidXRlLiBUaGlzIGlzIGFkZGVkIGZvciBwZXJmb3JtYW5jZVxuICAgICAgICAgKiBhbG9uZyB0aGUgY3JpdGljYWwgcGF0aCwgd2hlcmUgdGhlIGNhbGxpbmcgbWV0aG9kIGhhcyBhbHJlYWR5IG9idGFpbmVkIGxhenkgY29uZmlnIGZyb20gc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBfYWRkTGF6eUF0dHI6IGZ1bmN0aW9uKG5hbWUsIGxhenlDZmcpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXG4gICAgICAgICAgICBsYXp5Q2ZnID0gbGF6eUNmZyB8fCBzdGF0ZS5nZXQobmFtZSwgTEFaWSk7XG5cbiAgICAgICAgICAgIGlmIChsYXp5Q2ZnKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBQRVJGIFRPRE86IEZvciBBcHAncyBpZCBvdmVycmlkZSwgb3RoZXJ3aXNlIHdvdWxkbid0IGJlXG4gICAgICAgICAgICAgICAgLy8gbmVlZGVkLiBJdCBleHBlY3RzIHRvIGZpbmQgaXQgaW4gdGhlIGNmZyBmb3IgaXQnc1xuICAgICAgICAgICAgICAgIC8vIGFkZEF0dHIgb3ZlcnJpZGUuIFdvdWxkIGxpa2UgdG8gcmVtb3ZlLCBvbmNlIEFwcCBvdmVycmlkZSBpc1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgc3RhdGUuZGF0YVtuYW1lXS5sYXp5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgbGF6eUNmZy5pc0xhenlBZGQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBdHRyKG5hbWUsIGxhenlDZmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS4gSWYgdGhlXG4gICAgICAgICAqIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBpcyBhbiBPYmplY3QsIGRvdCBub3RhdGlvbiBjYW4gYmUgdXNlZFxuICAgICAgICAgKiB0byBzZXQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgd2l0aGluIHRoZSBvYmplY3QgKGUuZy4gPGNvZGU+c2V0KFwieC55LnpcIiwgNSk8L2NvZGU+KS5cbiAgICAgICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0by5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBPcHRpb25hbCBkYXRhIHByb3ZpZGluZyB0aGUgY2lyY3Vtc3RhbmNlcyBmb3IgdGhlIGNoYW5nZS5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBIHJlZmVyZW5jZSB0byB0aGUgaG9zdCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQgOiBmdW5jdGlvbihuYW1lLCB2YWwsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRBdHRyKG5hbWUsIHZhbCwgb3B0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyBzZXR0aW5nIG9mIHJlYWRPbmx5L3dyaXRlT25jZSBhdHRyaWJ1dGVzLiBTZWUgPGEgaHJlZj1cIiNtZXRob2Rfc2V0XCI+c2V0PC9hPiBmb3IgYXJndW1lbnQgZGV0YWlscy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfc2V0XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQGNoYWluYWJsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAgICAgKiBAcGFyYW0ge0FueX0gdmFsIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0by5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBPcHRpb25hbCBkYXRhIHByb3ZpZGluZyB0aGUgY2lyY3Vtc3RhbmNlcyBmb3IgdGhlIGNoYW5nZS5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBIHJlZmVyZW5jZSB0byB0aGUgaG9zdCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0IDogZnVuY3Rpb24obmFtZSwgdmFsLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0QXR0cihuYW1lLCB2YWwsIG9wdHMsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm92aWRlcyB0aGUgY29tbW9uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgcHVibGljIHNldCBhbmQgcHJvdGVjdGVkIF9zZXQgbWV0aG9kcy5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIDxhIGhyZWY9XCIjbWV0aG9kX3NldFwiPnNldDwvYT4gZm9yIGFyZ3VtZW50IGRldGFpbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX3NldEF0dHJcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAY2hhaW5hYmxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gT3B0aW9uYWwgZGF0YSBwcm92aWRpbmcgdGhlIGNpcmN1bXN0YW5jZXMgZm9yIHRoZSBjaGFuZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgSWYgdHJ1ZSwgYWxsb3dzIHRoZSBjYWxsZXIgdG8gc2V0IHZhbHVlcyBmb3JcbiAgICAgICAgICogcmVhZE9ubHkgb3Igd3JpdGVPbmNlIGF0dHJpYnV0ZXMgd2hpY2ggaGF2ZSBhbHJlYWR5IGJlZW4gc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVmZXJlbmNlIHRvIHRoZSBob3N0IG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIF9zZXRBdHRyIDogZnVuY3Rpb24obmFtZSwgdmFsLCBvcHRzLCBmb3JjZSkgIHtcbiAgICAgICAgICAgIHZhciBhbGxvd1NldCA9IHRydWUsXG4gICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLl9zdGF0ZSxcbiAgICAgICAgICAgICAgICBzdGF0ZVByb3h5ID0gdGhpcy5fc3RhdGVQcm94eSxcbiAgICAgICAgICAgICAgICB0Q2ZncyA9IHRoaXMuX3RDZmdzLFxuICAgICAgICAgICAgICAgIGNmZyxcbiAgICAgICAgICAgICAgICBpbml0aWFsU2V0LFxuICAgICAgICAgICAgICAgIHN0clBhdGgsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBjdXJyVmFsLFxuICAgICAgICAgICAgICAgIHdyaXRlT25jZSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXppbmc7XG5cbiAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoRE9UKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdHJQYXRoID0gbmFtZTtcblxuICAgICAgICAgICAgICAgIHBhdGggPSBuYW1lLnNwbGl0KERPVCk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT24gRGVtYW5kIC0gU2hvdWxkIGJlIHJhcmUgLSBoYW5kbGVzIG91dCBvZiBvcmRlciB2YWx1ZUZuLCBzZXR0ZXIsIGdldHRlciByZWZlcmVuY2VzXG4gICAgICAgICAgICBpZiAodENmZ3MgJiYgdENmZ3NbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRPdXRPZk9yZGVyKG5hbWUsIHRDZmdzW25hbWVdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2ZnID0gc3RhdGUuZGF0YVtuYW1lXSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKGNmZy5sYXp5KSB7XG4gICAgICAgICAgICAgICAgY2ZnID0gY2ZnLmxhenk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGF6eUF0dHIobmFtZSwgY2ZnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5pdGlhbFNldCA9IChjZmcudmFsdWUgPT09IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZVByb3h5ICYmIG5hbWUgaW4gc3RhdGVQcm94eSAmJiAhY2ZnLl9ieXBhc3NQcm94eSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFZhbHVlIGlzIGFsd2F5cyBzZXQgZm9yIHByb3h5LiBDYW4gd2UgZG8gYW55IGJldHRlcj8gTWF5YmUgdGFrZSBhIHNuYXBzaG90IGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgZmlyc3QgY2FsbCB0byBzZXQ/XG4gICAgICAgICAgICAgICAgaW5pdGlhbFNldCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cml0ZU9uY2UgPSBjZmcud3JpdGVPbmNlO1xuICAgICAgICAgICAgaW5pdGlhbGl6aW5nID0gY2ZnLmluaXRpYWxpemluZztcblxuICAgICAgICAgICAgaWYgKCFpbml0aWFsU2V0ICYmICFmb3JjZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHdyaXRlT25jZSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1NldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjZmcucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dTZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaW5pdGlhbGl6aW5nICYmICFmb3JjZSAmJiB3cml0ZU9uY2UgPT09IElOSVRfT05MWSkge1xuICAgICAgICAgICAgICAgIGFsbG93U2V0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGxvd1NldCkge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IG5lZWQgY3VyclZhbCBpZiBpbml0aWFsU2V0IChtaWdodCBmYWlsIGluIGN1c3RvbSBnZXR0ZXIgaWYgaXQgYWx3YXlzIGV4cGVjdHMgYSBub24tdW5kZWZpbmVkL25vbi1udWxsIHZhbHVlKVxuICAgICAgICAgICAgICAgIGlmICghaW5pdGlhbFNldCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyVmFsID0gIHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgdmFsID0gTy5zZXRWYWx1ZShZLmNsb25lKGN1cnJWYWwpLCBwYXRoLCB2YWwpO1xuXG4gICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGFsbG93U2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhbGxvd1NldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZpcmVBdHRyQ2hhbmdlIHx8IGluaXRpYWxpemluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0QXR0clZhbChuYW1lLCBzdHJQYXRoLCBjdXJyVmFsLCB2YWwsIG9wdHMsIGNmZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIQUNLIC0gbm8gcmVhbCByZWFzb24gY29yZSBuZWVkcyB0byBrbm93IGFib3V0IF9maXJlQXR0ckNoYW5nZSwgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBhZGRzIGZuIGhvcHMgaWYgd2Ugd2FudCB0byBicmVhayBpdCBvdXQuIE5vdCBzdXJlIGl0J3Mgd29ydGggaXQgZm9yIHRoaXMgY3JpdGljYWwgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZUF0dHJDaGFuZ2UobmFtZSwgc3RyUGF0aCwgY3VyclZhbCwgdmFsLCBvcHRzLCBjZmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXRpbGl0eSBtZXRob2QgdXNlZCBieSBnZXQvc2V0IHRvIGFkZCBhdHRyaWJ1dGVzXG4gICAgICAgICAqIGVuY291bnRlcmVkIG91dCBvZiBvcmRlciB3aGVuIGNhbGxpbmcgYWRkQXR0cnMoKS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGlmOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdGhpcy5hZGRBdHRycyh7XG4gICAgICAgICAqICAgICAgICAgIGZvbzoge1xuICAgICAgICAgKiAgICAgICAgICAgICAgc2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGlzIGJhciBpcyBhdmFpbGFibGUgd2hlbiBmb28gaXMgYWRkZWRcbiAgICAgICAgICogICAgICAgICAgICAgICAgIHRoaXMuZ2V0KFwiYmFyXCIpO1xuICAgICAgICAgKiAgICAgICAgICAgICAgfVxuICAgICAgICAgKiAgICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgICBiYXI6IHtcbiAgICAgICAgICogICAgICAgICAgICAgIHZhbHVlOiAuLi5cbiAgICAgICAgICogICAgICAgICAgfVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2FkZE91dE9mT3JkZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIG5hbWUge1N0cmluZ30gYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICogQHBhcmFtIGNmZyB7T2JqZWN0fSBhdHRyaWJ1dGUgY29uZmlndXJhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgX2FkZE91dE9mT3JkZXIgOiBmdW5jdGlvbihuYW1lLCBjZmcpIHtcblxuICAgICAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IGNmZztcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RDZmdzW25hbWVdO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBUaGUgb3JpZ2luYWwgY29kZSB3ZW50IHRocm91Z2ggYWRkQXR0cnMsIHNvXG4gICAgICAgICAgICAvLyBzdGlja2luZyB3aXRoIGl0IGZvciB0aGlzIHBhc3MuIFNlZW1zIGxpa2Ugd2UgY291bGRcbiAgICAgICAgICAgIC8vIGp1c3QganVtcCBzdHJhaWdodCB0byBfYWRkQXR0cigpIGFuZCBnZXQgc29tZSBwZXJmXG4gICAgICAgICAgICAvLyBpbXByb3ZlbWVudC5cbiAgICAgICAgICAgIHRoaXMuX2FkZEF0dHJzKGF0dHJzLCB0aGlzLl90VmFscyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGVzIHRoZSBjb21tb24gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBwdWJsaWMgZ2V0IG1ldGhvZCxcbiAgICAgICAgICogYWxsb3dpbmcgQXR0cmlidXRlIGhvc3RzIHRvIG92ZXItcmlkZSBlaXRoZXIgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgPGEgaHJlZj1cIiNtZXRob2RfZ2V0XCI+Z2V0PC9hPiBmb3IgYXJndW1lbnQgZGV0YWlscy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfZ2V0QXR0clxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAgICogQHJldHVybiB7QW55fSBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIF9nZXRBdHRyIDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdmFyIGZ1bGxOYW1lID0gbmFtZSxcbiAgICAgICAgICAgICAgICB0Q2ZncyA9IHRoaXMuX3RDZmdzLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgZ2V0dGVyLFxuICAgICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgICBhdHRyQ2ZnO1xuXG4gICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKERPVCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IG5hbWUuc3BsaXQoRE9UKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gcGF0aC5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbiBEZW1hbmQgLSBTaG91bGQgYmUgcmFyZSAtIGhhbmRsZXMgb3V0IG9mXG4gICAgICAgICAgICAvLyBvcmRlciB2YWx1ZUZuLCBzZXR0ZXIsIGdldHRlciByZWZlcmVuY2VzXG4gICAgICAgICAgICBpZiAodENmZ3MgJiYgdENmZ3NbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRPdXRPZk9yZGVyKG5hbWUsIHRDZmdzW25hbWVdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXR0ckNmZyA9IHRoaXMuX3N0YXRlLmRhdGFbbmFtZV0gfHwge307XG5cbiAgICAgICAgICAgIC8vIExhenkgSW5pdFxuICAgICAgICAgICAgaWYgKGF0dHJDZmcubGF6eSkge1xuICAgICAgICAgICAgICAgIGF0dHJDZmcgPSBhdHRyQ2ZnLmxhenk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGF6eUF0dHIobmFtZSwgYXR0ckNmZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHRoaXMuX2dldFN0YXRlVmFsKG5hbWUsIGF0dHJDZmcpO1xuXG4gICAgICAgICAgICBnZXR0ZXIgPSBhdHRyQ2ZnLmdldHRlcjtcblxuICAgICAgICAgICAgaWYgKGdldHRlciAmJiAhZ2V0dGVyLmNhbGwpIHtcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSB0aGlzW2dldHRlcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IChnZXR0ZXIpID8gZ2V0dGVyLmNhbGwodGhpcywgdmFsLCBmdWxsTmFtZSkgOiB2YWw7XG4gICAgICAgICAgICB2YWwgPSAocGF0aCkgPyBPLmdldFZhbHVlKHZhbCwgcGF0aCkgOiB2YWw7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHN0b3JlZCB2YWx1ZSBmb3IgdGhlIGF0dHJpYnV0ZSwgZnJvbSBlaXRoZXIgdGhlXG4gICAgICAgICAqIGludGVybmFsIHN0YXRlIG9iamVjdCwgb3IgdGhlIHN0YXRlIHByb3h5IGlmIGl0IGV4aXRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2dldFN0YXRlVmFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjZmddIE9wdGlvbmFsIGNvbmZpZyBoYXNoIGZvciB0aGUgYXR0cmlidXRlLiBUaGlzIGlzIGFkZGVkIGZvciBwZXJmb3JtYW5jZSBhbG9uZyB0aGUgY3JpdGljYWwgcGF0aCxcbiAgICAgICAgICogd2hlcmUgdGhlIGNhbGxpbmcgbWV0aG9kIGhhcyBhbHJlYWR5IG9idGFpbmVkIHRoZSBjb25maWcgZnJvbSBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QW55fSBUaGUgc3RvcmVkIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIF9nZXRTdGF0ZVZhbCA6IGZ1bmN0aW9uKG5hbWUsIGNmZykge1xuICAgICAgICAgICAgdmFyIHN0YXRlUHJveHkgPSB0aGlzLl9zdGF0ZVByb3h5O1xuXG4gICAgICAgICAgICBpZiAoIWNmZykge1xuICAgICAgICAgICAgICAgIGNmZyA9IHRoaXMuX3N0YXRlLmdldEFsbChuYW1lKSB8fCB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChzdGF0ZVByb3h5ICYmIChuYW1lIGluIHN0YXRlUHJveHkpICYmICEoY2ZnLl9ieXBhc3NQcm94eSkpID8gc3RhdGVQcm94eVtuYW1lXSA6IGNmZy52YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc3RvcmVkIHZhbHVlIGZvciB0aGUgYXR0cmlidXRlLCBpbiBlaXRoZXIgdGhlXG4gICAgICAgICAqIGludGVybmFsIHN0YXRlIG9iamVjdCwgb3IgdGhlIHN0YXRlIHByb3h5IGlmIGl0IGV4aXRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX3NldFN0YXRlVmFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0U3RhdGVWYWwgOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlUHJveHkgPSB0aGlzLl9zdGF0ZVByb3h5O1xuICAgICAgICAgICAgaWYgKHN0YXRlUHJveHkgJiYgKG5hbWUgaW4gc3RhdGVQcm94eSkgJiYgIXRoaXMuX3N0YXRlLmdldChuYW1lLCBCWVBBU1NfUFJPWFkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVQcm94eVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5hZGQobmFtZSwgVkFMVUUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgc3RvcmVkIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgaW4gdGhlIHByaXZhdGVseSBoZWxkIFN0YXRlIG9iamVjdCxcbiAgICAgICAgICogaWYgdmFsaWRhdGlvbiBhbmQgc2V0dGVyIHBhc3Nlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfc2V0QXR0clZhbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ck5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3ViQXR0ck5hbWUgVGhlIHN1Yi1hdHRyaWJ1dGUgbmFtZSwgaWYgc2V0dGluZyBhIHN1Yi1hdHRyaWJ1dGUgcHJvcGVydHkgKFwieC55LnpcIikuXG4gICAgICAgICAqIEBwYXJhbSB7QW55fSBwcmV2VmFsIFRoZSBjdXJyZW50bHkgc3RvcmVkIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqIEBwYXJhbSB7QW55fSBuZXdWYWwgVGhlIHZhbHVlIHdoaWNoIGlzIGdvaW5nIHRvIGJlIHN0b3JlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBPcHRpb25hbCBkYXRhIHByb3ZpZGluZyB0aGUgY2lyY3Vtc3RhbmNlcyBmb3IgdGhlIGNoYW5nZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyQ2ZnXSBPcHRpb25hbCBjb25maWcgaGFzaCBmb3IgdGhlIGF0dHJpYnV0ZS4gVGhpcyBpcyBhZGRlZCBmb3IgcGVyZm9ybWFuY2UgYWxvbmcgdGhlIGNyaXRpY2FsIHBhdGgsXG4gICAgICAgICAqIHdoZXJlIHRoZSBjYWxsaW5nIG1ldGhvZCBoYXMgYWxyZWFkeSBvYnRhaW5lZCB0aGUgY29uZmlnIGZyb20gc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIG5ldyBhdHRyaWJ1dGUgdmFsdWUgd2FzIHN0b3JlZCwgZmFsc2UgaWYgbm90LlxuICAgICAgICAgKi9cbiAgICAgICAgX3NldEF0dHJWYWwgOiBmdW5jdGlvbihhdHRyTmFtZSwgc3ViQXR0ck5hbWUsIHByZXZWYWwsIG5ld1ZhbCwgb3B0cywgYXR0ckNmZykge1xuXG4gICAgICAgICAgICB2YXIgaG9zdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYWxsb3dTZXQgPSB0cnVlLFxuICAgICAgICAgICAgICAgIGNmZyA9IGF0dHJDZmcgfHwgdGhpcy5fc3RhdGUuZGF0YVthdHRyTmFtZV0gfHwge30sXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yID0gY2ZnLnZhbGlkYXRvcixcbiAgICAgICAgICAgICAgICBzZXR0ZXIgPSBjZmcuc2V0dGVyLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemluZyA9IGNmZy5pbml0aWFsaXppbmcsXG4gICAgICAgICAgICAgICAgcHJldlJhd1ZhbCA9IHRoaXMuX2dldFN0YXRlVmFsKGF0dHJOYW1lLCBjZmcpLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBzdWJBdHRyTmFtZSB8fCBhdHRyTmFtZSxcbiAgICAgICAgICAgICAgICByZXRWYWwsXG4gICAgICAgICAgICAgICAgdmFsaWQ7XG5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRvci5jYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBzdHJpbmcgLSB0cnlpbmcgdG8ga2VlcCBjcml0aWNhbCBwYXRoIHRpZ2h0LCBzbyBhdm9pZGluZyBMYW5nIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvciA9IHRoaXNbdmFsaWRhdG9yXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbGlkYXRvci5jYWxsKGhvc3QsIG5ld1ZhbCwgbmFtZSwgb3B0cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZCAmJiBpbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGNmZy5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7IC8vIEFzc3VtZSBpdCdzIHZhbGlkLCBmb3IgcGVyZi5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0b3IgfHwgdmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGVyLmNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBzdHJpbmcgLSB0cnlpbmcgdG8ga2VlcCBjcml0aWNhbCBwYXRoIHRpZ2h0LCBzbyBhdm9pZGluZyBMYW5nIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXIgPSB0aGlzW3NldHRlcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0VmFsID0gc2V0dGVyLmNhbGwoaG9zdCwgbmV3VmFsLCBuYW1lLCBvcHRzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldFZhbCA9PT0gSU5WQUxJRF9WQUxVRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gY2ZnLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1NldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0VmFsICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IHJldFZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhbGxvd1NldCkge1xuICAgICAgICAgICAgICAgICAgICBpZighc3ViQXR0ck5hbWUgJiYgKG5ld1ZhbCA9PT0gcHJldlJhd1ZhbCkgJiYgIUxhbmcuaXNPYmplY3QobmV3VmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dTZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShJTklUX1ZBTFVFIGluIGNmZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZmcuaW5pdFZhbHVlID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdC5fc2V0U3RhdGVWYWwoYXR0ck5hbWUsIG5ld1ZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxsb3dTZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFsbG93U2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG11bHRpcGxlIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QXR0cnNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzICBBbiBvYmplY3Qgd2l0aCBhdHRyaWJ1dGVzIG5hbWUvdmFsdWUgcGFpcnMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gT3B0aW9uYWwgZGF0YSBwcm92aWRpbmcgdGhlIGNpcmN1bXN0YW5jZXMgZm9yIHRoZSBjaGFuZ2UuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQSByZWZlcmVuY2UgdG8gdGhlIGhvc3Qgb2JqZWN0LlxuICAgICAgICAgKiBAY2hhaW5hYmxlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRBdHRycyA6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0QXR0cnMoYXR0cnMsIG9wdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRhdGlvbiBiZWhpbmQgdGhlIHB1YmxpYyBzZXRBdHRycyBtZXRob2QsIHRvIHNldCBtdWx0aXBsZSBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIF9zZXRBdHRyc1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyAgQW4gb2JqZWN0IHdpdGggYXR0cmlidXRlcyBuYW1lL3ZhbHVlIHBhaXJzLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIE9wdGlvbmFsIGRhdGEgcHJvdmlkaW5nIHRoZSBjaXJjdW1zdGFuY2VzIGZvciB0aGUgY2hhbmdlXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQSByZWZlcmVuY2UgdG8gdGhlIGhvc3Qgb2JqZWN0LlxuICAgICAgICAgKiBAY2hhaW5hYmxlXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0QXR0cnMgOiBmdW5jdGlvbihhdHRycywgb3B0cykge1xuICAgICAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgICAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIGF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChhdHRyLCBhdHRyc1thdHRyXSwgb3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgbXVsdGlwbGUgYXR0cmlidXRlIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBnZXRBdHRyc1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfEJvb2xlYW59IGF0dHJzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMuIElmIG9taXR0ZWQsIGFsbCBhdHRyaWJ1dGUgdmFsdWVzIGFyZVxuICAgICAgICAgKiByZXR1cm5lZC4gSWYgc2V0IHRvIHRydWUsIGFsbCBhdHRyaWJ1dGVzIG1vZGlmaWVkIGZyb20gdGhlaXIgaW5pdGlhbCB2YWx1ZXMgYXJlIHJldHVybmVkLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXR0cnMgOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEF0dHJzKGF0dHJzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50YXRpb24gYmVoaW5kIHRoZSBwdWJsaWMgZ2V0QXR0cnMgbWV0aG9kLCB0byBnZXQgbXVsdGlwbGUgYXR0cmlidXRlIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfZ2V0QXR0cnNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfEJvb2xlYW59IGF0dHJzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMuIElmIG9taXR0ZWQsIGFsbCBhdHRyaWJ1dGUgdmFsdWVzIGFyZVxuICAgICAgICAgKiByZXR1cm5lZC4gSWYgc2V0IHRvIHRydWUsIGFsbCBhdHRyaWJ1dGVzIG1vZGlmaWVkIGZyb20gdGhlaXIgaW5pdGlhbCB2YWx1ZXMgYXJlIHJldHVybmVkLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgX2dldEF0dHJzIDogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fSxcbiAgICAgICAgICAgICAgICBhdHRyLCBpLCBsZW4sXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRPbmx5ID0gKGF0dHJzID09PSB0cnVlKTtcblxuICAgICAgICAgICAgLy8gVE9ETyAtIGZpZ3VyZSBvdXQgaG93IHRvIGdldCBhbGwgXCJhZGRlZFwiXG4gICAgICAgICAgICBpZiAoIWF0dHJzIHx8IG1vZGlmaWVkT25seSkge1xuICAgICAgICAgICAgICAgIGF0dHJzID0gTy5rZXlzKHRoaXMuX3N0YXRlLmRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmICghbW9kaWZpZWRPbmx5IHx8IHRoaXMuX2dldFN0YXRlVmFsKGF0dHIpICE9IHRoaXMuX3N0YXRlLmdldChhdHRyLCBJTklUX1ZBTFVFKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGdldCwgdG8gaG9ub3IgY2xvbmluZy9ub3JtYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgICAgIG9ialthdHRyXSA9IHRoaXMuZ2V0KGF0dHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlcyBhIGdyb3VwIG9mIGF0dHJpYnV0ZXMsIGFuZCBzZXRzIGluaXRpYWwgdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogPHN0cm9uZz5OT1RFOjwvc3Ryb25nPiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBpc29sYXRlIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBieSBtZXJnaW5nL2Nsb25pbmcuXG4gICAgICAgICAqIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIG1lcmdpbmcvY2xvbmluZyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgaWYgcmVxdWlyZWQuXG4gICAgICAgICAqIDwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhZGRBdHRyc1xuICAgICAgICAgKiBAY2hhaW5hYmxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmdzIEFuIG9iamVjdCB3aXRoIGF0dHJpYnV0ZSBuYW1lL2NvbmZpZ3VyYXRpb24gcGFpcnMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgQW4gb2JqZWN0IHdpdGggYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMsIGRlZmluaW5nIHRoZSBpbml0aWFsIHZhbHVlcyB0byBhcHBseS5cbiAgICAgICAgICogVmFsdWVzIGRlZmluZWQgaW4gdGhlIGNmZ3MgYXJndW1lbnQgd2lsbCBiZSBvdmVyLXdyaXR0ZW4gYnkgdmFsdWVzIGluIHRoaXMgYXJndW1lbnQgdW5sZXNzIGRlZmluZWQgYXMgcmVhZCBvbmx5LlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxhenkgV2hldGhlciBvciBub3QgdG8gZGVsYXkgdGhlIGludGlhbGl6YXRpb24gb2YgdGhlc2UgYXR0cmlidXRlcyB1bnRpbCB0aGUgZmlyc3QgY2FsbCB0byBnZXQvc2V0LlxuICAgICAgICAgKiBJbmRpdmlkdWFsIGF0dHJpYnV0ZXMgY2FuIG92ZXItcmlkZSB0aGlzIGJlaGF2aW9yIGJ5IGRlZmluaW5nIGEgbGF6eUFkZCBjb25maWd1cmF0aW9uIHByb3BlcnR5IGluIHRoZWlyIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIFNlZSA8YSBocmVmPVwiI21ldGhvZF9hZGRBdHRyXCI+YWRkQXR0cjwvYT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQSByZWZlcmVuY2UgdG8gdGhlIGhvc3Qgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQXR0cnMgOiBmdW5jdGlvbihjZmdzLCB2YWx1ZXMsIGxhenkpIHtcbiAgICAgICAgICAgIGlmIChjZmdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdENmZ3MgPSBjZmdzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RWYWxzID0gKHZhbHVlcykgPyB0aGlzLl9ub3JtQXR0clZhbHModmFsdWVzKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQXR0cnMoY2ZncywgdGhpcy5fdFZhbHMsIGxhenkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RDZmdzID0gdGhpcy5fdFZhbHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50YXRpb24gYmVoaW5kIHRoZSBwdWJsaWMgYWRkQXR0cnMgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGRpcmVjdGx5IGJ5IGdldCBpZiBpdCBlbmNvdW50ZXJzIGEgc2NlbmFyaW9cbiAgICAgICAgICogaW4gd2hpY2ggYW4gYXR0cmlidXRlJ3MgdmFsdWVGbiBhdHRlbXB0cyB0byBvYnRhaW4gdGhlXG4gICAgICAgICAqIHZhbHVlIGFuIGF0dHJpYnV0ZSBpbiB0aGUgc2FtZSBncm91cCBvZiBhdHRyaWJ1dGVzLCB3aGljaCBoYXMgbm90IHlldFxuICAgICAgICAgKiBiZWVuIGFkZGVkIChvbiBkZW1hbmQgaW5pdGlhbGl6YXRpb24pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIF9hZGRBdHRyc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZncyBBbiBvYmplY3Qgd2l0aCBhdHRyaWJ1dGUgbmFtZS9jb25maWd1cmF0aW9uIHBhaXJzLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIEFuIG9iamVjdCB3aXRoIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzLCBkZWZpbmluZyB0aGUgaW5pdGlhbCB2YWx1ZXMgdG8gYXBwbHkuXG4gICAgICAgICAqIFZhbHVlcyBkZWZpbmVkIGluIHRoZSBjZmdzIGFyZ3VtZW50IHdpbGwgYmUgb3Zlci13cml0dGVuIGJ5IHZhbHVlcyBpbiB0aGlzIGFyZ3VtZW50IHVubGVzcyBkZWZpbmVkIGFzIHJlYWQgb25seS5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBsYXp5IFdoZXRoZXIgb3Igbm90IHRvIGRlbGF5IHRoZSBpbnRpYWxpemF0aW9uIG9mIHRoZXNlIGF0dHJpYnV0ZXMgdW50aWwgdGhlIGZpcnN0IGNhbGwgdG8gZ2V0L3NldC5cbiAgICAgICAgICogSW5kaXZpZHVhbCBhdHRyaWJ1dGVzIGNhbiBvdmVyLXJpZGUgdGhpcyBiZWhhdmlvciBieSBkZWZpbmluZyBhIGxhenlBZGQgY29uZmlndXJhdGlvbiBwcm9wZXJ0eSBpbiB0aGVpciBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBTZWUgPGEgaHJlZj1cIiNtZXRob2RfYWRkQXR0clwiPmFkZEF0dHI8L2E+LlxuICAgICAgICAgKi9cbiAgICAgICAgX2FkZEF0dHJzIDogZnVuY3Rpb24oY2ZncywgdmFsdWVzLCBsYXp5KSB7XG4gICAgICAgICAgICB2YXIgdENmZ3MgPSB0aGlzLl90Q2ZncyxcbiAgICAgICAgICAgICAgICB0VmFscyA9IHRoaXMuX3RWYWxzLFxuICAgICAgICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgICAgICAgYXR0ckNmZyxcbiAgICAgICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICAgICAgZm9yIChhdHRyIGluIGNmZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2Zncy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBNZXJnaW5nLiBDYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGlzb2xhdGluZyBjb25maWdzXG4gICAgICAgICAgICAgICAgICAgIGF0dHJDZmcgPSBjZmdzW2F0dHJdO1xuICAgICAgICAgICAgICAgICAgICBhdHRyQ2ZnLmRlZmF1bHRWYWx1ZSA9IGF0dHJDZmcudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHNpbXBsZSwgY29tcGxleCBhbmQgdXNlciB2YWx1ZXMsIGFjY291bnRpbmcgZm9yIHJlYWQtb25seVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2dldEF0dHJJbml0VmFsKGF0dHIsIGF0dHJDZmcsIHRWYWxzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ckNmZy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRDZmdzW2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0Q2Znc1thdHRyXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cihhdHRyLCBhdHRyQ2ZnLCBsYXp5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFV0aWxpdHkgbWV0aG9kIHRvIHByb3RlY3QgYW4gYXR0cmlidXRlIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICogaGFzaCwgYnkgbWVyZ2luZyB0aGUgZW50aXJlIG9iamVjdCBhbmQgdGhlIGluZGl2aWR1YWxcbiAgICAgICAgICogYXR0ciBjb25maWcgb2JqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfcHJvdGVjdEF0dHJzXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIEEgaGFzaCBvZiBhdHRyaWJ1dGUgdG8gY29uZmlndXJhdGlvbiBvYmplY3QgcGFpcnMuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBwcm90ZWN0ZWQgdmVyc2lvbiBvZiB0aGUgYXR0cnMgYXJndW1lbnQuXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgQXR0cmlidXRlQ29yZS5wcm90ZWN0QXR0cnMoKWAgb3JcbiAgICAgICAgICogICBgQXR0cmlidXRlLnByb3RlY3RBdHRycygpYCB3aGljaCBhcmUgdGhlIHNhbWUgc3RhdGljIHV0aWxpdHkgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgX3Byb3RlY3RBdHRycyA6IEF0dHJpYnV0ZUNvcmUucHJvdGVjdEF0dHJzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZCB0byBub3JtYWxpemUgYXR0cmlidXRlIHZhbHVlcy4gVGhlIGJhc2UgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICogc2ltcGx5IG1lcmdlcyB0aGUgaGFzaCB0byBwcm90ZWN0IHRoZSBvcmlnaW5hbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfbm9ybUF0dHJWYWxzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZUhhc2ggQW4gb2JqZWN0IHdpdGggYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIDIgcHJvcGVydGllcyAtIFwic2ltcGxlXCIgYW5kIFwiY29tcGxleFwiLFxuICAgICAgICAgKiBjb250YWluaW5nIHNpbXBsZSBhbmQgY29tcGxleCBhdHRyaWJ1dGUgdmFsdWVzIHJlc3BlY3RpdmVseSBrZXllZFxuICAgICAgICAgKiBieSB0aGUgdG9wIGxldmVsIGF0dHJpYnV0ZSBuYW1lLCBvciBudWxsLCBpZiB2YWx1ZUhhc2ggaXMgZmFsc2V5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX25vcm1BdHRyVmFscyA6IGZ1bmN0aW9uKHZhbHVlSGFzaCkge1xuICAgICAgICAgICAgdmFyIHZhbHMsXG4gICAgICAgICAgICAgICAgc3VidmFscyxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgICAgICAgdiwgaztcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZUhhc2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFscyA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWVIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlSGFzaC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoay5pbmRleE9mKERPVCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gay5zcGxpdChET1QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IHBhdGguc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3VidmFscyA9IHN1YnZhbHMgfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdWJ2YWxzW2F0dHJdID0gc3VidmFsc1thdHRyXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbdi5sZW5ndGhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUhhc2hba11cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxzW2tdID0gdmFsdWVIYXNoW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBzaW1wbGU6dmFscywgY29tcGxleDpzdWJ2YWxzIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGdpdmVuIGF0dHJpYnV0ZSBmcm9tXG4gICAgICAgICAqIGVpdGhlciB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHByb3ZpZGVkLCBvciB0aGVcbiAgICAgICAgICogb3Zlci1yaWRkZW4gdmFsdWUgaWYgaXQgZXhpc3RzIGluIHRoZSBzZXQgb2YgaW5pdFZhbHVlc1xuICAgICAgICAgKiBwcm92aWRlZCBhbmQgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcmVhZC1vbmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgVGhlIGF0dHJpYnV0ZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdFZhbHVlcyBUaGUgb2JqZWN0IHdpdGggc2ltcGxlIGFuZCBjb21wbGV4IGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIHJldHVybmVkIGZyb20gX25vcm1BdHRyVmFsc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtBbnl9IFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2dldEF0dHJJbml0VmFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0QXR0ckluaXRWYWwgOiBmdW5jdGlvbihhdHRyLCBjZmcsIGluaXRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBjZmcudmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsRm4gPSBjZmcudmFsdWVGbixcbiAgICAgICAgICAgICAgICB0bXBWYWwsXG4gICAgICAgICAgICAgICAgaW5pdFZhbFNldCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5ID0gY2ZnLnJlYWRPbmx5LFxuICAgICAgICAgICAgICAgIHNpbXBsZSxcbiAgICAgICAgICAgICAgICBjb21wbGV4LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbCxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIHN1YnZhbCxcbiAgICAgICAgICAgICAgICBzdWJ2YWxzO1xuXG4gICAgICAgICAgICBpZiAoIXJlYWRPbmx5ICYmIGluaXRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgQXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIHNpbXBsZSA9IGluaXRWYWx1ZXMuc2ltcGxlO1xuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUgJiYgc2ltcGxlLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHNpbXBsZVthdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFZhbFNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsRm4gJiYgIWluaXRWYWxTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbEZuLmNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsRm4gPSB0aGlzW3ZhbEZuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbEZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFZhbCA9IHZhbEZuLmNhbGwodGhpcywgYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHRtcFZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmVhZE9ubHkgJiYgaW5pdFZhbHVlcykge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcGxleCBBdHRyaWJ1dGVzIChjb21wbGV4IHZhbHVlcyBhcHBsaWVkLCBhZnRlciBzaW1wbGUsIGluIGNhc2UgYm90aCBhcmUgc2V0KVxuICAgICAgICAgICAgICAgIGNvbXBsZXggPSBpbml0VmFsdWVzLmNvbXBsZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleCAmJiBjb21wbGV4Lmhhc093blByb3BlcnR5KGF0dHIpICYmICh2YWwgIT09IHVuZGVmaW5lZCkgJiYgKHZhbCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidmFscyA9IGNvbXBsZXhbYXR0cl07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzdWJ2YWxzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHN1YnZhbHNbaV0ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnZhbCA9IHN1YnZhbHNbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBPLnNldFZhbHVlKHZhbCwgcGF0aCwgc3VidmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXRpbGl0eSBtZXRob2QgdG8gc2V0IHVwIGluaXRpYWwgYXR0cmlidXRlcyBkZWZpbmVkIGR1cmluZyBjb25zdHJ1Y3Rpb24sXG4gICAgICAgICAqIGVpdGhlciB0aHJvdWdoIHRoZSBjb25zdHJ1Y3Rvci5BVFRSUyBwcm9wZXJ0eSwgb3IgZXhwbGljaXRseSBwYXNzZWQgaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2luaXRBdHRyc1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSBhdHRycyB7T2JqZWN0fSBUaGUgYXR0cmlidXRlcyB0byBhZGQgZHVyaW5nIGNvbnN0cnVjdGlvbiAocGFzc2VkIHRocm91Z2ggdG8gPGEgaHJlZj1cIiNtZXRob2RfYWRkQXR0cnNcIj5hZGRBdHRyczwvYT4pLlxuICAgICAgICAgKiAgICAgICAgVGhlc2UgY2FuIGFsc28gYmUgZGVmaW5lZCBvbiB0aGUgY29uc3RydWN0b3IgYmVpbmcgYXVnbWVudGVkIHdpdGggQXR0cmlidXRlIGJ5IGRlZmluaW5nIHRoZSBBVFRSUyBwcm9wZXJ0eSBvbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZXMge09iamVjdH0gVGhlIGluaXRpYWwgYXR0cmlidXRlIHZhbHVlcyB0byBhcHBseSAocGFzc2VkIHRocm91Z2ggdG8gPGEgaHJlZj1cIiNtZXRob2RfYWRkQXR0cnNcIj5hZGRBdHRyczwvYT4pLlxuICAgICAgICAgKiAgICAgICAgVGhlc2UgYXJlIG5vdCBtZXJnZWQvY2xvbmVkLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBpc29sYXRpbmcgdXNlciBwcm92aWRlZCB2YWx1ZXMgaWYgcmVxdWlyZWQuXG4gICAgICAgICAqIEBwYXJhbSBsYXp5IHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0byBhZGQgYXR0cmlidXRlcyBsYXppbHkgKHBhc3NlZCB0aHJvdWdoIHRvIDxhIGhyZWY9XCIjbWV0aG9kX2FkZEF0dHJzXCI+YWRkQXR0cnM8L2E+KS5cbiAgICAgICAgICovXG4gICAgICAgIF9pbml0QXR0cnMgOiBmdW5jdGlvbihhdHRycywgdmFsdWVzLCBsYXp5KSB7XG4gICAgICAgICAgICAvLyBBVFRSUyBzdXBwb3J0IGZvciBOb2RlLCB3aGljaCBpcyBub3QgQmFzZSBiYXNlZFxuICAgICAgICAgICAgYXR0cnMgPSBhdHRycyB8fCB0aGlzLmNvbnN0cnVjdG9yLkFUVFJTO1xuXG4gICAgICAgICAgICB2YXIgQmFzZSA9IFkuQmFzZSxcbiAgICAgICAgICAgICAgICBCYXNlQ29yZSA9IFkuQmFzZUNvcmUsXG4gICAgICAgICAgICAgICAgYmFzZUluc3QgPSAoQmFzZSAmJiBZLmluc3RhbmNlT2YodGhpcywgQmFzZSkpLFxuICAgICAgICAgICAgICAgIGJhc2VDb3JlSW5zdCA9ICghYmFzZUluc3QgJiYgQmFzZUNvcmUgJiYgWS5pbnN0YW5jZU9mKHRoaXMsIEJhc2VDb3JlKSk7XG5cbiAgICAgICAgICAgIGlmIChhdHRycyAmJiAhYmFzZUluc3QgJiYgIWJhc2VDb3JlSW5zdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cnMoWS5BdHRyaWJ1dGVDb3JlLnByb3RlY3RBdHRycyhhdHRycyksIHZhbHVlcywgbGF6eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgWS5BdHRyaWJ1dGVDb3JlID0gQXR0cmlidXRlQ29yZTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wib29wXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2F0dHJpYnV0ZS1leHRyYXMnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF0dHJpYnV0ZSBtb2R1bGUgcHJvdmlkZXMgYW4gYXVnbWVudGFibGUgQXR0cmlidXRlIGltcGxlbWVudGF0aW9uLCB3aGljaFxuICAgICAqIGFkZHMgY29uZmlndXJhYmxlIGF0dHJpYnV0ZXMgYW5kIGF0dHJpYnV0ZSBjaGFuZ2UgZXZlbnRzIHRvIHRoZSBjbGFzcyBiZWluZ1xuICAgICAqIGF1Z21lbnRlZC4gSXQgYWxzbyBwcm92aWRlcyBhIFN0YXRlIGNsYXNzLCB3aGljaCBpcyB1c2VkIGludGVybmFsbHkgYnkgQXR0cmlidXRlLFxuICAgICAqIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIGluZGVwZW5kZW50bHkgdG8gcHJvdmlkZSBhIG5hbWUvcHJvcGVydHkvdmFsdWUgZGF0YSBzdHJ1Y3R1cmUgdG9cbiAgICAgKiBzdG9yZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgYXR0cmlidXRlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXR0cmlidXRlLWV4dHJhcyBzdWJtb2R1bGUgcHJvdmlkZXMgbGVzcyBjb21tb25seSB1c2VkIGF0dHJpYnV0ZSBtZXRob2RzLCBhbmQgY2FuXG4gICAgICogYmUgYXVnbWVudGVkL21peGVkIGludG8gYW4gaW1wbGVtZW50aW9uIHdoaWNoIHVzZWQgYXR0cmlidXRlLWNvcmUuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIGF0dHJpYnV0ZVxuICAgICAqIEBzdWJtb2R1bGUgYXR0cmlidXRlLWV4dHJhc1xuICAgICAqL1xuICAgIHZhciBCUk9BRENBU1QgPSBcImJyb2FkY2FzdFwiLFxuICAgICAgICBQVUJMSVNIRUQgPSBcInB1Ymxpc2hlZFwiLFxuICAgICAgICBJTklUX1ZBTFVFID0gXCJpbml0VmFsdWVcIixcblxuICAgICAgICBNT0RJRklBQkxFID0ge1xuICAgICAgICAgICAgcmVhZE9ubHk6MSxcbiAgICAgICAgICAgIHdyaXRlT25jZToxLFxuICAgICAgICAgICAgZ2V0dGVyOjEsXG4gICAgICAgICAgICBicm9hZGNhc3Q6MVxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBhdWdtZW50YWJsZSBpbXBsZW1lbnRhdGlvbiBmb3IgQXR0cmlidXRlQ29yZSwgcHJvdmlkaW5nIGxlc3MgZnJlcXVlbnRseSB1c2VkXG4gICAgICogbWV0aG9kcyBmb3IgQXR0cmlidXRlIG1hbmFnZW1lbnQgc3VjaCBhcyBtb2RpZnlBdHRycygpLCByZW1vdmVBdHRyIGFuZCByZXNldCgpXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQXR0cmlidXRlRXh0cmFzXG4gICAgICogQGV4dGVuc2lvbmZvciBBdHRyaWJ1dGVDb3JlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXR0cmlidXRlRXh0cmFzKCkge31cblxuICAgIEF0dHJpYnV0ZUV4dHJhcy5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYW4gYXR0cmlidXRlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBUaGUgcHJvcGVydGllcyB3aGljaCBjYW4gYmUgbW9kaWZpZWQgdGhyb3VnaCB0aGlzIGludGVyZmFjZSBhcmUgbGltaXRlZFxuICAgICAgICAgKiB0byB0aGUgZm9sbG93aW5nIHN1YnNldCBvZiBhdHRyaWJ1dGVzLCB3aGljaCBjYW4gYmUgc2FmZWx5IG1vZGlmaWVkXG4gICAgICAgICAqIGFmdGVyIGEgdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBzZXQgb24gdGhlIGF0dHJpYnV0ZTpcbiAgICAgICAgICogPC9wPlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICA8ZHQ+cmVhZE9ubHk7PC9kdD5cbiAgICAgICAgICogIDxkdD53cml0ZU9uY2U7PC9kdD5cbiAgICAgICAgICogIDxkdD5icm9hZGNhc3Q7IGFuZDwvZHQ+XG4gICAgICAgICAqICA8ZHQ+Z2V0dGVyLjwvZHQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBOb3RlOiBOZXcgYXR0cmlidXRlcyBjYW5ub3QgYmUgYWRkZWQgdXNpbmcgdGhpcyBpbnRlcmZhY2UuIE5ldyBhdHRyaWJ1dGVzIG11c3QgYmVcbiAgICAgICAgICogYWRkZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiQXR0cmlidXRlQ29yZS9hZGRBdHRyOm1ldGhvZFwifX1hZGRBdHRye3svY3Jvc3NMaW5rfX0sIG9yIGFuXG4gICAgICAgICAqIGFwcHJvcHJpYXRlIG1hbm5lciBmb3IgYSBjbGFzcyB3aGljaCB1dGlsaXNlcyBBdHRyaWJ1dGVzIChlLmcuIHRoZVxuICAgICAgICAgKiB7eyNjcm9zc0xpbmsgXCJCYXNlL0FUVFJTOnByb3BlcnR5XCJ9fUFUVFJTe3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5cbiAgICAgICAgICoge3sjY3Jvc3NMaW5rIFwiQmFzZVwifX1CYXNle3svY3Jvc3NMaW5rfX0pLlxuICAgICAgICAgKiA8L3A+XG4gICAgICAgICAqIEBtZXRob2QgbW9kaWZ5QXR0clxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHdob3NlIGNvbmZpZ3VyYXRpb24gaXMgdG8gYmUgdXBkYXRlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBBbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHByb3BlcnR5L3ZhbHVlIHBhaXJzLCBzcGVjaWZ5aW5nIHRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gbW9kaWZ5LlxuICAgICAgICAgKi9cbiAgICAgICAgbW9kaWZ5QXR0cjogZnVuY3Rpb24obmFtZSwgY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgaG9zdCA9IHRoaXMsIC8vIGhlbHAgY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICBwcm9wLCBzdGF0ZTtcblxuICAgICAgICAgICAgaWYgKGhvc3QuYXR0ckFkZGVkKG5hbWUpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaG9zdC5faXNMYXp5QXR0cihuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBob3N0Ll9hZGRMYXp5QXR0cihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGhvc3QuX3N0YXRlO1xuICAgICAgICAgICAgICAgIGZvciAocHJvcCBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1PRElGSUFCTEVbcHJvcF0gJiYgY29uZmlnLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hZGQobmFtZSwgcHJvcCwgY29uZmlnW3Byb3BdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVjb25maWd1cmVkIGJyb2FkY2FzdCwgbmVlZCB0byByZXB1Ymxpc2hcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBCUk9BRENBU1QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5yZW1vdmUobmFtZSwgUFVCTElTSEVEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIGhvc3Qgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlQXR0clxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGJlIHJlbW92ZWQuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5yZW1vdmVBbGwobmFtZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgYXR0cmlidXRlIChvciBhbGwgYXR0cmlidXRlcykgdG8gaXRzIGluaXRpYWwgdmFsdWUsIGFzIGxvbmcgYXNcbiAgICAgICAgICogdGhlIGF0dHJpYnV0ZSBpcyBub3QgcmVhZE9ubHksIG9yIHdyaXRlT25jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZXNldFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBPcHRpb25hbC4gVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byByZXNldC4gIElmIG9taXR0ZWQsIGFsbCBhdHRyaWJ1dGVzIGFyZSByZXNldC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBIHJlZmVyZW5jZSB0byB0aGUgaG9zdCBvYmplY3QuXG4gICAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0IDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdmFyIGhvc3QgPSB0aGlzOyAgLy8gaGVscCBjb21wcmVzc2lvblxuXG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChob3N0Ll9pc0xhenlBdHRyKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3QuX2FkZExhenlBdHRyKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob3N0LnNldChuYW1lLCBob3N0Ll9zdGF0ZS5nZXQobmFtZSwgSU5JVF9WQUxVRSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBZLk9iamVjdC5lYWNoKGhvc3QuX3N0YXRlLmRhdGEsIGZ1bmN0aW9uKHYsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdC5yZXNldChuKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3N0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgKGFuZCB2YWx1ZSlcbiAgICAgICAgICogZm9yIHRoZSBnaXZlbiBhdHRyaWJ1dGUuIElmIGF0dHJOYW1lIGlzIG5vdCBwcm92aWRlZCwgcmV0dXJucyB0aGVcbiAgICAgICAgICogY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgYXR0cmlidXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfZ2V0QXR0ckNmZ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE9wdGlvbmFsLiBUaGUgYXR0cmlidXRlIG5hbWUuIElmIG5vdCBwcm92aWRlZCwgdGhlIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgY29uZmlndXJhdGlvbiBmb3IgYWxsIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBmb3IgdGhlIGdpdmVuIGF0dHJpYnV0ZSwgb3IgYWxsIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0QXR0ckNmZyA6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBvLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5fc3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgbyA9IHN0YXRlLmdldEFsbChuYW1lKSB8fCB7fTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbyA9IHt9O1xuICAgICAgICAgICAgICAgIFkuZWFjaChzdGF0ZS5kYXRhLCBmdW5jdGlvbih2LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIG9bbl0gPSBzdGF0ZS5nZXRBbGwobik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFkuQXR0cmlidXRlRXh0cmFzID0gQXR0cmlidXRlRXh0cmFzO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJvb3BcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnYXR0cmlidXRlLW9ic2VydmFibGUnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4gICAgLypGb3IgbG9nIGxpbmVzKi9cbiAgICAvKmpzaGludCBtYXhsZW46MjAwKi9cblxuXG4gICAgLyoqXG4gICAgICogVGhlIGF0dHJpYnV0ZSBtb2R1bGUgcHJvdmlkZXMgYW4gYXVnbWVudGFibGUgQXR0cmlidXRlIGltcGxlbWVudGF0aW9uLCB3aGljaFxuICAgICAqIGFkZHMgY29uZmlndXJhYmxlIGF0dHJpYnV0ZXMgYW5kIGF0dHJpYnV0ZSBjaGFuZ2UgZXZlbnRzIHRvIHRoZSBjbGFzcyBiZWluZ1xuICAgICAqIGF1Z21lbnRlZC4gSXQgYWxzbyBwcm92aWRlcyBhIFN0YXRlIGNsYXNzLCB3aGljaCBpcyB1c2VkIGludGVybmFsbHkgYnkgQXR0cmlidXRlLFxuICAgICAqIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIGluZGVwZW5kZW50bHkgdG8gcHJvdmlkZSBhIG5hbWUvcHJvcGVydHkvdmFsdWUgZGF0YSBzdHJ1Y3R1cmUgdG9cbiAgICAgKiBzdG9yZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgYXR0cmlidXRlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYGF0dHJpYnV0ZS1vYnNlcnZhYmxlYCBzdWJtb2R1bGUgcHJvdmlkZXMgYXVnbWVudGFibGUgYXR0cmlidXRlIGNoYW5nZSBldmVudCBzdXBwb3J0XG4gICAgICogZm9yIEF0dHJpYnV0ZUNvcmUgYmFzZWQgaW1wbGVtZW50YXRpb25zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBhdHRyaWJ1dGVcbiAgICAgKiBAc3VibW9kdWxlIGF0dHJpYnV0ZS1vYnNlcnZhYmxlXG4gICAgICovXG4gICAgdmFyIEV2ZW50VGFyZ2V0ID0gWS5FdmVudFRhcmdldCxcblxuICAgICAgICBDSEFOR0UgPSBcIkNoYW5nZVwiLFxuICAgICAgICBCUk9BRENBU1QgPSBcImJyb2FkY2FzdFwiO1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gYXVnbWVudGFibGUgaW1wbGVtZW50YXRpb24gb2YgYXR0cmlidXRlIGNoYW5nZSBldmVudHMgZm9yXG4gICAgICogQXR0cmlidXRlQ29yZS5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBBdHRyaWJ1dGVPYnNlcnZhYmxlXG4gICAgICogQGV4dGVuc2lvbmZvciBBdHRyaWJ1dGVDb3JlXG4gICAgICogQHVzZXMgRXZlbnRUYXJnZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGVPYnNlcnZhYmxlKCkge1xuICAgICAgICAvLyBQZXJmIHR3ZWFrIC0gYXZvaWQgY3JlYXRpbmcgZXZlbnQgbGl0ZXJhbHMgaWYgbm90IHJlcXVpcmVkLlxuICAgICAgICB0aGlzLl9BVFRSX0VfRkFDQURFID0ge307XG5cbiAgICAgICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzLCB7ZW1pdEZhY2FkZTp0cnVlfSk7XG4gICAgfVxuXG4gICAgQXR0cmlidXRlT2JzZXJ2YWJsZS5fQVRUUl9DRkcgPSBbQlJPQURDQVNUXTtcblxuICAgIEF0dHJpYnV0ZU9ic2VydmFibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS4gSWYgdGhlXG4gICAgICAgICAqIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBpcyBhbiBPYmplY3QsIGRvdCBub3RhdGlvbiBjYW4gYmUgdXNlZFxuICAgICAgICAgKiB0byBzZXQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgd2l0aGluIHRoZSBvYmplY3QgKGUuZy4gPGNvZGU+c2V0KFwieC55LnpcIiwgNSk8L2NvZGU+KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0by5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgKE9wdGlvbmFsKSBPcHRpb25hbCBldmVudCBkYXRhIHRvIGJlIG1peGVkIGludG9cbiAgICAgICAgICogdGhlIGV2ZW50IGZhY2FkZSBwYXNzZWQgdG8gc3Vic2NyaWJlcnMgb2YgdGhlIGF0dHJpYnV0ZSdzIGNoYW5nZSBldmVudC4gVGhpc1xuICAgICAgICAgKiBjYW4gYmUgdXNlZCBhcyBhIGZsZXhpYmxlIHdheSB0byBpZGVudGlmeSB0aGUgc291cmNlIG9mIGEgY2FsbCB0byBzZXQsIGFsbG93aW5nXG4gICAgICAgICAqIHRoZSBkZXZlbG9wZXIgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBzZXQgY2FsbGVkIGludGVybmFsbHkgYnkgdGhlIGhvc3QsIHZzLlxuICAgICAgICAgKiBzZXQgY2FsbGVkIGV4dGVybmFsbHkgYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3Blci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBIHJlZmVyZW5jZSB0byB0aGUgaG9zdCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQgOiBmdW5jdGlvbihuYW1lLCB2YWwsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRBdHRyKG5hbWUsIHZhbCwgb3B0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyBzZXR0aW5nIG9mIHJlYWRPbmx5L3dyaXRlT25jZSBhdHRyaWJ1dGVzLiBTZWUgPGEgaHJlZj1cIiNtZXRob2Rfc2V0XCI+c2V0PC9hPiBmb3IgYXJndW1lbnQgZGV0YWlscy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfc2V0XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQGNoYWluYWJsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAgICAgKiBAcGFyYW0ge0FueX0gdmFsIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0by5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgKE9wdGlvbmFsKSBPcHRpb25hbCBldmVudCBkYXRhIHRvIGJlIG1peGVkIGludG9cbiAgICAgICAgICogdGhlIGV2ZW50IGZhY2FkZSBwYXNzZWQgdG8gc3Vic2NyaWJlcnMgb2YgdGhlIGF0dHJpYnV0ZSdzIGNoYW5nZSBldmVudC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBIHJlZmVyZW5jZSB0byB0aGUgaG9zdCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0IDogZnVuY3Rpb24obmFtZSwgdmFsLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0QXR0cihuYW1lLCB2YWwsIG9wdHMsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG11bHRpcGxlIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QXR0cnNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzICBBbiBvYmplY3Qgd2l0aCBhdHRyaWJ1dGVzIG5hbWUvdmFsdWUgcGFpcnMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICBQcm9wZXJ0aWVzIHRvIG1peCBpbnRvIHRoZSBldmVudCBwYXlsb2FkLiBUaGVzZSBhcmUgc2hhcmVkIGFuZCBtaXhlZCBpbnRvIGVhY2ggc2V0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQSByZWZlcmVuY2UgdG8gdGhlIGhvc3Qgb2JqZWN0LlxuICAgICAgICAgKiBAY2hhaW5hYmxlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRBdHRycyA6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0QXR0cnMoYXR0cnMsIG9wdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRhdGlvbiBiZWhpbmQgdGhlIHB1YmxpYyBzZXRBdHRycyBtZXRob2QsIHRvIHNldCBtdWx0aXBsZSBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIF9zZXRBdHRyc1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyAgQW4gb2JqZWN0IHdpdGggYXR0cmlidXRlcyBuYW1lL3ZhbHVlIHBhaXJzLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAgUHJvcGVydGllcyB0byBtaXggaW50byB0aGUgZXZlbnQgcGF5bG9hZC4gVGhlc2UgYXJlIHNoYXJlZCBhbmQgbWl4ZWQgaW50byBlYWNoIHNldFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVmZXJlbmNlIHRvIHRoZSBob3N0IG9iamVjdC5cbiAgICAgICAgICogQGNoYWluYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgX3NldEF0dHJzIDogZnVuY3Rpb24oYXR0cnMsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBhdHRyO1xuICAgICAgICAgICAgZm9yIChhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoYXR0ciwgYXR0cnNbYXR0cl0sIG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVdGlsaXR5IG1ldGhvZCB0byBoZWxwIHNldHVwIHRoZSBldmVudCBwYXlsb2FkIGFuZCBmaXJlIHRoZSBhdHRyaWJ1dGUgY2hhbmdlIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIF9maXJlQXR0ckNoYW5nZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ck5hbWUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3ViQXR0ck5hbWUgVGhlIGZ1bGwgcGF0aCBvZiB0aGUgcHJvcGVydHkgYmVpbmcgY2hhbmdlZCxcbiAgICAgICAgICogaWYgdGhpcyBpcyBhIHN1Yi1hdHRyaWJ1dGUgdmFsdWUgYmVpbmcgY2hhbmdlLiBPdGhlcndpc2UgbnVsbC5cbiAgICAgICAgICogQHBhcmFtIHtBbnl9IGN1cnJWYWwgVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcGFyYW0ge0FueX0gbmV3VmFsIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBBbnkgYWRkaXRpb25hbCBldmVudCBkYXRhIHRvIG1peCBpbnRvIHRoZSBhdHRyaWJ1dGUgY2hhbmdlIGV2ZW50J3MgZXZlbnQgZmFjYWRlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NmZ10gVGhlIGF0dHJpYnV0ZSBjb25maWcgc3RvcmVkIGluIFN0YXRlLCBpZiBhbHJlYWR5IGF2YWlsYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIF9maXJlQXR0ckNoYW5nZSA6IGZ1bmN0aW9uKGF0dHJOYW1lLCBzdWJBdHRyTmFtZSwgY3VyclZhbCwgbmV3VmFsLCBvcHRzLCBjZmcpIHtcbiAgICAgICAgICAgIHZhciBob3N0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBldmVudE5hbWUgPSB0aGlzLl9nZXRGdWxsVHlwZShhdHRyTmFtZSArIENIQU5HRSksXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBob3N0Ll9zdGF0ZSxcbiAgICAgICAgICAgICAgICBmYWNhZGUsXG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0LFxuICAgICAgICAgICAgICAgIGU7XG5cbiAgICAgICAgICAgIGlmICghY2ZnKSB7XG4gICAgICAgICAgICAgICAgY2ZnID0gc3RhdGUuZGF0YVthdHRyTmFtZV0gfHwge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2ZnLnB1Ymxpc2hlZCkge1xuXG4gICAgICAgICAgICAgICAgLy8gUEVSRjogVXNpbmcgbG93ZXIgbGV2ZWwgX3B1Ymxpc2goKSBmb3JcbiAgICAgICAgICAgICAgICAvLyBjcml0aWNhbCBwYXRoIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgZSA9IGhvc3QuX3B1Ymxpc2goZXZlbnROYW1lKTtcblxuICAgICAgICAgICAgICAgIGUuZW1pdEZhY2FkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZS5kZWZhdWx0VGFyZ2V0T25seSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZS5kZWZhdWx0Rm4gPSBob3N0Ll9kZWZBdHRyQ2hhbmdlRm47XG5cbiAgICAgICAgICAgICAgICBicm9hZGNhc3QgPSBjZmcuYnJvYWRjYXN0O1xuICAgICAgICAgICAgICAgIGlmIChicm9hZGNhc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBlLmJyb2FkY2FzdCA9IGJyb2FkY2FzdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjZmcucHVibGlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdHMpIHtcbiAgICAgICAgICAgICAgICBmYWNhZGUgPSBZLm1lcmdlKG9wdHMpO1xuICAgICAgICAgICAgICAgIGZhY2FkZS5fYXR0ck9wdHMgPSBvcHRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWNhZGUgPSBob3N0Ll9BVFRSX0VfRkFDQURFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3QgdXNpbmcgdGhlIHNpbmdsZSBvYmplY3Qgc2lnbmF0dXJlIGZvciBmaXJlKHt0eXBlOi4uLiwgbmV3VmFsOi4uLn0pLCBzaW5jZVxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBvdmVycmlkZSB0eXBlLiBDaGFuZ2VkIHRvIHRoZSBmaXJlKHR5cGUsIHtuZXdWYWw6Li4ufSkgc2lnbmF0dXJlLlxuXG4gICAgICAgICAgICBmYWNhZGUuYXR0ck5hbWUgPSBhdHRyTmFtZTtcbiAgICAgICAgICAgIGZhY2FkZS5zdWJBdHRyTmFtZSA9IHN1YkF0dHJOYW1lO1xuICAgICAgICAgICAgZmFjYWRlLnByZXZWYWwgPSBjdXJyVmFsO1xuICAgICAgICAgICAgZmFjYWRlLm5ld1ZhbCA9IG5ld1ZhbDtcblxuICAgICAgICAgICAgaWYgKGhvc3QuX2hhc1BvdGVudGlhbFN1YnNjcmliZXJzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBob3N0LmZpcmUoZXZlbnROYW1lLCBmYWNhZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyVmFsKGF0dHJOYW1lLCBzdWJBdHRyTmFtZSwgY3VyclZhbCwgbmV3VmFsLCBvcHRzLCBjZmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGZ1bmN0aW9uIGZvciBhdHRyaWJ1dGUgY2hhbmdlIGV2ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1ldGhvZCBfZGVmQXR0ckNoYW5nZUZuXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGUgVGhlIGV2ZW50IG9iamVjdCBmb3IgYXR0cmlidXRlIGNoYW5nZSBldmVudHMuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXZlbnRGYXN0UGF0aCBXaGV0aGVyIG9yIG5vdCB3ZSdyZSB1c2luZyB0aGlzIGFzIGEgZmFzdCBwYXRoIGluIHRoZSBjYXNlIG9mIG5vIGxpc3RlbmVycyBvciBub3RcbiAgICAgICAgICovXG4gICAgICAgIF9kZWZBdHRyQ2hhbmdlRm4gOiBmdW5jdGlvbihlLCBldmVudEZhc3RQYXRoKSB7XG5cbiAgICAgICAgICAgIHZhciBvcHRzID0gZS5fYXR0ck9wdHM7XG4gICAgICAgICAgICBpZiAob3B0cykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlLl9hdHRyT3B0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zZXRBdHRyVmFsKGUuYXR0ck5hbWUsIGUuc3ViQXR0ck5hbWUsIGUucHJldlZhbCwgZS5uZXdWYWwsIG9wdHMpKSB7XG5cblxuICAgICAgICAgICAgICAgIGlmICghZXZlbnRGYXN0UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IFwiYWZ0ZXJcIiBsaXN0ZW5lcnMgZnJvbSBiZWluZyBpbnZva2VkIHNpbmNlIG5vdGhpbmcgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFldmVudEZhc3RQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGUubmV3VmFsID0gdGhpcy5nZXQoZS5hdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEJhc2ljIHByb3RvdHlwZSBhdWdtZW50IC0gbm8gbGF6eSBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uLlxuICAgIFkubWl4KEF0dHJpYnV0ZU9ic2VydmFibGUsIEV2ZW50VGFyZ2V0LCBmYWxzZSwgbnVsbCwgMSk7XG5cbiAgICBZLkF0dHJpYnV0ZU9ic2VydmFibGUgPSBBdHRyaWJ1dGVPYnNlcnZhYmxlO1xuXG4gICAgLyoqXG4gICAgVGhlIGBBdHRyaWJ1dGVFdmVudHNgIGNsYXNzIGV4dGVuc2lvbiB3YXMgZGVwcmVjYXRlZCBpbiBZVUkgMy44LjAgYW5kIGlzIG5vd1xuICAgIGFuIGFsaWFzIGZvciB0aGUgYEF0dHJpYnV0ZU9ic2VydmFibGVgIGNsYXNzIGV4dGVuc2lvbi4gVXNlIHRoYXQgY2xhc3NcbiAgICBleHRuZXNpb24gaW5zdGVhZC4gVGhpcyBhbGlhcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBZVUkuXG5cbiAgICBAY2xhc3MgQXR0cmlidXRlRXZlbnRzXG4gICAgQHVzZXMgRXZlbnRUYXJnZXRcbiAgICBAZGVwcmVjYXRlZCBVc2UgYEF0dHJpYnV0ZU9ic2VydmFibGVgIGluc3RlYWQuXG4gICAgQHNlZSBBdHRyaWJ1dGVPYnNlcnZhYmxlXG4gICAgKiovXG4gICAgWS5BdHRyaWJ1dGVFdmVudHMgPSBBdHRyaWJ1dGVPYnNlcnZhYmxlO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJldmVudC1jdXN0b21cIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnYmFzZS1iYXNlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIG1vZHVsZSBwcm92aWRlcyB0aGUgQmFzZSBjbGFzcywgd2hpY2ggb2JqZWN0cyByZXF1aXJpbmcgYXR0cmlidXRlIGFuZCBjdXN0b20gZXZlbnQgc3VwcG9ydCBjYW4gZXh0ZW5kLlxuICAgICAqIFRoZSBtb2R1bGUgYWxzbyBwcm92aWRlcyB0d28gd2F5cyB0byByZXVzZSBjb2RlIC0gSXQgYXVnbWVudHMgQmFzZSB3aXRoIHRoZSBQbHVnaW4uSG9zdCBpbnRlcmZhY2Ugd2hpY2ggcHJvdmlkZXNcbiAgICAgKiBwbHVnaW4gc3VwcG9ydCBhbmQgYWxzbyBwcm92aWRlcyB0aGUgQmFzZUNvcmUuYnVpbGQgbWV0aG9kIHdoaWNoIHByb3ZpZGVzIGEgd2F5IHRvIGJ1aWxkIGN1c3RvbSBjbGFzc2VzIHVzaW5nIGV4dGVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIGJhc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlLWJhc2Ugc3VibW9kdWxlIHByb3ZpZGVzIHRoZSBCYXNlIGNsYXNzIHdpdGhvdXQgdGhlIFBsdWdpbiBzdXBwb3J0LCBwcm92aWRlZCBieSBQbHVnaW4uSG9zdCxcbiAgICAgKiBhbmQgd2l0aG91dCB0aGUgZXh0ZW5zaW9uIHN1cHBvcnQgcHJvdmlkZWQgYnkgQmFzZUNvcmUuYnVpbGQuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIGJhc2VcbiAgICAgKiBAc3VibW9kdWxlIGJhc2UtYmFzZVxuICAgICAqL1xuXG4gICAgdmFyIEF0dHJpYnV0ZUNvcmUgICA9IFkuQXR0cmlidXRlQ29yZSxcbiAgICAgICAgQXR0cmlidXRlRXh0cmFzID0gWS5BdHRyaWJ1dGVFeHRyYXMsXG4gICAgICAgIEJhc2VDb3JlICAgICAgICA9IFkuQmFzZUNvcmUsXG4gICAgICAgIEJhc2VPYnNlcnZhYmxlICA9IFkuQmFzZU9ic2VydmFibGU7XG5cbiAgICAvKipcbiAgICAgKiA8cD5cbiAgICAgKiBBIGJhc2UgY2xhc3Mgd2hpY2ggb2JqZWN0cyByZXF1aXJpbmcgYXR0cmlidXRlcyBhbmQgY3VzdG9tIGV2ZW50IHN1cHBvcnQgY2FuXG4gICAgICogZXh0ZW5kLiBCYXNlIGFsc28gaGFuZGxlcyB0aGUgY2hhaW5pbmcgb2YgaW5pdGlhbGl6ZXIgYW5kIGRlc3RydWN0b3IgbWV0aG9kcyBhY3Jvc3NcbiAgICAgKiB0aGUgaGllcmFyY2h5IGFzIHBhcnQgb2Ygb2JqZWN0IGNvbnN0cnVjdGlvbiBhbmQgZGVzdHJ1Y3Rpb24uIEFkZGl0aW9uYWxseSwgYXR0cmlidXRlcyBjb25maWd1cmVkXG4gICAgICogdGhyb3VnaCB0aGUgc3RhdGljIDxhIGhyZWY9XCIjcHJvcGVydHlfQVRUUlNcIj5BVFRSUzwvYT4gcHJvcGVydHkgZm9yIGVhY2ggY2xhc3NcbiAgICAgKiBpbiB0aGUgaGllcmFyY2h5IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYnkgQmFzZS5cbiAgICAgKiA8L3A+XG4gICAgICpcbiAgICAgKiA8cD5cbiAgICAgKiAqKk5PVEU6KiogUHJpb3IgdG8gdmVyc2lvbiAzLjExLjAsIEFUVFJTIHdvdWxkIGdldCBhZGRlZCBhIGNsYXNzIGF0IGEgdGltZS4gVGhhdCBpcyxcbiAgICAgKiBCYXNlIHdvdWxkIGxvb3AgdGhyb3VnaCBlYWNoIGNsYXNzIGluIHRoZSBoaWVyYXJjaHksIGFuZCBhZGQgdGhlIGNsYXNzJyBBVFRSUywgYW5kXG4gICAgICogdGhlbiBjYWxsIGl0J3MgaW5pdGlhbGl6ZXIsIGFuZCBtb3ZlIG9uIHRvIHRoZSBzdWJjbGFzcycgQVRUUlMgYW5kIGluaXRpYWxpemVyLiBBcyBvZlxuICAgICAqIDMuMTEuMCwgQVRUUlMgZnJvbSBhbGwgY2xhc3NlcyBpbiB0aGUgaGllcmFyY2h5IGFyZSBhZGRlZCBpbiBvbmUgYGFkZEF0dHJzYCBjYWxsIGJlZm9yZVxuICAgICAqIGFueSBpbml0aWFsaXplcnMgYXJlIGNhbGxlZC4gVGhpcyBmaXhlcyBzdWJ0bGUgZWRnZS1jYXNlIGlzc3VlcyB3aXRoIHN1YmNsYXNzIEFUVFJTIG92ZXJyaWRpbmdcbiAgICAgKiBzdXBlcmNsYXNzIGBzZXR0ZXJgLCBgZ2V0dGVyYCBvciBgdmFsdWVGbmAgZGVmaW5pdGlvbnMgYW5kIGJlaW5nIHVuYWJsZSB0byBnZXQvc2V0IGF0dHJpYnV0ZXNcbiAgICAgKiBkZWZpbmVkIGJ5IHRoZSBzdWJjbGFzcy4gVGhpcyBvcmRlciBvZiBvcGVyYXRpb24gY2hhbmdlIG1heSBpbXBhY3QgYHNldHRlcmAsIGBnZXR0ZXJgIG9yIGB2YWx1ZUZuYFxuICAgICAqIGNvZGUgd2hpY2ggZXhwZWN0cyBhIHN1cGVyY2xhc3MnIGluaXRpYWxpemVyIHRvIGhhdmUgcnVuLiBUaGlzIGlzIGV4cGVjdGVkIHRvIGJlIHJhcmUsIGJ1dCB0byBzdXBwb3J0XG4gICAgICogaXQsIEJhc2Ugc3VwcG9ydHMgYSBgX3ByZUFkZEF0dHJzKClgLCBtZXRob2QgaG9vayAoc2FtZSBzaWduYXR1cmUgYXMgYGFkZEF0dHJzYCkuIENvbXBvbmVudHMgY2FuXG4gICAgICogaW1wbGVtZW50IHRoaXMgbWV0aG9kIG9uIHRoZWlyIHByb3RvdHlwZSBmb3IgZWRnZSBjYXNlcyB3aGljaCBkbyByZXF1aXJlIGZpbmVyIGNvbnRyb2wgb3ZlclxuICAgICAqIHRoZSBvcmRlciBpbiB3aGljaCBhdHRyaWJ1dGVzIGFyZSBhZGRlZCAoc2VlIHdpZGdldC1odG1scGFyc2VyKS5cbiAgICAgKiA8L3A+XG4gICAgICpcbiAgICAgKiA8cD5cbiAgICAgKiBUaGUgc3RhdGljIDxhIGhyZWY9XCIjcHJvcGVydHlfTkFNRVwiPk5BTUU8L2E+IHByb3BlcnR5IG9mIGVhY2ggY2xhc3MgZXh0ZW5kaW5nXG4gICAgICogZnJvbSBCYXNlIHdpbGwgYmUgdXNlZCBhcyB0aGUgaWRlbnRpZmllciBmb3IgdGhlIGNsYXNzLCBhbmQgaXMgdXNlZCBieSBCYXNlIHRvIHByZWZpeFxuICAgICAqIGFsbCBldmVudHMgZmlyZWQgYnkgaW5zdGFuY2VzIG9mIHRoYXQgY2xhc3MuXG4gICAgICogPC9wPlxuICAgICAqXG4gICAgICogQGNsYXNzIEJhc2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAdXNlcyBCYXNlQ29yZVxuICAgICAqIEB1c2VzIEJhc2VPYnNlcnZhYmxlXG4gICAgICogQHVzZXMgQXR0cmlidXRlQ29yZVxuICAgICAqIEB1c2VzIEF0dHJpYnV0ZU9ic2VydmFibGVcbiAgICAgKiBAdXNlcyBBdHRyaWJ1dGVFeHRyYXNcbiAgICAgKiBAdXNlcyBFdmVudFRhcmdldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHByb3BlcnR5IG5hbWUvdmFsdWUgcGFpcnMuIFRoZSBvYmplY3QgY2FuIGJlXG4gICAgICogdXNlZCB0byBwcm92aWRlIGRlZmF1bHQgdmFsdWVzIGZvciB0aGUgb2JqZWN0cyBwdWJsaXNoZWQgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIDxwPlxuICAgICAqIFRoZSBjb25maWcgb2JqZWN0IGNhbiBhbHNvIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBub24tYXR0cmlidXRlIHByb3BlcnRpZXMsIHByb3ZpZGluZyBhIGNvbnZlbmllbnRcbiAgICAgKiB3YXkgdG8gY29uZmlndXJlIGV2ZW50cyBsaXN0ZW5lcnMgYW5kIHBsdWdpbnMgZm9yIHRoZSBpbnN0YW5jZSwgYXMgcGFydCBvZiB0aGUgY29uc3RydWN0b3IgY2FsbDpcbiAgICAgKiA8L3A+XG4gICAgICpcbiAgICAgKiA8ZGw+XG4gICAgICogICA8ZHQ+b248L2R0PlxuICAgICAqICAgPGRkPkFuIGV2ZW50IG5hbWUgdG8gbGlzdGVuZXIgZnVuY3Rpb24gbWFwLCB0byByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBcIm9uXCIgbW9tZW50IG9mIHRoZSBldmVudC5cbiAgICAgKiAgICAgICBBIGNvbnN0cnVjdG9yIGNvbnZlbmllbmNlIHByb3BlcnR5IGZvciB0aGUgPGEgaHJlZj1cIkJhc2UuaHRtbCNtZXRob2Rfb25cIj5vbjwvYT4gbWV0aG9kLjwvZGQ+XG4gICAgICogICA8ZHQ+YWZ0ZXI8L2R0PlxuICAgICAqICAgPGRkPkFuIGV2ZW50IG5hbWUgdG8gbGlzdGVuZXIgZnVuY3Rpb24gbWFwLCB0byByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBcImFmdGVyXCIgbW9tZW50IG9mIHRoZSBldmVudC5cbiAgICAgKiAgICAgICBBIGNvbnN0cnVjdG9yIGNvbnZlbmllbmNlIHByb3BlcnR5IGZvciB0aGUgPGEgaHJlZj1cIkJhc2UuaHRtbCNtZXRob2RfYWZ0ZXJcIj5hZnRlcjwvYT4gbWV0aG9kLjwvZGQ+XG4gICAgICogICA8ZHQ+YnViYmxlVGFyZ2V0czwvZHQ+XG4gICAgICogICA8ZGQ+QW4gb2JqZWN0LCBvciBhcnJheSBvZiBvYmplY3RzLCB0byByZWdpc3RlciBhcyBidWJibGUgdGFyZ2V0cyBmb3IgYnViYmxlZCBldmVudHMgZmlyZWQgYnkgdGhpcyBpbnN0YW5jZS5cbiAgICAgKiAgICAgICBBIGNvbnN0cnVjdG9yIGNvbnZlbmllbmNlIHByb3BlcnR5IGZvciB0aGUgPGEgaHJlZj1cIkV2ZW50VGFyZ2V0Lmh0bWwjbWV0aG9kX2FkZFRhcmdldFwiPmFkZFRhcmdldDwvYT4gbWV0aG9kLjwvZGQ+XG4gICAgICogICA8ZHQ+cGx1Z2luczwvZHQ+XG4gICAgICogICA8ZGQ+QSBwbHVnaW4sIG9yIGFycmF5IG9mIHBsdWdpbnMgdG8gYmUgcGx1Z2dlZCBpbnRvIHRoZSBpbnN0YW5jZSAoc2VlIFBsdWdpbkhvc3QncyBwbHVnIG1ldGhvZCBmb3Igc2lnbmF0dXJlIGRldGFpbHMpLlxuICAgICAqICAgICAgIEEgY29uc3RydWN0b3IgY29udmVuaWVuY2UgcHJvcGVydHkgZm9yIHRoZSA8YSBocmVmPVwiUGx1Z2luLkhvc3QuaHRtbCNtZXRob2RfcGx1Z1wiPnBsdWc8L2E+IG1ldGhvZC48L2RkPlxuICAgICAqIDwvZGw+XG4gICAgICovXG4gICAgZnVuY3Rpb24gQmFzZSgpIHtcbiAgICAgICAgQmFzZUNvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgQmFzZU9ic2VydmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgQXR0cmlidXRlRXh0cmFzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgcHJvcGVydGllcyB3aGljaCBjYW4gYmUgY29uZmlndXJlZCBmb3JcbiAgICAgKiBlYWNoIGF0dHJpYnV0ZSAoZS5nLiBzZXR0ZXIsIGdldHRlciwgd3JpdGVPbmNlLCByZWFkT25seSBldGMuKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9BVFRSX0NGR1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQmFzZS5fQVRUUl9DRkcgPSBCYXNlQ29yZS5fQVRUUl9DRkcuY29uY2F0KEJhc2VPYnNlcnZhYmxlLl9BVFRSX0NGRyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2Ygbm9uLWF0dHJpYnV0ZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgc3VwcG9ydGVkIGJ5IHRoaXMgY2xhc3MuXG4gICAgICpcbiAgICAgKiBgQmFzZWAgc3VwcG9ydHMgXCJvblwiLCBcImFmdGVyXCIsIFwicGx1Z2luc1wiIGFuZCBcImJ1YmJsZVRhcmdldHNcIiBwcm9wZXJ0aWVzLFxuICAgICAqIHdoaWNoIGFyZSBub3Qgc2V0IHVwIGFzIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHByaW1hcmlseSByZXF1aXJlZCBzbyB0aGF0IHdoZW5cbiAgICAgKiA8YSBocmVmPVwiI3Byb3BlcnR5X19hbGxvd0FkSG9jQXR0cnNcIj5gX2FsbG93QWRIb2NBdHRyc2A8L2E+IGlzIGVuYWJsZWQgYnlcbiAgICAgKiBhIGNsYXNzLCBub24tYXR0cmlidXRlIGNvbmZpZ3VyYXRpb25zIGRvbid0IGdldCBhZGRlZCBhcyBhZC1ob2MgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfTk9OX0FUVFJTX0NGR1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQmFzZS5fTk9OX0FUVFJTX0NGRyA9IEJhc2VDb3JlLl9OT05fQVRUUlNfQ0ZHLmNvbmNhdChCYXNlT2JzZXJ2YWJsZS5fTk9OX0FUVFJTX0NGRyk7XG5cbiAgICAvKipcbiAgICAgKiA8cD5cbiAgICAgKiBUaGUgc3RyaW5nIHRvIGJlIHVzZWQgdG8gaWRlbnRpZnkgaW5zdGFuY2VzIG9mXG4gICAgICogdGhpcyBjbGFzcywgZm9yIGV4YW1wbGUgaW4gcHJlZml4aW5nIGV2ZW50cy5cbiAgICAgKiA8L3A+XG4gICAgICogPHA+XG4gICAgICogQ2xhc3NlcyBleHRlbmRpbmcgQmFzZSwgc2hvdWxkIGRlZmluZSB0aGVpciBvd25cbiAgICAgKiBzdGF0aWMgTkFNRSBwcm9wZXJ0eSwgd2hpY2ggc2hvdWxkIGJlIGNhbWVsQ2FzZSBieVxuICAgICAqIGNvbnZlbnRpb24gKGUuZy4gTXlDbGFzcy5OQU1FID0gXCJteUNsYXNzXCI7KS5cbiAgICAgKiA8L3A+XG4gICAgICogQHByb3BlcnR5IE5BTUVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgQmFzZS5OQU1FID0gJ2Jhc2UnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc2V0IG9mIGF0dHJpYnV0ZXMgd2hpY2ggd2lsbCBiZSBhdmFpbGFibGUgZm9yIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLCBhbmRcbiAgICAgKiB0aGVpciBjb25maWd1cmF0aW9uLiBJbiBhZGRpdGlvbiB0byB0aGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGxpc3RlZCBieVxuICAgICAqIEF0dHJpYnV0ZSdzIDxhIGhyZWY9XCJBdHRyaWJ1dGUuaHRtbCNtZXRob2RfYWRkQXR0clwiPmFkZEF0dHI8L2E+IG1ldGhvZCwgdGhlIGF0dHJpYnV0ZVxuICAgICAqIGNhbiBhbHNvIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIFwiY2xvbmVEZWZhdWx0VmFsdWVcIiBwcm9wZXJ0eSwgd2hpY2ggZGVmaW5lcyBob3cgdGhlIHN0YXRpY2FsbHlcbiAgICAgKiBkZWZpbmVkIHZhbHVlIGZpZWxkIHNob3VsZCBiZSBwcm90ZWN0ZWQgKFwic2hhbGxvd1wiLCBcImRlZXBcIiBhbmQgZmFsc2UgYXJlIHN1cHBvcnRlZCB2YWx1ZXMpLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYW4gYXJyYXkgaXQgd2lsbCBiZSBcInNoYWxsb3dcIiBjbG9uZWQsIHRvXG4gICAgICogcHJvdGVjdCB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBBVFRSU1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBCYXNlLkFUVFJTID0gQXR0cmlidXRlQ29yZS5wcm90ZWN0QXR0cnMoQmFzZUNvcmUuQVRUUlMpO1xuXG4gICAgLyoqXG4gICAgUHJvdmlkZXMgYSB3YXkgdG8gc2FmZWx5IG1vZGlmeSBhIGBZLkJhc2VgIHN1YmNsYXNzJyBzdGF0aWMgYEFUVFJTYCBhZnRlclxuICAgIHRoZSBjbGFzcyBoYXMgYmVlbiBkZWZpbmVkIG9yIGNyZWF0ZWQuXG5cbiAgICBCYXNlLWJhc2VkIGNsYXNzZXMgY2FjaGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsYXNzIGhpZXJhcmNoeSBpbiBvcmRlciB0b1xuICAgIGVmZmljaWVudGx5IGNyZWF0ZSBpbnN0YW5jZXMuIFRoaXMgY2FjaGUgaW5jbHVkZXMgaW5jbHVkZXMgdGhlIGFnZ3JlZ2F0ZWRcbiAgICBgQVRUUlNgIGNvbmZpZ3MuIElmIHRoZSBzdGF0aWMgYEFUVFJTYCBjb25maWdzIG5lZWQgdG8gYmUgbW9kaWZpZWQgYWZ0ZXIgdGhlXG4gICAgY2xhc3MgaGFzIGJlZW4gZGVmaW5lZCBvciBjcmVhdGUsIHRoZW4gdXNlIHRoaXMgbWV0aG9kIHdoaWNoIHdpbGwgbWFrZSBzdXJlXG4gICAgdG8gY2xlYXIgYW55IGNhY2hlZCBkYXRhIGJlZm9yZSBtYWtpbmcgYW55IG1vZGlmaWNhdGlvbnMuXG5cbiAgICBAbWV0aG9kIG1vZGlmeUF0dHJzXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2N0b3JdIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aG9zZSBgQVRUUlNgIHNob3VsZCBiZVxuICAgICAgICBtb2RpZmllZC4gSWYgYSBgY3RvcmAgZnVuY3Rpb24gaXMgbm90IHNwZWNpZmllZCwgdGhlbiBgdGhpc2AgaXMgYXNzdW1lZFxuICAgICAgICB0byBiZSB0aGUgY29uc3RydWN0b3Igd2hpY2ggaG9zdHMgdGhlIGBBVFRSU2AuXG4gICAgQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3MgVGhlIGNvbGxlY3Rpb24gb2YgYEFUVFJTYCBjb25maWdzIHRvIG1peCB3aXRoIHRoZVxuICAgICAgICBleGlzdGluZyBhdHRyaWJ1dGUgY29uZmlndXJhdGlvbnMuXG4gICAgQHN0YXRpY1xuICAgIEBzaW5jZSAzLjEwLjBcbiAgICAqKi9cbiAgICBCYXNlLm1vZGlmeUF0dHJzID0gQmFzZUNvcmUubW9kaWZ5QXR0cnM7XG5cbiAgICBZLm1peChCYXNlLCBCYXNlQ29yZSwgZmFsc2UsIG51bGwsIDEpO1xuICAgIFkubWl4KEJhc2UsIEF0dHJpYnV0ZUV4dHJhcywgZmFsc2UsIG51bGwsIDEpO1xuXG4gICAgLy8gTmVlZHMgdG8gYmUgYHRydWVgLCB0byBvdmVyd3JpdGUgbWV0aG9kcyBmcm9tIGBCYXNlQ29yZWAuXG4gICAgWS5taXgoQmFzZSwgQmFzZU9ic2VydmFibGUsIHRydWUsIG51bGwsIDEpO1xuXG4gICAgLy8gRml4IGNvbnN0cnVjdG9yXG4gICAgQmFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCYXNlO1xuXG4gICAgWS5CYXNlID0gQmFzZTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiYXR0cmlidXRlLWJhc2VcIiwgXCJiYXNlLWNvcmVcIiwgXCJiYXNlLW9ic2VydmFibGVcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnYmFzZS1idWlsZCcsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZS1idWlsZCBzdWJtb2R1bGUgcHJvdmlkZXMgQmFzZS5idWlsZCBmdW5jdGlvbmFsaXR5LCB3aGljaFxuICAgICAqIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBjdXN0b20gY2xhc3NlcywgYnkgYWdncmVnYXRpbmcgZXh0ZW5zaW9ucyBvbnRvXG4gICAgICogYSBtYWluIGNsYXNzLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBiYXNlXG4gICAgICogQHN1Ym1vZHVsZSBiYXNlLWJ1aWxkXG4gICAgICogQGZvciBCYXNlXG4gICAgICovXG4gICAgdmFyIEJhc2VDb3JlID0gWS5CYXNlQ29yZSxcbiAgICAgICAgQmFzZSAgICAgPSBZLkJhc2UsXG4gICAgICAgIEwgICAgICAgID0gWS5MYW5nLFxuXG4gICAgICAgIElOSVRJQUxJWkVSID0gXCJpbml0aWFsaXplclwiLFxuICAgICAgICBERVNUUlVDVE9SICA9IFwiZGVzdHJ1Y3RvclwiLFxuICAgICAgICBBR0dSRUdBVEVTICA9IFtcIl9QTFVHXCIsIFwiX1VOUExVR1wiXSxcblxuICAgICAgICBidWlsZDtcblxuICAgIC8vIFV0aWxpdHkgZnVuY3Rpb24gdXNlZCBpbiBgX2J1aWxkQ2ZnYCB0byBhZ2dyZWdhdGUgYXJyYXkgdmFsdWVzIGludG8gYSBuZXdcbiAgICAvLyBhcnJheSBmcm9tIHRoZSBzZW5kZXIgY29uc3RydWN0b3IgdG8gdGhlIHJlY2VpdmVyIGNvbnN0cnVjdG9yLlxuICAgIGZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihwcm9wLCByLCBzKSB7XG4gICAgICAgIGlmIChzW3Byb3BdKSB7XG4gICAgICAgICAgICByW3Byb3BdID0gKHJbcHJvcF0gfHwgW10pLmNvbmNhdChzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFV0aWxpdHkgZnVuY3Rpb24gdXNlZCBpbiBgX2J1aWxkQ2ZnYCB0byBhZ2dyZWdhdGUgYF9BVFRSX0NGR2AgYXJyYXlcbiAgICAvLyB2YWx1ZXMgZnJvbSB0aGUgc2VuZGVyIGNvbnN0cnVjdG9yIGludG8gYSBuZXcgYXJyYXkgb24gcmVjZWl2ZXInc1xuICAgIC8vIGNvbnN0cnVjdG9yLCBhbmQgY2xlYXIgdGhlIGNhY2hlZCBoYXNoLlxuICAgIGZ1bmN0aW9uIGF0dHJDZmdBZ2dyZWdhdG9yKHByb3AsIHIsIHMpIHtcbiAgICAgICAgaWYgKHMuX0FUVFJfQ0ZHKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBjYWNoZWQgaGFzaC5cbiAgICAgICAgICAgIHIuX0FUVFJfQ0ZHX0hBU0ggPSBudWxsO1xuXG4gICAgICAgICAgICBhcnJheUFnZ3JlZ2F0b3IuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFV0aWxpdHkgZnVuY3Rpb24gdXNlZCBpbiBgX2J1aWxkQ2ZnYCB0byBhZ2dyZWdhdGUgQVRUUlMgY29uZmlncyBmcm9tIG9uZVxuICAgIC8vIHRoZSBzZW5kZXIgY29uc3RydWN0b3IgdG8gdGhlIHJlY2VpdmVyIGNvbnN0cnVjdG9yLlxuICAgIGZ1bmN0aW9uIGF0dHJzQWdncmVnYXRvcihwcm9wLCByLCBzKSB7XG4gICAgICAgIEJhc2VDb3JlLm1vZGlmeUF0dHJzKHIsIHMuQVRUUlMpO1xuICAgIH1cblxuICAgIEJhc2UuX2J1aWxkID0gZnVuY3Rpb24obmFtZSwgbWFpbiwgZXh0ZW5zaW9ucywgcHgsIHN4LCBjZmcpIHtcblxuICAgICAgICB2YXIgYnVpbGQgPSBCYXNlLl9idWlsZCxcblxuICAgICAgICAgICAgYnVpbHRDbGFzcyA9IGJ1aWxkLl9jdG9yKG1haW4sIGNmZyksXG4gICAgICAgICAgICBidWlsZENmZyA9IGJ1aWxkLl9jZmcobWFpbiwgY2ZnLCBleHRlbnNpb25zKSxcblxuICAgICAgICAgICAgX21peEN1c3QgPSBidWlsZC5fbWl4Q3VzdCxcblxuICAgICAgICAgICAgZHluYW1pYyA9IGJ1aWx0Q2xhc3MuX3l1aWJ1aWxkLmR5bmFtaWMsXG5cbiAgICAgICAgICAgIGksIGwsIGV4dENsYXNzLCBleHRQcm90byxcbiAgICAgICAgICAgIGluaXRpYWxpemVyLFxuICAgICAgICAgICAgZGVzdHJ1Y3RvcjtcblxuICAgICAgICAvLyBBdWdtZW50L0FnZ3JlZ2F0ZVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGV4dENsYXNzID0gZXh0ZW5zaW9uc1tpXTtcblxuICAgICAgICAgICAgZXh0UHJvdG8gPSBleHRDbGFzcy5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgIGluaXRpYWxpemVyID0gZXh0UHJvdG9bSU5JVElBTElaRVJdO1xuICAgICAgICAgICAgZGVzdHJ1Y3RvciA9IGV4dFByb3RvW0RFU1RSVUNUT1JdO1xuICAgICAgICAgICAgZGVsZXRlIGV4dFByb3RvW0lOSVRJQUxJWkVSXTtcbiAgICAgICAgICAgIGRlbGV0ZSBleHRQcm90b1tERVNUUlVDVE9SXTtcblxuICAgICAgICAgICAgLy8gUHJvdG90eXBlLCBvbGQgbm9uLWRpc3BsYWNpbmcgYXVnbWVudFxuICAgICAgICAgICAgWS5taXgoYnVpbHRDbGFzcywgZXh0Q2xhc3MsIHRydWUsIG51bGwsIDEpO1xuXG4gICAgICAgICAgICAvLyBDdXN0b20gU3RhdGljc1xuICAgICAgICAgICAgX21peEN1c3QoYnVpbHRDbGFzcywgZXh0Q2xhc3MsIGJ1aWxkQ2ZnKTtcblxuICAgICAgICAgICAgaWYgKGluaXRpYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgZXh0UHJvdG9bSU5JVElBTElaRVJdID0gaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgZXh0UHJvdG9bREVTVFJVQ1RPUl0gPSBkZXN0cnVjdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWlsdENsYXNzLl95dWlidWlsZC5leHRzLnB1c2goZXh0Q2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHB4KSB7XG4gICAgICAgICAgICBZLm1peChidWlsdENsYXNzLnByb3RvdHlwZSwgcHgsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN4KSB7XG4gICAgICAgICAgICBZLm1peChidWlsdENsYXNzLCBidWlsZC5fY2xlYW4oc3gsIGJ1aWxkQ2ZnKSwgdHJ1ZSk7XG4gICAgICAgICAgICBfbWl4Q3VzdChidWlsdENsYXNzLCBzeCwgYnVpbGRDZmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVpbHRDbGFzcy5wcm90b3R5cGUuaGFzSW1wbCA9IGJ1aWxkLl9pbXBsO1xuXG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBidWlsdENsYXNzLk5BTUUgPSBuYW1lO1xuICAgICAgICAgICAgYnVpbHRDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBidWlsdENsYXNzO1xuXG4gICAgICAgICAgICAvLyBDYXJyeSBhbG9uZyB0aGUgcmVmZXJlbmNlIHRvIGBtb2RpZnlBdHRycygpYCBmcm9tIGBtYWluYC5cbiAgICAgICAgICAgIGJ1aWx0Q2xhc3MubW9kaWZ5QXR0cnMgPSBtYWluLm1vZGlmeUF0dHJzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1aWx0Q2xhc3M7XG4gICAgfTtcblxuICAgIGJ1aWxkID0gQmFzZS5fYnVpbGQ7XG5cbiAgICBZLm1peChidWlsZCwge1xuXG4gICAgICAgIF9taXhDdXN0OiBmdW5jdGlvbihyLCBzLCBjZmcpIHtcblxuICAgICAgICAgICAgdmFyIGFnZ3JlZ2F0ZXMsXG4gICAgICAgICAgICAgICAgY3VzdG9tLFxuICAgICAgICAgICAgICAgIHN0YXRpY3MsXG4gICAgICAgICAgICAgICAgYWdncixcbiAgICAgICAgICAgICAgICBsLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGlmIChjZmcpIHtcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVzID0gY2ZnLmFnZ3JlZ2F0ZXM7XG4gICAgICAgICAgICAgICAgY3VzdG9tID0gY2ZnLmN1c3RvbTtcbiAgICAgICAgICAgICAgICBzdGF0aWNzID0gY2ZnLnN0YXRpY3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0aWNzKSB7XG4gICAgICAgICAgICAgICAgWS5taXgociwgcywgdHJ1ZSwgc3RhdGljcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGFnZ3JlZ2F0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFnZ3IgPSBhZ2dyZWdhdGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXIuaGFzT3duUHJvcGVydHkoYWdncikgJiYgcy5oYXNPd25Qcm9wZXJ0eShhZ2dyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgclthZ2dyXSA9IEwuaXNBcnJheShzW2FnZ3JdKSA/IFtdIDoge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgWS5hZ2dyZWdhdGUociwgcywgdHJ1ZSwgW2FnZ3JdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXN0b20pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gY3VzdG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXN0b20uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVtpXShpLCByLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIF90bXBsOiBmdW5jdGlvbihtYWluKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEJ1aWx0Q2xhc3MoKSB7XG4gICAgICAgICAgICAgICAgQnVpbHRDbGFzcy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBZLmV4dGVuZChCdWlsdENsYXNzLCBtYWluKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJ1aWx0Q2xhc3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2ltcGwgOiBmdW5jdGlvbihleHRDbGFzcykge1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKCksIGksIGwsIGNscywgZXh0cywgbGwsIGo7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjbHMgPSBjbGFzc2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjbHMuX3l1aWJ1aWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHMgPSBjbHMuX3l1aWJ1aWxkLmV4dHM7XG4gICAgICAgICAgICAgICAgICAgIGxsID0gZXh0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxsOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRzW2pdID09PSBleHRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jdG9yIDogZnVuY3Rpb24obWFpbiwgY2ZnKSB7XG5cbiAgICAgICAgICAgdmFyIGR5bmFtaWMgPSAoY2ZnICYmIGZhbHNlID09PSBjZmcuZHluYW1pYykgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgICAgICAgICBidWlsdENsYXNzID0gKGR5bmFtaWMpID8gYnVpbGQuX3RtcGwobWFpbikgOiBtYWluLFxuICAgICAgICAgICAgICAgYnVpbGRDZmcgPSBidWlsdENsYXNzLl95dWlidWlsZDtcblxuICAgICAgICAgICAgaWYgKCFidWlsZENmZykge1xuICAgICAgICAgICAgICAgIGJ1aWxkQ2ZnID0gYnVpbHRDbGFzcy5feXVpYnVpbGQgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVpbGRDZmcuaWQgPSBidWlsZENmZy5pZCB8fCBudWxsO1xuICAgICAgICAgICAgYnVpbGRDZmcuZXh0cyA9IGJ1aWxkQ2ZnLmV4dHMgfHwgW107XG4gICAgICAgICAgICBidWlsZENmZy5keW5hbWljID0gZHluYW1pYztcblxuICAgICAgICAgICAgcmV0dXJuIGJ1aWx0Q2xhc3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NmZyA6IGZ1bmN0aW9uKG1haW4sIGNmZywgZXh0cykge1xuICAgICAgICAgICAgdmFyIGFnZ3IgPSBbXSxcbiAgICAgICAgICAgICAgICBjdXN0ID0ge30sXG4gICAgICAgICAgICAgICAgc3RhdGljcyA9IFtdLFxuICAgICAgICAgICAgICAgIGJ1aWxkQ2ZnLFxuICAgICAgICAgICAgICAgIGNmZ0FnZ3IgPSAoY2ZnICYmIGNmZy5hZ2dyZWdhdGVzKSxcbiAgICAgICAgICAgICAgICBjZmdDdXN0QnVpbGQgPSAoY2ZnICYmIGNmZy5jdXN0b20pLFxuICAgICAgICAgICAgICAgIGNmZ1N0YXRpY3MgPSAoY2ZnICYmIGNmZy5zdGF0aWNzKSxcbiAgICAgICAgICAgICAgICBjID0gbWFpbixcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGw7XG5cbiAgICAgICAgICAgIC8vIFByb3RvdHlwZSBDaGFpblxuICAgICAgICAgICAgd2hpbGUgKGMgJiYgYy5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBidWlsZENmZyA9IGMuX2J1aWxkQ2ZnO1xuICAgICAgICAgICAgICAgIGlmIChidWlsZENmZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVpbGRDZmcuYWdncmVnYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdnciA9IGFnZ3IuY29uY2F0KGJ1aWxkQ2ZnLmFnZ3JlZ2F0ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWlsZENmZy5jdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFkubWl4KGN1c3QsIGJ1aWxkQ2ZnLmN1c3RvbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1aWxkQ2ZnLnN0YXRpY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY3MgPSBzdGF0aWNzLmNvbmNhdChidWlsZENmZy5zdGF0aWNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjID0gYy5zdXBlcmNsYXNzID8gYy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yIDogbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXh0c1xuICAgICAgICAgICAgaWYgKGV4dHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGV4dHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkQ2ZnID0gYy5fYnVpbGRDZmc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWlsZENmZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1aWxkQ2ZnLmFnZ3JlZ2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2dyID0gYWdnci5jb25jYXQoYnVpbGRDZmcuYWdncmVnYXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVpbGRDZmcuY3VzdG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWS5taXgoY3VzdCwgYnVpbGRDZmcuY3VzdG9tLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWlsZENmZy5zdGF0aWNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljcyA9IHN0YXRpY3MuY29uY2F0KGJ1aWxkQ2ZnLnN0YXRpY3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2ZnQWdncikge1xuICAgICAgICAgICAgICAgIGFnZ3IgPSBhZ2dyLmNvbmNhdChjZmdBZ2dyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNmZ0N1c3RCdWlsZCkge1xuICAgICAgICAgICAgICAgIFkubWl4KGN1c3QsIGNmZy5jZmdCdWlsZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjZmdTdGF0aWNzKSB7XG4gICAgICAgICAgICAgICAgc3RhdGljcyA9IHN0YXRpY3MuY29uY2F0KGNmZ1N0YXRpY3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZXM6IGFnZ3IsXG4gICAgICAgICAgICAgICAgY3VzdG9tOiBjdXN0LFxuICAgICAgICAgICAgICAgIHN0YXRpY3M6IHN0YXRpY3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFuIDogZnVuY3Rpb24oc3gsIGNmZykge1xuICAgICAgICAgICAgdmFyIHByb3AsIGksIGwsIHN4Y2xvbmUgPSBZLm1lcmdlKHN4KSxcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVzID0gY2ZnLmFnZ3JlZ2F0ZXMsXG4gICAgICAgICAgICAgICAgY3VzdG9tID0gY2ZnLmN1c3RvbTtcblxuICAgICAgICAgICAgZm9yIChwcm9wIGluIGN1c3RvbSkge1xuICAgICAgICAgICAgICAgIGlmIChzeGNsb25lLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzeGNsb25lW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGFnZ3JlZ2F0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGFnZ3JlZ2F0ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHN4Y2xvbmUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN4Y2xvbmVbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3hjbG9uZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogPHA+XG4gICAgICogQnVpbGRzIGEgY3VzdG9tIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIChjbGFzcykgZnJvbSB0aGVcbiAgICAgKiBtYWluIGZ1bmN0aW9uLCBhbmQgYXJyYXkgb2YgZXh0ZW5zaW9uIGZ1bmN0aW9ucyAoY2xhc3NlcylcbiAgICAgKiBwcm92aWRlZC4gVGhlIE5BTUUgZmllbGQgZm9yIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpc1xuICAgICAqIGRlZmluZWQgYnkgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCBpbi5cbiAgICAgKiA8L3A+XG4gICAgICogPHA+XG4gICAgICogVGhlIGNmZyBvYmplY3Qgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzXG4gICAgICogPC9wPlxuICAgICAqIDxkbD5cbiAgICAgKiAgICA8ZHQ+ZHluYW1pYyAmIzYwO2Jvb2xlYW4mIzYyOzwvZHQ+XG4gICAgICogICAgPGRkPlxuICAgICAqICAgIDxwPklmIHRydWUgKGRlZmF1bHQpLCBhIGNvbXBsZXRlbHkgbmV3IGNsYXNzXG4gICAgICogICAgaXMgY3JlYXRlZCB3aGljaCBleHRlbmRzIHRoZSBtYWluIGNsYXNzLCBhbmQgYWN0cyBhcyB0aGVcbiAgICAgKiAgICBob3N0IG9uIHdoaWNoIHRoZSBleHRlbnNpb24gY2xhc3NlcyBhcmUgYXVnbWVudGVkLjwvcD5cbiAgICAgKiAgICA8cD5JZiBmYWxzZSwgdGhlIGV4dGVuc2lvbnMgY2xhc3NlcyBhcmUgYXVnbWVudGVkIGRpcmVjdGx5IHRvXG4gICAgICogICAgdGhlIG1haW4gY2xhc3MsIG1vZGlmeWluZyB0aGUgbWFpbiBjbGFzcycgcHJvdG90eXBlLjwvcD5cbiAgICAgKiAgICA8L2RkPlxuICAgICAqICAgIDxkdD5hZ2dyZWdhdGVzICYjNjA7U3RyaW5nW10mIzYyOzwvZHQ+XG4gICAgICogICAgPGRkPkFuIGFycmF5IG9mIHN0YXRpYyBwcm9wZXJ0eSBuYW1lcywgd2hpY2ggd2lsbCBnZXQgYWdncmVnYXRlZFxuICAgICAqICAgIG9uIHRvIHRoZSBidWlsdCBjbGFzcywgaW4gYWRkaXRpb24gdG8gdGhlIGRlZmF1bHQgcHJvcGVydGllcyBidWlsZFxuICAgICAqICAgIHdpbGwgYWx3YXlzIGFnZ3JlZ2F0ZSBhcyBkZWZpbmVkIGJ5IHRoZSBtYWluIGNsYXNzJyBzdGF0aWMgX2J1aWxkQ2ZnXG4gICAgICogICAgcHJvcGVydHkuXG4gICAgICogICAgPC9kZD5cbiAgICAgKiA8L2RsPlxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZFxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgbW9yZSBjb252ZW5pZW50IEJhc2UuY3JlYXRlIGFuZCBCYXNlLm1peCBtZXRob2RzIGluc3RlYWRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IGNsYXNzLiBVc2VkIHRvIGRlZmluZSB0aGUgTkFNRSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYWluIFRoZSBtYWluIGNsYXNzIG9uIHdoaWNoIHRvIGJhc2UgdGhlIGJ1aWx0IGNsYXNzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBleHRlbnNpb25zIFRoZSBzZXQgb2YgZXh0ZW5zaW9uIGNsYXNzZXMgd2hpY2ggd2lsbCBiZVxuICAgICAqIGF1Z21lbnRlZC9hZ2dyZWdhdGVkIHRvIHRoZSBidWlsdCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIE9wdGlvbmFsLiBCdWlsZCBjb25maWd1cmF0aW9uIGZvciB0aGUgY2xhc3MgKHNlZSBkZXNjcmlwdGlvbikuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgY3VzdG9tIGNsYXNzLCBjcmVhdGVkIGZyb20gdGhlIHByb3ZpZGVkIG1haW4gYW5kIGV4dGVuc2lvbiBjbGFzc2VzXG4gICAgICovXG4gICAgQmFzZS5idWlsZCA9IGZ1bmN0aW9uKG5hbWUsIG1haW4sIGV4dGVuc2lvbnMsIGNmZykge1xuICAgICAgICByZXR1cm4gYnVpbGQobmFtZSwgbWFpbiwgZXh0ZW5zaW9ucywgbnVsbCwgbnVsbCwgY2ZnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjbGFzcyAoY29uc3RydWN0b3IgZnVuY3Rpb24pIHdoaWNoIGV4dGVuZHMgdGhlIGJhc2UgY2xhc3MgcGFzc2VkIGluIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsXG4gICAgICogYW5kIG1peGVzIGluIHRoZSBhcnJheSBvZiBleHRlbnNpb25zIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogUHJvdG90eXBlIHByb3BlcnRpZXMgb3IgbWV0aG9kcyBjYW4gYmUgYWRkZWQgdG8gdGhlIG5ldyBjbGFzcywgdXNpbmcgdGhlIHB4IGFyZ3VtZW50IChzaW1pbGFyIHRvIFkuZXh0ZW5kKS5cbiAgICAgKlxuICAgICAqIFN0YXRpYyBwcm9wZXJ0aWVzIG9yIG1ldGhvZHMgY2FuIGJlIGFkZGVkIHRvIHRoZSBuZXcgY2xhc3MsIHVzaW5nIHRoZSBzeCBhcmd1bWVudCAoc2ltaWxhciB0byBZLmV4dGVuZCkuXG4gICAgICpcbiAgICAgKiAqKk5PVEUgRk9SIENPTVBPTkVOVCBERVZFTE9QRVJTKio6IEJvdGggdGhlIGBiYXNlYCBjbGFzcywgYW5kIGBleHRlbnNpb25zYCBjYW4gZGVmaW5lIHN0YXRpYyBhIGBfYnVpbGRDZmdgXG4gICAgICogcHJvcGVydHksIHdoaWNoIGFjdHMgYXMgY2xhc3MgY3JlYXRpb24gbWV0YS1kYXRhLCBhbmQgZHJpdmVzIGhvdyBzcGVjaWFsIHN0YXRpYyBwcm9wZXJ0aWVzIGZyb20gdGhlIGJhc2VcbiAgICAgKiBjbGFzcywgb3IgZXh0ZW5zaW9ucyBzaG91bGQgYmUgY29waWVkLCBhZ2dyZWdhdGVkIG9yIChjdXN0b20pIG1peGVkIGludG8gdGhlIG5ld2x5IGNyZWF0ZWQgY2xhc3MuXG4gICAgICpcbiAgICAgKiBUaGUgYF9idWlsZENmZ2AgcHJvcGVydHkgaXMgYSBoYXNoIHdpdGggMyBzdXBwb3J0ZWQgcHJvcGVydGllczogYHN0YXRpY3NgLCBgYWdncmVnYXRlc2AgYW5kIGBjdXN0b21gLCBlLmc6XG4gICAgICpcbiAgICAgKiAgICAgLy8gSWYgdGhlIEJhc2UvTWFpbiBjbGFzcyBpcyB0aGUgdGhpbmcgaW50cm9kdWNpbmcgdGhlIHByb3BlcnR5OlxuICAgICAqXG4gICAgICogICAgIE15QmFzZUNsYXNzLl9idWlsZENmZyA9IHtcbiAgICAgKlxuICAgICAqICAgICAgICAvLyBTdGF0aWMgcHJvcGVydGllcy9tZXRob2RzIHRvIGNvcHkgKEFsaWFzKSB0byB0aGUgYnVpbHQgY2xhc3MuXG4gICAgICogICAgICAgIHN0YXRpY3M6IFtcIkNvcHlUaGlzTWV0aG9kXCIsIFwiQ29weVRoaXNQcm9wZXJ0eVwiXSxcbiAgICAgKlxuICAgICAqICAgICAgICAvLyBTdGF0aWMgcHJvcHMgdG8gYWdncmVnYXRlIG9udG8gdGhlIGJ1aWx0IGNsYXNzLlxuICAgICAqICAgICAgICBhZ2dyZWdhdGVzOiBbXCJBZ2dyZWdhdGVUaGlzUHJvcGVydHlcIl0sXG4gICAgICpcbiAgICAgKiAgICAgICAgLy8gU3RhdGljIHByb3BlcnRpZXMgd2hpY2ggbmVlZCBjdXN0b20gaGFuZGxpbmcgKGUuZy4gZGVlcCBtZXJnZSBldGMuKVxuICAgICAqICAgICAgICBjdXN0b206IHtcbiAgICAgKiAgICAgICAgICAgXCJDdXN0b21Qcm9wZXJ0eVwiIDogZnVuY3Rpb24ocHJvcGVydHksIFJlY2VpdmVyLCBTdXBwbGllcikge1xuICAgICAqICAgICAgICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgICAgICAgdmFyIHRyaWdnZXJzID0gUmVjZWl2ZXIuQ3VzdG9tUHJvcGVydHkudHJpZ2dlcnM7XG4gICAgICogICAgICAgICAgICAgIFJlY2VpdmVyLkN1c3RvbVByb3BlcnR5LnRyaWdnZXJzID0gdHJpZ2dlcnMuY29uY2F0KFN1cHBsaWVyLkN1c3RvbVByb3BlcnR5LnRyaWdnZXJzKTtcbiAgICAgKiAgICAgICAgICAgICAgLi4uXG4gICAgICogICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICB9O1xuICAgICAqXG4gICAgICogICAgIE15QmFzZUNsYXNzLkNvcHlUaGlzTWV0aG9kID0gZnVuY3Rpb24oKSB7Li4ufTtcbiAgICAgKiAgICAgTXlCYXNlQ2xhc3MuQ29weVRoaXNQcm9wZXJ0eSA9IFwiZm9vXCI7XG4gICAgICogICAgIE15QmFzZUNsYXNzLkFnZ3JlZ2F0ZVRoaXNQcm9wZXJ0eSA9IHsuLi59O1xuICAgICAqICAgICBNeUJhc2VDbGFzcy5DdXN0b21Qcm9wZXJ0eSA9IHtcbiAgICAgKiAgICAgICAgdHJpZ2dlcnM6IFsuLi5dXG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICAvLyBPciwgaWYgdGhlIEV4dGVuc2lvbiBpcyB0aGUgdGhpbmcgaW50cm9kdWNpbmcgdGhlIHByb3BlcnR5OlxuICAgICAqXG4gICAgICogICAgIE15RXh0ZW5zaW9uLl9idWlsZENmZyA9IHtcbiAgICAgKiAgICAgICAgIHN0YXRpY3MgOiAuLi5cbiAgICAgKiAgICAgICAgIGFnZ3JlZ2F0ZXMgOiAuLi5cbiAgICAgKiAgICAgICAgIGN1c3RvbSA6IC4uLlxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBUaGlzIHdheSwgd2hlbiB1c2VycyBwYXNzIHlvdXIgYmFzZSBvciBleHRlbnNpb24gY2xhc3MgdG8gYFkuQmFzZS5jcmVhdGVgIG9yIGBZLkJhc2UubWl4YCwgdGhleSBkb24ndCBuZWVkIHRvXG4gICAgICoga25vdyB3aGljaCBwcm9wZXJ0aWVzIG5lZWQgc3BlY2lhbCBoYW5kbGluZy4gYFkuQmFzZWAgaGFzIGEgYnVpbGRDZmcgd2hpY2ggZGVmaW5lcyBgQVRUUlNgIGZvciBjdXN0b20gbWl4IGhhbmRsaW5nXG4gICAgICogKHRvIHByb3RlY3QgdGhlIHN0YXRpYyBjb25maWcgb2JqZWN0cyksIGFuZCBgWS5XaWRnZXRgIGhhcyBhIGJ1aWxkQ2ZnIHdoaWNoIHNwZWNpZmllcyBgSFRNTF9QQVJTRVJgIGZvclxuICAgICAqIHN0cmFpZ2h0IHVwIGFnZ3JlZ2F0aW9uLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgY2xhc3MuIFVzZWQgdG8gZGVmaW5lIHRoZSBOQU1FIHByb3BlcnR5IGZvciB0aGUgbmV3IGNsYXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1haW4gVGhlIGJhc2UgY2xhc3Mgd2hpY2ggdGhlIG5ldyBjbGFzcyBzaG91bGQgZXh0ZW5kLlxuICAgICAqIFRoaXMgY2xhc3MgbmVlZHMgdG8gYmUgQmFzZSBvciBhIGNsYXNzIGRlcml2ZWQgZnJvbSBiYXNlIChlLmcuIFdpZGdldCkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBleHRlbnNpb25zIFRoZSBsaXN0IG9mIGV4dGVuc2lvbnMgd2hpY2ggd2lsbCBiZSBtaXhlZCBpbnRvIHRoZSBidWlsdCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHggVGhlIHNldCBvZiBwcm90b3R5cGUgcHJvcGVydGllcy9tZXRob2RzIHRvIGFkZCB0byB0aGUgYnVpbHQgY2xhc3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN4IFRoZSBzZXQgb2Ygc3RhdGljIHByb3BlcnRpZXMvbWV0aG9kcyB0byBhZGQgdG8gdGhlIGJ1aWx0IGNsYXNzLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbmV3bHkgY3JlYXRlZCBjbGFzcy5cbiAgICAgKi9cbiAgICBCYXNlLmNyZWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIGJhc2UsIGV4dGVuc2lvbnMsIHB4LCBzeCkge1xuICAgICAgICBpZiAoWS5jb25maWcud2luID09PSBZLmNvbmZpZy53aW4udG9wKSB7XG4gICAgICAgICAgICBZVUkuc3RhdHMubWFya0NyZWF0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGQobmFtZSwgYmFzZSwgZXh0ZW5zaW9ucywgcHgsIHN4KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogPHA+TWl4ZXMgaW4gYSBsaXN0IG9mIGV4dGVuc2lvbnMgdG8gYW4gZXhpc3RpbmcgY2xhc3MuPC9wPlxuICAgICAqIEBtZXRob2QgbWl4XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1haW4gVGhlIGV4aXN0aW5nIGNsYXNzIGludG8gd2hpY2ggdGhlIGV4dGVuc2lvbnMgc2hvdWxkIGJlIG1peGVkLlxuICAgICAqIFRoZSBjbGFzcyBuZWVkcyB0byBiZSBCYXNlIG9yIGEgY2xhc3MgZGVyaXZlZCBmcm9tIEJhc2UgKGUuZy4gV2lkZ2V0KVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gZXh0ZW5zaW9ucyBUaGUgc2V0IG9mIGV4dGVuc2lvbiBjbGFzc2VzIHdoaWNoIHdpbGwgbWl4ZWQgaW50byB0aGUgZXhpc3RpbmcgbWFpbiBjbGFzcy5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIG1vZGlmaWVkIG1haW4gY2xhc3MsIHdpdGggZXh0ZW5zaW9ucyBtaXhlZCBpbi5cbiAgICAgKi9cbiAgICBCYXNlLm1peCA9IGZ1bmN0aW9uKG1haW4sIGV4dGVuc2lvbnMpIHtcblxuICAgICAgICBpZiAobWFpbi5fQ0FDSEVEX0NMQVNTX0RBVEEpIHtcbiAgICAgICAgICAgIG1haW4uX0NBQ0hFRF9DTEFTU19EQVRBID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidWlsZChudWxsLCBtYWluLCBleHRlbnNpb25zLCBudWxsLCBudWxsLCB7ZHluYW1pYzpmYWxzZX0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYnVpbGQgY29uZmlndXJhdGlvbiBmb3IgdGhlIEJhc2UgY2xhc3MuXG4gICAgICpcbiAgICAgKiBEZWZpbmVzIHRoZSBzdGF0aWMgZmllbGRzIHdoaWNoIG5lZWQgdG8gYmUgYWdncmVnYXRlZCB3aGVuIHRoZSBCYXNlIGNsYXNzXG4gICAgICogaXMgdXNlZCBhcyB0aGUgbWFpbiBjbGFzcyBwYXNzZWQgdG8gdGhlXG4gICAgICogPGEgaHJlZj1cIiNtZXRob2RfQmFzZS5idWlsZFwiPkJhc2UuYnVpbGQ8L2E+IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfYnVpbGRDZmdcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZpbmFsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBCYXNlQ29yZS5fYnVpbGRDZmcgPSB7XG4gICAgICAgIGFnZ3JlZ2F0ZXM6IEFHR1JFR0FURVMuY29uY2F0KCksXG5cbiAgICAgICAgY3VzdG9tOiB7XG4gICAgICAgICAgICBBVFRSUyAgICAgICAgIDogYXR0cnNBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgX0FUVFJfQ0ZHICAgICA6IGF0dHJDZmdBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgX05PTl9BVFRSU19DRkc6IGFycmF5QWdncmVnYXRvclxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIE1ha2VzIHN1cmUgQmFzZSBhbmQgQmFzZUNvcmUgdXNlIHNlcGFyYXRlIGBfYnVpbGRDZmdgIG9iamVjdHMuXG4gICAgQmFzZS5fYnVpbGRDZmcgPSB7XG4gICAgICAgIGFnZ3JlZ2F0ZXM6IEFHR1JFR0FURVMuY29uY2F0KCksXG5cbiAgICAgICAgY3VzdG9tOiB7XG4gICAgICAgICAgICBBVFRSUyAgICAgICAgIDogYXR0cnNBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgX0FUVFJfQ0ZHICAgICA6IGF0dHJDZmdBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgX05PTl9BVFRSU19DRkc6IGFycmF5QWdncmVnYXRvclxuICAgICAgICB9XG4gICAgfTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiYmFzZS1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2Jhc2UtY29yZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBtb2R1bGUgcHJvdmlkZXMgdGhlIEJhc2UgY2xhc3MsIHdoaWNoIG9iamVjdHMgcmVxdWlyaW5nIGF0dHJpYnV0ZSBhbmQgY3VzdG9tIGV2ZW50IHN1cHBvcnQgY2FuIGV4dGVuZC5cbiAgICAgKiBUaGUgbW9kdWxlIGFsc28gcHJvdmlkZXMgdHdvIHdheXMgdG8gcmV1c2UgY29kZSAtIEl0IGF1Z21lbnRzIEJhc2Ugd2l0aCB0aGUgUGx1Z2luLkhvc3QgaW50ZXJmYWNlIHdoaWNoIHByb3ZpZGVzXG4gICAgICogcGx1Z2luIHN1cHBvcnQgYW5kIGFsc28gcHJvdmlkZXMgdGhlIEJhc2VDb3JlLmJ1aWxkIG1ldGhvZCB3aGljaCBwcm92aWRlcyBhIHdheSB0byBidWlsZCBjdXN0b20gY2xhc3NlcyB1c2luZyBleHRlbnNpb25zLlxuICAgICAqXG4gICAgICogQG1vZHVsZSBiYXNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiA8cD5UaGUgYmFzZS1jb3JlIG1vZHVsZSBwcm92aWRlcyB0aGUgQmFzZUNvcmUgY2xhc3MsIHRoZSBsaWdodGVzdCB2ZXJzaW9uIG9mIEJhc2UsXG4gICAgICogd2hpY2ggcHJvdmlkZXMgQmFzZSdzIGJhc2ljIGxpZmVjeWNsZSBtYW5hZ2VtZW50IGFuZCBBVFRSUyBjb25zdHJ1Y3Rpb24gc3VwcG9ydCxcbiAgICAgKiBidXQgZG9lc24ndCBmaXJlIGluaXQvZGVzdHJveSBvciBhdHRyaWJ1dGUgY2hhbmdlIGV2ZW50cy48L3A+XG4gICAgICpcbiAgICAgKiA8cD5JdCBtaXhlcyBpbiBBdHRyaWJ1dGVDb3JlLCB3aGljaCBpcyB0aGUgbGlnaHRlc3QgdmVyc2lvbiBvZiBBdHRyaWJ1dGU8L3A+XG4gICAgICpcbiAgICAgKiBAbW9kdWxlIGJhc2VcbiAgICAgKiBAc3VibW9kdWxlIGJhc2UtY29yZVxuICAgICAqL1xuICAgIHZhciBPID0gWS5PYmplY3QsXG4gICAgICAgIEwgPSBZLkxhbmcsXG4gICAgICAgIERPVCA9IFwiLlwiLFxuICAgICAgICBJTklUSUFMSVpFRCA9IFwiaW5pdGlhbGl6ZWRcIixcbiAgICAgICAgREVTVFJPWUVEID0gXCJkZXN0cm95ZWRcIixcbiAgICAgICAgSU5JVElBTElaRVIgPSBcImluaXRpYWxpemVyXCIsXG4gICAgICAgIFZBTFVFID0gXCJ2YWx1ZVwiLFxuICAgICAgICBPQkpFQ1RfQ09OU1RSVUNUT1IgPSBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuICAgICAgICBERUVQID0gXCJkZWVwXCIsXG4gICAgICAgIFNIQUxMT1cgPSBcInNoYWxsb3dcIixcbiAgICAgICAgREVTVFJVQ1RPUiA9IFwiZGVzdHJ1Y3RvclwiLFxuXG4gICAgICAgIEF0dHJpYnV0ZUNvcmUgPSBZLkF0dHJpYnV0ZUNvcmUsXG5cbiAgICAgICAgX3dsbWl4ID0gZnVuY3Rpb24ociwgcywgd2xoYXNoKSB7XG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIGZvciAocCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYod2xoYXNoW3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJbcF0gPSBzW3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIEJhc2VDb3JlIGNsYXNzLCBpcyB0aGUgbGlnaHRlc3QgdmVyc2lvbiBvZiBCYXNlLCBhbmQgcHJvdmlkZXMgQmFzZSdzXG4gICAgICogYmFzaWMgbGlmZWN5Y2xlIG1hbmFnZW1lbnQgYW5kIEFUVFJTIGNvbnN0cnVjdGlvbiBzdXBwb3J0LCBidXQgZG9lc24ndFxuICAgICAqIGZpcmUgaW5pdC9kZXN0cm95IG9yIGF0dHJpYnV0ZSBjaGFuZ2UgZXZlbnRzLlxuICAgICAqXG4gICAgICogQmFzZUNvcmUgYWxzbyBoYW5kbGVzIHRoZSBjaGFpbmluZyBvZiBpbml0aWFsaXplciBhbmQgZGVzdHJ1Y3RvciBtZXRob2RzIGFjcm9zc1xuICAgICAqIHRoZSBoaWVyYXJjaHkgYXMgcGFydCBvZiBvYmplY3QgY29uc3RydWN0aW9uIGFuZCBkZXN0cnVjdGlvbi4gQWRkaXRpb25hbGx5LCBhdHRyaWJ1dGVzXG4gICAgICogY29uZmlndXJlZCB0aHJvdWdoIHRoZSBzdGF0aWMgPGEgaHJlZj1cIiNwcm9wZXJ0eV9CYXNlQ29yZS5BVFRSU1wiPkFUVFJTPC9hPlxuICAgICAqIHByb3BlcnR5IGZvciBlYWNoIGNsYXNzIGluIHRoZSBoaWVyYXJjaHkgd2lsbCBiZSBpbml0aWFsaXplZCBieSBCYXNlQ29yZS5cbiAgICAgKlxuICAgICAqIENsYXNzZXMgd2hpY2ggcmVxdWlyZSBhdHRyaWJ1dGUgc3VwcG9ydCwgYnV0IGRvbid0IGludGVuZCB0byB1c2UvZXhwb3NlIGF0dHJpYnV0ZVxuICAgICAqIGNoYW5nZSBldmVudHMgY2FuIGV4dGVuZCBCYXNlQ29yZSBpbnN0ZWFkIG9mIEJhc2UgZm9yIG9wdGltYWwga3dlaWdodCBhbmRcbiAgICAgKiBydW50aW1lIHBlcmZvcm1hbmNlLlxuICAgICAqXG4gICAgICogKiozLjExLjAgQkFDSyBDT01QQVQgTk9URSBGT1IgQ09NUE9ORU5UIERFVkVMT1BFUlMqKlxuICAgICAqXG4gICAgICogUHJpb3IgdG8gdmVyc2lvbiAzLjExLjAsIEFUVFJTIHdvdWxkIGdldCBhZGRlZCBhIGNsYXNzIGF0IGEgdGltZS4gVGhhdCBpczpcbiAgICAgKlxuICAgICAqIDxwcmU+XG4gICAgICogICAgZm9yIGVhY2ggKGNsYXNzIGluIHRoZSBoaWVyYXJjaHkpIHtcbiAgICAgKiAgICAgICBDYWxsIHRoZSBjbGFzcyBFeHRlbnNpb24gY29uc3RydWN0b3JzLlxuICAgICAqXG4gICAgICogICAgICAgQWRkIHRoZSBjbGFzcyBBVFRSUy5cbiAgICAgKlxuICAgICAqICAgICAgIENhbGwgdGhlIGNsYXNzIGluaXRpYWxpemVyXG4gICAgICogICAgICAgQ2FsbCB0aGUgY2xhc3MgRXh0ZW5zaW9uIGluaXRpYWxpemVycy5cbiAgICAgKiAgICB9XG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiBBcyBvZiAzLjExLjAsIEFUVFJTIGZyb20gYWxsIGNsYXNzZXMgaW4gdGhlIGhpZXJhcmNoeSBhcmUgYWRkZWQgaW4gb25lIGBhZGRBdHRyc2AgY2FsbFxuICAgICAqIGJlZm9yZSAqKmFueSoqIGluaXRpYWxpemVycyBhcmUgY2FsbGVkLiBUaGF0IGlzLCB0aGUgZmxvdyBiZWNvbWVzOlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiAgICBmb3IgZWFjaCAoY2xhc3MgaW4gdGhlIGhpZXJhcmNoeSkge1xuICAgICAqICAgICAgIENhbGwgdGhlIGNsYXNzIEV4dGVuc2lvbiBjb25zdHJ1Y3RvcnMuXG4gICAgICogICAgfVxuICAgICAqXG4gICAgICogICAgQWRkIEFUVFJTIGZvciBhbGwgY2xhc3Nlc1xuICAgICAqXG4gICAgICogICAgZm9yIGVhY2ggKGNsYXNzIGluIHRoZSBoaWVyYXJjaHkpIHtcbiAgICAgKiAgICAgICBDYWxsIHRoZSBjbGFzcyBpbml0aWFsaXplci5cbiAgICAgKiAgICAgICBDYWxsIHRoZSBjbGFzcyBFeHRlbnNpb24gaW5pdGlhbGl6ZXJzLlxuICAgICAqICAgIH1cbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIEFkZGluZyBhbGwgQVRUUlMgYXQgb25jZSBmaXhlcyBzdWJ0bGUgZWRnZS1jYXNlIGlzc3VlcyB3aXRoIHN1YmNsYXNzIEFUVFJTIG92ZXJyaWRpbmdcbiAgICAgKiBzdXBlcmNsYXNzIGBzZXR0ZXJgLCBgZ2V0dGVyYCBvciBgdmFsdWVGbmAgZGVmaW5pdGlvbnMgYW5kIGJlaW5nIHVuYWJsZSB0byBnZXQvc2V0IGF0dHJpYnV0ZXNcbiAgICAgKiBkZWZpbmVkIGJ5IHRoZSBzdWJjbGFzcy4gSXQgYWxzbyBsZWF2ZXMgdXMgd2l0aCBhIGNsZWFuZXIgb3JkZXIgb2Ygb3BlcmF0aW9uIGZsb3cgbW92aW5nXG4gICAgICogZm9yd2FyZC5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIGl0IG1heSByZXF1aXJlIGNvbXBvbmVudCBkZXZlbG9wZXJzIHRvIHVwZ3JhZGUgdGhlaXIgY29tcG9uZW50cywgZm9yIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBzY2VuYXJpb3M6XG4gICAgICpcbiAgICAgKiAxLiBJdCBpbXBhY3RzIGNvbXBvbmVudHMgd2hpY2ggbWF5IGhhdmUgYHNldHRlcmAsIGBnZXR0ZXJgIG9yIGB2YWx1ZUZuYCBjb2RlIHdoaWNoXG4gICAgICogZXhwZWN0cyBhIHN1cGVyY2xhc3MnIGluaXRpYWxpemVyIHRvIGhhdmUgcnVuLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBleHBlY3RlZCB0byBiZSByYXJlLCBidXQgdG8gc3VwcG9ydCBpdCwgQmFzZSBub3cgc3VwcG9ydHMgYSBgX3ByZUFkZEF0dHJzKClgLCBtZXRob2RcbiAgICAgKiBob29rIChzYW1lIHNpZ25hdHVyZSBhcyBgYWRkQXR0cnNgKS4gQ29tcG9uZW50cyBjYW4gaW1wbGVtZW50IHRoaXMgbWV0aG9kIG9uIHRoZWlyIHByb3RvdHlwZVxuICAgICAqIGZvciBlZGdlIGNhc2VzIHdoaWNoIGRvIHJlcXVpcmUgZmluZXIgY29udHJvbCBvdmVyIHRoZSBvcmRlciBpbiB3aGljaCBhdHRyaWJ1dGVzIGFyZSBhZGRlZFxuICAgICAqIChzZWUgd2lkZ2V0LWh0bWxwYXJzZXIgZm9yIGV4YW1wbGUpLlxuICAgICAqXG4gICAgICogMi4gRXh0ZW5zaW9uIGRldmVsb3BlcnMgbWF5IG5lZWQgdG8gbW92ZSBjb2RlIGZyb20gRXh0ZW5zaW9uIGNvbnN0cnVjdG9ycyB0byBgaW5pdGlhbGl6ZXJgc1xuICAgICAqXG4gICAgICogT2xkZXIgZXh0ZW5zaW9ucywgd2hpY2ggd2VyZSB3cml0dGVuIGJlZm9yZSBgaW5pdGlhbGl6ZXJgIHN1cHBvcnQgd2FzIGFkZGVkLCBoYWQgYSBsb3Qgb2ZcbiAgICAgKiBpbml0aWFsaXphdGlvbiBjb2RlIGluIHRoZWlyIGNvbnN0cnVjdG9ycy4gRm9yIGV4YW1wbGUsIGNvZGUgd2hpY2ggYWNjY2Vzc2VkIHN1cGVyY2xhc3NcbiAgICAgKiBhdHRyaWJ1dGVzLiBXaXRoIHRoZSBuZXcgZmxvdyB0aGlzIGNvZGUgd291bGQgbm90IGJlIGFibGUgdG8gc2VlIGF0dHJpYnV0ZXMuIFRoZSByZWNvbW1lbmRhdGlvblxuICAgICAqIGlzIHRvIG1vdmUgdGhpcyBpbml0aWFsaXphdGlvbiBjb2RlIHRvIGFuIGBpbml0aWFsaXplcmAgb24gdGhlIEV4dGVuc2lvbiwgd2hpY2ggd2FzIHRoZVxuICAgICAqIHJlY29tbWVuZGF0aW9uIGZvciBhbnl0aGluZyBjcmVhdGVkIGFmdGVyIGBpbml0aWFsaXplcmAgc3VwcG9ydCBmb3IgRXh0ZW5zaW9ucyB3YXMgYWRkZWQuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQmFzZUNvcmVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAdXNlcyBBdHRyaWJ1dGVDb3JlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHByb3BlcnR5IG5hbWUvdmFsdWUgcGFpcnMuXG4gICAgICogVGhlIG9iamVjdCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGluaXRpYWwgdmFsdWVzIGZvciB0aGUgb2JqZWN0cyBwdWJsaXNoZWRcbiAgICAgKiBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJhc2VDb3JlKGNmZykge1xuICAgICAgICBpZiAoIXRoaXMuX0Jhc2VJbnZva2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9CYXNlSW52b2tlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX2luaXRCYXNlKGNmZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBwcm9wZXJ0aWVzIHdoaWNoIGNhbiBiZSBjb25maWd1cmVkIGZvciBlYWNoIGF0dHJpYnV0ZVxuICAgICAqIChlLmcuIHNldHRlciwgZ2V0dGVyLCB3cml0ZU9uY2UsIHJlYWRPbmx5IGV0Yy4pXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX0FUVFJfQ0ZHXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBCYXNlQ29yZS5fQVRUUl9DRkcgPSBBdHRyaWJ1dGVDb3JlLl9BVFRSX0NGRy5jb25jYXQoXCJjbG9uZURlZmF1bHRWYWx1ZVwiKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiBub24tYXR0cmlidXRlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBzdXBwb3J0ZWQgYnkgdGhpcyBjbGFzcy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlIGBCYXNlQ29yZWAgZGVmaW5lcyBhIFwicGx1Z2luc1wiIGNvbmZpZ3VyYXRpb24gcHJvcGVydHkgd2hpY2hcbiAgICAgKiBzaG91bGQgbm90IGJlIHNldCB1cCBhcyBhbiBhdHRyaWJ1dGUuIFRoaXMgcHJvcGVydHkgaXMgcHJpbWFyaWx5IHJlcXVpcmVkIHNvXG4gICAgICogdGhhdCB3aGVuIDxhIGhyZWY9XCIjcHJvcGVydHlfX2FsbG93QWRIb2NBdHRyc1wiPmBfYWxsb3dBZEhvY0F0dHJzYDwvYT4gaXMgZW5hYmxlZCBieSBhIGNsYXNzLFxuICAgICAqIG5vbi1hdHRyaWJ1dGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGRvbid0IGdldCBhZGRlZCBhcyBhZC1ob2MgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfTk9OX0FUVFJTX0NGR1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQmFzZUNvcmUuX05PTl9BVFRSU19DRkcgPSBbXCJwbHVnaW5zXCJdO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBjb250cm9scyB3aGV0aGVyIG9yIG5vdCBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBzaG91bGRcbiAgICAgKiBhbGxvdyB1c2VycyB0byBhZGQgYWQtaG9jIGF0dHJpYnV0ZXMgdGhyb3VnaCB0aGUgY29uc3RydWN0b3IgY29uZmlndXJhdGlvblxuICAgICAqIGhhc2guXG4gICAgICpcbiAgICAgKiBBZEhvYyBhdHRyaWJ1dGVzIGFyZSBhdHRyaWJ1dGVzIHdoaWNoIGFyZSBub3QgZGVmaW5lZCBieSB0aGUgY2xhc3MsIGFuZCBhcmVcbiAgICAgKiBub3QgaGFuZGxlZCBieSB0aGUgTXlDbGFzcy5fTk9OX0FUVFJTX0NGR1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9hbGxvd0FkSG9jQXR0cnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkIChmYWxzZSlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHRvIGJlIHVzZWQgdG8gaWRlbnRpZnkgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuXG4gICAgICpcbiAgICAgKiBDbGFzc2VzIGV4dGVuZGluZyBCYXNlQ29yZSwgc2hvdWxkIGRlZmluZSB0aGVpciBvd25cbiAgICAgKiBzdGF0aWMgTkFNRSBwcm9wZXJ0eSwgd2hpY2ggc2hvdWxkIGJlIGNhbWVsQ2FzZSBieVxuICAgICAqIGNvbnZlbnRpb24gKGUuZy4gTXlDbGFzcy5OQU1FID0gXCJteUNsYXNzXCI7KS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBOQU1FXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIEJhc2VDb3JlLk5BTUUgPSBcImJhc2VDb3JlXCI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzZXQgb2YgYXR0cmlidXRlcyB3aGljaCB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MsIGFuZFxuICAgICAqIHRoZWlyIGNvbmZpZ3VyYXRpb24uIEluIGFkZGl0aW9uIHRvIHRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgbGlzdGVkIGJ5XG4gICAgICogQXR0cmlidXRlQ29yZSdzIDxhIGhyZWY9XCJBdHRyaWJ1dGVDb3JlLmh0bWwjbWV0aG9kX2FkZEF0dHJcIj5hZGRBdHRyPC9hPiBtZXRob2QsXG4gICAgICogdGhlIGF0dHJpYnV0ZSBjYW4gYWxzbyBiZSBjb25maWd1cmVkIHdpdGggYSBcImNsb25lRGVmYXVsdFZhbHVlXCIgcHJvcGVydHksIHdoaWNoXG4gICAgICogZGVmaW5lcyBob3cgdGhlIHN0YXRpY2FsbHkgZGVmaW5lZCB2YWx1ZSBmaWVsZCBzaG91bGQgYmUgcHJvdGVjdGVkXG4gICAgICogKFwic2hhbGxvd1wiLCBcImRlZXBcIiBhbmQgZmFsc2UgYXJlIHN1cHBvcnRlZCB2YWx1ZXMpLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYW4gYXJyYXkgaXQgd2lsbCBiZSBcInNoYWxsb3dcIlxuICAgICAqIGNsb25lZCwgdG8gcHJvdGVjdCB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBBVFRSU1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBCYXNlQ29yZS5BVFRSUyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIG9iamVjdFxuICAgICAgICAgKiBoYXMgYmVlbiB0aHJvdWdoIHRoZSBpbml0IGxpZmVjeWNsZSBwaGFzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGF0dHJpYnV0ZSBpbml0aWFsaXplZFxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZWQ6IHtcbiAgICAgICAgICAgIHJlYWRPbmx5OnRydWUsXG4gICAgICAgICAgICB2YWx1ZTpmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhpcyBvYmplY3RcbiAgICAgICAgICogaGFzIGJlZW4gdGhyb3VnaCB0aGUgZGVzdHJveSBsaWZlY3ljbGUgcGhhc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhdHRyaWJ1dGUgZGVzdHJveWVkXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95ZWQ6IHtcbiAgICAgICAgICAgIHJlYWRPbmx5OnRydWUsXG4gICAgICAgICAgICB2YWx1ZTpmYWxzZVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgIFByb3ZpZGVzIGEgd2F5IHRvIHNhZmVseSBtb2RpZnkgYSBgWS5CYXNlQ29yZWAgc3ViY2xhc3MnIHN0YXRpYyBgQVRUUlNgXG4gICAgYWZ0ZXIgdGhlIGNsYXNzIGhhcyBiZWVuIGRlZmluZWQgb3IgY3JlYXRlZC5cblxuICAgIEJhc2VDb3JlLWJhc2VkIGNsYXNzZXMgY2FjaGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsYXNzIGhpZXJhcmNoeSBpbiBvcmRlclxuICAgIHRvIGVmZmljaWVudGx5IGNyZWF0ZSBpbnN0YW5jZXMuIFRoaXMgY2FjaGUgaW5jbHVkZXMgaW5jbHVkZXMgdGhlIGFnZ3JlZ2F0ZWRcbiAgICBgQVRUUlNgIGNvbmZpZ3MuIElmIHRoZSBzdGF0aWMgYEFUVFJTYCBjb25maWdzIG5lZWQgdG8gYmUgbW9kaWZpZWQgYWZ0ZXIgdGhlXG4gICAgY2xhc3MgaGFzIGJlZW4gZGVmaW5lZCBvciBjcmVhdGUsIHRoZW4gdXNlIHRoaXMgbWV0aG9kIHdoaWNoIHdpbGwgbWFrZSBzdXJlXG4gICAgdG8gY2xlYXIgYW55IGNhY2hlZCBkYXRhIGJlZm9yZSBtYWtpbmcgYW55IG1vZGlmaWNhdGlvbnMuXG5cbiAgICBAbWV0aG9kIG1vZGlmeUF0dHJzXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2N0b3JdIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aG9zZSBgQVRUUlNgIHNob3VsZCBiZVxuICAgICAgICBtb2RpZmllZC4gSWYgYSBgY3RvcmAgZnVuY3Rpb24gaXMgbm90IHNwZWNpZmllZCwgdGhlbiBgdGhpc2AgaXMgYXNzdW1lZFxuICAgICAgICB0byBiZSB0aGUgY29uc3RydWN0b3Igd2hpY2ggaG9zdHMgdGhlIGBBVFRSU2AuXG4gICAgQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3MgVGhlIGNvbGxlY3Rpb24gb2YgYEFUVFJTYCBjb25maWdzIHRvIG1peCB3aXRoIHRoZVxuICAgICAgICBleGlzdGluZyBhdHRyaWJ1dGUgY29uZmlndXJhdGlvbnMuXG4gICAgQHN0YXRpY1xuICAgIEBzaW5jZSAzLjEwLjBcbiAgICAqKi9cbiAgICBCYXNlQ29yZS5tb2RpZnlBdHRycyA9IGZ1bmN0aW9uIChjdG9yLCBjb25maWdzKSB7XG4gICAgICAgIC8vIFdoZW4gY2FsbGVkIHdpdGhvdXQgYSBjb25zdHJ1Y3RvciwgYXNzdW1lIGB0aGlzYCBpcyB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgIGlmICh0eXBlb2YgY3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uZmlncyA9IGN0b3I7XG4gICAgICAgICAgICBjdG9yICAgID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRycywgYXR0ciwgbmFtZTtcblxuICAgICAgICAvLyBFYWdlcmx5IGNyZWF0ZSB0aGUgYEFUVFJTYCBvYmplY3QgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICAgICAgICBhdHRycyA9IGN0b3IuQVRUUlMgfHwgKGN0b3IuQVRUUlMgPSB7fSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZ3MpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIGNhY2hlIGJlY2F1c2UgaXQgaGFzIEFUVFJTIGFnZ3JlZ2F0aW9uIGRhdGEgd2hpY2ggaXMgYWJvdXRcbiAgICAgICAgICAgIC8vIHRvIGJlIG1vZGlmaWVkLlxuICAgICAgICAgICAgY3Rvci5fQ0FDSEVEX0NMQVNTX0RBVEEgPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gY29uZmlncykge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyc1tuYW1lXSB8fCAoYXR0cnNbbmFtZV0gPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIFkubWl4KGF0dHIsIGNvbmZpZ3NbbmFtZV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBCYXNlQ29yZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGNvbnN0cnVjdGlvbiBsb2dpYyBmb3IgQmFzZUNvcmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2luaXRCYXNlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbnN0cnVjdG9yIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaW5pdEJhc2UgOiBmdW5jdGlvbihjb25maWcpIHtcblxuICAgICAgICAgICAgWS5zdGFtcCh0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5faW5pdEF0dHJpYnV0ZShjb25maWcpO1xuXG4gICAgICAgICAgICAvLyBJZiBQbHVnaW4uSG9zdCBoYXMgYmVlbiBhdWdtZW50ZWQgWyB0aHJvdWdoIGJhc2UtcGx1Z2luaG9zdCBdLCBzZXR1cCBpdCdzXG4gICAgICAgICAgICAvLyBpbml0aWFsIHN0YXRlLCBidXQgZG9uJ3QgaW5pdGlhbGl6ZSBQbHVnaW5zIHlldC4gVGhhdCdzIGRvbmUgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YXIgUGx1Z2luSG9zdCA9IFkuUGx1Z2luICYmIFkuUGx1Z2luLkhvc3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5pdFBsdWdpbnMgJiYgUGx1Z2luSG9zdCkge1xuICAgICAgICAgICAgICAgIFBsdWdpbkhvc3QuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhenlBZGRBdHRycyAhPT0gZmFsc2UpIHsgdGhpcy5fbGF6eUFkZEF0dHJzID0gdHJ1ZTsgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBzdHJpbmcgdXNlZCB0byBpZGVudGlmeSB0aGUgY2xhc3Mgb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoaXMuY29uc3RydWN0b3IuTkFNRVxuICAgICAgICAgICAgICogQHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLk5BTUU7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplcyBBdHRyaWJ1dGVDb3JlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2luaXRBdHRyaWJ1dGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9pbml0QXR0cmlidXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEF0dHJpYnV0ZUNvcmUuY2FsbCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdCBsaWZlY3ljbGUgbWV0aG9kLCBpbnZva2VkIGR1cmluZyBjb25zdHJ1Y3Rpb24uIFNldHMgdXAgYXR0cmlidXRlc1xuICAgICAgICAgKiBhbmQgaW52b2tlcyBpbml0aWFsaXplcnMgZm9yIHRoZSBjbGFzcyBoaWVyYXJjaHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAgICAgKiBAY2hhaW5hYmxlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgT2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwcm9wZXJ0eSBuYW1lL3ZhbHVlIHBhaXJzXG4gICAgICAgICAqIEByZXR1cm4ge0Jhc2VDb3JlfSBBIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24oY2ZnKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2Jhc2VJbml0KGNmZyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBpbml0aWFsaXphdGlvbiBpbXBsZW1lbnRhdGlvbiBmb3IgQmFzZUNvcmVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfYmFzZUluaXRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9iYXNlSW5pdDogZnVuY3Rpb24oY2ZnKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0SGllcmFyY2h5KGNmZyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbml0UGx1Z2lucykge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gaW5pdFBsdWdpbnMgbWFudWFsbHksIHRvIGhhbmRsZSBjb25zdHJ1Y3RvciBwYXJzaW5nLCBzdGF0aWMgUGx1ZyBwYXJzaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFBsdWdpbnMoY2ZnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldChJTklUSUFMSVpFRCwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgbGlmZWN5Y2xlIG1ldGhvZC4gSW52b2tlcyBkZXN0cnVjdG9ycyBmb3IgdGhlIGNsYXNzIGhpZXJhcmNoeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICAgICAqIEByZXR1cm4ge0Jhc2VDb3JlfSBBIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdFxuICAgICAgICAgKiBAY2hhaW5hYmxlXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VEZXN0cm95KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZGVzdHJveSBpbXBsZW1lbnRhdGlvbiBmb3IgQmFzZUNvcmVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfYmFzZURlc3Ryb3lcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9iYXNlRGVzdHJveSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rlc3Ryb3lQbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveVBsdWdpbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lIaWVyYXJjaHkoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChERVNUUk9ZRUQsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjbGFzcyBoaWVyYXJjaHkgZm9yIHRoaXMgb2JqZWN0LCB3aXRoIEJhc2VDb3JlIGJlaW5nIHRoZSBsYXN0IGNsYXNzIGluIHRoZSBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfZ2V0Q2xhc3Nlc1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9uW119IEFuIGFycmF5IG9mIGNsYXNzZXMgKGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyksIG1ha2luZyB1cCB0aGUgY2xhc3MgaGllcmFyY2h5IGZvciB0aGlzIG9iamVjdC5cbiAgICAgICAgICogVGhpcyB2YWx1ZSBpcyBjYWNoZWQgdGhlIGZpcnN0IHRpbWUgdGhlIG1ldGhvZCwgb3IgX2dldEF0dHJDZmdzLCBpcyBpbnZva2VkLiBTdWJzZXF1ZW50IGludm9jYXRpb25zIHJldHVybiB0aGVcbiAgICAgICAgICogY2FjaGVkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgX2dldENsYXNzZXMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRIaWVyYXJjaHlEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3NlcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBhZ2dyZWdhdGVkIHNldCBvZiBhdHRyaWJ1dGUgY29uZmlndXJhdGlvbnMsIGJ5IHRyYXZlcnNpbmdcbiAgICAgICAgICogdGhlIGNsYXNzIGhpZXJhcmNoeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfZ2V0QXR0ckNmZ3NcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBoYXNoIG9mIGF0dHJpYnV0ZSBjb25maWd1cmF0aW9ucywgYWdncmVnYXRlZCBhY3Jvc3MgY2xhc3NlcyBpbiB0aGUgaGllcmFyY2h5XG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgY2FjaGVkIHRoZSBmaXJzdCB0aW1lIHRoZSBtZXRob2QsIG9yIF9nZXRDbGFzc2VzLCBpcyBpbnZva2VkLiBTdWJzZXF1ZW50IGludm9jYXRpb25zIHJldHVyblxuICAgICAgICAgKiB0aGUgY2FjaGVkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgX2dldEF0dHJDZmdzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dHJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdEhpZXJhcmNoeURhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRycztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBoZWxwZXIgbWV0aG9kIHVzZWQgdG8gaXNvbGF0ZSB0aGUgYXR0cnMgY29uZmlnIGZvciB0aGlzIGluc3RhbmNlIHRvIHBhc3MgdG8gYGFkZEF0dHJzYCxcbiAgICAgICAgICogZnJvbSB0aGUgc3RhdGljIGNhY2hlZCBBVFRSUyBmb3IgdGhlIGNsYXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIF9nZXRJbnN0YW5jZUF0dHJDZmdzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbGxDZmdzIFRoZSBzZXQgb2YgYWxsIGF0dHJpYnV0ZSBjb25maWd1cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICogQXR0cmlidXRlcyB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGlzIHNldCwgaWYgdGhleSBiZWxvbmcgdG8gdGhlIGZpbHRlcmVkIGNsYXNzLCBzb1xuICAgICAgICAgKiB0aGF0IGJ5IHRoZSB0aW1lIGFsbCBjbGFzc2VzIGFyZSBwcm9jZXNzZWQsIGFsbENmZ3Mgd2lsbCBiZSBlbXB0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgc2V0IG9mIGF0dHJpYnV0ZXMgdG8gYmUgYWRkZWQgZm9yIHRoaXMgaW5zdGFuY2UsIHN1aXRhYmxlXG4gICAgICAgICAqIGZvciBwYXNzaW5nIHRocm91Z2ggdG8gYGFkZEF0dHJzYC5cbiAgICAgICAgICovXG4gICAgICAgIF9nZXRJbnN0YW5jZUF0dHJDZmdzIDogZnVuY3Rpb24oYWxsQ2Zncykge1xuXG4gICAgICAgICAgICB2YXIgY2ZncyA9IHt9LFxuICAgICAgICAgICAgICAgIGNmZyxcbiAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgc3ViQXR0cixcbiAgICAgICAgICAgICAgICBzdWJBdHRycyxcbiAgICAgICAgICAgICAgICBzdWJBdHRyUGF0aCxcbiAgICAgICAgICAgICAgICBhdHRyLFxuICAgICAgICAgICAgICAgIGF0dHJDZmcsXG4gICAgICAgICAgICAgICAgYWxsU3ViQXR0cnMgPSBhbGxDZmdzLl9zdWJBdHRycyxcbiAgICAgICAgICAgICAgICBhdHRyQ2ZnUHJvcGVydGllcyA9IHRoaXMuX2F0dHJDZmdIYXNoKCk7XG5cbiAgICAgICAgICAgIGZvciAoYXR0ciBpbiBhbGxDZmdzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxsQ2Zncy5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiBhdHRyICE9PSBcIl9zdWJBdHRyc1wiKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYXR0ckNmZyA9IGFsbENmZ3NbYXR0cl07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBpc29sYXRlIGZyb20gYWxsQ2ZncywgYmVjYXVzZSB3ZSdyZSBnb2luZyB0byBzZXQgdmFsdWVzIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgY2ZnID0gY2Znc1thdHRyXSA9IF93bG1peCh7fSwgYXR0ckNmZywgYXR0ckNmZ1Byb3BlcnRpZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGNmZy52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvbmVEZWZhdWx0VmFsdWUoYXR0ciwgY2ZnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxTdWJBdHRycyAmJiBhbGxTdWJBdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViQXR0cnMgPSBhbGxDZmdzLl9zdWJBdHRyc1thdHRyXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzdWJBdHRyUGF0aCBpbiBzdWJBdHRycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YkF0dHIgPSBzdWJBdHRyc1tzdWJBdHRyUGF0aF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViQXR0ci5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8uc2V0VmFsdWUoY2ZnLnZhbHVlLCBzdWJBdHRyLnBhdGgsIHN1YkF0dHIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNmZ3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZXRob2QgX2ZpbHRlckFkSG9jQXR0cnNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFsbEF0dHJzIFRoZSBzZXQgb2YgYWxsIGF0dHJpYnV0ZSBjb25maWd1cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICogQXR0cmlidXRlcyB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGlzIHNldCwgaWYgdGhleSBiZWxvbmcgdG8gdGhlIGZpbHRlcmVkIGNsYXNzLCBzb1xuICAgICAgICAgKiB0aGF0IGJ5IHRoZSB0aW1lIGFsbCBjbGFzc2VzIGFyZSBwcm9jZXNzZWQsIGFsbENmZ3Mgd2lsbCBiZSBlbXB0eS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJWYWxzIFRoZSBjb25maWcgb2JqZWN0IHBhc3NlZCBpbiBieSB0aGUgdXNlciwgZnJvbSB3aGljaCBhZGhvYyBhdHRycyBhcmUgdG8gYmUgZmlsdGVyZWQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHNldCBvZiBhZGhvYyBhdHRyaWJ1dGVzIHBhc3NlZCBpbiwgaW4gdGhlIGZvcm1cbiAgICAgICAgICogb2YgYW4gb2JqZWN0IHdpdGggYXR0cmlidXRlIG5hbWUvY29uZmlndXJhdGlvbiBwYWlycy5cbiAgICAgICAgICovXG4gICAgICAgIF9maWx0ZXJBZEhvY0F0dHJzIDogZnVuY3Rpb24oYWxsQXR0cnMsIHVzZXJWYWxzKSB7XG4gICAgICAgICAgICB2YXIgYWRIb2NzLFxuICAgICAgICAgICAgICAgIG5vbkF0dHJzID0gdGhpcy5fbm9uQXR0cnMsXG4gICAgICAgICAgICAgICAgYXR0cjtcblxuICAgICAgICAgICAgaWYgKHVzZXJWYWxzKSB7XG4gICAgICAgICAgICAgICAgYWRIb2NzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChhdHRyIGluIHVzZXJWYWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsQXR0cnNbYXR0cl0gJiYgIW5vbkF0dHJzW2F0dHJdICYmIHVzZXJWYWxzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZEhvY3NbYXR0cl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dXNlclZhbHNbYXR0cl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhZEhvY3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgaGVscGVyIG1ldGhvZCB1c2VkIGJ5IF9nZXRDbGFzc2VzIGFuZCBfZ2V0QXR0ckNmZ3MsIHdoaWNoIGRldGVybWluZXMgYm90aFxuICAgICAgICAgKiB0aGUgYXJyYXkgb2YgY2xhc3NlcyBhbmQgYWdncmVnYXRlIHNldCBvZiBhdHRyaWJ1dGUgY29uZmlndXJhdGlvbnNcbiAgICAgICAgICogYWNyb3NzIHRoZSBjbGFzcyBoaWVyYXJjaHkgZm9yIHRoZSBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfaW5pdEhpZXJhcmNoeURhdGFcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9pbml0SGllcmFyY2h5RGF0YSA6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3IsXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2xhc3NEYXRhID0gY3Rvci5fQ0FDSEVEX0NMQVNTX0RBVEEsXG4gICAgICAgICAgICAgICAgYyxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgICAgYXR0ckNmZyxcbiAgICAgICAgICAgICAgICBhdHRyQ2ZnSGFzaCxcbiAgICAgICAgICAgICAgICBuZWVkc0F0dHJDZmdIYXNoID0gIWN0b3IuX0FUVFJfQ0ZHX0hBU0gsXG4gICAgICAgICAgICAgICAgbm9uQXR0cnNDZmcsXG4gICAgICAgICAgICAgICAgbm9uQXR0cnMgPSB7fSxcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gW10sXG4gICAgICAgICAgICAgICAgYXR0cnMgPSBbXTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBgdGhpc2AgaW5zdGFuY2UncyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGMgPSBjdG9yO1xuXG4gICAgICAgICAgICBpZiAoIWNhY2hlZENsYXNzRGF0YSkge1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIGNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlc1tjbGFzc2VzLmxlbmd0aF0gPSBjO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLkFUVFJTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1thdHRycy5sZW5ndGhdID0gYy5BVFRSUztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFnZ3JlZ2F0ZSBBVFRSIGNmZyB3aGl0ZWxpc3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc0F0dHJDZmdIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyQ2ZnICAgICA9IGMuX0FUVFJfQ0ZHO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ckNmZ0hhc2ggPSBhdHRyQ2ZnSGFzaCB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJDZmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gYXR0ckNmZy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ckNmZ0hhc2hbYXR0ckNmZ1tpXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbW1lbnRpbmcgb3V0IHRoZSBpZi4gV2UgYWx3YXlzIGFnZ3JlZ2F0ZSwgc2luY2Ugd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgICAgLy8ga25vdyBpZiB3ZSdsbCBiZSBuZWVkaW5nIHRoaXMgb24gdGhlIGluc3RhbmNlIG9yIG5vdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuX2FsbG93QWRIb2NBdHRycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9uQXR0cnNDZmcgPSBjLl9OT05fQVRUUlNfQ0ZHO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbkF0dHJzQ2ZnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG5vbkF0dHJzQ2ZnLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25BdHRyc1tub25BdHRyc0NmZ1tpXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy99XG5cbiAgICAgICAgICAgICAgICAgICAgYyA9IGMuc3VwZXJjbGFzcyA/IGMuc3VwZXJjbGFzcy5jb25zdHJ1Y3RvciA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2FjaGUgY29tcHV0ZWQgYF9BVFRSX0NGR19IQVNIYCBvbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAgICAgaWYgKG5lZWRzQXR0ckNmZ0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Rvci5fQVRUUl9DRkdfSEFTSCA9IGF0dHJDZmdIYXNoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhY2hlZENsYXNzRGF0YSA9IGN0b3IuX0NBQ0hFRF9DTEFTU19EQVRBID0ge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzIDogY2xhc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgbm9uQXR0cnMgOiBub25BdHRycyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMgOiB0aGlzLl9hZ2dyZWdhdGVBdHRycyhhdHRycylcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NsYXNzZXMgPSBjYWNoZWRDbGFzc0RhdGEuY2xhc3NlcztcbiAgICAgICAgICAgIHRoaXMuX2F0dHJzID0gY2FjaGVkQ2xhc3NEYXRhLmF0dHJzO1xuICAgICAgICAgICAgdGhpcy5fbm9uQXR0cnMgPSBjYWNoZWRDbGFzc0RhdGEubm9uQXR0cnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFV0aWxpdHkgbWV0aG9kIHRvIGRlZmluZSB0aGUgYXR0cmlidXRlIGhhc2ggdXNlZCB0byBmaWx0ZXIvd2hpdGVsaXN0IHByb3BlcnR5IG1peGVzIGZvclxuICAgICAgICAgKiB0aGlzIGNsYXNzIGZvciBpdGVyYXRpb24gcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfYXR0ckNmZ0hhc2hcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9hdHRyQ2ZnSGFzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fQVRUUl9DRkdfSEFTSDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgYXNzdW1lcyB0aGF0IHRoZSB2YWx1ZSBoYXMgYWxyZWFkeSBiZWVuIGNoZWNrZWQgdG8gYmUgYW4gb2JqZWN0LlxuICAgICAgICAgKiBTaW5jZSBpdCdzIG9uIGEgY3JpdGljYWwgcGF0aCwgd2UgZG9uJ3Qgd2FudCB0byByZS1kbyB0aGUgY2hlY2suXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2Nsb25lRGVmYXVsdFZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmdcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9jbG9uZURlZmF1bHRWYWx1ZSA6IGZ1bmN0aW9uKGF0dHIsIGNmZykge1xuXG4gICAgICAgICAgICB2YXIgdmFsID0gY2ZnLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNsb25lID0gY2ZnLmNsb25lRGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoY2xvbmUgPT09IERFRVAgfHwgY2xvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjZmcudmFsdWUgPSBZLmNsb25lKHZhbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsb25lID09PSBTSEFMTE9XKSB7XG4gICAgICAgICAgICAgICAgY2ZnLnZhbHVlID0gWS5tZXJnZSh2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoY2xvbmUgPT09IHVuZGVmaW5lZCAmJiAoT0JKRUNUX0NPTlNUUlVDVE9SID09PSB2YWwuY29uc3RydWN0b3IgfHwgTC5pc0FycmF5KHZhbCkpKSkge1xuICAgICAgICAgICAgICAgIGNmZy52YWx1ZSA9IFkuY2xvbmUodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgaWYgKGNsb25lID09PSBmYWxzZSksIGRvbid0IGNsb25lIHRoZSBzdGF0aWMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8gYmUgdXNlZCBieSByZWZlcmVuY2UuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgaGVscGVyIG1ldGhvZCwgdXNlZCBieSBfaW5pdEhpZXJhcmNoeURhdGEgdG8gYWdncmVnYXRlXG4gICAgICAgICAqIGF0dHJpYnV0ZSBjb25maWd1cmF0aW9uIGFjcm9zcyB0aGUgaW5zdGFuY2VzIGNsYXNzIGhpZXJhcmNoeS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIG1ldGhvZCB3aWxsIHByb3RlY3QgdGhlIGF0dHJpYnV0ZSBjb25maWd1cmF0aW9uIHZhbHVlIHRvIHByb3RlY3QgdGhlIHN0YXRpY2FsbHkgZGVmaW5lZFxuICAgICAgICAgKiBkZWZhdWx0IHZhbHVlIGluIEFUVFJTIGlmIHJlcXVpcmVkIChpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IGxpdGVyYWwsIGFycmF5IG9yIHRoZVxuICAgICAgICAgKiBhdHRyaWJ1dGUgY29uZmlndXJhdGlvbiBoYXMgY2xvbmVEZWZhdWx0VmFsdWUgc2V0IHRvIHNoYWxsb3cgb3IgZGVlcCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2FnZ3JlZ2F0ZUF0dHJzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFsbEF0dHJzIEFuIGFycmF5IG9mIEFUVFJTIGRlZmluaXRpb25zIGFjcm9zcyBjbGFzc2VzIGluIHRoZSBoaWVyYXJjaHlcbiAgICAgICAgICogKHN1YmNsYXNzIGZpcnN0LCBCYXNlIGxhc3QpXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGFnZ3JlZ2F0ZSBzZXQgb2YgQVRUUlMgZGVmaW5pdGlvbnMgZm9yIHRoZSBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgX2FnZ3JlZ2F0ZUF0dHJzIDogZnVuY3Rpb24oYWxsQXR0cnMpIHtcblxuICAgICAgICAgICAgdmFyIGF0dHIsXG4gICAgICAgICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgICAgICAgc3ViQXR0cnNIYXNoLFxuICAgICAgICAgICAgICAgIGNmZyxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgY2ZnUHJvcHNIYXNoID0gdGhpcy5fYXR0ckNmZ0hhc2goKSxcbiAgICAgICAgICAgICAgICBhZ2dBdHRyLFxuICAgICAgICAgICAgICAgIGFnZ0F0dHJzID0ge307XG5cbiAgICAgICAgICAgIGlmIChhbGxBdHRycykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGFsbEF0dHJzLmxlbmd0aC0xOyBpID49IDA7IC0taSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzID0gYWxsQXR0cnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBFUkYgVE9ETzogRG8gd2UgbmVlZCB0byBtZXJnZSBoZXJlLCBzaW5jZSB3ZSdyZSBtZXJnaW5nIGxhdGVyIGluIGdldEluc3RhbmNlQXR0ckNmZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgd2UgbW92ZSB0aGlzIGRvd24gdG8gb25seSBtZXJnZSBpZiB3ZSBoaXQgdGhlIHBhdGggb3IgdmFsdWVGbiBpZnMgYmVsb3c/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ZnID0gX3dsbWl4KHt9LCBhdHRyc1thdHRyXSwgY2ZnUHJvcHNIYXNoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLmluZGV4T2YoRE9UKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGF0dHIuc3BsaXQoRE9UKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2dBdHRyID0gYWdnQXR0cnNbYXR0cl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCAmJiBhZ2dBdHRyICYmIGFnZ0F0dHIudmFsdWUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJBdHRyc0hhc2ggPSBhZ2dBdHRycy5fc3ViQXR0cnM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJBdHRyc0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YkF0dHJzSGFzaCA9IGFnZ0F0dHJzLl9zdWJBdHRycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJBdHRyc0hhc2hbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YkF0dHJzSGFzaFthdHRyXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViQXR0cnNIYXNoW2F0dHJdW3BhdGguam9pbihET1QpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjZmcudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoIDogcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcGF0aCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWdnQXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdnQXR0cnNbYXR0cl0gPSBjZmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWdnQXR0ci52YWx1ZUZuICYmIFZBTFVFIGluIGNmZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZ0F0dHIudmFsdWVGbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCBpbnRvIGV4aXN0aW5nIGNvbmZpZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF93bG1peChhZ2dBdHRyLCBjZmcsIGNmZ1Byb3BzSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhZ2dBdHRycztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGNsYXNzIGhpZXJhcmNoeSBmb3IgdGhlIGluc3RhbmNlLCB3aGljaCBpbmNsdWRlc1xuICAgICAgICAgKiBpbml0aWFsaXppbmcgYXR0cmlidXRlcyBmb3IgZWFjaCBjbGFzcyBkZWZpbmVkIGluIHRoZSBjbGFzcydzXG4gICAgICAgICAqIHN0YXRpYyA8YSBocmVmPVwiI3Byb3BlcnR5X0Jhc2VDb3JlLkFUVFJTXCI+QVRUUlM8L2E+IHByb3BlcnR5IGFuZFxuICAgICAgICAgKiBpbnZva2luZyB0aGUgaW5pdGlhbGl6ZXIgbWV0aG9kIG9uIHRoZSBwcm90b3R5cGUgb2YgZWFjaCBjbGFzcyBpbiB0aGUgaGllcmFyY2h5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIF9pbml0SGllcmFyY2h5XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyVmFscyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHByb3BlcnR5IG5hbWUvdmFsdWUgcGFpcnNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9pbml0SGllcmFyY2h5IDogZnVuY3Rpb24odXNlclZhbHMpIHtcblxuICAgICAgICAgICAgdmFyIGxhenkgPSB0aGlzLl9sYXp5QWRkQXR0cnMsXG4gICAgICAgICAgICAgICAgY29uc3RyLFxuICAgICAgICAgICAgICAgIGNvbnN0clByb3RvLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbCxcbiAgICAgICAgICAgICAgICBjaSxcbiAgICAgICAgICAgICAgICBlaSxcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBleHQsXG4gICAgICAgICAgICAgICAgZXh0UHJvdG8sXG4gICAgICAgICAgICAgICAgZXh0cyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUF0dHJzLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVycyA9IFtdLFxuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKCksXG4gICAgICAgICAgICAgICAgYXR0ckNmZ3MgPSB0aGlzLl9nZXRBdHRyQ2ZncygpLFxuICAgICAgICAgICAgICAgIGNsID0gY2xhc3Nlcy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3RvcnNcbiAgICAgICAgICAgIGZvciAoY2kgPSBjbDsgY2kgPj0gMDsgY2ktLSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3RyID0gY2xhc3Nlc1tjaV07XG4gICAgICAgICAgICAgICAgY29uc3RyUHJvdG8gPSBjb25zdHIucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIGV4dHMgPSBjb25zdHIuX3l1aWJ1aWxkICYmIGNvbnN0ci5feXVpYnVpbGQuZXh0cztcblxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIElOSVRJQUxJWkVSIGluIGhhc093blByb3BlcnR5IGNoZWNrLCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAoaGVscHMgSUU2IGF2b2lkIEdDIHRocmVzaG9sZHMgd2hlblxuICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jaW5nIHN0cmluZyBsaXRlcmFscykuIE5vdCB1c2luZyBpdCBpbiBhcHBseSwgYWdhaW4sIGZvciBwZXJmb3JtYW5jZSBcIi5cIiBpcyBmYXN0ZXIuXG5cbiAgICAgICAgICAgICAgICBpZiAoWS5jb25maWcud2luID09PSBZLmNvbmZpZy53aW4udG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIFlVSS5zdGF0cy5tYXJrSW5pdGlhbGl6ZXIoY29uc3RyLk5BTUUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb25zdHJQcm90by5oYXNPd25Qcm9wZXJ0eShJTklUSUFMSVpFUikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgaW5pdGlhbGl6ZXIgd2hpbGUgd2UncmUgaGVyZSBhbmQgbG9vcGluZ1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplcnNbaW5pdGlhbGl6ZXJzLmxlbmd0aF0gPSBjb25zdHJQcm90by5pbml0aWFsaXplcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZXh0cykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGVpID0gMCwgZWwgPSBleHRzLmxlbmd0aDsgZWkgPCBlbDsgZWkrKykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBleHQgPSBleHRzW2VpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChZLmNvbmZpZy53aW4gPT09IFkuY29uZmlnLndpbi50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBZVUkuc3RhdHMubWFya0luaXRpYWxpemVyKGV4dC5OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dCBDb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dFByb3RvID0gZXh0LnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRQcm90by5oYXNPd25Qcm9wZXJ0eShJTklUSUFMSVpFUikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBpbml0aWFsaXplciB3aGlsZSB3ZSdyZSBoZXJlIGFuZCBsb29waW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZXJzW2luaXRpYWxpemVycy5sZW5ndGhdID0gZXh0UHJvdG8uaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFUVFJTXG4gICAgICAgICAgICBpbnN0YW5jZUF0dHJzID0gdGhpcy5fZ2V0SW5zdGFuY2VBdHRyQ2ZncyhhdHRyQ2Zncyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmVBZGRBdHRycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZUFkZEF0dHJzKGluc3RhbmNlQXR0cnMsIHVzZXJWYWxzLCBsYXp5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2FsbG93QWRIb2NBdHRycykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cnModGhpcy5fZmlsdGVyQWRIb2NBdHRycyhhdHRyQ2ZncywgdXNlclZhbHMpLCB1c2VyVmFscywgbGF6eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWRkQXR0cnMoaW5zdGFuY2VBdHRycywgdXNlclZhbHMsIGxhenkpO1xuXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplcnNcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpbml0aWFsaXplcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3lzIHRoZSBjbGFzcyBoaWVyYXJjaHkgZm9yIHRoaXMgaW5zdGFuY2UgYnkgaW52b2tpbmdcbiAgICAgICAgICogdGhlIGRlc3RydWN0b3IgbWV0aG9kIG9uIHRoZSBwcm90b3R5cGUgb2YgZWFjaCBjbGFzcyBpbiB0aGUgaGllcmFyY2h5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIF9kZXN0cm95SGllcmFyY2h5XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZGVzdHJveUhpZXJhcmNoeSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbnN0cixcbiAgICAgICAgICAgICAgICBjb25zdHJQcm90byxcbiAgICAgICAgICAgICAgICBjaSwgY2wsIGVpLCBlbCwgZXh0cywgZXh0UHJvdG8sXG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoKTtcblxuICAgICAgICAgICAgZm9yIChjaSA9IDAsIGNsID0gY2xhc3Nlcy5sZW5ndGg7IGNpIDwgY2w7IGNpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdHIgPSBjbGFzc2VzW2NpXTtcbiAgICAgICAgICAgICAgICBjb25zdHJQcm90byA9IGNvbnN0ci5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgZXh0cyA9IGNvbnN0ci5feXVpYnVpbGQgJiYgY29uc3RyLl95dWlidWlsZC5leHRzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlaSA9IDAsIGVsID0gZXh0cy5sZW5ndGg7IGVpIDwgZWw7IGVpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dFByb3RvID0gZXh0c1tlaV0ucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dFByb3RvLmhhc093blByb3BlcnR5KERFU1RSVUNUT1IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFkuY29uZmlnLndpbiA9PT0gWS5jb25maWcud2luLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBZVUkuc3RhdHMubWFya0Rlc3RydWN0b3IoZXh0c1tlaV0uTkFNRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dFByb3RvLmRlc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb25zdHJQcm90by5oYXNPd25Qcm9wZXJ0eShERVNUUlVDVE9SKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoWS5jb25maWcud2luID09PSBZLmNvbmZpZy53aW4udG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBZVUkuc3RhdHMubWFya0Rlc3RydWN0b3IoY29uc3RyLk5BTUUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0clByb3RvLmRlc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgdG9TdHJpbmcgaW1wbGVtZW50YXRpb24uIFByb3ZpZGVzIHRoZSBjb25zdHJ1Y3RvciBOQU1FXG4gICAgICAgICAqIGFuZCB0aGUgaW5zdGFuY2UgZ3VpZCwgaWYgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGlzIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiW1wiICsgWS5zdGFtcCh0aGlzLCB0cnVlKSArIFwiXVwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFN0cmFpZ2h0dXAgYXVnbWVudCwgbm8gd3JhcHBlciBmdW5jdGlvbnNcbiAgICBZLm1peChCYXNlQ29yZSwgQXR0cmlidXRlQ29yZSwgZmFsc2UsIG51bGwsIDEpO1xuXG4gICAgLy8gRml4IGNvbnN0cnVjdG9yXG4gICAgQmFzZUNvcmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFzZUNvcmU7XG5cbiAgICBZLkJhc2VDb3JlID0gQmFzZUNvcmU7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImF0dHJpYnV0ZS1jb3JlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2Jhc2Utb2JzZXJ2YWJsZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbiAgICAvKipcbiAgICBUaGUgYGJhc2Utb2JzZXJ2YWJsZWAgc3VibW9kdWxlIGFkZHMgb2JzZXJ2YWJpbGl0eSB0byBCYXNlJ3MgbGlmZWN5Y2xlIGFuZFxuICAgIGF0dHJpYnV0ZXMsIGFuZCBhbHNvIG1ha2UgaXQgYW4gYEV2ZW50VGFyZ2V0YC5cblxuICAgIEBtb2R1bGUgYmFzZVxuICAgIEBzdWJtb2R1bGUgYmFzZS1vYnNlcnZhYmxlXG4gICAgKiovXG4gICAgdmFyIEwgPSBZLkxhbmcsXG5cbiAgICAgICAgREVTVFJPWSA9IFwiZGVzdHJveVwiLFxuICAgICAgICBJTklUID0gXCJpbml0XCIsXG5cbiAgICAgICAgQlVCQkxFVEFSR0VUUyA9IFwiYnViYmxlVGFyZ2V0c1wiLFxuICAgICAgICBfQlVCQkxFVEFSR0VUUyA9IFwiX2J1YmJsZVRhcmdldHNcIixcblxuICAgICAgICBBdHRyaWJ1dGVPYnNlcnZhYmxlID0gWS5BdHRyaWJ1dGVPYnNlcnZhYmxlLFxuICAgICAgICBCYXNlQ29yZSAgICAgICAgICAgID0gWS5CYXNlQ29yZTtcblxuICAgIC8qKlxuICAgIFByb3ZpZGVzIGFuIGF1Z21lbnRhYmxlIGltcGxlbWVudGF0aW9uIG9mIGxpZmVjeWNsZSBhbmQgYXR0cmlidXRlIGV2ZW50cyBmb3JcbiAgICBgQmFzZUNvcmVgLlxuXG4gICAgQGNsYXNzIEJhc2VPYnNlcnZhYmxlXG4gICAgQGV4dGVuc2lvbmZvciBCYXNlQ29yZVxuICAgIEB1c2VzIEF0dHJpYnV0ZU9ic2VydmFibGVcbiAgICBAdXNlcyBFdmVudFRhcmdldFxuICAgIEBzaW5jZSAzLjguMFxuICAgICoqL1xuICAgIGZ1bmN0aW9uIEJhc2VPYnNlcnZhYmxlKCkge31cblxuICAgIEJhc2VPYnNlcnZhYmxlLl9BVFRSX0NGRyAgICAgID0gQXR0cmlidXRlT2JzZXJ2YWJsZS5fQVRUUl9DRkcuY29uY2F0KCk7XG4gICAgQmFzZU9ic2VydmFibGUuX05PTl9BVFRSU19DRkcgPSBbXCJvblwiLCBcImFmdGVyXCIsIFwiYnViYmxlVGFyZ2V0c1wiXTtcblxuICAgIEJhc2VPYnNlcnZhYmxlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgQXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2luaXRBdHRyaWJ1dGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9pbml0QXR0cmlidXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEJhc2VDb3JlLnByb3RvdHlwZS5faW5pdEF0dHJpYnV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgQXR0cmlidXRlT2JzZXJ2YWJsZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLl9ldmVudFByZWZpeCA9IHRoaXMuY29uc3RydWN0b3IuRVZFTlRfUFJFRklYIHx8IHRoaXMuY29uc3RydWN0b3IuTkFNRTtcbiAgICAgICAgICAgIHRoaXMuX3l1aWV2dC5jb25maWcucHJlZml4ID0gdGhpcy5fZXZlbnRQcmVmaXg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXQgbGlmZWN5Y2xlIG1ldGhvZCwgaW52b2tlZCBkdXJpbmcgY29uc3RydWN0aW9uLlxuICAgICAgICAgKiBGaXJlcyB0aGUgaW5pdCBldmVudCBwcmlvciB0byBzZXR0aW5nIHVwIGF0dHJpYnV0ZXMgYW5kXG4gICAgICAgICAqIGludm9raW5nIGluaXRpYWxpemVycyBmb3IgdGhlIGNsYXNzIGhpZXJhcmNoeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBpbml0XG4gICAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHByb3BlcnR5IG5hbWUvdmFsdWUgcGFpcnNcbiAgICAgICAgICogQHJldHVybiB7QmFzZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIDxwPlxuICAgICAgICAgICAgICogTGlmZWN5Y2xlIGV2ZW50IGZvciB0aGUgaW5pdCBwaGFzZSwgZmlyZWQgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAgICAgKiBJbnZva2luZyB0aGUgcHJldmVudERlZmF1bHQoKSBtZXRob2Qgb24gdGhlIGV2ZW50IG9iamVjdCBwcm92aWRlZFxuICAgICAgICAgICAgICogdG8gc3Vic2NyaWJlcnMgd2lsbCBwcmV2ZW50IGluaXRpYWxpemF0aW9uIGZyb20gb2NjdXJpbmcuXG4gICAgICAgICAgICAgKiA8L3A+XG4gICAgICAgICAgICAgKiA8cD5cbiAgICAgICAgICAgICAqIFN1YnNjcmliZXJzIHRvIHRoZSBcImFmdGVyXCIgbW9tZW10IG9mIHRoaXMgZXZlbnQsIHdpbGwgYmUgbm90aWZpZWRcbiAgICAgICAgICAgICAqIGFmdGVyIGluaXRpYWxpemF0aW9uIG9mIHRoZSBvYmplY3QgaXMgY29tcGxldGUgKGFuZCB0aGVyZWZvcmVcbiAgICAgICAgICAgICAqIGNhbm5vdCBwcmV2ZW50IGluaXRpYWxpemF0aW9uKS5cbiAgICAgICAgICAgICAqIDwvcD5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXZlbnQgaW5pdFxuICAgICAgICAgICAgICogQHByZXZlbnRhYmxlIF9kZWZJbml0Rm5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGUgRXZlbnQgb2JqZWN0LCB3aXRoIGEgY2ZnIHByb3BlcnR5IHdoaWNoXG4gICAgICAgICAgICAgKiByZWZlcnMgdG8gdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gUEVSRjogVXNpbmcgbG93ZXIgbGV2ZWwgX3B1Ymxpc2goKSBmb3JcbiAgICAgICAgICAgIC8vIGNyaXRpY2FsIHBhdGggcGVyZm9ybWFuY2VcblxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl9nZXRGdWxsVHlwZShJTklUKSxcbiAgICAgICAgICAgICAgICBlID0gdGhpcy5fcHVibGlzaCh0eXBlKTtcblxuICAgICAgICAgICAgZS5lbWl0RmFjYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGUuZmlyZU9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgZS5kZWZhdWx0VGFyZ2V0T25seSA9IHRydWU7XG4gICAgICAgICAgICBlLmRlZmF1bHRGbiA9IHRoaXMuX2RlZkluaXRGbjtcblxuICAgICAgICAgICAgdGhpcy5fcHJlSW5pdEV2ZW50Q2ZnKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChlLl9oYXNQb3RlbnRpYWxTdWJzY3JpYmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKHR5cGUsIHtjZmc6IGNvbmZpZ30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Jhc2VJbml0KGNvbmZpZyk7XG5cbiAgICAgICAgICAgICAgICAvLyBIQUNLLiBNYWpvciBoYWNrIGFjdHVhbGx5LiBCdXQgcmVhbGx5IGZhc3QgZm9yIG5vLWxpc3RlbmVycy5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBpdCdzIGZpcmVPbmNlLCBzdWJzY3JpYmVycyBtYXkgY29tZSBhbG9uZyBsYXRlciwgc28gc2luY2Ugd2UncmVcbiAgICAgICAgICAgICAgICAvLyBieXBhc3NpbmcgdGhlIGV2ZW50IHN0YWNrIHRoZSBmaXJzdCB0aW1lLCB3ZSBuZWVkIHRvIHRlbGwgdGhlIHB1Ymxpc2hlZFxuICAgICAgICAgICAgICAgIC8vIGV2ZW50IHRoYXQgaXQncyBiZWVuIFwiZmlyZWRcIi4gQ291bGQgZXh0cmFjdCBpdCBpbnRvIGEgQ0UgbWV0aG9kP1xuICAgICAgICAgICAgICAgIGUuZmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGUuZmlyZWRXaXRoID0gW3tjZmc6Y29uZmlnfV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHRoZSBzcGVjaWFsIG9uLCBhZnRlciBhbmQgdGFyZ2V0IHByb3BlcnRpZXMgd2hpY2ggYWxsb3cgdGhlIHVzZXIgdG9cbiAgICAgICAgICogZWFzaWx5IGNvbmZpZ3VyZSBvbiBhbmQgYWZ0ZXIgbGlzdGVuZXJzIGFzIHdlbGwgYXMgYnViYmxlIHRhcmdldHMgZHVyaW5nXG4gICAgICAgICAqIGNvbnN0cnVjdGlvbiwgcHJpb3IgdG8gaW5pdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1ldGhvZCBfcHJlSW5pdEV2ZW50Q2ZnXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIHVzZXIgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIF9wcmVJbml0RXZlbnRDZmcgOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLm9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub24oY29uZmlnLm9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5hZnRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFmdGVyKGNvbmZpZy5hZnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaSwgbCwgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHVzZXJUYXJnZXRzID0gKGNvbmZpZyAmJiBCVUJCTEVUQVJHRVRTIGluIGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICh1c2VyVGFyZ2V0cyB8fCBfQlVCQkxFVEFSR0VUUyBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdXNlclRhcmdldHMgPyAoY29uZmlnICYmIGNvbmZpZy5idWJibGVUYXJnZXRzKSA6IHRoaXMuX2J1YmJsZVRhcmdldHM7XG5cbiAgICAgICAgICAgICAgICBpZiAoTC5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRhcmdldC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFyZ2V0KHRhcmdldFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhcmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIERlc3Ryb3kgbGlmZWN5Y2xlIG1ldGhvZC4gRmlyZXMgdGhlIGRlc3Ryb3lcbiAgICAgICAgICogZXZlbnQsIHByaW9yIHRvIGludm9raW5nIGRlc3RydWN0b3JzIGZvciB0aGVcbiAgICAgICAgICogY2xhc3MgaGllcmFyY2h5LlxuICAgICAgICAgKiA8L3A+XG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBTdWJzY3JpYmVycyB0byB0aGUgZGVzdHJveVxuICAgICAgICAgKiBldmVudCBjYW4gaW52b2tlIHByZXZlbnREZWZhdWx0IG9uIHRoZSBldmVudCBvYmplY3QsIHRvIHByZXZlbnQgZGVzdHJ1Y3Rpb25cbiAgICAgICAgICogZnJvbSBwcm9jZWVkaW5nLlxuICAgICAgICAgKiA8L3A+XG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAgICAgKiBAcmV0dXJuIHtCYXNlfSBBIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdFxuICAgICAgICAgKiBAY2hhaW5hYmxlXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiA8cD5cbiAgICAgICAgICAgICAqIExpZmVjeWNsZSBldmVudCBmb3IgdGhlIGRlc3Ryb3kgcGhhc2UsXG4gICAgICAgICAgICAgKiBmaXJlZCBwcmlvciB0byBkZXN0cnVjdGlvbi4gSW52b2tpbmcgdGhlIHByZXZlbnREZWZhdWx0XG4gICAgICAgICAgICAgKiBtZXRob2Qgb24gdGhlIGV2ZW50IG9iamVjdCBwcm92aWRlZCB0byBzdWJzY3JpYmVycyB3aWxsXG4gICAgICAgICAgICAgKiBwcmV2ZW50IGRlc3RydWN0aW9uIGZyb20gcHJvY2VlZGluZy5cbiAgICAgICAgICAgICAqIDwvcD5cbiAgICAgICAgICAgICAqIDxwPlxuICAgICAgICAgICAgICogU3Vic2NyaWJlcnMgdG8gdGhlIFwiYWZ0ZXJcIiBtb21lbnQgb2YgdGhpcyBldmVudCwgd2lsbCBiZSBub3RpZmllZFxuICAgICAgICAgICAgICogYWZ0ZXIgZGVzdHJ1Y3Rpb24gaXMgY29tcGxldGUgKGFuZCBhcyBhIHJlc3VsdCBjYW5ub3QgcHJldmVudFxuICAgICAgICAgICAgICogZGVzdHJ1Y3Rpb24pLlxuICAgICAgICAgICAgICogPC9wPlxuICAgICAgICAgICAgICogQGV2ZW50IGRlc3Ryb3lcbiAgICAgICAgICAgICAqIEBwcmV2ZW50YWJsZSBfZGVmRGVzdHJveUZuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50RmFjYWRlfSBlIEV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2goREVTVFJPWSwge1xuICAgICAgICAgICAgICAgIGZpcmVPbmNlOnRydWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhcmdldE9ubHk6dHJ1ZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0Rm46IHRoaXMuX2RlZkRlc3Ryb3lGblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoREVTVFJPWSk7XG5cbiAgICAgICAgICAgIHRoaXMuZGV0YWNoQWxsKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBpbml0IGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfZGVmSW5pdEZuXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGUgRXZlbnQgb2JqZWN0LCB3aXRoIGEgY2ZnIHByb3BlcnR5IHdoaWNoXG4gICAgICAgICAqIHJlZmVycyB0byB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgX2RlZkluaXRGbiA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VJbml0KGUuY2ZnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBkZXN0cm95IGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfZGVmRGVzdHJveUZuXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGUgRXZlbnQgb2JqZWN0XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIF9kZWZEZXN0cm95Rm4gOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXNlRGVzdHJveShlLmNmZyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgWS5taXgoQmFzZU9ic2VydmFibGUsIEF0dHJpYnV0ZU9ic2VydmFibGUsIGZhbHNlLCBudWxsLCAxKTtcblxuICAgIFkuQmFzZU9ic2VydmFibGUgPSBCYXNlT2JzZXJ2YWJsZTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiYXR0cmlidXRlLW9ic2VydmFibGVcIiwgXCJiYXNlLWNvcmVcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnYmFzZS1wbHVnaW5ob3N0JywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlLXBsdWdpbmhvc3Qgc3VibW9kdWxlIGFkZHMgUGx1Z2luIHN1cHBvcnQgdG8gQmFzZSwgYnkgYXVnbWVudGluZyBCYXNlIHdpdGhcbiAgICAgKiBQbHVnaW4uSG9zdCBhbmQgc2V0dGluZyB1cCBzdGF0aWMgKGNsYXNzIGxldmVsKSBCYXNlLnBsdWcgYW5kIEJhc2UudW5wbHVnIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIGJhc2VcbiAgICAgKiBAc3VibW9kdWxlIGJhc2UtcGx1Z2luaG9zdFxuICAgICAqIEBmb3IgQmFzZVxuICAgICAqL1xuXG4gICAgdmFyIEJhc2UgPSBZLkJhc2UsXG4gICAgICAgIFBsdWdpbkhvc3QgPSBZLlBsdWdpbi5Ib3N0O1xuXG4gICAgWS5taXgoQmFzZSwgUGx1Z2luSG9zdCwgZmFsc2UsIG51bGwsIDEpO1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIDxhIGhyZWY9XCJQbHVnaW4uSG9zdC5odG1sI21ldGhvZF9QbHVnaW4uSG9zdC5wbHVnXCI+UGx1Z2luLkhvc3QucGx1ZzwvYT4uIFNlZSBhbGlhc2VkXG4gICAgICogbWV0aG9kIGZvciBhcmd1bWVudCBhbmQgcmV0dXJuIHZhbHVlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHBsdWdcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgQmFzZS5wbHVnID0gUGx1Z2luSG9zdC5wbHVnO1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIDxhIGhyZWY9XCJQbHVnaW4uSG9zdC5odG1sI21ldGhvZF9QbHVnaW4uSG9zdC51bnBsdWdcIj5QbHVnaW4uSG9zdC51bnBsdWc8L2E+LiBTZWUgdGhlXG4gICAgICogYWxpYXNlZCBtZXRob2QgZm9yIGFyZ3VtZW50IGFuZCByZXR1cm4gdmFsdWUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdW5wbHVnXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIEJhc2UudW5wbHVnID0gUGx1Z2luSG9zdC51bnBsdWc7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImJhc2UtYmFzZVwiLCBcInBsdWdpbmhvc3RcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnY2xhc3NuYW1lbWFuYWdlcicsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuKiBDb250YWlucyBhIHNpbmdsZXRvbiAoQ2xhc3NOYW1lTWFuYWdlcikgdGhhdCBlbmFibGVzIGVhc3kgY3JlYXRpb24gYW5kIGNhY2hpbmcgb2ZcbiogcHJlZml4ZWQgY2xhc3MgbmFtZXMuXG4qIEBtb2R1bGUgY2xhc3NuYW1lbWFuYWdlclxuKi9cblxuLyoqXG4gKiBBIHNpbmdsZXRvbiBjbGFzcyBwcm92aWRpbmc6XG4gKlxuICogPHVsPlxuICogICAgPGxpPkVhc3kgY3JlYXRpb24gb2YgcHJlZml4ZWQgY2xhc3MgbmFtZXM8L2xpPlxuICogICAgPGxpPkNhY2hpbmcgb2YgcHJldmlvdXNseSBjcmVhdGVkIGNsYXNzIG5hbWVzIGZvciBpbXByb3ZlZCBwZXJmb3JtYW5jZS48L2xpPlxuICogPC91bD5cbiAqXG4gKiBAY2xhc3MgQ2xhc3NOYW1lTWFuYWdlclxuICogQHN0YXRpY1xuICovXG5cbi8vIFN0cmluZyBjb25zdGFudHNcbnZhciBDTEFTU19OQU1FX1BSRUZJWCA9ICdjbGFzc05hbWVQcmVmaXgnLFxuXHRDTEFTU19OQU1FX0RFTElNSVRFUiA9ICdjbGFzc05hbWVEZWxpbWl0ZXInLFxuICAgIENPTkZJRyA9IFkuY29uZmlnO1xuXG4vLyBHbG9iYWwgY29uZmlnXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBwcm9wZXJ0eSBpbmRpY2F0aW5nIHRoZSBwcmVmaXggZm9yIGFsbCBDU1MgY2xhc3MgbmFtZXMgaW4gdGhpcyBZVUkgaW5zdGFuY2UuXG4gKlxuICogQHByb3BlcnR5IGNsYXNzTmFtZVByZWZpeFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0IFwieXVpXCJcbiAqIEBzdGF0aWNcbiAqL1xuQ09ORklHW0NMQVNTX05BTUVfUFJFRklYXSA9IENPTkZJR1tDTEFTU19OQU1FX1BSRUZJWF0gfHwgJ3l1aTMnO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gcHJvcGVydHkgaW5kaWNhdGluZyB0aGUgZGVsaW1pdGVyIHVzZWQgdG8gY29tcG9zZSBhbGwgQ1NTIGNsYXNzIG5hbWVzIGluXG4gKiB0aGlzIFlVSSBpbnN0YW5jZS5cbiAqXG4gKiBAcHJvcGVydHkgY2xhc3NOYW1lRGVsaW1pdGVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgXCItXCJcbiAqIEBzdGF0aWNcbiAqL1xuQ09ORklHW0NMQVNTX05BTUVfREVMSU1JVEVSXSA9IENPTkZJR1tDTEFTU19OQU1FX0RFTElNSVRFUl0gfHwgJy0nO1xuXG5ZLkNsYXNzTmFtZU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHNQcmVmaXggICAgPSBDT05GSUdbQ0xBU1NfTkFNRV9QUkVGSVhdLFxuXHRcdHNEZWxpbWl0ZXIgPSBDT05GSUdbQ0xBU1NfTkFNRV9ERUxJTUlURVJdO1xuXG5cdHJldHVybiB7XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgY2xhc3MgbmFtZSBwcmVmaXhlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGVcblx0XHQgKiA8Y29kZT5ZLmNvbmZpZy5jbGFzc05hbWVQcmVmaXg8L2NvZGU+IGF0dHJpYnV0ZSArIHRoZSBwcm92aWRlZCBzdHJpbmdzLlxuXHRcdCAqIFVzZXMgdGhlIDxjb2RlPlkuY29uZmlnLmNsYXNzTmFtZURlbGltaXRlcjwvY29kZT4gYXR0cmlidXRlIHRvIGRlbGltaXQgdGhlXG5cdFx0ICogcHJvdmlkZWQgc3RyaW5ncy4gRS5nLiBZLkNsYXNzTmFtZU1hbmFnZXIuZ2V0Q2xhc3NOYW1lKCdmb28nLCdiYXInKTsgLy8geXVpLWZvby1iYXJcblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgZ2V0Q2xhc3NOYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IFtjbGFzc25hbWVTZWN0aW9uKl0gb25lIG9yIG1vcmUgY2xhc3NuYW1lIHNlY3Rpb25zIHRvIGJlIGpvaW5lZFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcFByZWZpeCBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGNsYXNzbmFtZSB3aWxsIG5vdCBiZSBwcmVmaXhlZCB3aXRoIHRoZSBkZWZhdWx0IFkuY29uZmlnLmNsYXNzTmFtZURlbGltaXRlciB2YWx1ZS5cblx0XHQgKi9cblx0XHRnZXRDbGFzc05hbWU6IFkuY2FjaGVkKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBZLkFycmF5KGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChhcmdzW2FyZ3MubGVuZ3RoLTFdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KHNQcmVmaXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgfVxuXG5cdFx0XHRyZXR1cm4gYXJncy5qb2luKHNEZWxpbWl0ZXIpO1xuXHRcdH0pXG5cblx0fTtcblxufSgpO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJ5dWktYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdjb2xvci1iYXNlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG5Db2xvciBwcm92aWRlcyBzdGF0aWMgbWV0aG9kcyBmb3IgY29sb3IgY29udmVyc2lvbi5cblxuICAgIFkuQ29sb3IudG9SR0IoJ2YwMCcpOyAvLyByZ2IoMjU1LCAwLCAwKVxuXG4gICAgWS5Db2xvci50b0hleCgncmdiKDI1NSwgMjU1LCAwKScpOyAvLyAjZmZmZjAwXG5cbkBtb2R1bGUgY29sb3JcbkBzdWJtb2R1bGUgY29sb3ItYmFzZVxuQGNsYXNzIENvbG9yXG5Ac2luY2UgMy44LjBcbioqL1xuXG52YXIgUkVHRVhfSEVYID0gL14jPyhbXFxkYS1mQS1GXXsyfSkoW1xcZGEtZkEtRl17Mn0pKFtcXGRhLWZBLUZdezJ9KShcXHVmZmZlKT8vLFxuICAgIFJFR0VYX0hFWDMgPSAvXiM/KFtcXGRhLWZBLUZdezF9KShbXFxkYS1mQS1GXXsxfSkoW1xcZGEtZkEtRl17MX0pKFxcdWZmZmUpPy8sXG4gICAgUkVHRVhfUkdCID0gL3JnYmE/XFwoKFtcXGRdezEsM30pLCA/KFtcXGRdezEsM30pLCA/KFtcXGRdezEsM30pLD8gPyhbLlxcZF0qKT9cXCkvLFxuICAgIFRZUEVTID0geyAnSEVYJzogJ2hleCcsICdSR0InOiAncmdiJywgJ1JHQkEnOiAncmdiYScgfSxcbiAgICBDT05WRVJUUyA9IHsgJ2hleCc6ICd0b0hleCcsICdyZ2InOiAndG9SR0InLCAncmdiYSc6ICd0b1JHQkEnIH07XG5cblxuWS5Db2xvciA9IHtcbiAgICAvKipcbiAgICBAc3RhdGljXG4gICAgQHByb3BlcnR5IEtFWVdPUkRTXG4gICAgQHR5cGUgT2JqZWN0XG4gICAgQHNpbmNlIDMuOC4wXG4gICAgKiovXG4gICAgS0VZV09SRFM6IHtcbiAgICAgICAgJ2JsYWNrJzogJzAwMCcsICdzaWx2ZXInOiAnYzBjMGMwJywgJ2dyYXknOiAnODA4MDgwJywgJ3doaXRlJzogJ2ZmZicsXG4gICAgICAgICdtYXJvb24nOiAnODAwMDAwJywgJ3JlZCc6ICdmMDAnLCAncHVycGxlJzogJzgwMDA4MCcsICdmdWNoc2lhJzogJ2YwZicsXG4gICAgICAgICdncmVlbic6ICcwMDgwMDAnLCAnbGltZSc6ICcwZjAnLCAnb2xpdmUnOiAnODA4MDAwJywgJ3llbGxvdyc6ICdmZjAnLFxuICAgICAgICAnbmF2eSc6ICcwMDAwODAnLCAnYmx1ZSc6ICcwMGYnLCAndGVhbCc6ICcwMDgwODAnLCAnYXF1YSc6ICcwZmYnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAgICBOT1RFOiBgKFxcdWZmZmUpP2AgaXMgYWRkZWQgdG8gdGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB0byBjYXJ2ZSBvdXQgYVxuICAgICAgICBwbGFjZSBmb3IgdGhlIGFscGhhIGNoYW5uZWwgdGhhdCBpcyByZXR1cm5lZCBmcm9tIHRvQXJyYXlcbiAgICAgICAgd2l0aG91dCBjb21wcm9taXNpbmcgYW55IHVzYWdlIG9mIHRoZSBSZWd1bGFyIEV4cHJlc3Npb25cblxuICAgIEBzdGF0aWNcbiAgICBAcHJvcGVydHkgUkVHRVhfSEVYXG4gICAgQHR5cGUgUmVnRXhwXG4gICAgQGRlZmF1bHQgL14jPyhbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShcXHVmZmZlKT8vXG4gICAgQHNpbmNlIDMuOC4wXG4gICAgKiovXG4gICAgUkVHRVhfSEVYOiBSRUdFWF9IRVgsXG5cbiAgICAvKipcbiAgICAgICAgTk9URTogYChcXHVmZmZlKT9gIGlzIGFkZGVkIHRvIHRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdG8gY2FydmUgb3V0IGFcbiAgICAgICAgcGxhY2UgZm9yIHRoZSBhbHBoYSBjaGFubmVsIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB0b0FycmF5XG4gICAgICAgIHdpdGhvdXQgY29tcHJvbWlzaW5nIGFueSB1c2FnZSBvZiB0aGUgUmVndWxhciBFeHByZXNzaW9uXG5cbiAgICBAc3RhdGljXG4gICAgQHByb3BlcnR5IFJFR0VYX0hFWDNcbiAgICBAdHlwZSBSZWdFeHBcbiAgICBAZGVmYXVsdCAvXiM/KFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFxcdWZmZmUpPy9cbiAgICBAc2luY2UgMy44LjBcbiAgICAqKi9cbiAgICBSRUdFWF9IRVgzOiBSRUdFWF9IRVgzLFxuXG4gICAgLyoqXG4gICAgQHN0YXRpY1xuICAgIEBwcm9wZXJ0eSBSRUdFWF9SR0JcbiAgICBAdHlwZSBSZWdFeHBcbiAgICBAZGVmYXVsdCAvcmdiYT9cXCgoWzAtOV17MSwzfSksID8oWzAtOV17MSwzfSksID8oWzAtOV17MSwzfSksPyA/KFsuMC05XXsxLDN9KT9cXCkvXG4gICAgQHNpbmNlIDMuOC4wXG4gICAgKiovXG4gICAgUkVHRVhfUkdCOiBSRUdFWF9SR0IsXG5cbiAgICByZV9SR0I6IFJFR0VYX1JHQixcblxuICAgIHJlX2hleDogUkVHRVhfSEVYLFxuXG4gICAgcmVfaGV4MzogUkVHRVhfSEVYMyxcblxuICAgIC8qKlxuICAgIEBzdGF0aWNcbiAgICBAcHJvcGVydHkgU1RSX0hFWFxuICAgIEB0eXBlIFN0cmluZ1xuICAgIEBkZWZhdWx0ICN7Kn17Kn17Kn1cbiAgICBAc2luY2UgMy44LjBcbiAgICAqKi9cbiAgICBTVFJfSEVYOiAnI3sqfXsqfXsqfScsXG5cbiAgICAvKipcbiAgICBAc3RhdGljXG4gICAgQHByb3BlcnR5IFNUUl9SR0JcbiAgICBAdHlwZSBTdHJpbmdcbiAgICBAZGVmYXVsdCByZ2Ioeyp9LCB7Kn0sIHsqfSlcbiAgICBAc2luY2UgMy44LjBcbiAgICAqKi9cbiAgICBTVFJfUkdCOiAncmdiKHsqfSwgeyp9LCB7Kn0pJyxcblxuICAgIC8qKlxuICAgIEBzdGF0aWNcbiAgICBAcHJvcGVydHkgU1RSX1JHQkFcbiAgICBAdHlwZSBTdHJpbmdcbiAgICBAZGVmYXVsdCByZ2JhKHsqfSwgeyp9LCB7Kn0sIHsqfSlcbiAgICBAc2luY2UgMy44LjBcbiAgICAqKi9cbiAgICBTVFJfUkdCQTogJ3JnYmEoeyp9LCB7Kn0sIHsqfSwgeyp9KScsXG5cbiAgICAvKipcbiAgICBAc3RhdGljXG4gICAgQHByb3BlcnR5IFRZUEVTXG4gICAgQHR5cGUgT2JqZWN0XG4gICAgQGRlZmF1bHQgeydyZ2InOidyZ2InLCAncmdiYSc6J3JnYmEnfVxuICAgIEBzaW5jZSAzLjguMFxuICAgICoqL1xuICAgIFRZUEVTOiBUWVBFUyxcblxuICAgIC8qKlxuICAgIEBzdGF0aWNcbiAgICBAcHJvcGVydHkgQ09OVkVSVFNcbiAgICBAdHlwZSBPYmplY3RcbiAgICBAZGVmYXVsdCB7fVxuICAgIEBzaW5jZSAzLjguMFxuICAgICoqL1xuICAgIENPTlZFUlRTOiBDT05WRVJUUyxcblxuICAgIC8qKlxuICAgICBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgc3RyaW5nIHRvIHRoZSBwcm92aWRlZCB0eXBlLlxuICAgICBZb3UgY2FuIHVzZSB0aGUgYFkuQ29sb3IuVFlQRVNgIHRvIGdldCBhIHZhbGlkIGB0b2AgdHlwZS5cbiAgICAgSWYgdGhlIGNvbG9yIGNhbm5vdCBiZSBjb252ZXJ0ZWQsIHRoZSBvcmlnaW5hbCBjb2xvciB3aWxsIGJlIHJldHVybmVkLlxuXG4gICAgIEBwdWJsaWNcbiAgICAgQG1ldGhvZCBjb252ZXJ0XG4gICAgIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICAgQHBhcmFtIHtTdHJpbmd9IHRvXG4gICAgIEByZXR1cm4ge1N0cmluZ31cbiAgICAgQHNpbmNlIDMuOC4wXG4gICAgICoqL1xuICAgIGNvbnZlcnQ6IGZ1bmN0aW9uIChzdHIsIHRvKSB7XG4gICAgICAgIHZhciBjb252ZXJ0ID0gWS5Db2xvci5DT05WRVJUU1t0by50b0xvd2VyQ2FzZSgpXSxcbiAgICAgICAgICAgIGNsciA9IHN0cjtcblxuICAgICAgICBpZiAoY29udmVydCAmJiBZLkNvbG9yW2NvbnZlcnRdKSB7XG4gICAgICAgICAgICBjbHIgPSBZLkNvbG9yW2NvbnZlcnRdKHN0cik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBDb252ZXJ0cyBwcm92aWRlZCBjb2xvciB2YWx1ZSB0byBhIGhleCB2YWx1ZSBzdHJpbmdcblxuICAgIEBwdWJsaWNcbiAgICBAbWV0aG9kIHRvSGV4XG4gICAgQHBhcmFtIHtTdHJpbmd9IHN0ciBIZXggb3IgUkdCIHZhbHVlIHN0cmluZ1xuICAgIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyBhcnJheSBvZiB2YWx1ZXMgb3IgQ1NTIHN0cmluZyBpZiBvcHRpb25zLmNzcyBpcyB0cnVlXG4gICAgQHNpbmNlIDMuOC4wXG4gICAgKiovXG4gICAgdG9IZXg6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIGNsciA9IFkuQ29sb3IuX2NvbnZlcnRUbyhzdHIsICdoZXgnKSxcbiAgICAgICAgICAgIGlzVHJhbnNwYXJlbnQgPSBjbHIudG9Mb3dlckNhc2UoKSA9PT0gJ3RyYW5zcGFyZW50JztcblxuICAgICAgICBpZiAoY2xyLmNoYXJBdCgwKSAhPT0gJyMnICYmICFpc1RyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICBjbHIgPSAnIycgKyBjbHI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNUcmFuc3BhcmVudCA/IGNsci50b0xvd2VyQ2FzZSgpIDogY2xyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIENvbnZlcnRzIHByb3ZpZGVkIGNvbG9yIHZhbHVlIHRvIGFuIFJHQiB2YWx1ZSBzdHJpbmdcbiAgICBAcHVibGljXG4gICAgQG1ldGhvZCB0b1JHQlxuICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgSGV4IG9yIFJHQiB2YWx1ZSBzdHJpbmdcbiAgICBAcmV0dXJuIHtTdHJpbmd9XG4gICAgQHNpbmNlIDMuOC4wXG4gICAgKiovXG4gICAgdG9SR0I6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIGNsciA9IFkuQ29sb3IuX2NvbnZlcnRUbyhzdHIsICdyZ2InKTtcbiAgICAgICAgcmV0dXJuIGNsci50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBDb252ZXJ0cyBwcm92aWRlZCBjb2xvciB2YWx1ZSB0byBhbiBSR0IgdmFsdWUgc3RyaW5nXG4gICAgQHB1YmxpY1xuICAgIEBtZXRob2QgdG9SR0JBXG4gICAgQHBhcmFtIHtTdHJpbmd9IHN0ciBIZXggb3IgUkdCIHZhbHVlIHN0cmluZ1xuICAgIEByZXR1cm4ge1N0cmluZ31cbiAgICBAc2luY2UgMy44LjBcbiAgICAqKi9cbiAgICB0b1JHQkE6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIGNsciA9IFkuQ29sb3IuX2NvbnZlcnRUbyhzdHIsICdyZ2JhJyApO1xuICAgICAgICByZXR1cm4gY2xyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIENvbnZlcnRzIHRoZSBwcm92aWRlZCBjb2xvciBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgdmFsdWVzIHdoZXJlIHRoZVxuICAgICAgICBsYXN0IHZhbHVlIGlzIHRoZSBhbHBoYSB2YWx1ZS4gV2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgaWZcbiAgICAgICAgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBub3QgYWJsZSB0byBiZSBwYXJzZWQuXG5cbiAgICAgICAgTk9URTogYChcXHVmZmZlKT9gIGlzIGFkZGVkIHRvIGBIRVhgIGFuZCBgSEVYM2AgUmVndWxhciBFeHByZXNzaW9ucyB0b1xuICAgICAgICBjYXJ2ZSBvdXQgYSBwbGFjZSBmb3IgdGhlIGFscGhhIGNoYW5uZWwgdGhhdCBpcyByZXR1cm5lZCBmcm9tXG4gICAgICAgIHRvQXJyYXkgd2l0aG91dCBjb21wcm9taXNpbmcgYW55IHVzYWdlIG9mIHRoZSBSZWd1bGFyIEV4cHJlc3Npb25cblxuICAgICAgICBZLkNvbG9yLnRvQXJyYXkoJ2ZmZicpOyAgICAgICAgICAgICAgLy8gWydmZicsICdmZicsICdmZicsIDFdXG4gICAgICAgIFkuQ29sb3IudG9BcnJheSgncmdiKDAsIDAsIDApJyk7ICAgICAvLyBbJzAnLCAnMCcsICcwJywgMV1cbiAgICAgICAgWS5Db2xvci50b0FycmF5KCdyZ2JhKDAsIDAsIDAsIDApJyk7IC8vIFsnMCcsICcwJywgJzAnLCAxXVxuXG5cblxuICAgIEBwdWJsaWNcbiAgICBAbWV0aG9kIHRvQXJyYXlcbiAgICBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgQHJldHVybiB7QXJyYXl9XG4gICAgQHNpbmNlIDMuOC4wXG4gICAgKiovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIC8vIHBhcnNlIHdpdGggcmVnZXggYW5kIHJldHVybiBcIm1hdGNoZXNcIiBhcnJheVxuICAgICAgICB2YXIgdHlwZSA9IFkuQ29sb3IuZmluZFR5cGUoc3RyKS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgcmVnZXgsXG4gICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBsYXN0SXRlbTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ0hFWCcgJiYgc3RyLmxlbmd0aCA8IDUpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnSEVYMyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5jaGFyQXQodHlwZS5sZW5ndGggLSAxKSA9PT0gJ0EnKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdleCA9IFkuQ29sb3JbJ1JFR0VYXycgKyB0eXBlXTtcblxuICAgICAgICBpZiAocmVnZXgpIHtcbiAgICAgICAgICAgIGFyciA9IHJlZ2V4LmV4ZWMoc3RyKSB8fCBbXTtcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgIGFyci5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdIRVgzJykge1xuICAgICAgICAgICAgICAgICAgICBhcnJbMF0gKz0gYXJyWzBdO1xuICAgICAgICAgICAgICAgICAgICBhcnJbMV0gKz0gYXJyWzFdO1xuICAgICAgICAgICAgICAgICAgICBhcnJbMl0gKz0gYXJyWzJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxhc3RJdGVtID0gYXJyW2xlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyW2xlbmd0aCAtIDFdID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgIENvbnZlcnRzIHRoZSBhcnJheSBvZiB2YWx1ZXMgdG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHRlbXBsYXRlLlxuICAgIEBwdWJsaWNcbiAgICBAbWV0aG9kIGZyb21BcnJheVxuICAgIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuICAgIEByZXR1cm4ge1N0cmluZ31cbiAgICBAc2luY2UgMy44LjBcbiAgICAqKi9cbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uKGFyciwgdGVtcGxhdGUpIHtcbiAgICAgICAgYXJyID0gYXJyLmNvbmNhdCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmpvaW4oJywgJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVwbGFjZSA9ICd7Kn0nO1xuXG4gICAgICAgIHRlbXBsYXRlID0gWS5Db2xvclsnU1RSXycgKyB0ZW1wbGF0ZS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMyAmJiB0ZW1wbGF0ZS5tYXRjaCgvXFx7XFwqXFx9L2cpLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgYXJyLnB1c2goMSk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoIHRlbXBsYXRlLmluZGV4T2YocmVwbGFjZSkgPj0gMCAmJiBhcnIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKHJlcGxhY2UsIGFyci5zaGlmdCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgRmluZHMgdGhlIHZhbHVlIHR5cGUgYmFzZWQgb24gdGhlIHN0ciB2YWx1ZSBwcm92aWRlZC5cbiAgICBAcHVibGljXG4gICAgQG1ldGhvZCBmaW5kVHlwZVxuICAgIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICBAcmV0dXJuIHtTdHJpbmd9XG4gICAgQHNpbmNlIDMuOC4wXG4gICAgKiovXG4gICAgZmluZFR5cGU6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKFkuQ29sb3IuS0VZV09SRFNbc3RyXSkge1xuICAgICAgICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKCcoJyksXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAga2V5ID0gc3RyLnN1YnN0cigwLCBpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ICYmIFkuQ29sb3IuVFlQRVNba2V5LnRvVXBwZXJDYXNlKCldKSB7XG4gICAgICAgICAgICByZXR1cm4gWS5Db2xvci5UWVBFU1trZXkudG9VcHBlckNhc2UoKV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ2hleCc7XG5cbiAgICB9LCAvLyByZXR1cm4gJ2tleXdvcmQnLCAnaGV4JywgJ3JnYidcblxuICAgIC8qKlxuICAgIFJldHJpdmVzIHRoZSBhbHBoYSBjaGFubmVsIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy4gSWYgbm8gYWxwaGFcbiAgICAgICAgY2hhbm5lbCBpcyBwcmVzZW50LCBgMWAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICBAcHJvdGVjdGVkXG4gICAgQG1ldGhvZCBfZ2V0QWxwaGFcbiAgICBAcGFyYW0ge1N0cmluZ30gY2xyXG4gICAgQHJldHVybiB7TnVtYmVyfVxuICAgIEBzaW5jZSAzLjguMFxuICAgICoqL1xuICAgIF9nZXRBbHBoYTogZnVuY3Rpb24gKGNscikge1xuICAgICAgICB2YXIgYWxwaGEsXG4gICAgICAgICAgICBhcnIgPSBZLkNvbG9yLnRvQXJyYXkoY2xyKTtcblxuICAgICAgICBpZiAoYXJyLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIGFscGhhID0gYXJyLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICthbHBoYSB8fCAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBoZXggdmFsdWUgc3RyaW5nIGlmIGZvdW5kIGluIHRoZSBLRVlXT1JEUyBvYmplY3RcbiAgICBAcHJvdGVjdGVkXG4gICAgQG1ldGhvZCBfa2V5d29yZFRvSGV4XG4gICAgQHBhcmFtIHtTdHJpbmd9IGNsclxuICAgIEByZXR1cm4ge1N0cmluZ31cbiAgICBAc2luY2UgMy44LjBcbiAgICAqKi9cbiAgICBfa2V5d29yZFRvSGV4OiBmdW5jdGlvbiAoY2xyKSB7XG4gICAgICAgIHZhciBrZXl3b3JkID0gWS5Db2xvci5LRVlXT1JEU1tjbHJdO1xuXG4gICAgICAgIGlmIChrZXl3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5d29yZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgY29sb3Igc3RyaW5nIHRvIHRoZSB2YWx1ZSB0eXBlIHByb3ZpZGVkIGFzIGB0b2BcbiAgICBAcHJvdGVjdGVkXG4gICAgQG1ldGhvZCBfY29udmVydFRvXG4gICAgQHBhcmFtIHtTdHJpbmd9IGNsclxuICAgIEBwYXJhbSB7U3RyaW5nfSB0b1xuICAgIEByZXR1cm4ge1N0cmluZ31cbiAgICBAc2luY2UgMy44LjBcbiAgICAqKi9cbiAgICBfY29udmVydFRvOiBmdW5jdGlvbihjbHIsIHRvKSB7XG5cbiAgICAgICAgaWYgKGNsciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIGNscjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmcm9tID0gWS5Db2xvci5maW5kVHlwZShjbHIpLFxuICAgICAgICAgICAgb3JpZ2luYWxUbyA9IHRvLFxuICAgICAgICAgICAgbmVlZHNBbHBoYSxcbiAgICAgICAgICAgIGFscGhhLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgdWNUbztcblxuICAgICAgICBpZiAoZnJvbSA9PT0gJ2tleXdvcmQnKSB7XG4gICAgICAgICAgICBjbHIgPSBZLkNvbG9yLl9rZXl3b3JkVG9IZXgoY2xyKTtcbiAgICAgICAgICAgIGZyb20gPSAnaGV4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tID09PSAnaGV4JyAmJiBjbHIubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgaWYgKGNsci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgICAgIGNsciA9IGNsci5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsciA9ICcjJyArIGNsci5jaGFyQXQoMCkgKyBjbHIuY2hhckF0KDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsci5jaGFyQXQoMSkgKyBjbHIuY2hhckF0KDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsci5jaGFyQXQoMikgKyBjbHIuY2hhckF0KDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20uY2hhckF0KGZyb20ubGVuZ3RoIC0gMSkgPT09ICdhJykge1xuICAgICAgICAgICAgZnJvbSA9IGZyb20uc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmVlZHNBbHBoYSA9ICh0by5jaGFyQXQodG8ubGVuZ3RoIC0gMSkgPT09ICdhJyk7XG4gICAgICAgIGlmIChuZWVkc0FscGhhKSB7XG4gICAgICAgICAgICB0byA9IHRvLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGFscGhhID0gWS5Db2xvci5fZ2V0QWxwaGEoY2xyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVjVG8gPSB0by5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRvLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBtZXRob2QgPSBZLkNvbG9yWydfJyArIGZyb20gKyAnVG8nICsgdWNUbyBdO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBuZWVkIGNvbnZlcnNpb24gdG8gcmdiIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGRpcmVjdCBjb252ZXJzaW9uIG1ldGhvZFxuICAgICAgICAvLyBjb252ZXJ0aW9ucyBhcmU6IGhleCA8LT4gcmdiIDwtPiBoc2xcbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChmcm9tICE9PSAncmdiJyAmJiB0byAhPT0gJ3JnYicpIHtcbiAgICAgICAgICAgICAgICBjbHIgPSBZLkNvbG9yWydfJyArIGZyb20gKyAnVG9SZ2InXShjbHIpO1xuICAgICAgICAgICAgICAgIGZyb20gPSAncmdiJztcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBZLkNvbG9yWydfJyArIGZyb20gKyAnVG8nICsgdWNUbyBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgY2xyID0gKChtZXRob2QpKGNsciwgbmVlZHNBbHBoYSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJvY2VzcyBjbHIgZnJvbSBhcnJheXMgdG8gc3RyaW5ncyBhZnRlciBjb252ZXJzaW9ucyBpZiBhbHBoYSBpcyBuZWVkZWRcbiAgICAgICAgaWYgKG5lZWRzQWxwaGEpIHtcbiAgICAgICAgICAgIGlmICghWS5MYW5nLmlzQXJyYXkoY2xyKSkge1xuICAgICAgICAgICAgICAgIGNsciA9IFkuQ29sb3IudG9BcnJheShjbHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xyLnB1c2goYWxwaGEpO1xuICAgICAgICAgICAgY2xyID0gWS5Db2xvci5mcm9tQXJyYXkoY2xyLCBvcmlnaW5hbFRvLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNscjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgUHJvY2Vzc2VzIHRoZSBoZXggc3RyaW5nIGludG8gciwgZywgYiB2YWx1ZXMuIFdpbGwgcmV0dXJuIHZhbHVlcyBhc1xuICAgICAgICBhbiBhcnJheSwgb3IgYXMgYW4gcmdiIHN0cmluZy5cbiAgICBAcHJvdGVjdGVkXG4gICAgQG1ldGhvZCBfaGV4VG9SZ2JcbiAgICBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgQHBhcmFtIHtCb29sZWFufSBbdG9BcnJheV1cbiAgICBAcmV0dXJuIHtTdHJpbmd8QXJyYXl9XG4gICAgQHNpbmNlIDMuOC4wXG4gICAgKiovXG4gICAgX2hleFRvUmdiOiBmdW5jdGlvbiAoc3RyLCB0b0FycmF5KSB7XG4gICAgICAgIHZhciByLCBnLCBiO1xuXG4gICAgICAgIC8qanNoaW50IGJpdHdpc2U6ZmFsc2UqL1xuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyID0gcGFyc2VJbnQoc3RyLCAxNik7XG5cbiAgICAgICAgciA9IHN0ciA+PiAxNjtcbiAgICAgICAgZyA9IHN0ciA+PiA4ICYgMHhGRjtcbiAgICAgICAgYiA9IHN0ciAmIDB4RkY7XG5cbiAgICAgICAgaWYgKHRvQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ3JnYignICsgciArICcsICcgKyBnICsgJywgJyArIGIgKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIFByb2Nlc3NlcyB0aGUgcmdiIHN0cmluZyBpbnRvIHIsIGcsIGIgdmFsdWVzLiBXaWxsIHJldHVybiB2YWx1ZXMgYXNcbiAgICAgICAgYW4gYXJyYXksIG9yIGFzIGEgaGV4IHN0cmluZy5cbiAgICBAcHJvdGVjdGVkXG4gICAgQG1ldGhvZCBfcmdiVG9IZXhcbiAgICBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgQHBhcmFtIHtCb29sZWFufSBbdG9BcnJheV1cbiAgICBAcmV0dXJuIHtTdHJpbmd8QXJyYXl9XG4gICAgQHNpbmNlIDMuOC4wXG4gICAgKiovXG4gICAgX3JnYlRvSGV4OiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8qanNoaW50IGJpdHdpc2U6ZmFsc2UqL1xuICAgICAgICB2YXIgcmdiID0gWS5Db2xvci50b0FycmF5KHN0ciksXG4gICAgICAgICAgICBoZXggPSByZ2JbMl0gfCAocmdiWzFdIDw8IDgpIHwgKHJnYlswXSA8PCAxNik7XG5cbiAgICAgICAgaGV4ID0gKCtoZXgpLnRvU3RyaW5nKDE2KTtcblxuICAgICAgICB3aGlsZSAoaGV4Lmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIGhleCA9ICcwJyArIGhleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnIycgKyBoZXg7XG4gICAgfVxuXG59O1xuXG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcInl1aS1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2Nvb2tpZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogVXRpbGl0aWVzIGZvciBjb29raWUgbWFuYWdlbWVudFxuICogQG1vZHVsZSBjb29raWVcbiAqL1xuXG4gICAgLy9zaG9ydGN1dHNcbiAgICB2YXIgTCAgICAgICA9IFkuTGFuZyxcbiAgICAgICAgTyAgICAgICA9IFkuT2JqZWN0LFxuICAgICAgICBOVUxMICAgID0gbnVsbCxcblxuICAgICAgICAvL3Nob3J0Y3V0cyB0byBmdW5jdGlvbnNcbiAgICAgICAgaXNTdHJpbmcgICAgPSBMLmlzU3RyaW5nLFxuICAgICAgICBpc09iamVjdCAgICA9IEwuaXNPYmplY3QsXG4gICAgICAgIGlzVW5kZWZpbmVkID0gTC5pc1VuZGVmaW5lZCxcbiAgICAgICAgaXNGdW5jdGlvbiAgPSBMLmlzRnVuY3Rpb24sXG4gICAgICAgIGVuY29kZSAgICAgID0gZW5jb2RlVVJJQ29tcG9uZW50LFxuICAgICAgICBkZWNvZGUgICAgICA9IGRlY29kZVVSSUNvbXBvbmVudCxcblxuICAgICAgICAvL3Nob3J0Y3V0IHRvIGRvY3VtZW50XG4gICAgICAgIGRvYyAgICAgICAgID0gWS5jb25maWcuZG9jO1xuXG4gICAgLypcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKXtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENoZWNrcyB0aGUgdmFsaWRpdHkgb2YgYSBjb29raWUgbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZU5hbWUobmFtZSl7XG4gICAgICAgIGlmICghaXNTdHJpbmcobmFtZSkgfHwgbmFtZSA9PT0gXCJcIil7XG4gICAgICAgICAgICBlcnJvcihcIkNvb2tpZSBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBhIHN1YmNvb2tpZSBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3ViY29va2llTmFtZShzdWJOYW1lKXtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdWJOYW1lKSB8fCBzdWJOYW1lID09PSBcIlwiKXtcbiAgICAgICAgICAgIGVycm9yKFwiU3ViY29va2llIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29va2llIHV0aWxpdHkuXG4gICAgICogQGNsYXNzIENvb2tpZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBZLkNvb2tpZSA9IHtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gUHJpdmF0ZSBNZXRob2RzXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY29va2llIHN0cmluZyB0aGF0IGNhbiBiZSBhc3NpZ25lZCBpbnRvIGRvY3VtZW50LmNvb2tpZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvb2tpZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgY29va2llLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZVZhbHVlIFRydWUgdG8gZW5jb2RlIHRoZSB2YWx1ZSwgZmFsc2UgdG8gbGVhdmUgYXMtaXMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChPcHRpb25hbCkgT3B0aW9ucyBmb3IgdGhlIGNvb2tpZS5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgZm9ybWF0dGVkIGNvb2tpZSBzdHJpbmcuXG4gICAgICAgICAqIEBtZXRob2QgX2NyZWF0ZUNvb2tpZVN0cmluZ1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBfY3JlYXRlQ29va2llU3RyaW5nIDogZnVuY3Rpb24gKG5hbWUgLyo6U3RyaW5nKi8sIHZhbHVlIC8qOlZhcmlhbnQqLywgZW5jb2RlVmFsdWUgLyo6Qm9vbGVhbiovLCBvcHRpb25zIC8qOk9iamVjdCovKSAvKjpTdHJpbmcqLyB7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgdGV4dCAvKjpTdHJpbmcqLyA9IGVuY29kZShuYW1lKSArIFwiPVwiICsgKGVuY29kZVZhbHVlID8gZW5jb2RlKHZhbHVlKSA6IHZhbHVlKSxcbiAgICAgICAgICAgICAgICBleHBpcmVzID0gb3B0aW9ucy5leHBpcmVzLFxuICAgICAgICAgICAgICAgIHBhdGggICAgPSBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgICAgICAgZG9tYWluICA9IG9wdGlvbnMuZG9tYWluO1xuXG5cbiAgICAgICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSl7XG4gICAgICAgICAgICAgICAgLy9leHBpcmF0aW9uIGRhdGVcbiAgICAgICAgICAgICAgICBpZiAoZXhwaXJlcyBpbnN0YW5jZW9mIERhdGUpe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiOyBleHBpcmVzPVwiICsgZXhwaXJlcy50b1VUQ1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vcGF0aFxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhwYXRoKSAmJiBwYXRoICE9PSBcIlwiKXtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcIjsgcGF0aD1cIiArIHBhdGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9kb21haW5cbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZG9tYWluKSAmJiBkb21haW4gIT09IFwiXCIpe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiOyBkb21haW49XCIgKyBkb21haW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9zZWN1cmVcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZWN1cmUgPT09IHRydWUpe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiOyBzZWN1cmVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JtYXRzIGEgY29va2llIHZhbHVlIGZvciBhbiBvYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSB2YWx1ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIEFuIG9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gY3JlYXRlIGEgc3RyaW5nIGZvci5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyBzdWl0YWJsZSBmb3IgdXNlIGFzIGEgY29va2llIHZhbHVlLlxuICAgICAgICAgKiBAbWV0aG9kIF9jcmVhdGVDb29raWVIYXNoU3RyaW5nXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIF9jcmVhdGVDb29raWVIYXNoU3RyaW5nIDogZnVuY3Rpb24gKGhhc2ggLyo6T2JqZWN0Ki8pIC8qOlN0cmluZyovIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoaGFzaCkpe1xuICAgICAgICAgICAgICAgIGVycm9yKFwiQ29va2llLl9jcmVhdGVDb29raWVIYXNoU3RyaW5nKCk6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHQgLyo6QXJyYXkqLyA9IFtdO1xuXG4gICAgICAgICAgICBPLmVhY2goaGFzaCwgZnVuY3Rpb24odmFsdWUsIGtleSl7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSAmJiAhaXNVbmRlZmluZWQodmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKGVuY29kZShrZXkpICsgXCI9XCIgKyBlbmNvZGUoU3RyaW5nKHZhbHVlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGV4dC5qb2luKFwiJlwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGEgY29va2llIGhhc2ggc3RyaW5nIGludG8gYW4gb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgY29va2llIGhhc2ggc3RyaW5nIHRvIHBhcnNlIChmb3JtYXQ6IG4xPXYxJm4yPXYyKS5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBlbnRyaWVzIGZvciBlYWNoIGNvb2tpZSB2YWx1ZS5cbiAgICAgICAgICogQG1ldGhvZCBfcGFyc2VDb29raWVIYXNoXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIF9wYXJzZUNvb2tpZUhhc2ggOiBmdW5jdGlvbiAodGV4dCkge1xuXG4gICAgICAgICAgICB2YXIgaGFzaFBhcnRzICAgPSB0ZXh0LnNwbGl0KFwiJlwiKSxcbiAgICAgICAgICAgICAgICBoYXNoUGFydCAgICA9IE5VTEwsXG4gICAgICAgICAgICAgICAgaGFzaCAgICAgICAgPSB7fTtcblxuICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1oYXNoUGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBoYXNoUGFydCA9IGhhc2hQYXJ0c1tpXS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hbZGVjb2RlKGhhc2hQYXJ0WzBdKV0gPSBkZWNvZGUoaGFzaFBhcnRbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIGNvb2tpZSBzdHJpbmcgaW50byBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGFsbCBhY2Nlc3NpYmxlIGNvb2tpZXMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBjb29raWUgc3RyaW5nIHRvIHBhcnNlLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZERlY29kZSAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiB0aGUgY29va2llIHZhbHVlcyBzaG91bGQgYmUgZGVjb2RlZCBvciBub3QuIERlZmF1bHQgaXMgdHJ1ZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgKE9wdGlvbmFsKSBDb250YWlucyBzZXR0aW5ncyBmb3IgbG9hZGluZyB0aGUgY29va2llLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGVudHJpZXMgZm9yIGVhY2ggYWNjZXNzaWJsZSBjb29raWUuXG4gICAgICAgICAqIEBtZXRob2QgX3BhcnNlQ29va2llU3RyaW5nXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIF9wYXJzZUNvb2tpZVN0cmluZyA6IGZ1bmN0aW9uICh0ZXh0IC8qOlN0cmluZyovLCBzaG91bGREZWNvZGUgLyo6Qm9vbGVhbiovLCBvcHRpb25zIC8qOk9iamVjdCovKSAvKjpPYmplY3QqLyB7XG5cbiAgICAgICAgICAgIHZhciBjb29raWVzIC8qOk9iamVjdCovID0ge307XG5cbiAgICAgICAgICAgIGlmIChpc1N0cmluZyh0ZXh0KSAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgICAgIHZhciBkZWNvZGVWYWx1ZSA9IChzaG91bGREZWNvZGUgPT09IGZhbHNlID8gZnVuY3Rpb24ocyl7cmV0dXJuIHM7fSA6IGRlY29kZSksXG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzID0gdGV4dC5zcGxpdCgvO1xccy9nKSxcbiAgICAgICAgICAgICAgICAgICAgY29va2llTmFtZSAgPSBOVUxMLFxuICAgICAgICAgICAgICAgICAgICBjb29raWVWYWx1ZSA9IE5VTEwsXG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZU5hbWVWYWx1ZSA9IE5VTEw7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1jb29raWVQYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIG5vcm1hbGx5LWZvcm1hdHRlZCBjb29raWUgKG5hbWUtdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZU5hbWVWYWx1ZSA9IGNvb2tpZVBhcnRzW2ldLm1hdGNoKC8oW149XSspPS9pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb2tpZU5hbWVWYWx1ZSBpbnN0YW5jZW9mIEFycmF5KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llTmFtZSA9IGRlY29kZShjb29raWVOYW1lVmFsdWVbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZVZhbHVlID0gZGVjb2RlVmFsdWUoY29va2llUGFydHNbaV0uc3Vic3RyaW5nKGNvb2tpZU5hbWVWYWx1ZVsxXS5sZW5ndGgrMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGNvb2tpZSAtIHRoZSBlbmNvZGluZyBpcyB3cm9uZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9tZWFucyB0aGUgY29va2llIGRvZXMgbm90IGhhdmUgYW4gXCI9XCIsIHNvIHRyZWF0IGl0IGFzIGEgYm9vbGVhbiBmbGFnXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29raWVOYW1lID0gZGVjb2RlKGNvb2tpZVBhcnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZVZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBvdmVyd3JpdGUgYW4gYWxyZWFkeSBsb2FkZWQgY29va2llIGlmIHNldCBieSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChvcHRpb25zKSAmJiBvcHRpb25zLnJldmVyc2VDb29raWVMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoY29va2llc1tjb29raWVOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29raWVzW2Nvb2tpZU5hbWVdID0gY29va2llVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29raWVzW2Nvb2tpZU5hbWVdID0gY29va2llVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRvY3VtZW50IG9iamVjdCB0aGF0IHRoZSBjb29raWUgdXRpbGl0eSB1c2VzIGZvciBzZXR0aW5nXG4gICAgICAgICAqIGNvb2tpZXMuIFRoaXMgbWV0aG9kIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCB0aGUgY29va2llIHV0aWxpdHlcbiAgICAgICAgICogdW5pdCB0ZXN0cyBjYW4gcGFzcyBldmVuIHdoZW4gcnVuIG9uIGEgZG9tYWluIGluc3RlYWQgb2YgbG9jYWxseS5cbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkIG90aGVyd2lzZTsgeW91IHNob3VsZCB1c2VcbiAgICAgICAgICogPGNvZGU+WS5jb25maWcuZG9jPC9jb2RlPiB0byBjaGFuZ2UgdGhlIGRvY3VtZW50IHRoYXQgdGhlIGNvb2tpZVxuICAgICAgICAgKiB1dGlsaXR5IHVzZXMgZm9yIGV2ZXJ5ZGF5IHB1cnBvc2VzLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3RG9jIFRoZSBvYmplY3QgdG8gdXNlIGFzIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICogQG1ldGhvZCBfc2V0RG9jXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0RG9jOiBmdW5jdGlvbihuZXdEb2Mpe1xuICAgICAgICAgICAgZG9jID0gbmV3RG9jO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBQdWJsaWMgTWV0aG9kc1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgY29va2llIHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICAgICAgICogQm9vbGVhbiBjb29raWVzICh0aG9zZSB0aGF0IGRvIG5vdCBmb2xsb3cgdGhlIG5hbWU9dmFsdWUgY29udmVudGlvbikuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb29raWUgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGNvb2tpZSBleGlzdHMsIGZhbHNlIGlmIG5vdC5cbiAgICAgICAgICogQG1ldGhvZCBleGlzdHNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgZXhpc3RzOiBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICAgICAgICAgIHZhbGlkYXRlQ29va2llTmFtZShuYW1lKTsgICAvL3Rocm93cyBlcnJvclxuXG4gICAgICAgICAgICB2YXIgY29va2llcyA9IHRoaXMuX3BhcnNlQ29va2llU3RyaW5nKGRvYy5jb29raWUsIHRydWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gY29va2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY29va2llIHZhbHVlIGZvciB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvb2tpZSB0byByZXRyaWV2ZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IG9wdGlvbnMgKE9wdGlvbmFsKSBBbiBvYmplY3QgY29udGFpbmluZyBvbmUgb3IgbW9yZVxuICAgICAgICAgKiAgICAgIGNvb2tpZSBvcHRpb25zOiByYXcgKHRydWUvZmFsc2UpLCByZXZlcnNlQ29va2llTG9hZGluZyAodHJ1ZS9mYWxzZSlcbiAgICAgICAgICogICAgICBhbmQgY29udmVydGVyIChhIGZ1bmN0aW9uKS5cbiAgICAgICAgICogICAgICBUaGUgY29udmVydGVyIGZ1bmN0aW9uIGlzIHJ1biBvbiB0aGUgdmFsdWUgYmVmb3JlIHJldHVybmluZyBpdC4gVGhlXG4gICAgICAgICAqICAgICAgZnVuY3Rpb24gaXMgbm90IHVzZWQgaWYgdGhlIGNvb2tpZSBkb2Vzbid0IGV4aXN0LiBUaGUgZnVuY3Rpb24gY2FuIGJlXG4gICAgICAgICAqICAgICAgcGFzc2VkIGluc3RlYWQgb2YgdGhlIG9wdGlvbnMgb2JqZWN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gV2hlblxuICAgICAgICAgKiAgICAgIHJhdyBpcyBzZXQgdG8gdHJ1ZSwgdGhlIGNvb2tpZSB2YWx1ZSBpcyBub3QgVVJJIGRlY29kZWQuXG4gICAgICAgICAqIEByZXR1cm4ge0FueX0gSWYgbm8gY29udmVydGVyIGlzIHNwZWNpZmllZCwgcmV0dXJucyBhIHN0cmluZyBvciBudWxsIGlmXG4gICAgICAgICAqICAgICAgdGhlIGNvb2tpZSBkb2Vzbid0IGV4aXN0LiBJZiB0aGUgY29udmVydGVyIGlzIHNwZWNpZmllZCwgcmV0dXJucyB0aGUgdmFsdWVcbiAgICAgICAgICogICAgICByZXR1cm5lZCBmcm9tIHRoZSBjb252ZXJ0ZXIgb3IgbnVsbCBpZiB0aGUgY29va2llIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIHZhbGlkYXRlQ29va2llTmFtZShuYW1lKTsgICAvL3Rocm93cyBlcnJvclxuXG4gICAgICAgICAgICB2YXIgY29va2llcyxcbiAgICAgICAgICAgICAgICBjb29raWUsXG4gICAgICAgICAgICAgICAgY29udmVydGVyO1xuXG4gICAgICAgICAgICAvL2lmIG9wdGlvbnMgaXMgYSBmdW5jdGlvbiwgdGhlbiBpdCdzIHRoZSBjb252ZXJ0ZXJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVyID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVyID0gb3B0aW9ucy5jb252ZXJ0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29va2llcyA9IHRoaXMuX3BhcnNlQ29va2llU3RyaW5nKGRvYy5jb29raWUsICFvcHRpb25zLnJhdywgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb29raWUgPSBjb29raWVzW25hbWVdO1xuXG4gICAgICAgICAgICAvL3Nob3VsZCByZXR1cm4gbnVsbCwgbm90IHVuZGVmaW5lZCBpZiB0aGUgY29va2llIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChjb29raWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5VTEw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbihjb252ZXJ0ZXIpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29va2llO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVyKGNvb2tpZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgc3ViY29va2llLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29va2llIHRvIHJldHJpZXZlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3ViTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ViY29va2llIHRvIHJldHJpZXZlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb252ZXJ0ZXIgKE9wdGlvbmFsKSBBIGZ1bmN0aW9uIHRvIHJ1biBvbiB0aGUgdmFsdWUgYmVmb3JlIHJldHVybmluZ1xuICAgICAgICAgKiAgICAgIGl0LiBUaGUgZnVuY3Rpb24gaXMgbm90IHVzZWQgaWYgdGhlIGNvb2tpZSBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAoT3B0aW9uYWwpIENvbnRhaW5pbmcgb25lIG9yIG1vcmUgc2V0dGluZ3MgZm9yIGNvb2tpZSBwYXJzaW5nLlxuICAgICAgICAgKiBAcmV0dXJuIHtBbnl9IElmIHRoZSBjb29raWUgZG9lc24ndCBleGlzdCwgbnVsbCBpcyByZXR1cm5lZC4gSWYgdGhlIHN1YmNvb2tpZVxuICAgICAgICAgKiAgICAgIGRvZXNuJ3QgZXhpc3QsIG51bGwgaWYgYWxzbyByZXR1cm5lZC4gSWYgbm8gY29udmVydGVyIGlzIHNwZWNpZmllZCBhbmQgdGhlXG4gICAgICAgICAqICAgICAgc3ViY29va2llIGV4aXN0cywgYSBzdHJpbmcgaXMgcmV0dXJuZWQuIElmIGEgY29udmVydGVyIGlzIHNwZWNpZmllZCBhbmQgdGhlXG4gICAgICAgICAqICAgICAgc3ViY29va2llIGV4aXN0cywgdGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIGNvbnZlcnRlciBpcyByZXR1cm5lZC5cbiAgICAgICAgICogQG1ldGhvZCBnZXRTdWJcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3ViIDogZnVuY3Rpb24gKG5hbWUgLyo6U3RyaW5nKi8sIHN1Yk5hbWUgLyo6U3RyaW5nKi8sIGNvbnZlcnRlciAvKjpGdW5jdGlvbiovLCBvcHRpb25zIC8qOk9iamVjdCovKSAvKjpWYXJpYW50Ki8ge1xuXG4gICAgICAgICAgICB2YXIgaGFzaCAvKjpWYXJpYW50Ki8gPSB0aGlzLmdldFN1YnMobmFtZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChoYXNoICE9PSBOVUxMKSB7XG5cbiAgICAgICAgICAgICAgICB2YWxpZGF0ZVN1YmNvb2tpZU5hbWUoc3ViTmFtZSk7ICAgLy90aHJvd3MgZXJyb3JcblxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChoYXNoW3N1Yk5hbWVdKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOVUxMO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbihjb252ZXJ0ZXIpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2hbc3ViTmFtZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRlcihoYXNoW3N1Yk5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBOVUxMO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmFtZS12YWx1ZSBwYWlycyBzdG9yZWQgaW4gdGhlIGNvb2tpZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29va2llIHRvIHJldHJpZXZlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAoT3B0aW9uYWwpIENvbnRhaW5pbmcgb25lIG9yIG1vcmUgc2V0dGluZ3MgZm9yIGNvb2tpZSBwYXJzaW5nLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBvZiBuYW1lLXZhbHVlIHBhaXJzIGlmIHRoZSBjb29raWUgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgICAgICAgKiAgICAgIGV4aXN0cywgbnVsbCBpZiBpdCBkb2VzIG5vdC5cbiAgICAgICAgICogQG1ldGhvZCBnZXRTdWJzXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGdldFN1YnMgOiBmdW5jdGlvbiAobmFtZSAvKjpTdHJpbmcqLywgb3B0aW9ucyAvKjpPYmplY3QqLykge1xuXG4gICAgICAgICAgICB2YWxpZGF0ZUNvb2tpZU5hbWUobmFtZSk7ICAgLy90aHJvd3MgZXJyb3JcblxuICAgICAgICAgICAgdmFyIGNvb2tpZXMgPSB0aGlzLl9wYXJzZUNvb2tpZVN0cmluZyhkb2MuY29va2llLCBmYWxzZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoY29va2llc1tuYW1lXSkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUNvb2tpZUhhc2goY29va2llc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTlVMTDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIGNvb2tpZSBmcm9tIHRoZSBtYWNoaW5lIGJ5IHNldHRpbmcgaXRzIGV4cGlyYXRpb24gZGF0ZSB0b1xuICAgICAgICAgKiBzb21ldGltZSBpbiB0aGUgcGFzdC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvb2tpZSB0byByZW1vdmUuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChPcHRpb25hbCkgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25lIG9yIG1vcmVcbiAgICAgICAgICogICAgICBjb29raWUgb3B0aW9uczogcGF0aCAoYSBzdHJpbmcpLCBkb21haW4gKGEgc3RyaW5nKSxcbiAgICAgICAgICogICAgICBhbmQgc2VjdXJlICh0cnVlL2ZhbHNlKS4gVGhlIGV4cGlyZXMgb3B0aW9uIHdpbGwgYmUgb3ZlcndyaXR0ZW5cbiAgICAgICAgICogICAgICBieSB0aGUgbWV0aG9kLlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjcmVhdGVkIGNvb2tpZSBzdHJpbmcuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZSA6IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIHZhbGlkYXRlQ29va2llTmFtZShuYW1lKTsgICAvL3Rocm93cyBlcnJvclxuXG4gICAgICAgICAgICAvL3NldCBvcHRpb25zXG4gICAgICAgICAgICBvcHRpb25zID0gWS5tZXJnZShvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICAgICAgZXhwaXJlczogbmV3IERhdGUoMClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL3NldCBjb29raWVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChuYW1lLCBcIlwiLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIHN1YiBjb29raWUgd2l0aCBhIGdpdmVuIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb29raWUgaW4gd2hpY2ggdGhlIHN1YmNvb2tpZSBleGlzdHMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdWJOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdWJjb29raWUgdG8gcmVtb3ZlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAoT3B0aW9uYWwpIEFuIG9iamVjdCBjb250YWluaW5nIG9uZSBvciBtb3JlXG4gICAgICAgICAqICAgICAgY29va2llIG9wdGlvbnM6IHBhdGggKGEgc3RyaW5nKSwgZG9tYWluIChhIHN0cmluZyksIGV4cGlyZXMgKGEgRGF0ZSBvYmplY3QpLFxuICAgICAgICAgKiAgICAgIHJlbW92ZUlmRW1wdHkgKHRydWUvZmFsc2UpLCBhbmQgc2VjdXJlICh0cnVlL2ZhbHNlKS4gVGhpcyBtdXN0IGJlIHRoZSBzYW1lXG4gICAgICAgICAqICAgICAgc2V0dGluZ3MgYXMgdGhlIG9yaWdpbmFsIHN1YmNvb2tpZS5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY3JlYXRlZCBjb29raWUgc3RyaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVN1YlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVTdWIgOiBmdW5jdGlvbihuYW1lLCBzdWJOYW1lLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIHZhbGlkYXRlQ29va2llTmFtZShuYW1lKTsgICAvL3Rocm93cyBlcnJvclxuXG4gICAgICAgICAgICB2YWxpZGF0ZVN1YmNvb2tpZU5hbWUoc3ViTmFtZSk7ICAgLy90aHJvd3MgZXJyb3JcblxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgIC8vZ2V0IGFsbCBzdWJjb29raWVzIGZvciB0aGlzIGNvb2tpZVxuICAgICAgICAgICAgdmFyIHN1YnMgPSB0aGlzLmdldFN1YnMobmFtZSk7XG5cbiAgICAgICAgICAgIC8vZGVsZXRlIHRoZSBpbmRpY2F0ZWQgc3ViY29va2llXG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3VicykgJiYgc3Vicy5oYXNPd25Qcm9wZXJ0eShzdWJOYW1lKSl7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN1YnNbc3ViTmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMucmVtb3ZlSWZFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAvL3Jlc2V0IHRoZSBjb29raWVcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdWJzKG5hbWUsIHN1YnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcmVzZXQgdGhlIGNvb2tpZSBpZiB0aGVyZSBhcmUgc3ViY29va2llcyBsZWZ0LCBlbHNlIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3Vicyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vicy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc0Z1bmN0aW9uKHN1YnNba2V5XSkgJiYgIWlzVW5kZWZpbmVkKHN1YnNba2V5XSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN1YnMobmFtZSwgc3Vicywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGEgY29va2llIHdpdGggYSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvb2tpZSB0byBzZXQuXG4gICAgICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IGZvciB0aGUgY29va2llLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAoT3B0aW9uYWwpIEFuIG9iamVjdCBjb250YWluaW5nIG9uZSBvciBtb3JlXG4gICAgICAgICAqICAgICAgY29va2llIG9wdGlvbnM6IHBhdGggKGEgc3RyaW5nKSwgZG9tYWluIChhIHN0cmluZyksIGV4cGlyZXMgKGEgRGF0ZSBvYmplY3QpLFxuICAgICAgICAgKiAgICAgIHNlY3VyZSAodHJ1ZS9mYWxzZSksIGFuZCByYXcgKHRydWUvZmFsc2UpLiBTZXR0aW5nIHJhdyB0byB0cnVlIGluZGljYXRlc1xuICAgICAgICAgKiAgICAgIHRoYXQgdGhlIGNvb2tpZSBzaG91bGQgbm90IGJlIFVSSSBlbmNvZGVkIGJlZm9yZSBiZWluZyBzZXQuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNyZWF0ZWQgY29va2llIHN0cmluZy5cbiAgICAgICAgICogQG1ldGhvZCBzZXRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIHZhbGlkYXRlQ29va2llTmFtZShuYW1lKTsgICAvL3Rocm93cyBlcnJvclxuXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKXtcbiAgICAgICAgICAgICAgICBlcnJvcihcIkNvb2tpZS5zZXQoKTogVmFsdWUgY2Fubm90IGJlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2NyZWF0ZUNvb2tpZVN0cmluZyhuYW1lLCB2YWx1ZSwgIW9wdGlvbnMucmF3LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRvYy5jb29raWUgPSB0ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYSBzdWIgY29va2llIHdpdGggYSBnaXZlbiBuYW1lIHRvIGEgcGFydGljdWxhciB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvb2tpZSB0byBzZXQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdWJOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdWJjb29raWUgdG8gc2V0LlxuICAgICAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgKE9wdGlvbmFsKSBBbiBvYmplY3QgY29udGFpbmluZyBvbmUgb3IgbW9yZVxuICAgICAgICAgKiAgICAgIGNvb2tpZSBvcHRpb25zOiBwYXRoIChhIHN0cmluZyksIGRvbWFpbiAoYSBzdHJpbmcpLCBleHBpcmVzIChhIERhdGUgb2JqZWN0KSxcbiAgICAgICAgICogICAgICBhbmQgc2VjdXJlICh0cnVlL2ZhbHNlKS5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY3JlYXRlZCBjb29raWUgc3RyaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHNldFN1YlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBzZXRTdWIgOiBmdW5jdGlvbiAobmFtZSwgc3ViTmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgdmFsaWRhdGVDb29raWVOYW1lKG5hbWUpOyAgIC8vdGhyb3dzIGVycm9yXG5cbiAgICAgICAgICAgIHZhbGlkYXRlU3ViY29va2llTmFtZShzdWJOYW1lKTsgICAvL3Rocm93cyBlcnJvclxuXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKXtcbiAgICAgICAgICAgICAgICBlcnJvcihcIkNvb2tpZS5zZXRTdWIoKTogU3ViY29va2llIHZhbHVlIGNhbm5vdCBiZSB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuZ2V0U3VicyhuYW1lKTtcblxuICAgICAgICAgICAgaWYgKCFpc09iamVjdChoYXNoKSl7XG4gICAgICAgICAgICAgICAgaGFzaCA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYXNoW3N1Yk5hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN1YnMobmFtZSwgaGFzaCwgb3B0aW9ucyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIGNvb2tpZSB3aXRoIGEgZ2l2ZW4gbmFtZSB0byBjb250YWluIGEgaGFzaCBvZiBuYW1lLXZhbHVlIHBhaXJzLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29va2llIHRvIHNldC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIEFuIG9iamVjdCBjb250YWluaW5nIG5hbWUtdmFsdWUgcGFpcnMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChPcHRpb25hbCkgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25lIG9yIG1vcmVcbiAgICAgICAgICogICAgICBjb29raWUgb3B0aW9uczogcGF0aCAoYSBzdHJpbmcpLCBkb21haW4gKGEgc3RyaW5nKSwgZXhwaXJlcyAoYSBEYXRlIG9iamVjdCksXG4gICAgICAgICAqICAgICAgYW5kIHNlY3VyZSAodHJ1ZS9mYWxzZSkuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNyZWF0ZWQgY29va2llIHN0cmluZy5cbiAgICAgICAgICogQG1ldGhvZCBzZXRTdWJzXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHNldFN1YnMgOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgdmFsaWRhdGVDb29raWVOYW1lKG5hbWUpOyAgIC8vdGhyb3dzIGVycm9yXG5cbiAgICAgICAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKXtcbiAgICAgICAgICAgICAgICBlcnJvcihcIkNvb2tpZS5zZXRTdWJzKCk6IENvb2tpZSB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZXh0IC8qOlN0cmluZyovID0gdGhpcy5fY3JlYXRlQ29va2llU3RyaW5nKG5hbWUsIHRoaXMuX2NyZWF0ZUNvb2tpZUhhc2hTdHJpbmcodmFsdWUpLCBmYWxzZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBkb2MuY29va2llID0gdGV4dDtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG5cbiAgICB9O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJ5dWktYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdkYXRhdHlwZS14bWwtcGFyc2UnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIFBhcnNlIFhNTCBzdWJtb2R1bGUuXG4gKlxuICogQG1vZHVsZSBkYXRhdHlwZS14bWxcbiAqIEBzdWJtb2R1bGUgZGF0YXR5cGUteG1sLXBhcnNlXG4gKiBAZm9yIFhNTFxuICovXG5cblkubWl4KFkubmFtZXNwYWNlKFwiWE1MXCIpLCB7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgZGF0YSB0byB0eXBlIFhNTERvY3VtZW50LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBwYXJzZVxuICAgICAqIEBwYXJhbSBkYXRhIHtTdHJpbmd9IERhdGEgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJuIHtYTUxEb2N1bWVudH0gWE1MIERvY3VtZW50LlxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciB4bWxEb2MgPSBudWxsLCB3aW47XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgd2luID0gWS5jb25maWcud2luO1xuICAgICAgICAgICAgaWYgKHdpbi5BY3RpdmVYT2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB4bWxEb2MgPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgICAgICAgICAgICAgeG1sRG9jLmFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgeG1sRG9jLmxvYWRYTUwoZGF0YSk7ICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpbi5ET01QYXJzZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHhtbERvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZGF0YSwgXCJ0ZXh0L3htbFwiKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2luLldpbmRvd3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHhtbERvYyA9IG5ldyBXaW5kb3dzLkRhdGEuWG1sLkRvbS5YbWxEb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgIHhtbERvYy5sb2FkWG1sKGRhdGEpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHhtbERvYyA9PT0gbnVsbCB8fCB4bWxEb2MuZG9jdW1lbnRFbGVtZW50ID09PSBudWxsIHx8IHhtbERvYy5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGFyc2VyZXJyb3JcIikge1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHhtbERvYztcbiAgICB9XG59KTtcblxuLy8gQWRkIFBhcnNlcnMgc2hvcnRjdXRcblkubmFtZXNwYWNlKFwiUGFyc2Vyc1wiKS54bWwgPSBZLlhNTC5wYXJzZTtcblxuWS5uYW1lc3BhY2UoXCJEYXRhVHlwZVwiKTtcblkuRGF0YVR5cGUuWE1MID0gWS5YTUw7XG5cblxufSwgJzMuMTcuMicpO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdkb20tYmFzZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuKiBAZm9yIERPTVxuKiBAbW9kdWxlIGRvbVxuKi9cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBZLmNvbmZpZy5kb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgIFlfRE9NID0gWS5ET00sXG4gICAgVEFHX05BTUUgPSAndGFnTmFtZScsXG4gICAgT1dORVJfRE9DVU1FTlQgPSAnb3duZXJEb2N1bWVudCcsXG4gICAgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgYWRkRmVhdHVyZSA9IFkuRmVhdHVyZXMuYWRkLFxuICAgIHRlc3RGZWF0dXJlID0gWS5GZWF0dXJlcy50ZXN0O1xuXG5ZLm1peChZX0RPTSwge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgSFRNTEVsZW1lbnQuXG4gICAgICogQG1ldGhvZCBnZXRUZXh0XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgaHRtbCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHRleHQgY29udGVudCBvZiB0aGUgZWxlbWVudCAoaW5jbHVkZXMgdGV4dCBvZiBhbnkgZGVzY2VuZGluZyBlbGVtZW50cykuXG4gICAgICovXG4gICAgZ2V0VGV4dDogKGRvY3VtZW50RWxlbWVudC50ZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkKSA/XG4gICAgICAgIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSAnJztcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gZWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQgfHwgJyc7XG4gICAgICAgIH0gOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gJyc7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldCA9IGVsZW1lbnQuaW5uZXJUZXh0IHx8IGVsZW1lbnQubm9kZVZhbHVlOyAvLyBtaWdodCBiZSBhIHRleHROb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0IHx8ICcnO1xuICAgICAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBIVE1MRWxlbWVudC5cbiAgICAgKiBAbWV0aG9kIHNldFRleHRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBodG1sIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnQgVGhlIGNvbnRlbnQgdG8gYWRkLlxuICAgICAqL1xuICAgIHNldFRleHQ6IChkb2N1bWVudEVsZW1lbnQudGV4dENvbnRlbnQgIT09IHVuZGVmaW5lZCkgP1xuICAgICAgICBmdW5jdGlvbihlbGVtZW50LCBjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IDogZnVuY3Rpb24oZWxlbWVudCwgY29udGVudCkge1xuICAgICAgICAgICAgaWYgKCdpbm5lclRleHQnIGluIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVyVGV4dCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdub2RlVmFsdWUnIGluIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5vZGVWYWx1ZSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgfSxcblxuICAgIENVU1RPTV9BVFRSSUJVVEVTOiAoIWRvY3VtZW50RWxlbWVudC5oYXNBdHRyaWJ1dGUpID8geyAvLyBJRSA8IDhcbiAgICAgICAgJ2Zvcic6ICdodG1sRm9yJyxcbiAgICAgICAgJ2NsYXNzJzogJ2NsYXNzTmFtZSdcbiAgICB9IDogeyAvLyB3M2NcbiAgICAgICAgJ2h0bWxGb3InOiAnZm9yJyxcbiAgICAgICAgJ2NsYXNzTmFtZSc6ICdjbGFzcydcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBub3JtYWxpemVkIGF0dHJpYnV0ZSBpbnRlcmZhY2UuXG4gICAgICogQG1ldGhvZCBzZXRBdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgdGFyZ2V0IGVsZW1lbnQgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsLCBhdHRyLCB2YWwsIGllQXR0cikge1xuICAgICAgICBpZiAoZWwgJiYgYXR0ciAmJiBlbC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGF0dHIgPSBZX0RPTS5DVVNUT01fQVRUUklCVVRFU1thdHRyXSB8fCBhdHRyO1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbCwgaWVBdHRyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgbm9ybWFsaXplZCBhdHRyaWJ1dGUgaW50ZXJmYWNlLlxuICAgICAqIEBtZXRob2QgZ2V0QXR0cmlidXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIHRhcmdldCBlbGVtZW50IGZvciB0aGUgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsLCBhdHRyLCBpZUF0dHIpIHtcbiAgICAgICAgaWVBdHRyID0gKGllQXR0ciAhPT0gdW5kZWZpbmVkKSA/IGllQXR0ciA6IDI7XG4gICAgICAgIHZhciByZXQgPSAnJztcbiAgICAgICAgaWYgKGVsICYmIGF0dHIgJiYgZWwuZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICBhdHRyID0gWV9ET00uQ1VTVE9NX0FUVFJJQlVURVNbYXR0cl0gfHwgYXR0cjtcbiAgICAgICAgICAgIC8vIEJVVFRPTiB2YWx1ZSBpc3N1ZSBmb3IgSUUgPCA4XG4gICAgICAgICAgICByZXQgPSAoZWwudGFnTmFtZSA9PT0gXCJCVVRUT05cIiAmJiBhdHRyID09PSAndmFsdWUnKSA/IFlfRE9NLmdldFZhbHVlKGVsKSA6IGVsLmdldEF0dHJpYnV0ZShhdHRyLCBpZUF0dHIpO1xuXG4gICAgICAgICAgICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gJyc7IC8vIHBlciBET00gc3BlY1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIFZBTFVFX1NFVFRFUlM6IHt9LFxuXG4gICAgVkFMVUVfR0VUVEVSUzoge30sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcmV0ID0gJycsIC8vIFRPRE86IHJldHVybiBudWxsP1xuICAgICAgICAgICAgZ2V0dGVyO1xuXG4gICAgICAgIGlmIChub2RlICYmIG5vZGVbVEFHX05BTUVdKSB7XG4gICAgICAgICAgICBnZXR0ZXIgPSBZX0RPTS5WQUxVRV9HRVRURVJTW25vZGVbVEFHX05BTUVdLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgICAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gZ2V0dGVyKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSBub2RlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgSUU4IEpTT04gc3RyaW5naWZ5IGJ1Z1xuICAgICAgICAvLyB3aGljaCBjb252ZXJ0cyBlbXB0eSBzdHJpbmcgdmFsdWVzIHRvIG51bGxcbiAgICAgICAgaWYgKHJldCA9PT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICAgICAgICByZXQgPSBFTVBUWV9TVFJJTkc7IC8vIGZvciByZWFsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHR5cGVvZiByZXQgPT09ICdzdHJpbmcnKSA/IHJldCA6ICcnO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24obm9kZSwgdmFsKSB7XG4gICAgICAgIHZhciBzZXR0ZXI7XG5cbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZVtUQUdfTkFNRV0pIHtcbiAgICAgICAgICAgIHNldHRlciA9IFlfRE9NLlZBTFVFX1NFVFRFUlNbbm9kZVtUQUdfTkFNRV0udG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICB2YWwgPSAodmFsID09PSBudWxsKSA/ICcnIDogdmFsO1xuICAgICAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgICAgICAgIHNldHRlcihub2RlLCB2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0b3JzOiB7fVxufSk7XG5cbmFkZEZlYXR1cmUoJ3ZhbHVlLXNldCcsICdzZWxlY3QnLCB7XG4gICAgdGVzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub2RlID0gWS5jb25maWcuZG9jLmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgICAgICBub2RlLmlubmVySFRNTCA9ICc8b3B0aW9uPjE8L29wdGlvbj48b3B0aW9uPjI8L29wdGlvbj4nO1xuICAgICAgICBub2RlLnZhbHVlID0gJzInO1xuICAgICAgICByZXR1cm4gKG5vZGUudmFsdWUgJiYgbm9kZS52YWx1ZSA9PT0gJzInKTtcbiAgICB9XG59KTtcblxuaWYgKCF0ZXN0RmVhdHVyZSgndmFsdWUtc2V0JywgJ3NlbGVjdCcpKSB7XG4gICAgWV9ET00uVkFMVUVfU0VUVEVSUy5zZWxlY3QgPSBmdW5jdGlvbihub2RlLCB2YWwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9wdGlvbnMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdvcHRpb24nKSwgb3B0aW9uO1xuICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbaSsrXTspIHtcbiAgICAgICAgICAgIGlmIChZX0RPTS5nZXRWYWx1ZShvcHRpb24pID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vWV9ET00uc2V0QXR0cmlidXRlKG9wdGlvbiwgJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5ZLm1peChZX0RPTS5WQUxVRV9HRVRURVJTLCB7XG4gICAgYnV0dG9uOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiAobm9kZS5hdHRyaWJ1dGVzICYmIG5vZGUuYXR0cmlidXRlcy52YWx1ZSkgPyBub2RlLmF0dHJpYnV0ZXMudmFsdWUudmFsdWUgOiAnJztcbiAgICB9XG59KTtcblxuWS5taXgoWV9ET00uVkFMVUVfU0VUVEVSUywge1xuICAgIC8vIElFOiBub2RlLnZhbHVlIGNoYW5nZXMgdGhlIGJ1dHRvbiB0ZXh0LCB3aGljaCBzaG91bGQgYmUgaGFuZGxlZCB2aWEgaW5uZXJIVE1MXG4gICAgYnV0dG9uOiBmdW5jdGlvbihub2RlLCB2YWwpIHtcbiAgICAgICAgdmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICAgIGlmICghYXR0cikge1xuICAgICAgICAgICAgYXR0ciA9IG5vZGVbT1dORVJfRE9DVU1FTlRdLmNyZWF0ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTm9kZShhdHRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHIudmFsdWUgPSB2YWw7XG4gICAgfVxufSk7XG5cblxuWS5taXgoWV9ET00uVkFMVUVfR0VUVEVSUywge1xuICAgIG9wdGlvbjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIHJldHVybiAoYXR0cnMudmFsdWUgJiYgYXR0cnMudmFsdWUuc3BlY2lmaWVkKSA/IG5vZGUudmFsdWUgOiBub2RlLnRleHQ7XG4gICAgfSxcblxuICAgIHNlbGVjdDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgdmFsID0gbm9kZS52YWx1ZSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBub2RlLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBtdWx0aXBlIHNlbGVjdFxuICAgICAgICAgICAgaWYgKG5vZGUubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5zZWxlY3RlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBZX0RPTS5nZXRWYWx1ZShvcHRpb25zW25vZGUuc2VsZWN0ZWRJbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59KTtcbnZhciBhZGRDbGFzcywgaGFzQ2xhc3MsIHJlbW92ZUNsYXNzO1xuXG5ZLm1peChZLkRPTSwge1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhIERPTSBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gY2xhc3NOYW1lLlxuICAgICAqIEBtZXRob2QgaGFzQ2xhc3NcbiAgICAgKiBAZm9yIERPTVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgdGhlIGNsYXNzIG5hbWUgdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gY2xhc3MuXG4gICAgICovXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgcmUgPSBZLkRPTS5fZ2V0UmVnRXhwKCcoPzpefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzK3wkKScpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiByZS50ZXN0KG5vZGUuY2xhc3NOYW1lKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNsYXNzIG5hbWUgdG8gYSBnaXZlbiBET00gZWxlbWVudC5cbiAgICAgKiBAbWV0aG9kIGFkZENsYXNzXG4gICAgICogQGZvciBET01cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIHRoZSBjbGFzcyBuYW1lIHRvIGFkZCB0byB0aGUgY2xhc3MgYXR0cmlidXRlXG4gICAgICovXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAobm9kZSAmJiAhWS5ET00uaGFzQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSkgeyAvLyBza2lwIGlmIGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBZLkxhbmcudHJpbShbbm9kZS5jbGFzc05hbWUsIGNsYXNzTmFtZV0uam9pbignICcpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2xhc3MgbmFtZSBmcm9tIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNsYXNzXG4gICAgICogQGZvciBET01cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIHRoZSBjbGFzcyBuYW1lIHRvIHJlbW92ZSBmcm9tIHRoZSBjbGFzcyBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24obm9kZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChjbGFzc05hbWUgJiYgaGFzQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBZLkxhbmcudHJpbShub2RlLmNsYXNzTmFtZS5yZXBsYWNlKFkuRE9NLl9nZXRSZWdFeHAoJyg/Ol58XFxcXHMrKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSArICcoPzpcXFxccyt8JCknKSwgJyAnKSk7XG5cbiAgICAgICAgICAgIGlmICggaGFzQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSApIHsgLy8gaW4gY2FzZSBvZiBtdWx0aXBsZSBhZGphY2VudFxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBhIGNsYXNzIHdpdGggYW5vdGhlciBjbGFzcyBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIG5vIG9sZENsYXNzTmFtZSBpcyBwcmVzZW50LCB0aGUgbmV3Q2xhc3NOYW1lIGlzIHNpbXBseSBhZGRlZC5cbiAgICAgKiBAbWV0aG9kIHJlcGxhY2VDbGFzc1xuICAgICAqIEBmb3IgRE9NXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkQ2xhc3NOYW1lIHRoZSBjbGFzcyBuYW1lIHRvIGJlIHJlcGxhY2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld0NsYXNzTmFtZSB0aGUgY2xhc3MgbmFtZSB0aGF0IHdpbGwgYmUgcmVwbGFjaW5nIHRoZSBvbGQgY2xhc3MgbmFtZVxuICAgICAqL1xuICAgIHJlcGxhY2VDbGFzczogZnVuY3Rpb24obm9kZSwgb2xkQywgbmV3Qykge1xuICAgICAgICByZW1vdmVDbGFzcyhub2RlLCBvbGRDKTsgLy8gcmVtb3ZlIGZpcnN0IGluIGNhc2Ugb2xkQyA9PT0gbmV3Q1xuICAgICAgICBhZGRDbGFzcyhub2RlLCBuZXdDKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGNsYXNzTmFtZSBleGlzdHMgb24gdGhlIG5vZGUgaXQgaXMgcmVtb3ZlZCwgaWYgaXQgZG9lc24ndCBleGlzdCBpdCBpcyBhZGRlZC5cbiAgICAgKiBAbWV0aG9kIHRvZ2dsZUNsYXNzXG4gICAgICogQGZvciBET01cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgdGhlIGNsYXNzIG5hbWUgdG8gYmUgdG9nZ2xlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkQ2xhc3Mgb3B0aW9uYWwgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIGNsYXNzXG4gICAgICogc2hvdWxkIGJlIGFkZGVkIG9yIHJlbW92ZWQgcmVnYXJkbGVzcyBvZiBjdXJyZW50IHN0YXRlXG4gICAgICovXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKG5vZGUsIGNsYXNzTmFtZSwgZm9yY2UpIHtcbiAgICAgICAgdmFyIGFkZCA9IChmb3JjZSAhPT0gdW5kZWZpbmVkKSA/IGZvcmNlIDpcbiAgICAgICAgICAgICAgICAhKGhhc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSkpO1xuXG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmhhc0NsYXNzID0gWS5ET00uaGFzQ2xhc3M7XG5yZW1vdmVDbGFzcyA9IFkuRE9NLnJlbW92ZUNsYXNzO1xuYWRkQ2xhc3MgPSBZLkRPTS5hZGRDbGFzcztcblxudmFyIHJlX3RhZyA9IC88KFthLXpdKykvaSxcblxuICAgIFlfRE9NID0gWS5ET00sXG5cbiAgICBhZGRGZWF0dXJlID0gWS5GZWF0dXJlcy5hZGQsXG4gICAgdGVzdEZlYXR1cmUgPSBZLkZlYXR1cmVzLnRlc3QsXG5cbiAgICBjcmVhdG9ycyA9IHt9LFxuXG4gICAgY3JlYXRlRnJvbURJViA9IGZ1bmN0aW9uKGh0bWwsIHRhZykge1xuICAgICAgICB2YXIgZGl2ID0gWS5jb25maWcuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcblxuICAgICAgICBkaXYuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgaWYgKCFkaXYuZmlyc3RDaGlsZCB8fCBkaXYuZmlyc3RDaGlsZC50YWdOYW1lICE9PSB0YWcudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICByZV90Ym9keSA9IC8oPzpcXC8oPzp0aGVhZHx0Zm9vdHx0Ym9keXxjYXB0aW9ufGNvbHxjb2xncm91cCk+KStcXHMqPHRib2R5LyxcblxuICAgIFRBQkxFX09QRU4gPSAnPHRhYmxlPicsXG4gICAgVEFCTEVfQ0xPU0UgPSAnPC90YWJsZT4nLFxuXG4gICAgc2VsZWN0ZWRJbmRleDtcblxuWS5taXgoWS5ET00sIHtcbiAgICBfZnJhZ0Nsb25lczoge30sXG5cbiAgICBfY3JlYXRlOiBmdW5jdGlvbihodG1sLCBkb2MsIHRhZykge1xuICAgICAgICB0YWcgPSB0YWcgfHwgJ2Rpdic7XG5cbiAgICAgICAgdmFyIGZyYWcgPSBZX0RPTS5fZnJhZ0Nsb25lc1t0YWddO1xuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWcuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBZX0RPTS5fZnJhZ0Nsb25lc1t0YWddID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgfVxuICAgICAgICBmcmFnLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgIH0sXG5cbiAgICBfY2hpbGRyZW46IGZ1bmN0aW9uKG5vZGUsIHRhZykge1xuICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGROb2RlcyxcbiAgICAgICAgICAgIGhhc0NvbW1lbnRzLFxuICAgICAgICAgICAgY2hpbGQ7XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLnRhZ3MpIHsgLy8gdXNlIHRhZ3MgZmlsdGVyIHdoZW4gcG9zc2libGVcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4udGFncyh0YWcpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gSUUgbGVha3MgY29tbWVudHMgaW50byBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGhhc0NvbW1lbnRzID0gY2hpbGRyZW4udGFncygnIScpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hpbGRyZW4gfHwgKCFjaGlsZHJlbi50YWdzICYmIHRhZykgfHwgaGFzQ29tbWVudHMpIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBjaGlsZHJlbiB8fCBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKChjaGlsZCA9IGNoaWxkTm9kZXNbaSsrXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YWcgfHwgdGFnID09PSBjaGlsZC50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZHJlbiB8fCBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkb20gbm9kZSB1c2luZyB0aGUgcHJvdmlkZWQgbWFya3VwIHN0cmluZy5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBtYXJrdXAgdXNlZCB0byBjcmVhdGUgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0hUTUxEb2N1bWVudH0gZG9jIEFuIG9wdGlvbmFsIGRvY3VtZW50IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSByZXR1cm5zIGEgc2luZ2xlIEhUTUxFbGVtZW50XG4gICAgICogd2hlbiBjcmVhdGluZyBvbmUgbm9kZSwgYW5kIGEgZG9jdW1lbnRGcmFnbWVudCB3aGVuIGNyZWF0aW5nXG4gICAgICogbXVsdGlwbGUgbm9kZXMuXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihodG1sLCBkb2MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBodG1sID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaHRtbCA9IFkuTGFuZy50cmltKGh0bWwpOyAvLyBtYXRjaCBJRSB3aGljaCB0cmltcyB3aGl0ZXNwYWNlIGZyb20gaW5uZXJIVE1MXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGRvYyA9IGRvYyB8fCBZLmNvbmZpZy5kb2M7XG4gICAgICAgIHZhciBtID0gcmVfdGFnLmV4ZWMoaHRtbCksXG4gICAgICAgICAgICBjcmVhdGUgPSBZX0RPTS5fY3JlYXRlLFxuICAgICAgICAgICAgY3VzdG9tID0gY3JlYXRvcnMsXG4gICAgICAgICAgICByZXQgPSBudWxsLFxuICAgICAgICAgICAgY3JlYXRvciwgdGFnLCBub2RlLCBub2RlcztcblxuICAgICAgICBpZiAoaHRtbCAhPSB1bmRlZmluZWQpIHsgLy8gbm90IHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRvciA9IGN1c3RvbVttWzFdLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGUgPSBjcmVhdG9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZyA9IGNyZWF0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gY3JlYXRlKGh0bWwsIGRvYywgdGFnKTtcbiAgICAgICAgICAgIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXG4gICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxKSB7IC8vIHJldHVybiBzaW5nbGUgbm9kZSwgYnJlYWtpbmcgcGFyZW50Tm9kZSByZWYgZnJvbSBcImZyYWdtZW50XCJcbiAgICAgICAgICAgICAgICByZXQgPSBub2RlLnJlbW92ZUNoaWxkKG5vZGVzWzBdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZXNbMF0gJiYgbm9kZXNbMF0uY2xhc3NOYW1lID09PSAneXVpMy1iaWctZHVtbXknKSB7IC8vIHVzaW5nIGR1bW15IG5vZGUgdG8gcHJlc2VydmUgc29tZSBhdHRyaWJ1dGVzIChlLmcuIE9QVElPTiBub3Qgc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IG5vZGUuc2VsZWN0ZWRJbmRleDtcblxuICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gbm9kZXNbMF0ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2Rlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IFlfRE9NLl9ubDJmcmFnKG5vZGVzLCBkb2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHJldHVybiBtdWx0aXBsZSBub2RlcyBhcyBhIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgIHJldCA9IFlfRE9NLl9ubDJmcmFnKG5vZGVzLCBkb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBfbmwyZnJhZzogZnVuY3Rpb24obm9kZXMsIGRvYykge1xuICAgICAgICB2YXIgcmV0ID0gbnVsbCxcbiAgICAgICAgICAgIGksIGxlbjtcblxuICAgICAgICBpZiAobm9kZXMgJiYgKG5vZGVzLnB1c2ggfHwgbm9kZXMuaXRlbSkgJiYgbm9kZXNbMF0pIHtcbiAgICAgICAgICAgIGRvYyA9IGRvYyB8fCBub2Rlc1swXS5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgcmV0ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgICAgICAgaWYgKG5vZGVzLml0ZW0pIHsgLy8gY29udmVydCBsaXZlIGxpc3QgdG8gc3RhdGljIGFycmF5XG4gICAgICAgICAgICAgICAgbm9kZXMgPSBZLkFycmF5KG5vZGVzLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIGVsc2UgaW5saW5lIHdpdGggbG9nIGZvciBtaW5pZmljYXRpb25cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBjb250ZW50IGluIGEgbm9kZSBhdCB0aGUgZ2l2ZW4gbG9jYXRpb25cbiAgICAgKiBAbWV0aG9kIGFkZEhUTUxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFRoZSBub2RlIHRvIGluc2VydCBpbnRvXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IEFycmF5IHwgSFRNTENvbGxlY3Rpb259IGNvbnRlbnQgVGhlIGNvbnRlbnQgdG8gYmUgaW5zZXJ0ZWRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB3aGVyZSBXaGVyZSB0byBpbnNlcnQgdGhlIGNvbnRlbnRcbiAgICAgKiBJZiBubyBcIndoZXJlXCIgaXMgZ2l2ZW4sIGNvbnRlbnQgaXMgYXBwZW5kZWQgdG8gdGhlIG5vZGVcbiAgICAgKiBQb3NzaWJsZSB2YWx1ZXMgZm9yIFwid2hlcmVcIlxuICAgICAqIDxkbD5cbiAgICAgKiA8ZHQ+SFRNTEVsZW1lbnQ8L2R0PlxuICAgICAqIDxkZD5UaGUgZWxlbWVudCB0byBpbnNlcnQgYmVmb3JlPC9kZD5cbiAgICAgKiA8ZHQ+XCJyZXBsYWNlXCI8L2R0PlxuICAgICAqIDxkZD5SZXBsYWNlcyB0aGUgZXhpc3RpbmcgSFRNTDwvZGQ+XG4gICAgICogPGR0PlwiYmVmb3JlXCI8L2R0PlxuICAgICAqIDxkZD5JbnNlcnRzIGJlZm9yZSB0aGUgZXhpc3RpbmcgSFRNTDwvZGQ+XG4gICAgICogPGR0PlwiYmVmb3JlXCI8L2R0PlxuICAgICAqIDxkZD5JbnNlcnRzIGNvbnRlbnQgYmVmb3JlIHRoZSBub2RlPC9kZD5cbiAgICAgKiA8ZHQ+XCJhZnRlclwiPC9kdD5cbiAgICAgKiA8ZGQ+SW5zZXJ0cyBjb250ZW50IGFmdGVyIHRoZSBub2RlPC9kZD5cbiAgICAgKiA8L2RsPlxuICAgICAqL1xuICAgIGFkZEhUTUw6IGZ1bmN0aW9uKG5vZGUsIGNvbnRlbnQsIHdoZXJlKSB7XG4gICAgICAgIHZhciBub2RlUGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgcmV0ID0gY29udGVudCxcbiAgICAgICAgICAgIG5ld05vZGU7XG5cblxuICAgICAgICBpZiAoY29udGVudCAhPSB1bmRlZmluZWQpIHsgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkIChtYXliZSAwKVxuICAgICAgICAgICAgaWYgKGNvbnRlbnQubm9kZVR5cGUpIHsgLy8gRE9NIG5vZGUsIGp1c3QgYWRkIGl0XG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZW50ID09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb250ZW50ID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3Tm9kZSA9IFlfRE9NLmNyZWF0ZShjb250ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGVudFswXSAmJiBjb250ZW50WzBdLm5vZGVUeXBlKSB7IC8vIGFycmF5IG9yIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBuZXdOb2RlID0gWS5jb25maWcuZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGl0ZW0gPSBjb250ZW50W2krK10pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQoaXRlbSk7IC8vIGFwcGVuZCB0byBmcmFnbWVudCBmb3IgaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdoZXJlKSB7XG4gICAgICAgICAgICBpZiAobmV3Tm9kZSAmJiB3aGVyZS5wYXJlbnROb2RlKSB7IC8vIGluc2VydCByZWdhcmRsZXNzIG9mIHJlbGF0aW9uc2hpcCB0byBub2RlXG4gICAgICAgICAgICAgICAgd2hlcmUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgd2hlcmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdoZXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlKSB7IC8vIGFsbG93IGVtcHR5IGNvbnRlbnQgdG8gY2xlYXIgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVBhcmVudC5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZykgeyAvLyBJRSBlcnJvcnMgaWYgcmVmTm9kZSBpcyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVQYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIG5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVQYXJlbnQuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBgc2VsZWN0YCBlbGVtZW50cyBhcmUgdGhlIG9ubHkgZWxlbWVudHMgd2l0aCBgc2VsZWN0ZWRJbmRleGAuXG4gICAgICAgIC8vIERvbid0IGdyYWIgdGhlIGR1bW15IGBvcHRpb25gIGVsZW1lbnQncyBgc2VsZWN0ZWRJbmRleGAuXG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiU0VMRUNUXCIgJiYgc2VsZWN0ZWRJbmRleCA+IDApIHtcbiAgICAgICAgICAgIG5vZGUuc2VsZWN0ZWRJbmRleCA9IHNlbGVjdGVkSW5kZXggLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgd3JhcDogZnVuY3Rpb24obm9kZSwgaHRtbCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gKGh0bWwgJiYgaHRtbC5ub2RlVHlwZSkgPyBodG1sIDogWS5ET00uY3JlYXRlKGh0bWwpLFxuICAgICAgICAgICAgbm9kZXMgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcblxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQocGFyZW50LCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfSxcblxuICAgIHVud3JhcDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgbGFzdENoaWxkID0gcGFyZW50Lmxhc3RDaGlsZCxcbiAgICAgICAgICAgIG5leHQgPSBub2RlLFxuICAgICAgICAgICAgZ3JhbmRwYXJlbnQ7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgZ3JhbmRwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChncmFuZHBhcmVudCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSAhPT0gbGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBncmFuZHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdyYW5kcGFyZW50LnJlcGxhY2VDaGlsZChsYXN0Q2hpbGQsIHBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5hZGRGZWF0dXJlKCdpbm5lcmh0bWwnLCAndGFibGUnLCB7XG4gICAgdGVzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub2RlID0gWS5jb25maWcuZG9jLmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub2RlLmlubmVySFRNTCA9ICc8dGJvZHk+PC90Ym9keT4nO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5vZGUuZmlyc3RDaGlsZCAmJiBub2RlLmZpcnN0Q2hpbGQubm9kZU5hbWUgPT09ICdUQk9EWScpO1xuICAgIH1cbn0pO1xuXG5hZGRGZWF0dXJlKCdpbm5lcmh0bWwtZGl2JywgJ3RyJywge1xuICAgIHRlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbURJVignPHRyPjwvdHI+JywgJ3RyJyk7XG4gICAgfVxufSk7XG5cbmFkZEZlYXR1cmUoJ2lubmVyaHRtbC1kaXYnLCAnc2NyaXB0Jywge1xuICAgIHRlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbURJVignPHNjcmlwdD48L3NjcmlwdD4nLCAnc2NyaXB0Jyk7XG4gICAgfVxufSk7XG5cbmlmICghdGVzdEZlYXR1cmUoJ2lubmVyaHRtbCcsICd0YWJsZScpKSB7XG4gICAgLy8gVE9ETzogdGhlYWQvdGZvb3Qgd2l0aCBuZXN0ZWQgdGJvZHlcbiAgICAgICAgLy8gSUUgYWRkcyBUQk9EWSB3aGVuIGNyZWF0aW5nIFRBQkxFIGVsZW1lbnRzICh3aGljaCBtYXkgc2hhcmUgdGhpcyBpbXBsKVxuICAgIGNyZWF0b3JzLnRib2R5ID0gZnVuY3Rpb24oaHRtbCwgZG9jKSB7XG4gICAgICAgIHZhciBmcmFnID0gWV9ET00uY3JlYXRlKFRBQkxFX09QRU4gKyBodG1sICsgVEFCTEVfQ0xPU0UsIGRvYyksXG4gICAgICAgICAgICB0YiA9IFkuRE9NLl9jaGlsZHJlbihmcmFnLCAndGJvZHknKVswXTtcblxuICAgICAgICBpZiAoZnJhZy5jaGlsZHJlbi5sZW5ndGggPiAxICYmIHRiICYmICFyZV90Ym9keS50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICB0Yi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRiKTsgLy8gc3RyaXAgZXh0cmFuZW91cyB0Ym9keVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgIH07XG59XG5cbmlmICghdGVzdEZlYXR1cmUoJ2lubmVyaHRtbC1kaXYnLCAnc2NyaXB0JykpIHtcbiAgICBjcmVhdG9ycy5zY3JpcHQgPSBmdW5jdGlvbihodG1sLCBkb2MpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgZnJhZy5pbm5lckhUTUwgPSAnLScgKyBodG1sO1xuICAgICAgICBmcmFnLnJlbW92ZUNoaWxkKGZyYWcuZmlyc3RDaGlsZCk7XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgIH07XG5cbiAgICBjcmVhdG9ycy5saW5rID0gY3JlYXRvcnMuc3R5bGUgPSBjcmVhdG9ycy5zY3JpcHQ7XG59XG5cbmlmICghdGVzdEZlYXR1cmUoJ2lubmVyaHRtbC1kaXYnLCAndHInKSkge1xuICAgIFkubWl4KGNyZWF0b3JzLCB7XG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24oaHRtbCwgZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gWV9ET00uY3JlYXRlKCc8c2VsZWN0PjxvcHRpb24gY2xhc3M9XCJ5dWkzLWJpZy1kdW1teVwiIHNlbGVjdGVkPjwvb3B0aW9uPicgKyBodG1sICsgJzwvc2VsZWN0PicsIGRvYyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHI6IGZ1bmN0aW9uKGh0bWwsIGRvYykge1xuICAgICAgICAgICAgcmV0dXJuIFlfRE9NLmNyZWF0ZSgnPHRib2R5PicgKyBodG1sICsgJzwvdGJvZHk+JywgZG9jKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0ZDogZnVuY3Rpb24oaHRtbCwgZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gWV9ET00uY3JlYXRlKCc8dHI+JyArIGh0bWwgKyAnPC90cj4nLCBkb2MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbDogZnVuY3Rpb24oaHRtbCwgZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gWV9ET00uY3JlYXRlKCc8Y29sZ3JvdXA+JyArIGh0bWwgKyAnPC9jb2xncm91cD4nLCBkb2MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRib2R5OiAndGFibGUnXG4gICAgfSk7XG5cbiAgICBZLm1peChjcmVhdG9ycywge1xuICAgICAgICBsZWdlbmQ6ICdmaWVsZHNldCcsXG4gICAgICAgIHRoOiBjcmVhdG9ycy50ZCxcbiAgICAgICAgdGhlYWQ6IGNyZWF0b3JzLnRib2R5LFxuICAgICAgICB0Zm9vdDogY3JlYXRvcnMudGJvZHksXG4gICAgICAgIGNhcHRpb246IGNyZWF0b3JzLnRib2R5LFxuICAgICAgICBjb2xncm91cDogY3JlYXRvcnMudGJvZHksXG4gICAgICAgIG9wdGdyb3VwOiBjcmVhdG9ycy5vcHRpb25cbiAgICB9KTtcbn1cblxuWV9ET00uY3JlYXRvcnMgPSBjcmVhdG9ycztcblkubWl4KFkuRE9NLCB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNpemUsIHJlZ2FyZGxlc3NcbiAgICAgKiBvZiBib3ggbW9kZWwsIGJvcmRlciwgcGFkZGluZywgZXRjLlxuICAgICAqIEBtZXRob2Qgc2V0V2lkdGhcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHNpemUgVGhlIHBpeGVsIGhlaWdodCB0byBzaXplIHRvXG4gICAgICovXG5cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24obm9kZSwgc2l6ZSkge1xuICAgICAgICBZLkRPTS5fc2V0U2l6ZShub2RlLCAnd2lkdGgnLCBzaXplKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IHRvIHRoZSBnaXZlbiBzaXplLCByZWdhcmRsZXNzXG4gICAgICogb2YgYm94IG1vZGVsLCBib3JkZXIsIHBhZGRpbmcsIGV0Yy5cbiAgICAgKiBAbWV0aG9kIHNldEhlaWdodFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gc2l6ZSBUaGUgcGl4ZWwgaGVpZ2h0IHRvIHNpemUgdG9cbiAgICAgKi9cblxuICAgIHNldEhlaWdodDogZnVuY3Rpb24obm9kZSwgc2l6ZSkge1xuICAgICAgICBZLkRPTS5fc2V0U2l6ZShub2RlLCAnaGVpZ2h0Jywgc2l6ZSk7XG4gICAgfSxcblxuICAgIF9zZXRTaXplOiBmdW5jdGlvbihub2RlLCBwcm9wLCB2YWwpIHtcbiAgICAgICAgdmFsID0gKHZhbCA+IDApID8gdmFsIDogMDtcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuXG4gICAgICAgIG5vZGUuc3R5bGVbcHJvcF0gPSB2YWwgKyAncHgnO1xuICAgICAgICBzaXplID0gKHByb3AgPT09ICdoZWlnaHQnKSA/IG5vZGUub2Zmc2V0SGVpZ2h0IDogbm9kZS5vZmZzZXRXaWR0aDtcblxuICAgICAgICBpZiAoc2l6ZSA+IHZhbCkge1xuICAgICAgICAgICAgdmFsID0gdmFsIC0gKHNpemUgLSB2YWwpO1xuXG4gICAgICAgICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUuc3R5bGVbcHJvcF0gPSB2YWwgKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImRvbS1jb3JlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2RvbS1jb3JlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxudmFyIE5PREVfVFlQRSA9ICdub2RlVHlwZScsXG4gICAgT1dORVJfRE9DVU1FTlQgPSAnb3duZXJEb2N1bWVudCcsXG4gICAgRE9DVU1FTlRfRUxFTUVOVCA9ICdkb2N1bWVudEVsZW1lbnQnLFxuICAgIERFRkFVTFRfVklFVyA9ICdkZWZhdWx0VmlldycsXG4gICAgUEFSRU5UX1dJTkRPVyA9ICdwYXJlbnRXaW5kb3cnLFxuICAgIFRBR19OQU1FID0gJ3RhZ05hbWUnLFxuICAgIFBBUkVOVF9OT0RFID0gJ3BhcmVudE5vZGUnLFxuICAgIFBSRVZJT1VTX1NJQkxJTkcgPSAncHJldmlvdXNTaWJsaW5nJyxcbiAgICBORVhUX1NJQkxJTkcgPSAnbmV4dFNpYmxpbmcnLFxuICAgIENPTlRBSU5TID0gJ2NvbnRhaW5zJyxcbiAgICBDT01QQVJFX0RPQ1VNRU5UX1BPU0lUSU9OID0gJ2NvbXBhcmVEb2N1bWVudFBvc2l0aW9uJyxcbiAgICBFTVBUWV9BUlJBWSA9IFtdLFxuXG4gICAgLy8gSUUgPCA4IHRocm93cyBvbiBub2RlLmNvbnRhaW5zKHRleHROb2RlKVxuICAgIHN1cHBvcnRzQ29udGFpbnNUZXh0Tm9kZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBZLmNvbmZpZy5kb2MuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICB0ZXh0Tm9kZSA9IG5vZGUuYXBwZW5kQ2hpbGQoWS5jb25maWcuZG9jLmNyZWF0ZVRleHROb2RlKCcnKSksXG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbm9kZS5jb250YWlucyh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gY2F0Y2goZSkge31cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKCksXG5cbi8qKlxuICogVGhlIERPTSB1dGlsaXR5IHByb3ZpZGVzIGEgY3Jvc3MtYnJvd3NlciBhYnRyYWN0aW9uIGxheWVyXG4gKiBub3JtYWxpemluZyBET00gdGFza3MsIGFuZCBhZGRzIGV4dHJhIGhlbHBlciBmdW5jdGlvbmFsaXR5XG4gKiBmb3Igb3RoZXIgY29tbW9uIHRhc2tzLlxuICogQG1vZHVsZSBkb21cbiAqIEBtYWluIGRvbVxuICogQHN1Ym1vZHVsZSBkb20tYmFzZVxuICogQGZvciBET01cbiAqXG4gKi9cblxuLyoqXG4gKiBQcm92aWRlcyBET00gaGVscGVyIG1ldGhvZHMuXG4gKiBAY2xhc3MgRE9NXG4gKlxuICovXG5cbllfRE9NID0ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEhUTUxFbGVtZW50IHdpdGggdGhlIGdpdmVuIElEIChXcmFwcGVyIGZvciBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCkuXG4gICAgICogQG1ldGhvZCBieUlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBpZCBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZG9jIG9wdGlvbmFsIFRoZSBkb2N1bWVudCB0byBzZWFyY2guIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudCB8IG51bGx9IFRoZSBIVE1MRWxlbWVudCB3aXRoIHRoZSBpZCwgb3IgbnVsbCBpZiBub25lIGZvdW5kLlxuICAgICAqL1xuICAgIGJ5SWQ6IGZ1bmN0aW9uKGlkLCBkb2MpIHtcbiAgICAgICAgLy8gaGFuZGxlIGR1cGUgSURzIGFuZCBJRSBuYW1lIGNvbGxpc2lvblxuICAgICAgICByZXR1cm4gWV9ET00uYWxsQnlJZChpZCwgZG9jKVswXSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRJZDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIC8vIEhUTUxFbGVtZW50IHJldHVybmVkIGZyb20gRk9STSB3aGVuIElOUFVUIG5hbWUgPT09IFwiaWRcIlxuICAgICAgICAvLyBJRSA8IDg6IEhUTUxDb2xsZWN0aW9uIHJldHVybmVkIHdoZW4gSU5QVVQgaWQgPT09IFwiaWRcIlxuICAgICAgICAvLyB2aWEgYm90aCBnZXRBdHRyaWJ1dGUgYW5kIGZvcm0uaWRcbiAgICAgICAgaWYgKG5vZGUuaWQgJiYgIW5vZGUuaWQudGFnTmFtZSAmJiAhbm9kZS5pZC5pdGVtKSB7XG4gICAgICAgICAgICBpZCA9IG5vZGUuaWQ7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hdHRyaWJ1dGVzICYmIG5vZGUuYXR0cmlidXRlcy5pZCkge1xuICAgICAgICAgICAgaWQgPSBub2RlLmF0dHJpYnV0ZXMuaWQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfSxcblxuICAgIHNldElkOiBmdW5jdGlvbihub2RlLCBpZCkge1xuICAgICAgICBpZiAobm9kZS5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEZpbmRzIHRoZSBhbmNlc3RvciBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAbWV0aG9kIGFuY2VzdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgaHRtbCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIG9wdGlvbmFsIEFuIG9wdGlvbmFsIGJvb2xlYW4gdGVzdCB0byBhcHBseS5cbiAgICAgKiBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBjdXJyZW50IERPTSBub2RlIGJlaW5nIHRlc3RlZCBhcyBpdHMgb25seSBhcmd1bWVudC5cbiAgICAgKiBJZiBubyBmdW5jdGlvbiBpcyBnaXZlbiwgdGhlIHBhcmVudE5vZGUgaXMgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0ZXN0U2VsZiBvcHRpb25hbCBXaGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIHRoZSBlbGVtZW50IGluIHRoZSBzY2FuXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnQgfCBudWxsfSBUaGUgbWF0Y2hpbmcgRE9NIG5vZGUgb3IgbnVsbCBpZiBub25lIGZvdW5kLlxuICAgICAqL1xuICAgIGFuY2VzdG9yOiBmdW5jdGlvbihlbGVtZW50LCBmbiwgdGVzdFNlbGYsIHN0b3BGbikge1xuICAgICAgICB2YXIgcmV0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRlc3RTZWxmKSB7XG4gICAgICAgICAgICByZXQgPSAoIWZuIHx8IGZuKGVsZW1lbnQpKSA/IGVsZW1lbnQgOiBudWxsO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldCB8fCBZX0RPTS5lbGVtZW50QnlBeGlzKGVsZW1lbnQsIFBBUkVOVF9OT0RFLCBmbiwgbnVsbCwgc3RvcEZuKTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBGaW5kcyB0aGUgYW5jZXN0b3JzIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBtZXRob2QgYW5jZXN0b3JzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgaHRtbCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIG9wdGlvbmFsIEFuIG9wdGlvbmFsIGJvb2xlYW4gdGVzdCB0byBhcHBseS5cbiAgICAgKiBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBjdXJyZW50IERPTSBub2RlIGJlaW5nIHRlc3RlZCBhcyBpdHMgb25seSBhcmd1bWVudC5cbiAgICAgKiBJZiBubyBmdW5jdGlvbiBpcyBnaXZlbiwgYWxsIGFuY2VzdG9ycyBhcmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0ZXN0U2VsZiBvcHRpb25hbCBXaGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIHRoZSBlbGVtZW50IGluIHRoZSBzY2FuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG1hdGNoaW5nIERPTSBub2Rlcy5cbiAgICAgKi9cbiAgICBhbmNlc3RvcnM6IGZ1bmN0aW9uKGVsZW1lbnQsIGZuLCB0ZXN0U2VsZiwgc3RvcEZuKSB7XG4gICAgICAgIHZhciBhbmNlc3RvciA9IGVsZW1lbnQsXG4gICAgICAgICAgICByZXQgPSBbXTtcblxuICAgICAgICB3aGlsZSAoKGFuY2VzdG9yID0gWV9ET00uYW5jZXN0b3IoYW5jZXN0b3IsIGZuLCB0ZXN0U2VsZiwgc3RvcEZuKSkpIHtcbiAgICAgICAgICAgIHRlc3RTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXQudW5zaGlmdChhbmNlc3Rvcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RvcEZuICYmIHN0b3BGbihhbmNlc3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aGUgZWxlbWVudCBieSB0aGUgZ2l2ZW4gYXhpcyBmb3IgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQuXG4gICAgICogQG1ldGhvZCBlbGVtZW50QnlBeGlzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgaHRtbCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIFRoZSBheGlzIHRvIHNlYXJjaCAocGFyZW50Tm9kZSwgbmV4dFNpYmxpbmcsIHByZXZpb3VzU2libGluZykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBBbiBvcHRpb25hbCBib29sZWFuIHRlc3QgdG8gYXBwbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWxsXSBXaGV0aGVyIHRleHQgbm9kZXMgYXMgd2VsbCBhcyBlbGVtZW50IG5vZGVzIHNob3VsZCBiZSByZXR1cm5lZCwgb3JcbiAgICAgKiBqdXN0IGVsZW1lbnQgbm9kZXMgd2lsbCBiZSByZXR1cm5lZChkZWZhdWx0KVxuICAgICAqIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIGN1cnJlbnQgSFRNTEVsZW1lbnQgYmVpbmcgdGVzdGVkIGFzIGl0cyBvbmx5IGFyZ3VtZW50LlxuICAgICAqIElmIG5vIGZ1bmN0aW9uIGlzIGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBpcyByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudCB8IG51bGx9IFRoZSBtYXRjaGluZyBlbGVtZW50IG9yIG51bGwgaWYgbm9uZSBmb3VuZC5cbiAgICAgKi9cbiAgICBlbGVtZW50QnlBeGlzOiBmdW5jdGlvbihlbGVtZW50LCBheGlzLCBmbiwgYWxsLCBzdG9wQXQpIHtcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgKGVsZW1lbnQgPSBlbGVtZW50W2F4aXNdKSkgeyAvLyBOT1RFOiBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgaWYgKCAoYWxsIHx8IGVsZW1lbnRbVEFHX05BTUVdKSAmJiAoIWZuIHx8IGZuKGVsZW1lbnQpKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BBdCAmJiBzdG9wQXQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IG9uZSBIVE1MRWxlbWVudCBpcyBvciBjb250YWlucyBhbm90aGVyIEhUTUxFbGVtZW50LlxuICAgICAqIEBtZXRob2QgY29udGFpbnNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBjb250YWluaW5nIGh0bWwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBuZWVkbGUgVGhlIGh0bWwgZWxlbWVudCB0aGF0IG1heSBiZSBjb250YWluZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGVsZW1lbnQgaXMgb3IgY29udGFpbnMgdGhlIG5lZWRsZS5cbiAgICAgKi9cbiAgICBjb250YWluczogZnVuY3Rpb24oZWxlbWVudCwgbmVlZGxlKSB7XG4gICAgICAgIHZhciByZXQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoICFuZWVkbGUgfHwgIWVsZW1lbnQgfHwgIW5lZWRsZVtOT0RFX1RZUEVdIHx8ICFlbGVtZW50W05PREVfVFlQRV0pIHtcbiAgICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRbQ09OVEFJTlNdICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgPCA4IHRocm93cyBvbiBub2RlLmNvbnRhaW5zKHRleHROb2RlKSBzbyBmYWxsIGJhY2sgdG8gYnJ1dGUuXG4gICAgICAgICAgICAgICAgLy8gRmFsbGluZyBiYWNrIGZvciBvdGhlciBub2RlVHlwZXMgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICAobmVlZGxlW05PREVfVFlQRV0gPT09IDEgfHwgc3VwcG9ydHNDb250YWluc1RleHROb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGVsZW1lbnRbQ09OVEFJTlNdKG5lZWRsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFtDT01QQVJFX0RPQ1VNRU5UX1BPU0lUSU9OXSkge1xuICAgICAgICAgICAgLy8gTWF0Y2ggY29udGFpbnMgYmVoYXZpb3IgKG5vZGUuY29udGFpbnMobm9kZSkgPT09IHRydWUpLlxuICAgICAgICAgICAgLy8gTmVlZGVkIGZvciBGaXJlZm94IDwgNC5cbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBuZWVkbGUgfHwgISEoZWxlbWVudFtDT01QQVJFX0RPQ1VNRU5UX1BPU0lUSU9OXShuZWVkbGUpICYgMTYpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IFlfRE9NLl9icnV0ZUNvbnRhaW5zKGVsZW1lbnQsIG5lZWRsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBIVE1MRWxlbWVudCBpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAbWV0aG9kIGluRG9jXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgY29udGFpbmluZyBodG1sIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9jIG9wdGlvbmFsIFRoZSBkb2N1bWVudCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgaW5Eb2M6IGZ1bmN0aW9uKGVsZW1lbnQsIGRvYykge1xuICAgICAgICB2YXIgcmV0ID0gZmFsc2UsXG4gICAgICAgICAgICByb290Tm9kZTtcblxuICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAoZG9jKSB8fCAoZG9jID0gZWxlbWVudFtPV05FUl9ET0NVTUVOVF0pO1xuXG4gICAgICAgICAgICByb290Tm9kZSA9IGRvY1tET0NVTUVOVF9FTEVNRU5UXTtcblxuICAgICAgICAgICAgLy8gY29udGFpbnMgb25seSB3b3JrcyB3aXRoIEhUTUxfRUxFTUVOVFxuICAgICAgICAgICAgaWYgKHJvb3ROb2RlICYmIHJvb3ROb2RlLmNvbnRhaW5zICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHJvb3ROb2RlLmNvbnRhaW5zKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSBZX0RPTS5jb250YWlucyhyb290Tm9kZSwgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuXG4gICAgfSxcblxuICAgYWxsQnlJZDogZnVuY3Rpb24oaWQsIHJvb3QpIHtcbiAgICAgICAgcm9vdCA9IHJvb3QgfHwgWS5jb25maWcuZG9jO1xuICAgICAgICB2YXIgbm9kZXMgPSBbXSxcbiAgICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKHJvb3QucXVlcnlTZWxlY3RvckFsbCkge1xuICAgICAgICAgICAgcmV0ID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCdbaWQ9XCInICsgaWQgKyAnXCJdJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdC5hbGwpIHtcbiAgICAgICAgICAgIG5vZGVzID0gcm9vdC5hbGwoaWQpO1xuXG4gICAgICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICAvLyByb290LmFsbCBtYXkgcmV0dXJuIEhUTUxFbGVtZW50IG9yIEhUTUxDb2xsZWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIHNvbWUgZWxlbWVudHMgYXJlIGFsc28gSFRNTENvbGxlY3Rpb24gKEZPUk0sIFNFTEVDVCkuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5pZCA9PT0gaWQpIHsgLy8gYXZvaWQgZmFsc2UgcG9zaXRpdmUgb24gbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gobm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMgPSBFTVBUWV9BUlJBWTsgLy8gZG9uZSwgbm8gbmVlZCB0byBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gIHByZXAgZm9yIGZpbHRlcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IG1hdGNoZXMgb24gbm9kZS5uYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBlbGVtZW50LmlkIGFzIHJlZmVyZW5jZSB0byBlbGVtZW50IHdpdGggaWQgPT09ICdpZCdcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgbm9kZSA9IG5vZGVzW2krK107KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PT0gaWQgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLmF0dHJpYnV0ZXMgJiYgbm9kZS5hdHRyaWJ1dGVzLmlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlcy5pZC52YWx1ZSA9PT0gaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBbWV9ET00uX2dldERvYyhyb290KS5nZXRFbGVtZW50QnlJZChpZCldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgIH0sXG5cblxuICAgIGlzV2luZG93OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuICEhKG9iaiAmJiBvYmouc2Nyb2xsVG8gJiYgb2JqLmRvY3VtZW50KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUNoaWxkTm9kZXM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbihub2RlLCBmbikge1xuICAgICAgICB2YXIgbm9kZXMgPSBbXSxcbiAgICAgICAgICAgIHNpYmxpbmcgPSBub2RlO1xuXG4gICAgICAgIHdoaWxlICgoc2libGluZyA9IHNpYmxpbmdbUFJFVklPVVNfU0lCTElOR10pKSB7XG4gICAgICAgICAgICBpZiAoc2libGluZ1tUQUdfTkFNRV0gJiYgKCFmbiB8fCBmbihzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy51bnNoaWZ0KHNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2libGluZyA9IG5vZGU7XG4gICAgICAgIHdoaWxlICgoc2libGluZyA9IHNpYmxpbmdbTkVYVF9TSUJMSU5HXSkpIHtcbiAgICAgICAgICAgIGlmIChzaWJsaW5nW1RBR19OQU1FXSAmJiAoIWZuIHx8IGZuKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goc2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJydXRlIGZvcmNlIHZlcnNpb24gb2YgY29udGFpbnMuXG4gICAgICogVXNlZCBmb3IgYnJvd3NlcnMgd2l0aG91dCBjb250YWlucyBzdXBwb3J0IGZvciBub24tSFRNTEVsZW1lbnQgTm9kZXMgKHRleHROb2RlcywgZXRjKS5cbiAgICAgKiBAbWV0aG9kIF9icnV0ZUNvbnRhaW5zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBjb250YWluaW5nIGh0bWwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBuZWVkbGUgVGhlIGh0bWwgZWxlbWVudCB0aGF0IG1heSBiZSBjb250YWluZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGVsZW1lbnQgaXMgb3IgY29udGFpbnMgdGhlIG5lZWRsZS5cbiAgICAgKi9cbiAgICBfYnJ1dGVDb250YWluczogZnVuY3Rpb24oZWxlbWVudCwgbmVlZGxlKSB7XG4gICAgICAgIHdoaWxlIChuZWVkbGUpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBuZWVkbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lZWRsZSA9IG5lZWRsZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4vLyBUT0RPOiBtb3ZlIHRvIExhbmc/XG4gICAgLyoqXG4gICAgICogTWVtb2l6ZXMgZHluYW1pYyByZWd1bGFyIGV4cHJlc3Npb25zIHRvIGJvb3N0IHJ1bnRpbWUgcGVyZm9ybWFuY2UuXG4gICAgICogQG1ldGhvZCBfZ2V0UmVnRXhwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmxhZ3Mgb3B0aW9uYWwgQW4gb3B0aW5hbCBzdHJpbmcgb2YgZmxhZ3MuXG4gICAgICogQHJldHVybiB7UmVnRXhwfSBBbiBpbnN0YW5jZSBvZiBSZWdFeHBcbiAgICAgKi9cbiAgICBfZ2V0UmVnRXhwOiBmdW5jdGlvbihzdHIsIGZsYWdzKSB7XG4gICAgICAgIGZsYWdzID0gZmxhZ3MgfHwgJyc7XG4gICAgICAgIFlfRE9NLl9yZWdleENhY2hlID0gWV9ET00uX3JlZ2V4Q2FjaGUgfHwge307XG4gICAgICAgIGlmICghWV9ET00uX3JlZ2V4Q2FjaGVbc3RyICsgZmxhZ3NdKSB7XG4gICAgICAgICAgICBZX0RPTS5fcmVnZXhDYWNoZVtzdHIgKyBmbGFnc10gPSBuZXcgUmVnRXhwKHN0ciwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBZX0RPTS5fcmVnZXhDYWNoZVtzdHIgKyBmbGFnc107XG4gICAgfSxcblxuLy8gVE9ETzogbWFrZSBnZXREb2MvV2luIHRydWUgcHJpdmF0ZXM/XG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgZG9jdW1lbnQuXG4gICAgICogQG1ldGhvZCBfZ2V0RG9jXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IG9wdGlvbmFsIFRhcmdldCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRvY3VtZW50IGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBvciB0aGUgZGVmYXVsdCBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBfZ2V0RG9jOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHZhciBkb2MgPSBZLmNvbmZpZy5kb2M7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBkb2MgPSAoZWxlbWVudFtOT0RFX1RZUEVdID09PSA5KSA/IGVsZW1lbnQgOiAvLyBlbGVtZW50ID09PSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIGVsZW1lbnRbT1dORVJfRE9DVU1FTlRdIHx8IC8vIGVsZW1lbnQgPT09IERPTSBub2RlXG4gICAgICAgICAgICAgICAgZWxlbWVudC5kb2N1bWVudCB8fCAvLyBlbGVtZW50ID09PSB3aW5kb3dcbiAgICAgICAgICAgICAgICBZLmNvbmZpZy5kb2M7IC8vIGRlZmF1bHRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIHdpbmRvdy5cbiAgICAgKiBAbWV0aG9kIF9nZXRXaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgb3B0aW9uYWwgVGFyZ2V0IGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgd2luZG93IGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBvciB0aGUgZGVmYXVsdCB3aW5kb3cuXG4gICAgICovXG4gICAgX2dldFdpbjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB2YXIgZG9jID0gWV9ET00uX2dldERvYyhlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGRvY1tERUZBVUxUX1ZJRVddIHx8IGRvY1tQQVJFTlRfV0lORE9XXSB8fCBZLmNvbmZpZy53aW47XG4gICAgfSxcblxuICAgIF9iYXRjaDogZnVuY3Rpb24obm9kZXMsIGZuLCBhcmcxLCBhcmcyLCBhcmczLCBldGMpIHtcbiAgICAgICAgZm4gPSAodHlwZW9mIGZuID09PSAnc3RyaW5nJykgPyBZX0RPTVtmbl0gOiBmbjtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHJldDtcblxuICAgICAgICBpZiAoZm4gJiYgbm9kZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGVzW2krK10pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID0gZm4uY2FsbChZX0RPTSwgbm9kZSwgYXJnMSwgYXJnMiwgYXJnMywgZXRjKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgKHJldCkgfHwgKHJldCA9IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHR5cGVvZiByZXQgIT09ICd1bmRlZmluZWQnKSA/IHJldCA6IG5vZGVzO1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZUlEOiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgaWQgPSBlbC5pZDtcblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBpZCA9IFkuc3RhbXAoZWwpO1xuICAgICAgICAgICAgZWwuaWQgPSBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG59O1xuXG5cblkuRE9NID0gWV9ET007XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcIm9vcFwiLCBcImZlYXR1cmVzXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2RvbS1zY3JlZW4nLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4oZnVuY3Rpb24oWSkge1xuXG4vKipcbiAqIEFkZHMgcG9zaXRpb24gYW5kIHJlZ2lvbiBtYW5hZ2VtZW50IGZ1bmN0aW9uYWxpdHkgdG8gRE9NLlxuICogQG1vZHVsZSBkb21cbiAqIEBzdWJtb2R1bGUgZG9tLXNjcmVlblxuICogQGZvciBET01cbiAqL1xuXG52YXIgRE9DVU1FTlRfRUxFTUVOVCA9ICdkb2N1bWVudEVsZW1lbnQnLFxuICAgIENPTVBBVF9NT0RFID0gJ2NvbXBhdE1vZGUnLFxuICAgIFBPU0lUSU9OID0gJ3Bvc2l0aW9uJyxcbiAgICBGSVhFRCA9ICdmaXhlZCcsXG4gICAgUkVMQVRJVkUgPSAncmVsYXRpdmUnLFxuICAgIExFRlQgPSAnbGVmdCcsXG4gICAgVE9QID0gJ3RvcCcsXG4gICAgX0JBQ0tfQ09NUEFUID0gJ0JhY2tDb21wYXQnLFxuICAgIE1FRElVTSA9ICdtZWRpdW0nLFxuICAgIEJPUkRFUl9MRUZUX1dJRFRIID0gJ2JvcmRlckxlZnRXaWR0aCcsXG4gICAgQk9SREVSX1RPUF9XSURUSCA9ICdib3JkZXJUb3BXaWR0aCcsXG4gICAgR0VUX0JPVU5ESU5HX0NMSUVOVF9SRUNUID0gJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCcsXG4gICAgR0VUX0NPTVBVVEVEX1NUWUxFID0gJ2dldENvbXB1dGVkU3R5bGUnLFxuXG4gICAgWV9ET00gPSBZLkRPTSxcblxuICAgIC8vIFRPRE86IGhvdyBhYm91dCB0aGVhZC90Ym9keS90Zm9vdC90cj9cbiAgICAvLyBUT0RPOiBkb2VzIGNhcHRpb24gbWF0dGVyP1xuICAgIFJFX1RBQkxFID0gL150KD86YWJsZXxkfGgpJC9pLFxuXG4gICAgU0NST0xMX05PREU7XG5cbmlmIChZLlVBLmllKSB7XG4gICAgaWYgKFkuY29uZmlnLmRvY1tDT01QQVRfTU9ERV0gIT09ICdCYWNrQ29tcGF0Jykge1xuICAgICAgICBTQ1JPTExfTk9ERSA9IERPQ1VNRU5UX0VMRU1FTlQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgU0NST0xMX05PREUgPSAnYm9keSc7XG4gICAgfVxufVxuXG5ZLm1peChZX0RPTSwge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlubmVyIGhlaWdodCBvZiB0aGUgdmlld3BvcnQgKGV4bHVkZXMgc2Nyb2xsYmFyKS5cbiAgICAgKiBAbWV0aG9kIHdpbkhlaWdodFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgKi9cbiAgICB3aW5IZWlnaHQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGggPSBZX0RPTS5fZ2V0V2luU2l6ZShub2RlKS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbm5lciB3aWR0aCBvZiB0aGUgdmlld3BvcnQgKGV4bHVkZXMgc2Nyb2xsYmFyKS5cbiAgICAgKiBAbWV0aG9kIHdpbldpZHRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCB3aWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgd2luV2lkdGg6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHcgPSBZX0RPTS5fZ2V0V2luU2l6ZShub2RlKS53aWR0aDtcbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERvY3VtZW50IGhlaWdodFxuICAgICAqIEBtZXRob2QgZG9jSGVpZ2h0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGRvY0hlaWdodDogIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGggPSBZX0RPTS5fZ2V0RG9jU2l6ZShub2RlKS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChoLCBZX0RPTS5fZ2V0V2luU2l6ZShub2RlKS5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEb2N1bWVudCB3aWR0aFxuICAgICAqIEBtZXRob2QgZG9jV2lkdGhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBkb2NXaWR0aDogIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHcgPSBZX0RPTS5fZ2V0RG9jU2l6ZShub2RlKS53aWR0aDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHcsIFlfRE9NLl9nZXRXaW5TaXplKG5vZGUpLndpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW1vdW50IHBhZ2UgaGFzIGJlZW4gc2Nyb2xsIGhvcml6b250YWxseVxuICAgICAqIEBtZXRob2QgZG9jU2Nyb2xsWFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgYW1vdW50IHRoZSBzY3JlZW4gaXMgc2Nyb2xsZWQgaG9yaXpvbnRhbGx5LlxuICAgICAqL1xuICAgIGRvY1Njcm9sbFg6IGZ1bmN0aW9uKG5vZGUsIGRvYykge1xuICAgICAgICBkb2MgPSBkb2MgfHwgKG5vZGUpID8gWV9ET00uX2dldERvYyhub2RlKSA6IFkuY29uZmlnLmRvYzsgLy8gcGVyZiBvcHRpbWl6YXRpb25cbiAgICAgICAgdmFyIGR2ID0gZG9jLmRlZmF1bHRWaWV3LFxuICAgICAgICAgICAgcGFnZU9mZnNldCA9IChkdikgPyBkdi5wYWdlWE9mZnNldCA6IDA7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChkb2NbRE9DVU1FTlRfRUxFTUVOVF0uc2Nyb2xsTGVmdCwgZG9jLmJvZHkuc2Nyb2xsTGVmdCwgcGFnZU9mZnNldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFtb3VudCBwYWdlIGhhcyBiZWVuIHNjcm9sbCB2ZXJ0aWNhbGx5XG4gICAgICogQG1ldGhvZCBkb2NTY3JvbGxZXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCBhbW91bnQgdGhlIHNjcmVlbiBpcyBzY3JvbGxlZCB2ZXJ0aWNhbGx5LlxuICAgICAqL1xuICAgIGRvY1Njcm9sbFk6ICBmdW5jdGlvbihub2RlLCBkb2MpIHtcbiAgICAgICAgZG9jID0gZG9jIHx8IChub2RlKSA/IFlfRE9NLl9nZXREb2Mobm9kZSkgOiBZLmNvbmZpZy5kb2M7IC8vIHBlcmYgb3B0aW1pemF0aW9uXG4gICAgICAgIHZhciBkdiA9IGRvYy5kZWZhdWx0VmlldyxcbiAgICAgICAgICAgIHBhZ2VPZmZzZXQgPSAoZHYpID8gZHYucGFnZVlPZmZzZXQgOiAwO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZG9jW0RPQ1VNRU5UX0VMRU1FTlRdLnNjcm9sbFRvcCwgZG9jLmJvZHkuc2Nyb2xsVG9wLCBwYWdlT2Zmc2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IGJhc2VkIG9uIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICogRWxlbWVudCBtdXN0IGJlIHBhcnQgb2YgdGhlIERPTSB0cmVlIHRvIGhhdmUgcGFnZSBjb29yZGluYXRlc1xuICAgICAqIChkaXNwbGF5Om5vbmUgb3IgZWxlbWVudHMgbm90IGFwcGVuZGVkIHJldHVybiBmYWxzZSkuXG4gICAgICogQG1ldGhvZCBnZXRYWVxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgWFkgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRcblxuICAgICBUT0RPOiB0ZXN0IGluRG9jdW1lbnQvZGlzcGxheT9cbiAgICAgKi9cbiAgICBnZXRYWTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChZLmNvbmZpZy5kb2NbRE9DVU1FTlRfRUxFTUVOVF1bR0VUX0JPVU5ESU5HX0NMSUVOVF9SRUNUXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgeHkgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgIGJveCxcbiAgICAgICAgICAgICAgICAgICAgb2ZmWCxcbiAgICAgICAgICAgICAgICAgICAgb2ZmWSxcbiAgICAgICAgICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgICAgICAgICB3aW4sXG4gICAgICAgICAgICAgICAgICAgIGluRG9jLFxuICAgICAgICAgICAgICAgICAgICByb290Tm9kZTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBkb2NbQ09NUEFUX01PREVdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlICE9PSBfQkFDS19DT01QQVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3ROb2RlID0gZG9jW0RPQ1VNRU5UX0VMRU1FTlRdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGUgPSBkb2MuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlubGluZSBpbkRvYyBjaGVjayBmb3IgcGVyZlxuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdE5vZGUuY29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluRG9jID0gcm9vdE5vZGUuY29udGFpbnMobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkRvYyA9IFkuRE9NLmNvbnRhaW5zKHJvb3ROb2RlLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkRvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmxpbmUgc2Nyb2xsIGNhbGMgZm9yIHBlcmZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4gJiYgJ3BhZ2VYT2Zmc2V0JyBpbiB3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IChTQ1JPTExfTk9ERSkgPyBkb2NbU0NST0xMX05PREVdLnNjcm9sbExlZnQgOiBZX0RPTS5kb2NTY3JvbGxYKG5vZGUsIGRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gKFNDUk9MTF9OT0RFKSA/IGRvY1tTQ1JPTExfTk9ERV0uc2Nyb2xsVG9wIDogWV9ET00uZG9jU2Nyb2xsWShub2RlLCBkb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoWS5VQS5pZSkgeyAvLyBJRSA8IDgsIHF1aXJrcywgb3IgY29tcGF0TW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9jLmRvY3VtZW50TW9kZSB8fCBkb2MuZG9jdW1lbnRNb2RlIDwgOCB8fCBtb2RlID09PSBfQkFDS19DT01QQVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmWCA9IHJvb3ROb2RlLmNsaWVudExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZlkgPSByb290Tm9kZS5jbGllbnRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYm94ID0gbm9kZVtHRVRfQk9VTkRJTkdfQ0xJRU5UX1JFQ1RdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4eSA9IFtib3gubGVmdCwgYm94LnRvcF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZYIHx8IG9mZlkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeHlbMF0gLT0gb2ZmWDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeHlbMV0gLT0gb2ZmWTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzY3JvbGxUb3AgfHwgc2Nyb2xsTGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVkuVUEuaW9zIHx8IChZLlVBLmlvcyA+PSA0LjIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh5WzBdICs9IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh5WzFdICs9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHh5ID0gWV9ET00uX2dldE9mZnNldChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geHk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHsgLy8gbWFudWFsbHkgY2FsY3VsYXRlIGJ5IGNyYXdsaW5nIHVwIG9mZnNldFBhcmVudHNcbiAgICAgICAgICAgICAgICAvL0NhbGN1bGF0ZSB0aGUgVG9wIGFuZCBMZWZ0IGJvcmRlciBzaXplcyAoYXNzdW1lcyBwaXhlbHMpXG4gICAgICAgICAgICAgICAgdmFyIHh5ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICBiQ2hlY2ssXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChZX0RPTS5pbkRvYyhub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeHkgPSBbbm9kZS5vZmZzZXRMZWZ0LCBub2RlLm9mZnNldFRvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHdpdGggISEgb3IganVzdCBmYWxzZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJDaGVjayA9ICgoWS5VQS5nZWNrbyB8fCBZLlVBLndlYmtpdCA+IDUxOSkgPyB0cnVlIDogZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3b3J0aCByZWZhY3RvcmluZyBmb3IgVE9QL0xFRlQgb25seT9cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUub2Zmc2V0UGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh5WzBdICs9IHBhcmVudE5vZGUub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4eVsxXSArPSBwYXJlbnROb2RlLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYkNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh5ID0gWV9ET00uX2NhbGNCb3JkZXJzKHBhcmVudE5vZGUsIHh5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIGFueSBzY3JvbGxlZCBhbmNlc3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChZX0RPTS5nZXRTdHlsZShub2RlLCBQT1NJVElPTikgIT0gRklYRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gbm9kZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gcGFyZW50Tm9kZS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgPSBwYXJlbnROb2RlLnNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9GaXJlZm94IGRvZXMgc29tZXRoaW5nIGZ1bmt5IHdpdGggYm9yZGVycyB3aGVuIG92ZXJmbG93IGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoWS5VQS5nZWNrbyAmJiAoWV9ET00uZ2V0U3R5bGUocGFyZW50Tm9kZSwgJ292ZXJmbG93JykgIT09ICd2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4eSA9IFlfRE9NLl9jYWxjQm9yZGVycyhwYXJlbnROb2RlLCB4eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUb3AgfHwgc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeHlbMF0gLT0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh5WzFdIC09IHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4eVswXSArPSBZX0RPTS5kb2NTY3JvbGxYKG5vZGUsIGRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeHlbMV0gKz0gWV9ET00uZG9jU2Nyb2xsWShub2RlLCBkb2MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRml4IEZJWEVEIHBvc2l0aW9uIC0tIGFkZCBzY3JvbGxiYXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeHlbMF0gKz0gWV9ET00uZG9jU2Nyb2xsWChub2RlLCBkb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh5WzFdICs9IFlfRE9NLmRvY1Njcm9sbFkobm9kZSwgZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHh5ID0gWV9ET00uX2dldE9mZnNldChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB4eTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KCksLy8gTk9URTogRXhlY3V0aW5nIGZvciBsb2FkdGltZSBicmFuY2hpbmdcblxuICAgIC8qKlxuICAgIEdldHMgdGhlIHdpZHRoIG9mIHZlcnRpY2FsIHNjcm9sbGJhcnMgb24gb3ZlcmZsb3dlZCBjb250YWluZXJzIGluIHRoZSBib2R5XG4gICAgY29udGVudC5cblxuICAgIEBtZXRob2QgZ2V0U2Nyb2xsYmFyV2lkdGhcbiAgICBAcmV0dXJuIHtOdW1iZXJ9IFBpeGVsIHdpZHRoIG9mIGEgc2Nyb2xsYmFyIGluIHRoZSBjdXJyZW50IGJyb3dzZXJcbiAgICAqKi9cbiAgICBnZXRTY3JvbGxiYXJXaWR0aDogWS5jYWNoZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9jICAgICAgPSBZLmNvbmZpZy5kb2MsXG4gICAgICAgICAgICB0ZXN0Tm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIGJvZHkgICAgID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF0sXG4gICAgICAgICAgICAvLyAwLjEgYmVjYXVzZSBjYWNoZWQgZG9lc24ndCBzdXBwb3J0IGZhbHN5IHJlZmV0Y2ggdmFsdWVzXG4gICAgICAgICAgICB3aWR0aCAgICA9IDAuMTtcblxuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgdGVzdE5vZGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7dmlzaWJpbGl0eTpoaWRkZW47b3ZlcmZsb3c6c2Nyb2xsO3dpZHRoOjIwcHg7XCI7XG4gICAgICAgICAgICB0ZXN0Tm9kZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlRWxlbWVudCgncCcpKS5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgICAgICAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKHRlc3ROb2RlLCBib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgd2lkdGggPSB0ZXN0Tm9kZS5vZmZzZXRXaWR0aCAtIHRlc3ROb2RlLmNsaWVudFdpZHRoO1xuXG4gICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKHRlc3ROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LCBudWxsLCAwLjEpLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBYIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgYmFzZWQgb24gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgKiBFbGVtZW50IG11c3QgYmUgcGFydCBvZiB0aGUgRE9NIHRyZWUgdG8gaGF2ZSBwYWdlIGNvb3JkaW5hdGVzXG4gICAgICogKGRpc3BsYXk6bm9uZSBvciBlbGVtZW50cyBub3QgYXBwZW5kZWQgcmV0dXJuIGZhbHNlKS5cbiAgICAgKiBAbWV0aG9kIGdldFhcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgICovXG5cbiAgICBnZXRYOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiBZX0RPTS5nZXRYWShub2RlKVswXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBZIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgYmFzZWQgb24gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgKiBFbGVtZW50IG11c3QgYmUgcGFydCBvZiB0aGUgRE9NIHRyZWUgdG8gaGF2ZSBwYWdlIGNvb3JkaW5hdGVzXG4gICAgICogKGRpc3BsYXk6bm9uZSBvciBlbGVtZW50cyBub3QgYXBwZW5kZWQgcmV0dXJuIGZhbHNlKS5cbiAgICAgKiBAbWV0aG9kIGdldFlcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgICovXG5cbiAgICBnZXRZOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiBZX0RPTS5nZXRYWShub2RlKVsxXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiBhbiBodG1sIGVsZW1lbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgKiBUaGUgZWxlbWVudCBtdXN0IGJlIHBhcnQgb2YgdGhlIERPTSB0cmVlIHRvIGhhdmUgcGFnZSBjb29yZGluYXRlcyAoZGlzcGxheTpub25lIG9yIGVsZW1lbnRzIG5vdCBhcHBlbmRlZCByZXR1cm4gZmFsc2UpLlxuICAgICAqIEBtZXRob2Qgc2V0WFlcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB4eSBDb250YWlucyBYICYgWSB2YWx1ZXMgZm9yIG5ldyBwb3NpdGlvbiAoY29vcmRpbmF0ZXMgYXJlIHBhZ2UtYmFzZWQpXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBub1JldHJ5IEJ5IGRlZmF1bHQgd2UgdHJ5IGFuZCBzZXQgdGhlIHBvc2l0aW9uIGEgc2Vjb25kIHRpbWUgaWYgdGhlIGZpcnN0IGZhaWxzXG4gICAgICovXG4gICAgc2V0WFk6IGZ1bmN0aW9uKG5vZGUsIHh5LCBub1JldHJ5KSB7XG4gICAgICAgIHZhciBzZXRTdHlsZSA9IFlfRE9NLnNldFN0eWxlLFxuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICBuZXdYWSxcbiAgICAgICAgICAgIGN1cnJlbnRYWTtcblxuICAgICAgICBpZiAobm9kZSAmJiB4eSkge1xuICAgICAgICAgICAgcG9zID0gWV9ET00uZ2V0U3R5bGUobm9kZSwgUE9TSVRJT04pO1xuXG4gICAgICAgICAgICBkZWx0YSA9IFlfRE9NLl9nZXRPZmZzZXQobm9kZSk7XG4gICAgICAgICAgICBpZiAocG9zID09ICdzdGF0aWMnKSB7IC8vIGRlZmF1bHQgdG8gcmVsYXRpdmVcbiAgICAgICAgICAgICAgICBwb3MgPSBSRUxBVElWRTtcbiAgICAgICAgICAgICAgICBzZXRTdHlsZShub2RlLCBQT1NJVElPTiwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRYWSA9IFlfRE9NLmdldFhZKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAoeHlbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXRTdHlsZShub2RlLCBMRUZULCBNYXRoLmZsb29yKHh5WzBdIC0gY3VycmVudFhZWzBdICsgZGVsdGFbMF0pICsgJ3B4Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4eVsxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldFN0eWxlKG5vZGUsIFRPUCwgTWF0aC5mbG9vcih4eVsxXSAtIGN1cnJlbnRYWVsxXSArIGRlbHRhWzFdKSArICdweCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5vUmV0cnkpIHtcbiAgICAgICAgICAgICAgICBuZXdYWSA9IFlfRE9NLmdldFhZKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdYWVswXSAhPT0geHlbMF0gfHwgbmV3WFlbMV0gIT09IHh5WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIFlfRE9NLnNldFhZKG5vZGUsIHh5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIFggcG9zaXRpb24gb2YgYW4gaHRtbCBlbGVtZW50IGluIHBhZ2UgY29vcmRpbmF0ZXMsIHJlZ2FyZGxlc3Mgb2YgaG93IHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWQuXG4gICAgICogVGhlIGVsZW1lbnQocykgbXVzdCBiZSBwYXJ0IG9mIHRoZSBET00gdHJlZSB0byBoYXZlIHBhZ2UgY29vcmRpbmF0ZXMgKGRpc3BsYXk6bm9uZSBvciBlbGVtZW50cyBub3QgYXBwZW5kZWQgcmV0dXJuIGZhbHNlKS5cbiAgICAgKiBAbWV0aG9kIHNldFhcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCB2YWx1ZXMgZm9yIG5ldyBwb3NpdGlvbiAoY29vcmRpbmF0ZXMgYXJlIHBhZ2UtYmFzZWQpXG4gICAgICovXG4gICAgc2V0WDogZnVuY3Rpb24obm9kZSwgeCkge1xuICAgICAgICByZXR1cm4gWV9ET00uc2V0WFkobm9kZSwgW3gsIG51bGxdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBZIHBvc2l0aW9uIG9mIGFuIGh0bWwgZWxlbWVudCBpbiBwYWdlIGNvb3JkaW5hdGVzLCByZWdhcmRsZXNzIG9mIGhvdyB0aGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkLlxuICAgICAqIFRoZSBlbGVtZW50KHMpIG11c3QgYmUgcGFydCBvZiB0aGUgRE9NIHRyZWUgdG8gaGF2ZSBwYWdlIGNvb3JkaW5hdGVzIChkaXNwbGF5Om5vbmUgb3IgZWxlbWVudHMgbm90IGFwcGVuZGVkIHJldHVybiBmYWxzZSkuXG4gICAgICogQG1ldGhvZCBzZXRZXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgdmFsdWVzIGZvciBuZXcgcG9zaXRpb24gKGNvb3JkaW5hdGVzIGFyZSBwYWdlLWJhc2VkKVxuICAgICAqL1xuICAgIHNldFk6IGZ1bmN0aW9uKG5vZGUsIHkpIHtcbiAgICAgICAgcmV0dXJuIFlfRE9NLnNldFhZKG5vZGUsIFtudWxsLCB5XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgc3dhcFhZXG4gICAgICogQGRlc2NyaXB0aW9uIFN3YXAgdGhlIHh5IHBvc2l0aW9uIHdpdGggYW5vdGhlciBub2RlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHN3YXAgd2l0aFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gb3RoZXJOb2RlIFRoZSBvdGhlciBub2RlIHRvIHN3YXAgd2l0aFxuICAgICAqIEByZXR1cm4ge05vZGV9XG4gICAgICovXG4gICAgc3dhcFhZOiBmdW5jdGlvbihub2RlLCBvdGhlck5vZGUpIHtcbiAgICAgICAgdmFyIHh5ID0gWV9ET00uZ2V0WFkobm9kZSk7XG4gICAgICAgIFlfRE9NLnNldFhZKG5vZGUsIFlfRE9NLmdldFhZKG90aGVyTm9kZSkpO1xuICAgICAgICBZX0RPTS5zZXRYWShvdGhlck5vZGUsIHh5KTtcbiAgICB9LFxuXG4gICAgX2NhbGNCb3JkZXJzOiBmdW5jdGlvbihub2RlLCB4eTIpIHtcbiAgICAgICAgdmFyIHQgPSBwYXJzZUludChZX0RPTVtHRVRfQ09NUFVURURfU1RZTEVdKG5vZGUsIEJPUkRFUl9UT1BfV0lEVEgpLCAxMCkgfHwgMCxcbiAgICAgICAgICAgIGwgPSBwYXJzZUludChZX0RPTVtHRVRfQ09NUFVURURfU1RZTEVdKG5vZGUsIEJPUkRFUl9MRUZUX1dJRFRIKSwgMTApIHx8IDA7XG4gICAgICAgIGlmIChZLlVBLmdlY2tvKSB7XG4gICAgICAgICAgICBpZiAoUkVfVEFCTEUudGVzdChub2RlLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdCA9IDA7XG4gICAgICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeHkyWzBdICs9IGw7XG4gICAgICAgIHh5MlsxXSArPSB0O1xuICAgICAgICByZXR1cm4geHkyO1xuICAgIH0sXG5cbiAgICBfZ2V0V2luU2l6ZTogZnVuY3Rpb24obm9kZSwgZG9jKSB7XG4gICAgICAgIGRvYyAgPSBkb2MgfHwgKG5vZGUpID8gWV9ET00uX2dldERvYyhub2RlKSA6IFkuY29uZmlnLmRvYztcbiAgICAgICAgdmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93LFxuICAgICAgICAgICAgbW9kZSA9IGRvY1tDT01QQVRfTU9ERV0sXG4gICAgICAgICAgICBoID0gd2luLmlubmVySGVpZ2h0LFxuICAgICAgICAgICAgdyA9IHdpbi5pbm5lcldpZHRoLFxuICAgICAgICAgICAgcm9vdCA9IGRvY1tET0NVTUVOVF9FTEVNRU5UXTtcblxuICAgICAgICBpZiAoIG1vZGUgJiYgIVkuVUEub3BlcmEgKSB7IC8vIElFLCBHZWNrb1xuICAgICAgICAgICAgaWYgKG1vZGUgIT0gJ0NTUzFDb21wYXQnKSB7IC8vIFF1aXJrc1xuICAgICAgICAgICAgICAgIHJvb3QgPSBkb2MuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggPSByb290LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIHcgPSByb290LmNsaWVudFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGhlaWdodDogaCwgd2lkdGg6IHcgfTtcbiAgICB9LFxuXG4gICAgX2dldERvY1NpemU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGRvYyA9IChub2RlKSA/IFlfRE9NLl9nZXREb2Mobm9kZSkgOiBZLmNvbmZpZy5kb2MsXG4gICAgICAgICAgICByb290ID0gZG9jW0RPQ1VNRU5UX0VMRU1FTlRdO1xuXG4gICAgICAgIGlmIChkb2NbQ09NUEFUX01PREVdICE9ICdDU1MxQ29tcGF0Jykge1xuICAgICAgICAgICAgcm9vdCA9IGRvYy5ib2R5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0OiByb290LnNjcm9sbEhlaWdodCwgd2lkdGg6IHJvb3Quc2Nyb2xsV2lkdGggfTtcbiAgICB9XG59KTtcblxufSkoWSk7XG4oZnVuY3Rpb24oWSkge1xudmFyIFRPUCA9ICd0b3AnLFxuICAgIFJJR0hUID0gJ3JpZ2h0JyxcbiAgICBCT1RUT00gPSAnYm90dG9tJyxcbiAgICBMRUZUID0gJ2xlZnQnLFxuXG4gICAgZ2V0T2Zmc2V0cyA9IGZ1bmN0aW9uKHIxLCByMikge1xuICAgICAgICB2YXIgdCA9IE1hdGgubWF4KHIxW1RPUF0sIHIyW1RPUF0pLFxuICAgICAgICAgICAgciA9IE1hdGgubWluKHIxW1JJR0hUXSwgcjJbUklHSFRdKSxcbiAgICAgICAgICAgIGIgPSBNYXRoLm1pbihyMVtCT1RUT01dLCByMltCT1RUT01dKSxcbiAgICAgICAgICAgIGwgPSBNYXRoLm1heChyMVtMRUZUXSwgcjJbTEVGVF0pLFxuICAgICAgICAgICAgcmV0ID0ge307XG5cbiAgICAgICAgcmV0W1RPUF0gPSB0O1xuICAgICAgICByZXRbUklHSFRdID0gcjtcbiAgICAgICAgcmV0W0JPVFRPTV0gPSBiO1xuICAgICAgICByZXRbTEVGVF0gPSBsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBET00gPSBZLkRPTTtcblxuWS5taXgoRE9NLCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBPYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgYWJvdXQgdGhpcyBlbGVtZW50OiAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KVxuICAgICAqIEBmb3IgRE9NXG4gICAgICogQG1ldGhvZCByZWdpb25cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBET00gZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBhYm91dCB0aGlzIGVsZW1lbnQ6ICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpXG4gICAgICovXG4gICAgcmVnaW9uOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciB4eSA9IERPTS5nZXRYWShub2RlKSxcbiAgICAgICAgICAgIHJldCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChub2RlICYmIHh5KSB7XG4gICAgICAgICAgICByZXQgPSBET00uX2dldFJlZ2lvbihcbiAgICAgICAgICAgICAgICB4eVsxXSwgLy8gdG9wXG4gICAgICAgICAgICAgICAgeHlbMF0gKyBub2RlLm9mZnNldFdpZHRoLCAvLyByaWdodFxuICAgICAgICAgICAgICAgIHh5WzFdICsgbm9kZS5vZmZzZXRIZWlnaHQsIC8vIGJvdHRvbVxuICAgICAgICAgICAgICAgIHh5WzBdIC8vIGxlZnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBpbnRlcnNlY3QgaW5mb3JtYXRpb24gZm9yIHRoZSBwYXNzZWQgbm9kZXMuXG4gICAgICogQG1ldGhvZCBpbnRlcnNlY3RcbiAgICAgKiBAZm9yIERPTVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgT2JqZWN0fSBlbGVtZW50MiBUaGUgZWxlbWVudCBvciByZWdpb24gdG8gY2hlY2sgdGhlIGludGVyZWN0IHdpdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWx0UmVnaW9uIEFuIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgdGhlIHJlZ2lvbiBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBkYXRhIChmb3IgcGVyZm9ybWFuY2UgZS5nLiBEcmFnRHJvcClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBpbnRlcnNlY3Rpb24gZGF0YTogKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgYXJlYSwgeW9mZiwgeG9mZiwgaW5SZWdpb24pXG4gICAgICovXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbihub2RlLCBub2RlMiwgYWx0UmVnaW9uKSB7XG4gICAgICAgIHZhciByID0gYWx0UmVnaW9uIHx8IERPTS5yZWdpb24obm9kZSksIHJlZ2lvbiA9IHt9LFxuICAgICAgICAgICAgbiA9IG5vZGUyLFxuICAgICAgICAgICAgb2ZmO1xuXG4gICAgICAgIGlmIChuLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJlZ2lvbiA9IERPTS5yZWdpb24obik7XG4gICAgICAgIH0gZWxzZSBpZiAoWS5MYW5nLmlzT2JqZWN0KG5vZGUyKSkge1xuICAgICAgICAgICAgcmVnaW9uID0gbm9kZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvZmYgPSBnZXRPZmZzZXRzKHJlZ2lvbiwgcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IG9mZltUT1BdLFxuICAgICAgICAgICAgcmlnaHQ6IG9mZltSSUdIVF0sXG4gICAgICAgICAgICBib3R0b206IG9mZltCT1RUT01dLFxuICAgICAgICAgICAgbGVmdDogb2ZmW0xFRlRdLFxuICAgICAgICAgICAgYXJlYTogKChvZmZbQk9UVE9NXSAtIG9mZltUT1BdKSAqIChvZmZbUklHSFRdIC0gb2ZmW0xFRlRdKSksXG4gICAgICAgICAgICB5b2ZmOiAoKG9mZltCT1RUT01dIC0gb2ZmW1RPUF0pKSxcbiAgICAgICAgICAgIHhvZmY6IChvZmZbUklHSFRdIC0gb2ZmW0xFRlRdKSxcbiAgICAgICAgICAgIGluUmVnaW9uOiBET00uaW5SZWdpb24obm9kZSwgbm9kZTIsIGZhbHNlLCBhbHRSZWdpb24pXG4gICAgICAgIH07XG5cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFueSBwYXJ0IG9mIHRoaXMgbm9kZSBpcyBpbiB0aGUgcGFzc2VkIHJlZ2lvblxuICAgICAqIEBtZXRob2QgaW5SZWdpb25cbiAgICAgKiBAZm9yIERPTVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIFRoZSBub2RlIHRvIGdldCB0aGUgcmVnaW9uIGZyb21cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZTIgVGhlIHNlY29uZCBub2RlIHRvIGdldCB0aGUgcmVnaW9uIGZyb20gb3IgYW4gT2JqZWN0IGxpdGVyYWwgb2YgdGhlIHJlZ2lvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsIFNob3VsZCBhbGwgb2YgdGhlIG5vZGUgYmUgaW5zaWRlIHRoZSByZWdpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWx0UmVnaW9uIEFuIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgdGhlIHJlZ2lvbiBmb3IgdGhpcyBub2RlIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGUgZGF0YSAoZm9yIHBlcmZvcm1hbmNlIGUuZy4gRHJhZ0Ryb3ApXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBpbiByZWdpb24sIGZhbHNlIGlmIG5vdC5cbiAgICAgKi9cbiAgICBpblJlZ2lvbjogZnVuY3Rpb24obm9kZSwgbm9kZTIsIGFsbCwgYWx0UmVnaW9uKSB7XG4gICAgICAgIHZhciByZWdpb24gPSB7fSxcbiAgICAgICAgICAgIHIgPSBhbHRSZWdpb24gfHwgRE9NLnJlZ2lvbihub2RlKSxcbiAgICAgICAgICAgIG4gPSBub2RlMixcbiAgICAgICAgICAgIG9mZjtcblxuICAgICAgICBpZiAobi50YWdOYW1lKSB7XG4gICAgICAgICAgICByZWdpb24gPSBET00ucmVnaW9uKG4pO1xuICAgICAgICB9IGVsc2UgaWYgKFkuTGFuZy5pc09iamVjdChub2RlMikpIHtcbiAgICAgICAgICAgIHJlZ2lvbiA9IG5vZGUyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICByW0xFRlRdICAgPj0gcmVnaW9uW0xFRlRdICAgJiZcbiAgICAgICAgICAgICAgICByW1JJR0hUXSAgPD0gcmVnaW9uW1JJR0hUXSAgJiZcbiAgICAgICAgICAgICAgICByW1RPUF0gICAgPj0gcmVnaW9uW1RPUF0gICAgJiZcbiAgICAgICAgICAgICAgICByW0JPVFRPTV0gPD0gcmVnaW9uW0JPVFRPTV0gICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmYgPSBnZXRPZmZzZXRzKHJlZ2lvbiwgcik7XG4gICAgICAgICAgICBpZiAob2ZmW0JPVFRPTV0gPj0gb2ZmW1RPUF0gJiYgb2ZmW1JJR0hUXSA+PSBvZmZbTEVGVF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW55IHBhcnQgb2YgdGhpcyBlbGVtZW50IGlzIGluIHRoZSB2aWV3cG9ydFxuICAgICAqIEBtZXRob2QgaW5WaWV3cG9ydFJlZ2lvblxuICAgICAqIEBmb3IgRE9NXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgRE9NIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbGwgU2hvdWxkIGFsbCBvZiB0aGUgbm9kZSBiZSBpbnNpZGUgdGhlIHJlZ2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbHRSZWdpb24gQW4gb2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyB0aGUgcmVnaW9uIGZvciB0aGlzIG5vZGUgaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBkYXRhIChmb3IgcGVyZm9ybWFuY2UgZS5nLiBEcmFnRHJvcClcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGluIHJlZ2lvbiwgZmFsc2UgaWYgbm90LlxuICAgICAqL1xuICAgIGluVmlld3BvcnRSZWdpb246IGZ1bmN0aW9uKG5vZGUsIGFsbCwgYWx0UmVnaW9uKSB7XG4gICAgICAgIHJldHVybiBET00uaW5SZWdpb24obm9kZSwgRE9NLnZpZXdwb3J0UmVnaW9uKG5vZGUpLCBhbGwsIGFsdFJlZ2lvbik7XG5cbiAgICB9LFxuXG4gICAgX2dldFJlZ2lvbjogZnVuY3Rpb24odCwgciwgYiwgbCkge1xuICAgICAgICB2YXIgcmVnaW9uID0ge307XG5cbiAgICAgICAgcmVnaW9uW1RPUF0gPSByZWdpb25bMV0gPSB0O1xuICAgICAgICByZWdpb25bTEVGVF0gPSByZWdpb25bMF0gPSBsO1xuICAgICAgICByZWdpb25bQk9UVE9NXSA9IGI7XG4gICAgICAgIHJlZ2lvbltSSUdIVF0gPSByO1xuICAgICAgICByZWdpb24ud2lkdGggPSByZWdpb25bUklHSFRdIC0gcmVnaW9uW0xFRlRdO1xuICAgICAgICByZWdpb24uaGVpZ2h0ID0gcmVnaW9uW0JPVFRPTV0gLSByZWdpb25bVE9QXTtcblxuICAgICAgICByZXR1cm4gcmVnaW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIE9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBhYm91dCB0aGUgdmlzaWJsZSByZWdpb24gb2Ygdmlld3BvcnQ6ICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpXG4gICAgICogQG1ldGhvZCB2aWV3cG9ydFJlZ2lvblxuICAgICAqIEBmb3IgRE9NXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgYWJvdXQgdGhlIHZpc2libGUgcmVnaW9uIG9mIHRoZSB2aWV3cG9ydDogKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdClcbiAgICAgKi9cbiAgICB2aWV3cG9ydFJlZ2lvbjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlID0gbm9kZSB8fCBZLmNvbmZpZy5kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB2YXIgcmV0ID0gZmFsc2UsXG4gICAgICAgICAgICBzY3JvbGxYLFxuICAgICAgICAgICAgc2Nyb2xsWTtcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgc2Nyb2xsWCA9IERPTS5kb2NTY3JvbGxYKG5vZGUpO1xuICAgICAgICAgICAgc2Nyb2xsWSA9IERPTS5kb2NTY3JvbGxZKG5vZGUpO1xuXG4gICAgICAgICAgICByZXQgPSBET00uX2dldFJlZ2lvbihzY3JvbGxZLCAvLyB0b3BcbiAgICAgICAgICAgICAgICBET00ud2luV2lkdGgobm9kZSkgKyBzY3JvbGxYLCAvLyByaWdodFxuICAgICAgICAgICAgICAgIHNjcm9sbFkgKyBET00ud2luSGVpZ2h0KG5vZGUpLCAvLyBib3R0b21cbiAgICAgICAgICAgICAgICBzY3JvbGxYKTsgLy8gbGVmdFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59KTtcbn0pKFkpO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJkb20tYmFzZVwiLCBcImRvbS1zdHlsZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdkb20tc3R5bGUtaWUnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG52YXIgSEFTX0xBWU9VVCA9ICdoYXNMYXlvdXQnLFxuICAgIFBYID0gJ3B4JyxcbiAgICBGSUxURVIgPSAnZmlsdGVyJyxcbiAgICBGSUxURVJTID0gJ2ZpbHRlcnMnLFxuICAgIE9QQUNJVFkgPSAnb3BhY2l0eScsXG4gICAgQVVUTyA9ICdhdXRvJyxcblxuICAgIEJPUkRFUl9XSURUSCA9ICdib3JkZXJXaWR0aCcsXG4gICAgQk9SREVSX1RPUF9XSURUSCA9ICdib3JkZXJUb3BXaWR0aCcsXG4gICAgQk9SREVSX1JJR0hUX1dJRFRIID0gJ2JvcmRlclJpZ2h0V2lkdGgnLFxuICAgIEJPUkRFUl9CT1RUT01fV0lEVEggPSAnYm9yZGVyQm90dG9tV2lkdGgnLFxuICAgIEJPUkRFUl9MRUZUX1dJRFRIID0gJ2JvcmRlckxlZnRXaWR0aCcsXG4gICAgV0lEVEggPSAnd2lkdGgnLFxuICAgIEhFSUdIVCA9ICdoZWlnaHQnLFxuICAgIFRSQU5TUEFSRU5UID0gJ3RyYW5zcGFyZW50JyxcbiAgICBWSVNJQkxFID0gJ3Zpc2libGUnLFxuICAgIEdFVF9DT01QVVRFRF9TVFlMRSA9ICdnZXRDb21wdXRlZFN0eWxlJyxcbiAgICBkb2N1bWVudEVsZW1lbnQgPSBZLmNvbmZpZy5kb2MuZG9jdW1lbnRFbGVtZW50LFxuXG4gICAgdGVzdEZlYXR1cmUgPSBZLkZlYXR1cmVzLnRlc3QsXG4gICAgYWRkRmVhdHVyZSA9IFkuRmVhdHVyZXMuYWRkLFxuXG4gICAgLy8gVE9ETzogdW5pdC1sZXNzIGxpbmVIZWlnaHQgKGUuZy4gMS4yMilcbiAgICByZV91bml0ID0gL14oXFxkWy5cXGRdKikrKGVtfGV4fHB4fGdkfHJlbXx2d3x2aHx2bXxjaHxtbXxjbXxpbnxwdHxwY3xkZWd8cmFkfG1zfHN8aHp8a2h6fCUpezF9Py9pLFxuXG4gICAgaXNJRTggPSAoWS5VQS5pZSA+PSA4KSxcblxuICAgIF9nZXRTdHlsZU9iaiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY3VycmVudFN0eWxlIHx8IG5vZGUuc3R5bGU7XG4gICAgfSxcblxuICAgIENvbXB1dGVkU3R5bGUgPSB7XG4gICAgICAgIENVU1RPTV9TVFlMRVM6IHt9LFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oZWwsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAnJyxcbiAgICAgICAgICAgICAgICBjdXJyZW50O1xuXG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IF9nZXRTdHlsZU9iaihlbClbcHJvcGVydHldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSBPUEFDSVRZICYmIFkuRE9NLkNVU1RPTV9TVFlMRVNbT1BBQ0lUWV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBZLkRPTS5DVVNUT01fU1RZTEVTW09QQUNJVFldLmdldChlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghY3VycmVudCB8fCAoY3VycmVudC5pbmRleE9mICYmIGN1cnJlbnQuaW5kZXhPZihQWCkgPiAtMSkpIHsgLy8gbm8gbmVlZCB0byBjb252ZXJ0XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFkuRE9NLklFLkNPTVBVVEVEW3Byb3BlcnR5XSkgeyAvLyB1c2UgY29tcHV0ZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFkuRE9NLklFLkNPTVBVVEVEW3Byb3BlcnR5XShlbCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVfdW5pdC50ZXN0KGN1cnJlbnQpKSB7IC8vIGNvbnZlcnQgdG8gcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBDb21wdXRlZFN0eWxlLmdldFBpeGVsKGVsLCBwcm9wZXJ0eSkgKyBQWDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2l6ZU9mZnNldHM6IHtcbiAgICAgICAgICAgIHdpZHRoOiBbJ0xlZnQnLCAnUmlnaHQnXSxcbiAgICAgICAgICAgIGhlaWdodDogWydUb3AnLCAnQm90dG9tJ10sXG4gICAgICAgICAgICB0b3A6IFsnVG9wJ10sXG4gICAgICAgICAgICBib3R0b206IFsnQm90dG9tJ11cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRPZmZzZXQ6IGZ1bmN0aW9uKGVsLCBwcm9wKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IF9nZXRTdHlsZU9iaihlbClbcHJvcF0sICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgb2YgXCJ3aWR0aFwiLCBcInRvcFwiLCBldGMuXG4gICAgICAgICAgICAgICAgY2FwcGVkID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc3Vic3RyKDEpLCAvLyBcIldpZHRoXCIsIFwiVG9wXCIsIGV0Yy5cbiAgICAgICAgICAgICAgICBwaXhlbCA9ICdwaXhlbCcgKyBjYXBwZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwicGl4ZWxXaWR0aFwiLCBcInBpeGVsVG9wXCIsIGV0Yy5cbiAgICAgICAgICAgICAgICBzaXplT2Zmc2V0cyA9IENvbXB1dGVkU3R5bGUuc2l6ZU9mZnNldHNbcHJvcF0sXG4gICAgICAgICAgICAgICAgbW9kZSA9IGVsLm93bmVyRG9jdW1lbnQuY29tcGF0TW9kZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuXG4gICAgICAgICAgICAvLyBJRSBwaXhlbFdpZHRoIGluY29ycmVjdCBmb3IgcGVyY2VudFxuICAgICAgICAgICAgLy8gbWFudWFsbHkgY29tcHV0ZSBieSBzdWJ0cmFjdGluZyBwYWRkaW5nIGFuZCBib3JkZXIgZnJvbSBvZmZzZXQgc2l6ZVxuICAgICAgICAgICAgLy8gTk9URTogY2xpZW50V2lkdGgvSGVpZ2h0IChzaXplIG1pbnVzIGJvcmRlcikgaXMgMCB3aGVuIGN1cnJlbnQgPT09IEFVVE8gc28gb2Zmc2V0SGVpZ2h0IGlzIHVzZWRcbiAgICAgICAgICAgIC8vIHJldmVydGluZyB0byBhdXRvIGZyb20gYXV0byBjYXVzZXMgcG9zaXRpb24gc3RhY2tpbmcgaXNzdWVzIChvbGQgaW1wbClcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBBVVRPIHx8IGN1cnJlbnQuaW5kZXhPZignJScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsWydvZmZzZXQnICsgY2FwcGVkXTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2RlICE9PSAnQmFja0NvbXBhdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVPZmZzZXRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAtPSBDb21wdXRlZFN0eWxlLmdldFBpeGVsKGVsLCAncGFkZGluZycgKyBzaXplT2Zmc2V0c1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAtPSBDb21wdXRlZFN0eWxlLmdldEJvcmRlcldpZHRoKGVsLCAnYm9yZGVyJyArIHNpemVPZmZzZXRzWzBdICsgJ1dpZHRoJywgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZU9mZnNldHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIC09IENvbXB1dGVkU3R5bGUuZ2V0UGl4ZWwoZWwsICdwYWRkaW5nJyArIHNpemVPZmZzZXRzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIC09IENvbXB1dGVkU3R5bGUuZ2V0Qm9yZGVyV2lkdGgoZWwsICdib3JkZXInICsgc2l6ZU9mZnNldHNbMV0gKyAnV2lkdGgnLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXNlIHN0eWxlLnBpeGVsV2lkdGgsIGV0Yy4gdG8gY29udmVydCB0byBwaXhlbHNcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIG1hcCBzdHlsZS53aWR0aCB0byBjdXJyZW50U3R5bGUgKG5vIGN1cnJlbnRTdHlsZS5waXhlbFdpZHRoKVxuICAgICAgICAgICAgICAgIGlmICghZWwuc3R5bGVbcGl4ZWxdICYmICFlbC5zdHlsZVtwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZVtwcm9wXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZWwuc3R5bGVbcGl4ZWxdO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKyBQWDtcbiAgICAgICAgfSxcblxuICAgICAgICBib3JkZXJNYXA6IHtcbiAgICAgICAgICAgIHRoaW46IChpc0lFOCkgPyAnMXB4JyA6ICcycHgnLFxuICAgICAgICAgICAgbWVkaXVtOiAoaXNJRTgpID8gJzNweCc6ICc0cHgnLFxuICAgICAgICAgICAgdGhpY2s6IChpc0lFOCkgPyAnNXB4JyA6ICc2cHgnXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Qm9yZGVyV2lkdGg6IGZ1bmN0aW9uKGVsLCBwcm9wZXJ0eSwgb21pdFVuaXQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZWwuY3VycmVudFN0eWxlW3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnQuaW5kZXhPZihQWCkgPCAwKSB7IC8vIGxvb2sgdXAga2V5d29yZHMgaWYgYSBib3JkZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKENvbXB1dGVkU3R5bGUuYm9yZGVyTWFwW2N1cnJlbnRdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5jdXJyZW50U3R5bGUuYm9yZGVyU3R5bGUgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gQ29tcHV0ZWRTdHlsZS5ib3JkZXJNYXBbY3VycmVudF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIG5vIGJvcmRlciAoZGVmYXVsdCBpcyBcIm1lZGl1bVwiKVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKG9taXRVbml0KSA/IHBhcnNlRmxvYXQoY3VycmVudCkgOiBjdXJyZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFBpeGVsOiBmdW5jdGlvbihub2RlLCBhdHQpIHtcbiAgICAgICAgICAgIC8vIHVzZSBwaXhlbFJpZ2h0IHRvIGNvbnZlcnQgdG8gcHhcbiAgICAgICAgICAgIHZhciB2YWwgPSBudWxsLFxuICAgICAgICAgICAgICAgIHN0eWxlID0gX2dldFN0eWxlT2JqKG5vZGUpLFxuICAgICAgICAgICAgICAgIHN0eWxlUmlnaHQgPSBzdHlsZS5yaWdodCxcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gc3R5bGVbYXR0XTtcblxuICAgICAgICAgICAgbm9kZS5zdHlsZS5yaWdodCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB2YWwgPSBub2RlLnN0eWxlLnBpeGVsUmlnaHQ7XG4gICAgICAgICAgICBub2RlLnN0eWxlLnJpZ2h0ID0gc3R5bGVSaWdodDsgLy8gcmV2ZXJ0XG5cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TWFyZ2luOiBmdW5jdGlvbihub2RlLCBhdHQpIHtcbiAgICAgICAgICAgIHZhciB2YWwsXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBfZ2V0U3R5bGVPYmoobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZVthdHRdID09PSBBVVRPKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gQ29tcHV0ZWRTdHlsZS5nZXRQaXhlbChub2RlLCBhdHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbCArIFBYO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFZpc2liaWxpdHk6IGZ1bmN0aW9uKG5vZGUsIGF0dCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAoIChjdXJyZW50ID0gbm9kZS5jdXJyZW50U3R5bGUpICYmIGN1cnJlbnRbYXR0XSA9PT0gJ2luaGVyaXQnKSB7IC8vIE5PVEU6IGFzc2lnbm1lbnQgaW4gdGVzdFxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGN1cnJlbnQpID8gY3VycmVudFthdHRdIDogVklTSUJMRTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb2xvcjogZnVuY3Rpb24obm9kZSwgYXR0KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IF9nZXRTdHlsZU9iaihub2RlKVthdHRdO1xuXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQgfHwgY3VycmVudCA9PT0gVFJBTlNQQVJFTlQpIHtcbiAgICAgICAgICAgICAgICBZLkRPTS5lbGVtZW50QnlBeGlzKG5vZGUsICdwYXJlbnROb2RlJywgbnVsbCwgZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBfZ2V0U3R5bGVPYmoocGFyZW50KVthdHRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBUUkFOU1BBUkVOVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBZLkNvbG9yLnRvUkdCKGN1cnJlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvcmRlckNvbG9yOiBmdW5jdGlvbihub2RlLCBhdHQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gX2dldFN0eWxlT2JqKG5vZGUpLFxuICAgICAgICAgICAgICAgIHZhbCA9IGN1cnJlbnRbYXR0XSB8fCBjdXJyZW50LmNvbG9yO1xuICAgICAgICAgICAgcmV0dXJuIFkuQ29sb3IudG9SR0IoWS5Db2xvci50b0hleCh2YWwpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvL2ZvbnRTaXplOiBnZXRQaXhlbEZvbnQsXG4gICAgSUVDb21wdXRlZCA9IHt9O1xuXG5hZGRGZWF0dXJlKCdzdHlsZScsICdjb21wdXRlZFN0eWxlJywge1xuICAgIHRlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ2dldENvbXB1dGVkU3R5bGUnIGluIFkuY29uZmlnLndpbjtcbiAgICB9XG59KTtcblxuYWRkRmVhdHVyZSgnc3R5bGUnLCAnb3BhY2l0eScsIHtcbiAgICB0ZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdvcGFjaXR5JyBpbiBkb2N1bWVudEVsZW1lbnQuc3R5bGU7XG4gICAgfVxufSk7XG5cbmFkZEZlYXR1cmUoJ3N0eWxlJywgJ2ZpbHRlcicsIHtcbiAgICB0ZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdmaWx0ZXJzJyBpbiBkb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxufSk7XG5cbi8vIHVzZSBhbHBoYSBmaWx0ZXIgZm9yIElFIG9wYWNpdHlcbmlmICghdGVzdEZlYXR1cmUoJ3N0eWxlJywgJ29wYWNpdHknKSAmJiB0ZXN0RmVhdHVyZSgnc3R5bGUnLCAnZmlsdGVyJykpIHtcbiAgICBZLkRPTS5DVVNUT01fU1RZTEVTW09QQUNJVFldID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSAxMDA7XG4gICAgICAgICAgICB0cnkgeyAvLyB3aWxsIGVycm9yIGlmIG5vIERYSW1hZ2VUcmFuc2Zvcm1cbiAgICAgICAgICAgICAgICB2YWwgPSBub2RlW0ZJTFRFUlNdWydEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSddW09QQUNJVFldO1xuXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICB0cnkgeyAvLyBtYWtlIHN1cmUgaXRzIGluIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBub2RlW0ZJTFRFUlNdKCdhbHBoYScpW09QQUNJVFldO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbCAvIDEwMDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbCwgc3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlT2JqID0gX2dldFN0eWxlT2JqKG5vZGUpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWx0ZXIgPSBzdHlsZU9ialtGSUxURVJdO1xuXG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IG5vZGUuc3R5bGU7XG4gICAgICAgICAgICBpZiAodmFsID09PSAnJykgeyAvLyBub3JtYWxpemUgaW5saW5lIHN0eWxlIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IChPUEFDSVRZIGluIHN0eWxlT2JqKSA/IHN0eWxlT2JqW09QQUNJVFldIDogMTsgLy8gcmV2ZXJ0IHRvIG9yaWdpbmFsIG9wYWNpdHlcbiAgICAgICAgICAgICAgICB2YWwgPSBjdXJyZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRGaWx0ZXIgPT09ICdzdHJpbmcnKSB7IC8vIGluIGNhc2Ugbm90IGFwcGVuZGVkXG4gICAgICAgICAgICAgICAgc3R5bGVbRklMVEVSXSA9IGN1cnJlbnRGaWx0ZXIucmVwbGFjZSgvYWxwaGEoW14pXSpcXCkpL2dpLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCh2YWwgPD0gMSkgPyAnYWxwaGEoJyArIE9QQUNJVFkgKyAnPScgKyB2YWwgKiAxMDAgKyAnKScgOiAnJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlW0ZJTFRFUl0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKEZJTFRFUik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZU9ialtIQVNfTEFZT1VUXSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS56b29tID0gMTsgLy8gbmVlZHMgbGF5b3V0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cblxudHJ5IHtcbiAgICBZLmNvbmZpZy5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGUuaGVpZ2h0ID0gJy0xcHgnO1xufSBjYXRjaChlKSB7IC8vIElFIHRocm93cyBlcnJvciBvbiBpbnZhbGlkIHN0eWxlIHNldDsgdHJhcCBjb21tb24gY2FzZXNcbiAgICBZLkRPTS5DVVNUT01fU1RZTEVTLmhlaWdodCA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWwsIHN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgZmxvYXRWYWwgPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgICAgICBpZiAoZmxvYXRWYWwgPj0gMCB8fCB2YWwgPT09ICdhdXRvJyB8fCB2YWwgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gdmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBZLkRPTS5DVVNUT01fU1RZTEVTLndpZHRoID0ge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbCwgc3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBmbG9hdFZhbCA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgICAgIGlmIChmbG9hdFZhbCA+PSAwIHx8IHZhbCA9PT0gJ2F1dG8nIHx8IHZhbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5pZiAoIXRlc3RGZWF0dXJlKCdzdHlsZScsICdjb21wdXRlZFN0eWxlJykpIHtcbiAgICAvLyBUT0RPOiB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcbiAgICBJRUNvbXB1dGVkW1dJRFRIXSA9IElFQ29tcHV0ZWRbSEVJR0hUXSA9IENvbXB1dGVkU3R5bGUuZ2V0T2Zmc2V0O1xuXG4gICAgSUVDb21wdXRlZC5jb2xvciA9IElFQ29tcHV0ZWQuYmFja2dyb3VuZENvbG9yID0gQ29tcHV0ZWRTdHlsZS5nZXRDb2xvcjtcblxuICAgIElFQ29tcHV0ZWRbQk9SREVSX1dJRFRIXSA9IElFQ29tcHV0ZWRbQk9SREVSX1RPUF9XSURUSF0gPSBJRUNvbXB1dGVkW0JPUkRFUl9SSUdIVF9XSURUSF0gPVxuICAgICAgICAgICAgSUVDb21wdXRlZFtCT1JERVJfQk9UVE9NX1dJRFRIXSA9IElFQ29tcHV0ZWRbQk9SREVSX0xFRlRfV0lEVEhdID1cbiAgICAgICAgICAgIENvbXB1dGVkU3R5bGUuZ2V0Qm9yZGVyV2lkdGg7XG5cbiAgICBJRUNvbXB1dGVkLm1hcmdpblRvcCA9IElFQ29tcHV0ZWQubWFyZ2luUmlnaHQgPSBJRUNvbXB1dGVkLm1hcmdpbkJvdHRvbSA9XG4gICAgICAgICAgICBJRUNvbXB1dGVkLm1hcmdpbkxlZnQgPSBDb21wdXRlZFN0eWxlLmdldE1hcmdpbjtcblxuICAgIElFQ29tcHV0ZWQudmlzaWJpbGl0eSA9IENvbXB1dGVkU3R5bGUuZ2V0VmlzaWJpbGl0eTtcbiAgICBJRUNvbXB1dGVkLmJvcmRlckNvbG9yID0gSUVDb21wdXRlZC5ib3JkZXJUb3BDb2xvciA9XG4gICAgICAgICAgICBJRUNvbXB1dGVkLmJvcmRlclJpZ2h0Q29sb3IgPSBJRUNvbXB1dGVkLmJvcmRlckJvdHRvbUNvbG9yID1cbiAgICAgICAgICAgIElFQ29tcHV0ZWQuYm9yZGVyTGVmdENvbG9yID0gQ29tcHV0ZWRTdHlsZS5nZXRCb3JkZXJDb2xvcjtcblxuICAgIFkuRE9NW0dFVF9DT01QVVRFRF9TVFlMRV0gPSBDb21wdXRlZFN0eWxlLmdldDtcblxuICAgIFkubmFtZXNwYWNlKCdET00uSUUnKTtcbiAgICBZLkRPTS5JRS5DT01QVVRFRCA9IElFQ29tcHV0ZWQ7XG4gICAgWS5ET00uSUUuQ29tcHV0ZWRTdHlsZSA9IENvbXB1dGVkU3R5bGU7XG59XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImRvbS1zdHlsZVwiLCBcImNvbG9yLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnZG9tLXN0eWxlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBBZGQgc3R5bGUgbWFuYWdlbWVudCBmdW5jdGlvbmFsaXR5IHRvIERPTS5cbiAqIEBtb2R1bGUgZG9tXG4gKiBAc3VibW9kdWxlIGRvbS1zdHlsZVxuICogQGZvciBET01cbiAqL1xuXG52YXIgRE9DVU1FTlRfRUxFTUVOVCA9ICdkb2N1bWVudEVsZW1lbnQnLFxuICAgIERFRkFVTFRfVklFVyA9ICdkZWZhdWx0VmlldycsXG4gICAgT1dORVJfRE9DVU1FTlQgPSAnb3duZXJEb2N1bWVudCcsXG4gICAgU1RZTEUgPSAnc3R5bGUnLFxuICAgIEZMT0FUID0gJ2Zsb2F0JyxcbiAgICBDU1NfRkxPQVQgPSAnY3NzRmxvYXQnLFxuICAgIFNUWUxFX0ZMT0FUID0gJ3N0eWxlRmxvYXQnLFxuICAgIFRSQU5TUEFSRU5UID0gJ3RyYW5zcGFyZW50JyxcbiAgICBHRVRfQ09NUFVURURfU1RZTEUgPSAnZ2V0Q29tcHV0ZWRTdHlsZScsXG4gICAgR0VUX0JPVU5ESU5HX0NMSUVOVF9SRUNUID0gJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCcsXG5cbiAgICBET0NVTUVOVCA9IFkuY29uZmlnLmRvYyxcblxuICAgIFlfRE9NID0gWS5ET00sXG5cbiAgICBUUkFOU0ZPUk0sXG4gICAgVFJBTlNGT1JNT1JJR0lOLFxuICAgIFZFTkRPUl9UUkFOU0ZPUk0gPSBbXG4gICAgICAgICdXZWJraXRUcmFuc2Zvcm0nLFxuICAgICAgICAnTW96VHJhbnNmb3JtJyxcbiAgICAgICAgJ09UcmFuc2Zvcm0nLFxuICAgICAgICAnbXNUcmFuc2Zvcm0nLFxuICAgICAgICAndHJhbnNmb3JtJ1xuICAgIF0sXG5cbiAgICByZV91bml0ID0gL3dpZHRofGhlaWdodHx0b3B8bGVmdHxyaWdodHxib3R0b218bWFyZ2lufHBhZGRpbmcvaTtcblxuWS5BcnJheS5lYWNoKFZFTkRPUl9UUkFOU0ZPUk0sIGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmICh2YWwgaW4gRE9DVU1FTlRbRE9DVU1FTlRfRUxFTUVOVF0uc3R5bGUpIHtcbiAgICAgICAgVFJBTlNGT1JNID0gdmFsO1xuICAgICAgICBUUkFOU0ZPUk1PUklHSU4gPSB2YWwgKyBcIk9yaWdpblwiO1xuICAgIH1cbn0pO1xuXG5ZLm1peChZX0RPTSwge1xuICAgIERFRkFVTFRfVU5JVDogJ3B4JyxcblxuICAgIENVU1RPTV9TVFlMRVM6IHtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBAbWV0aG9kIHNldFN0eWxlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBUaGUgSFRNTEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHQgVGhlIHN0eWxlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbCBUaGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZV0gVGhlIHN0eWxlIG5vZGUuIERlZmF1bHRzIHRvIGBub2RlLnN0eWxlYC5cbiAgICAgKi9cbiAgICBzZXRTdHlsZTogZnVuY3Rpb24obm9kZSwgYXR0LCB2YWwsIHN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gc3R5bGUgfHwgbm9kZS5zdHlsZTtcbiAgICAgICAgdmFyIENVU1RPTV9TVFlMRVMgPSBZX0RPTS5DVVNUT01fU1RZTEVTO1xuXG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09ICcnKSB7IC8vIG5vcm1hbGl6ZSB1bnNldHRpbmdcbiAgICAgICAgICAgICAgICB2YWwgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKE51bWJlcih2YWwpKSAmJiByZV91bml0LnRlc3QoYXR0KSkgeyAvLyBudW1iZXIgdmFsdWVzIG1heSBuZWVkIGEgdW5pdFxuICAgICAgICAgICAgICAgIHZhbCArPSBZX0RPTS5ERUZBVUxUX1VOSVQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdHQgaW4gQ1VTVE9NX1NUWUxFUykge1xuICAgICAgICAgICAgICAgIGlmIChDVVNUT01fU1RZTEVTW2F0dF0uc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIENVU1RPTV9TVFlMRVNbYXR0XS5zZXQobm9kZSwgdmFsLCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gTk9URTogcmV0dXJuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQ1VTVE9NX1NUWUxFU1thdHRdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhdHQgPSBDVVNUT01fU1RZTEVTW2F0dF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhdHQgPT09ICcnKSB7IC8vIHVuc2V0IGlubGluZSBzdHlsZXNcbiAgICAgICAgICAgICAgICBhdHQgPSAnY3NzVGV4dCc7XG4gICAgICAgICAgICAgICAgdmFsID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVthdHRdID0gdmFsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3R5bGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAbWV0aG9kIGdldFN0eWxlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBUaGUgSFRNTEVsZW1lbnQgdG8gZ2V0IHRoZSBzdHlsZSBmcm9tLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHQgVGhlIHN0eWxlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlXSBUaGUgc3R5bGUgbm9kZS4gRGVmYXVsdHMgdG8gYG5vZGUuc3R5bGVgLlxuICAgICAqL1xuICAgIGdldFN0eWxlOiBmdW5jdGlvbihub2RlLCBhdHQsIHN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gc3R5bGUgfHwgbm9kZS5zdHlsZTtcbiAgICAgICAgdmFyIENVU1RPTV9TVFlMRVMgPSBZX0RPTS5DVVNUT01fU1RZTEVTLFxuICAgICAgICAgICAgdmFsID0gJyc7XG5cbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICBpZiAoYXR0IGluIENVU1RPTV9TVFlMRVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoQ1VTVE9NX1NUWUxFU1thdHRdLmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ1VTVE9NX1NUWUxFU1thdHRdLmdldChub2RlLCBhdHQsIHN0eWxlKTsgLy8gTk9URTogcmV0dXJuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQ1VTVE9NX1NUWUxFU1thdHRdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhdHQgPSBDVVNUT01fU1RZTEVTW2F0dF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsID0gc3R5bGVbYXR0XTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09ICcnKSB7IC8vIFRPRE86IGlzIGVtcHR5IHN0cmluZyBzdWZmaWNpZW50P1xuICAgICAgICAgICAgICAgIHZhbCA9IFlfRE9NW0dFVF9DT01QVVRFRF9TVFlMRV0obm9kZSwgYXR0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgbXVsdGlwbGUgc3R5bGUgcHJvcGVydGllcy5cbiAgICAgKiBAbWV0aG9kIHNldFN0eWxlc1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgVGhlIEhUTUxFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZXMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggQW4gb2JqZWN0IGxpdGVyYWwgb2YgcHJvcGVydHk6dmFsdWUgcGFpcnMuXG4gICAgICovXG4gICAgc2V0U3R5bGVzOiBmdW5jdGlvbihub2RlLCBoYXNoKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgICAgIFkuZWFjaChoYXNoLCBmdW5jdGlvbih2LCBuKSB7XG4gICAgICAgICAgICBZX0RPTS5zZXRTdHlsZShub2RlLCBuLCB2LCBzdHlsZSk7XG4gICAgICAgIH0sIFlfRE9NKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgc3R5bGUgZm9yIHRoZSBnaXZlbiBub2RlLlxuICAgICAqIEBtZXRob2QgZ2V0Q29tcHV0ZWRTdHlsZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgVGhlIEhUTUxFbGVtZW50IHRvIGdldCB0aGUgc3R5bGUgZnJvbS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0IFRoZSBzdHlsZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29tcHV0ZWQgdmFsdWUgb2YgdGhlIHN0eWxlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldENvbXB1dGVkU3R5bGU6IGZ1bmN0aW9uKG5vZGUsIGF0dCkge1xuICAgICAgICB2YXIgdmFsID0gJycsXG4gICAgICAgICAgICBkb2MgPSBub2RlW09XTkVSX0RPQ1VNRU5UXSxcbiAgICAgICAgICAgIGNvbXB1dGVkO1xuXG4gICAgICAgIGlmIChub2RlW1NUWUxFXSAmJiBkb2NbREVGQVVMVF9WSUVXXSAmJiBkb2NbREVGQVVMVF9WSUVXXVtHRVRfQ09NUFVURURfU1RZTEVdKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGRvY1tERUZBVUxUX1ZJRVddW0dFVF9DT01QVVRFRF9TVFlMRV0obm9kZSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoY29tcHV0ZWQpIHsgLy8gRkYgbWF5IGJlIG51bGwgaW4gc29tZSBjYXNlcyAodGlja2V0ICMyNTMwNTQ4KVxuICAgICAgICAgICAgICAgIHZhbCA9IGNvbXB1dGVkW2F0dF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59KTtcblxuLy8gbm9ybWFsaXplIHJlc2VydmVkIHdvcmQgZmxvYXQgYWx0ZXJuYXRpdmVzIChcImNzc0Zsb2F0XCIgb3IgXCJzdHlsZUZsb2F0XCIpXG5pZiAoRE9DVU1FTlRbRE9DVU1FTlRfRUxFTUVOVF1bU1RZTEVdW0NTU19GTE9BVF0gIT09IHVuZGVmaW5lZCkge1xuICAgIFlfRE9NLkNVU1RPTV9TVFlMRVNbRkxPQVRdID0gQ1NTX0ZMT0FUO1xufSBlbHNlIGlmIChET0NVTUVOVFtET0NVTUVOVF9FTEVNRU5UXVtTVFlMRV1bU1RZTEVfRkxPQVRdICE9PSB1bmRlZmluZWQpIHtcbiAgICBZX0RPTS5DVVNUT01fU1RZTEVTW0ZMT0FUXSA9IFNUWUxFX0ZMT0FUO1xufVxuXG4vLyBzYWZhcmkgY29udmVydHMgdHJhbnNwYXJlbnQgdG8gcmdiYSgpLCBvdGhlcnMgdXNlIFwidHJhbnNwYXJlbnRcIlxuaWYgKFkuVUEud2Via2l0KSB7XG4gICAgWV9ET01bR0VUX0NPTVBVVEVEX1NUWUxFXSA9IGZ1bmN0aW9uKG5vZGUsIGF0dCkge1xuICAgICAgICB2YXIgdmlldyA9IG5vZGVbT1dORVJfRE9DVU1FTlRdW0RFRkFVTFRfVklFV10sXG4gICAgICAgICAgICB2YWwgPSB2aWV3W0dFVF9DT01QVVRFRF9TVFlMRV0obm9kZSwgJycpW2F0dF07XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gJ3JnYmEoMCwgMCwgMCwgMCknKSB7XG4gICAgICAgICAgICB2YWwgPSBUUkFOU1BBUkVOVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxufVxuXG5ZLkRPTS5fZ2V0QXR0ck9mZnNldCA9IGZ1bmN0aW9uKG5vZGUsIGF0dHIpIHtcbiAgICB2YXIgdmFsID0gWS5ET01bR0VUX0NPTVBVVEVEX1NUWUxFXShub2RlLCBhdHRyKSxcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gbm9kZS5vZmZzZXRQYXJlbnQsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBwYXJlbnRPZmZzZXQsXG4gICAgICAgIG9mZnNldDtcblxuICAgIGlmICh2YWwgPT09ICdhdXRvJykge1xuICAgICAgICBwb3NpdGlvbiA9IFkuRE9NLmdldFN0eWxlKG5vZGUsICdwb3NpdGlvbicpO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdzdGF0aWMnIHx8IHBvc2l0aW9uID09PSAncmVsYXRpdmUnKSB7XG4gICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnRbR0VUX0JPVU5ESU5HX0NMSUVOVF9SRUNUXSkge1xuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50W0dFVF9CT1VORElOR19DTElFTlRfUkVDVF0oKVthdHRyXTtcbiAgICAgICAgICAgIG9mZnNldCA9IG5vZGVbR0VUX0JPVU5ESU5HX0NMSUVOVF9SRUNUXSgpW2F0dHJdO1xuICAgICAgICAgICAgaWYgKGF0dHIgPT09ICdsZWZ0JyB8fCBhdHRyID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgIHZhbCA9IG9mZnNldCAtIHBhcmVudE9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gcGFyZW50T2Zmc2V0IC0gbm9kZVtHRVRfQk9VTkRJTkdfQ0xJRU5UX1JFQ1RdKClbYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xufTtcblxuWS5ET00uX2dldE9mZnNldCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgcG9zLFxuICAgICAgICB4eSA9IG51bGw7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgICBwb3MgPSBZX0RPTS5nZXRTdHlsZShub2RlLCAncG9zaXRpb24nKTtcbiAgICAgICAgeHkgPSBbXG4gICAgICAgICAgICBwYXJzZUludChZX0RPTVtHRVRfQ09NUFVURURfU1RZTEVdKG5vZGUsICdsZWZ0JyksIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KFlfRE9NW0dFVF9DT01QVVRFRF9TVFlMRV0obm9kZSwgJ3RvcCcpLCAxMClcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoIGlzTmFOKHh5WzBdKSApIHsgLy8gaW4gY2FzZSBvZiAnYXV0bydcbiAgICAgICAgICAgIHh5WzBdID0gcGFyc2VJbnQoWV9ET00uZ2V0U3R5bGUobm9kZSwgJ2xlZnQnKSwgMTApOyAvLyB0cnkgaW5saW5lXG4gICAgICAgICAgICBpZiAoIGlzTmFOKHh5WzBdKSApIHsgLy8gZGVmYXVsdCB0byBvZmZzZXQgdmFsdWVcbiAgICAgICAgICAgICAgICB4eVswXSA9IChwb3MgPT09ICdyZWxhdGl2ZScpID8gMCA6IG5vZGUub2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpc05hTih4eVsxXSkgKSB7IC8vIGluIGNhc2Ugb2YgJ2F1dG8nXG4gICAgICAgICAgICB4eVsxXSA9IHBhcnNlSW50KFlfRE9NLmdldFN0eWxlKG5vZGUsICd0b3AnKSwgMTApOyAvLyB0cnkgaW5saW5lXG4gICAgICAgICAgICBpZiAoIGlzTmFOKHh5WzFdKSApIHsgLy8gZGVmYXVsdCB0byBvZmZzZXQgdmFsdWVcbiAgICAgICAgICAgICAgICB4eVsxXSA9IChwb3MgPT09ICdyZWxhdGl2ZScpID8gMCA6IG5vZGUub2Zmc2V0VG9wIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geHk7XG5cbn07XG5cbmlmIChUUkFOU0ZPUk0pIHtcbiAgICBZX0RPTS5DVVNUT01fU1RZTEVTLnRyYW5zZm9ybSA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWwsIHN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZVtUUkFOU0ZPUk1dID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFlfRE9NW0dFVF9DT01QVVRFRF9TVFlMRV0obm9kZSwgVFJBTlNGT1JNKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBZX0RPTS5DVVNUT01fU1RZTEVTLnRyYW5zZm9ybU9yaWdpbiA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWwsIHN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZVtUUkFOU0ZPUk1PUklHSU5dID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFlfRE9NW0dFVF9DT01QVVRFRF9TVFlMRV0obm9kZSwgVFJBTlNGT1JNT1JJR0lOKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImRvbS1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2VzY2FwZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuUHJvdmlkZXMgdXRpbGl0eSBtZXRob2RzIGZvciBlc2NhcGluZyBzdHJpbmdzLlxuXG5AbW9kdWxlIGVzY2FwZVxuQGNsYXNzIEVzY2FwZVxuQHN0YXRpY1xuQHNpbmNlIDMuMy4wXG4qKi9cblxudmFyIEhUTUxfQ0hBUlMgPSB7XG4gICAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAgICc+JzogJyZndDsnLFxuICAgICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICAgICAnLyc6ICcmI3gyRjsnLFxuICAgICAgICAnYCc6ICcmI3g2MDsnXG4gICAgfSxcblxuRXNjYXBlID0ge1xuICAgIC8vIC0tIFB1YmxpYyBTdGF0aWMgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgIFJldHVybnMgYSBjb3B5IG9mIHRoZSBzcGVjaWZpZWQgc3RyaW5nIHdpdGggc3BlY2lhbCBIVE1MIGNoYXJhY3RlcnNcbiAgICBlc2NhcGVkLiBUaGUgZm9sbG93aW5nIGNoYXJhY3RlcnMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdGhlaXJcbiAgICBjb3JyZXNwb25kaW5nIGNoYXJhY3RlciBlbnRpdGllczpcblxuICAgICAgICAmIDwgPiBcIiAnIC8gYFxuXG4gICAgVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB0aGUgW09XQVNQIEhUTUwgZXNjYXBpbmdcbiAgICByZWNvbW1lbmRhdGlvbnNdWzFdLiBJbiBhZGRpdGlvbiB0byB0aGUgY2hhcmFjdGVycyBpbiB0aGUgT1dBU1BcbiAgICByZWNvbW1lbmRhdGlvbnMsIHdlIGFsc28gZXNjYXBlIHRoZSA8Y29kZT4mI3g2MDs8L2NvZGU+IGNoYXJhY3Rlciwgc2luY2UgSUVcbiAgICBpbnRlcnByZXRzIGl0IGFzIGFuIGF0dHJpYnV0ZSBkZWxpbWl0ZXIuXG5cbiAgICBJZiBfc3RyaW5nXyBpcyBub3QgYWxyZWFkeSBhIHN0cmluZywgaXQgd2lsbCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nLlxuXG4gICAgWzFdOiBodHRwOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTXyhDcm9zc19TaXRlX1NjcmlwdGluZylfUHJldmVudGlvbl9DaGVhdF9TaGVldFxuXG4gICAgQG1ldGhvZCBodG1sXG4gICAgQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gZXNjYXBlLlxuICAgIEByZXR1cm4ge1N0cmluZ30gRXNjYXBlZCBzdHJpbmcuXG4gICAgQHN0YXRpY1xuICAgICoqL1xuICAgIGh0bWw6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIChzdHJpbmcgKyAnJykucmVwbGFjZSgvWyY8PlwiJ1xcL2BdL2csIEVzY2FwZS5faHRtbFJlcGxhY2VyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgUmV0dXJucyBhIGNvcHkgb2YgdGhlIHNwZWNpZmllZCBzdHJpbmcgd2l0aCBzcGVjaWFsIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgIGNoYXJhY3RlcnMgZXNjYXBlZCwgYWxsb3dpbmcgdGhlIHN0cmluZyB0byBiZSB1c2VkIHNhZmVseSBpbnNpZGUgYSByZWdleC5cbiAgICBUaGUgZm9sbG93aW5nIGNoYXJhY3RlcnMsIGFuZCBhbGwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLCBhcmUgZXNjYXBlZDpcblxuICAgICAgICAtICQgXiAqICggKSArIFsgXSB7IH0gfCBcXCAsIC4gP1xuXG4gICAgSWYgX3N0cmluZ18gaXMgbm90IGFscmVhZHkgYSBzdHJpbmcsIGl0IHdpbGwgYmUgY29lcmNlZCB0byBhIHN0cmluZy5cblxuICAgIEBtZXRob2QgcmVnZXhcbiAgICBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBlc2NhcGUuXG4gICAgQHJldHVybiB7U3RyaW5nfSBFc2NhcGVkIHN0cmluZy5cbiAgICBAc3RhdGljXG4gICAgKiovXG4gICAgcmVnZXg6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGVzY2FwZSAhLCA9LCBhbmQgOiBzaW5jZSB0aGV5IG9ubHkgaGF2ZSBtZWFuaW5nXG4gICAgICAgIC8vIHdoZW4gdGhleSBmb2xsb3cgYSBwYXJlbnRoZXNpemVkID8sIGFzIGluICg/Oi4uLiksIGFuZCB3ZSBhbHJlYWR5XG4gICAgICAgIC8vIGVzY2FwZSBwYXJlbnMgYW5kIHF1ZXN0aW9uIG1hcmtzLlxuICAgICAgICByZXR1cm4gKHN0cmluZyArICcnKS5yZXBsYWNlKC9bXFwtJFxcXiooKStcXFtcXF17fXxcXFxcLC4/XFxzXS9nLCAnXFxcXCQmJyk7XG4gICAgfSxcblxuICAgIC8vIC0tIFByb3RlY3RlZCBTdGF0aWMgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJlZ2V4IHJlcGxhY2VyIGZvciBIVE1MIGVzY2FwaW5nLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfaHRtbFJlcGxhY2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoIE1hdGNoZWQgY2hhcmFjdGVyIChtdXN0IGV4aXN0IGluIEhUTUxfQ0hBUlMpLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gSFRNTCBlbnRpdHkuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaHRtbFJlcGxhY2VyOiBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIEhUTUxfQ0hBUlNbbWF0Y2hdO1xuICAgIH1cbn07XG5cbkVzY2FwZS5yZWdleHAgPSBFc2NhcGUucmVnZXg7XG5cblkuRXNjYXBlID0gRXNjYXBlO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJ5dWktYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG4oZnVuY3Rpb24oKSB7XG5cbnZhciBzdGF0ZUNoYW5nZUxpc3RlbmVyLFxuICAgIEdMT0JBTF9FTlYgICA9IFlVSS5FbnYsXG4gICAgY29uZmlnICAgICAgID0gWVVJLmNvbmZpZyxcbiAgICBkb2MgICAgICAgICAgPSBjb25maWcuZG9jLFxuICAgIGRvY0VsZW1lbnQgICA9IGRvYyAmJiBkb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgIEVWRU5UX05BTUUgICA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnLFxuICAgIHBvbGxJbnRlcnZhbCA9IGNvbmZpZy5wb2xsSW50ZXJ2YWwgfHwgNDA7XG5cbmlmIChkb2NFbGVtZW50LmRvU2Nyb2xsICYmICFHTE9CQUxfRU5WLl9pZXJlYWR5KSB7XG4gICAgR0xPQkFMX0VOVi5faWVyZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBHTE9CQUxfRU5WLl9yZWFkeSgpO1xuICAgIH07XG5cbi8qISBET01SZWFkeTogYmFzZWQgb24gd29yayBieTogRGVhbiBFZHdhcmRzL0pvaG4gUmVzaWcvTWF0dGhpYXMgTWlsbGVyL0RpZWdvIFBlcmluaSAqL1xuLy8gSW50ZXJuZXQgRXhwbG9yZXI6IHVzZSB0aGUgZG9TY3JvbGwoKSBtZXRob2Qgb24gdGhlIHJvb3QgZWxlbWVudC5cbi8vIFRoaXMgaXNvbGF0ZXMgd2hhdCBhcHBlYXJzIHRvIGJlIGEgc2FmZSBtb21lbnQgdG8gbWFuaXB1bGF0ZSB0aGVcbi8vIERPTSBwcmlvciB0byB3aGVuIHRoZSBkb2N1bWVudCdzIHJlYWR5U3RhdGUgc3VnZ2VzdHMgaXQgaXMgc2FmZSB0byBkbyBzby5cbiAgICBpZiAoc2VsZiAhPT0gc2VsZi50b3ApIHtcbiAgICAgICAgc3RhdGVDaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGRvYy5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICBHTE9CQUxfRU5WLnJlbW92ZShkb2MsIEVWRU5UX05BTUUsIHN0YXRlQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIEdMT0JBTF9FTlYuaWVyZWFkeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBHTE9CQUxfRU5WLmFkZChkb2MsIEVWRU5UX05BTUUsIHN0YXRlQ2hhbmdlTGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEdMT0JBTF9FTlYuX2RyaSA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkb2NFbGVtZW50LmRvU2Nyb2xsKCdsZWZ0Jyk7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChHTE9CQUxfRU5WLl9kcmkpO1xuICAgICAgICAgICAgICAgIEdMT0JBTF9FTlYuX2RyaSA9IG51bGw7XG4gICAgICAgICAgICAgICAgR0xPQkFMX0VOVi5faWVyZWFkeSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZG9tTm90UmVhZHkpIHsgfVxuICAgICAgICB9LCBwb2xsSW50ZXJ2YWwpO1xuICAgIH1cbn1cblxufSkoKTtcbllVSS5hZGQoJ2V2ZW50LWJhc2UtaWUnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKlxuICogQ3VzdG9tIGV2ZW50IGVuZ2luZSwgRE9NIGV2ZW50IGxpc3RlbmVyIGFic3RyYWN0aW9uIGxheWVyLCBzeW50aGV0aWMgRE9NXG4gKiBldmVudHMuXG4gKiBAbW9kdWxlIGV2ZW50XG4gKiBAc3VibW9kdWxlIGV2ZW50LWJhc2VcbiAqL1xuXG5mdW5jdGlvbiBJRUV2ZW50RmFjYWRlKCkge1xuICAgIC8vIElFRXZlbnRGYWNhZGUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIFkuRE9NMkV2ZW50RmFjYWRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qXG4gKiAoaW50ZW50aWFsbHkgbGVmdCBvdXQgb2YgQVBJIGRvY3MpXG4gKiBBbHRlcm5hdGUgRmFjYWRlIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgYmFzZWQgb24gT2JqZWN0LmRlZmluZVByb3BlcnR5LCB3aGljaFxuICogaXMgcGFydGlhbGx5IHN1cHBvcnRlZCBpbiBJRTguICBQcm9wZXJ0aWVzIHRoYXQgaW52b2x2ZSBzZXR1cCB3b3JrIGFyZVxuICogZGVmZXJyZWQgdG8gdGVtcG9yYXJ5IGdldHRlcnMgdXNpbmcgdGhlIHN0YXRpYyBfZGVmaW5lIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gSUVMYXp5RmFjYWRlKGUpIHtcbiAgICB2YXIgcHJveHkgPSBZLmNvbmZpZy5kb2MuY3JlYXRlRXZlbnRPYmplY3QoZSksXG4gICAgICAgIHByb3RvID0gSUVMYXp5RmFjYWRlLnByb3RvdHlwZTtcblxuICAgIC8vIFRPRE86IG5lY2Vzc2FyeT9cbiAgICBwcm94eS5oYXNPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG5cbiAgICBwcm94eS5pbml0ID0gcHJvdG8uaW5pdDtcbiAgICBwcm94eS5oYWx0ID0gcHJvdG8uaGFsdDtcbiAgICBwcm94eS5wcmV2ZW50RGVmYXVsdCAgICAgICAgICAgPSBwcm90by5wcmV2ZW50RGVmYXVsdDtcbiAgICBwcm94eS5zdG9wUHJvcGFnYXRpb24gICAgICAgICAgPSBwcm90by5zdG9wUHJvcGFnYXRpb247XG4gICAgcHJveHkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gcHJvdG8uc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xuXG4gICAgWS5ET00yRXZlbnRGYWNhZGUuYXBwbHkocHJveHksIGFyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gcHJveHk7XG59XG5cblxudmFyIGltcCA9IFkuY29uZmlnLmRvYyAmJiBZLmNvbmZpZy5kb2MuaW1wbGVtZW50YXRpb24sXG4gICAgdXNlTGF6eUZhY2FkZSA9IFkuY29uZmlnLmxhenlFdmVudEZhY2FkZSxcblxuICAgIGJ1dHRvbk1hcCA9IHtcbiAgICAgICAgMDogMSwgLy8gbGVmdCBjbGlja1xuICAgICAgICA0OiAyLCAvLyBtaWRkbGUgY2xpY2tcbiAgICAgICAgMjogMyAgLy8gcmlnaHQgY2xpY2tcbiAgICB9LFxuICAgIHJlbGF0ZWRUYXJnZXRNYXAgPSB7XG4gICAgICAgIG1vdXNlb3V0OiAndG9FbGVtZW50JyxcbiAgICAgICAgbW91c2VvdmVyOiAnZnJvbUVsZW1lbnQnXG4gICAgfSxcblxuICAgIHJlc29sdmUgPSBZLkRPTTJFdmVudEZhY2FkZS5yZXNvbHZlLFxuXG4gICAgcHJvdG8gPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBJRUV2ZW50RmFjYWRlLnN1cGVyY2xhc3MuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuX2V2ZW50LFxuICAgICAgICAgICAgICAgIHgsIHksIGQsIGIsIGRlLCB0O1xuXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHJlc29sdmUoZS5zcmNFbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKCgnY2xpZW50WCcgaW4gZSkgJiYgKCF4KSAmJiAoMCAhPT0geCkpIHtcbiAgICAgICAgICAgICAgICB4ID0gZS5jbGllbnRYO1xuICAgICAgICAgICAgICAgIHkgPSBlLmNsaWVudFk7XG5cbiAgICAgICAgICAgICAgICBkID0gWS5jb25maWcuZG9jO1xuICAgICAgICAgICAgICAgIGIgPSBkLmJvZHk7XG4gICAgICAgICAgICAgICAgZGUgPSBkLmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIHggKz0gKGRlLnNjcm9sbExlZnQgfHwgKGIgJiYgYi5zY3JvbGxMZWZ0KSB8fCAwKTtcbiAgICAgICAgICAgICAgICB5ICs9IChkZS5zY3JvbGxUb3AgIHx8IChiICYmIGIuc2Nyb2xsVG9wKSAgfHwgMCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VYID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VZID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PSBcIm1vdXNlb3V0XCIpIHtcbiAgICAgICAgICAgICAgICB0ID0gZS50b0VsZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSBcIm1vdXNlb3ZlclwiKSB7XG4gICAgICAgICAgICAgICAgdCA9IGUuZnJvbUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIHQucmVsYXRlZFRhcmdldCB0byBzdXBwb3J0IHNpbXVsYXRlZCBldmVudHMuXG4gICAgICAgICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgc2V0dGluZyB0b0VsZW1lbnQgb3IgZnJvbUVsZW1lbnQgb24gZ2VuZXJpY1xuICAgICAgICAgICAgLy8gZXZlbnRzLCBzbyBZLkV2ZW50LnNpbXVsYXRlIHNldHMgcmVsYXRlZFRhcmdldCBpbnN0ZWFkLlxuICAgICAgICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gcmVzb2x2ZSh0IHx8IGUucmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgICAgIC8vIHdoaWNoIHNob3VsZCBjb250YWluIHRoZSB1bmljb2RlIGtleSBjb2RlIGlmIHRoaXMgaXMgYSBrZXkgZXZlbnQuXG4gICAgICAgICAgICAvLyBGb3IgY2xpY2sgZXZlbnRzLCB3aGljaCBpcyBub3JtYWxpemVkIGZvciB3aGljaCBtb3VzZSBidXR0b24gd2FzXG4gICAgICAgICAgICAvLyBjbGlja2VkLlxuICAgICAgICAgICAgdGhpcy53aGljaCA9IC8vIGNoYWluZWQgYXNzaWdubWVudFxuICAgICAgICAgICAgdGhpcy5idXR0b24gPSBlLmtleUNvZGUgfHwgYnV0dG9uTWFwW2UuYnV0dG9uXSB8fCBlLmJ1dHRvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZXIuc3RvcHBlZCA9IDE7XG4gICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlci5zdG9wcGVkID0gMjtcbiAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IDI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudC5yZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlIHx8IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlci5wcmV2ZW50ZWQgPSAxO1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSAxO1xuICAgICAgICB9XG4gICAgfTtcblxuWS5leHRlbmQoSUVFdmVudEZhY2FkZSwgWS5ET00yRXZlbnRGYWNhZGUsIHByb3RvKTtcblxuWS5leHRlbmQoSUVMYXp5RmFjYWRlLCBZLkRPTTJFdmVudEZhY2FkZSwgcHJvdG8pO1xuSUVMYXp5RmFjYWRlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlICAgICAgICAgPSB0aGlzLl9ldmVudCxcbiAgICAgICAgb3ZlcnJpZGVzID0gdGhpcy5fd3JhcHBlci5vdmVycmlkZXMsXG4gICAgICAgIGRlZmluZSAgICA9IElFTGF6eUZhY2FkZS5fZGVmaW5lLFxuICAgICAgICBsYXp5UHJvcGVydGllcyA9IElFTGF6eUZhY2FkZS5fbGF6eVByb3BlcnRpZXMsXG4gICAgICAgIHByb3A7XG5cbiAgICB0aGlzLmFsdEtleSAgID0gZS5hbHRLZXk7XG4gICAgdGhpcy5jdHJsS2V5ICA9IGUuY3RybEtleTtcbiAgICB0aGlzLm1ldGFLZXkgID0gZS5tZXRhS2V5O1xuICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICAgIHRoaXMudHlwZSAgICAgPSAob3ZlcnJpZGVzICYmIG92ZXJyaWRlcy50eXBlKSB8fCBlLnR5cGU7XG4gICAgdGhpcy5jbGllbnRYICA9IGUuY2xpZW50WDtcbiAgICB0aGlzLmNsaWVudFkgID0gZS5jbGllbnRZO1xuICAgIHRoaXMua2V5Q29kZSAgPSAvLyBjaGFpbmVkIGFzc2lnbm1lbnRcbiAgICB0aGlzLmNoYXJDb2RlID0gZS5rZXlDb2RlO1xuICAgIHRoaXMud2hpY2ggICAgPSAvLyBjaGFpbmVkIGFzc2lnbm1lbnRcbiAgICB0aGlzLmJ1dHRvbiAgID0gZS5rZXlDb2RlIHx8IGJ1dHRvbk1hcFtlLmJ1dHRvbl0gfHwgZS5idXR0b247XG5cbiAgICBmb3IgKHByb3AgaW4gbGF6eVByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKGxhenlQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBkZWZpbmUodGhpcywgcHJvcCwgbGF6eVByb3BlcnRpZXNbcHJvcF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RvdWNoKSB7XG4gICAgICAgIHRoaXMuX3RvdWNoKGUsIHRoaXMuX2N1cnJlbnRUYXJnZXQsIHRoaXMuX3dyYXBwZXIpO1xuICAgIH1cbn07XG5cbklFTGF6eUZhY2FkZS5fbGF6eVByb3BlcnRpZXMgPSB7XG4gICAgdGFyZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMuX2V2ZW50LnNyY0VsZW1lbnQpO1xuICAgIH0sXG4gICAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuX2V2ZW50LFxuICAgICAgICAgICAgdGFyZ2V0UHJvcCA9IHJlbGF0ZWRUYXJnZXRNYXBbZS50eXBlXSB8fCAncmVsYXRlZFRhcmdldCc7XG5cbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gdC5yZWxhdGVkVGFyZ2V0IHRvIHN1cHBvcnQgc2ltdWxhdGVkIGV2ZW50cy5cbiAgICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IHNldHRpbmcgdG9FbGVtZW50IG9yIGZyb21FbGVtZW50IG9uIGdlbmVyaWNcbiAgICAgICAgLy8gZXZlbnRzLCBzbyBZLkV2ZW50LnNpbXVsYXRlIHNldHMgcmVsYXRlZFRhcmdldCBpbnN0ZWFkLlxuICAgICAgICByZXR1cm4gcmVzb2x2ZShlW3RhcmdldFByb3BdIHx8IGUucmVsYXRlZFRhcmdldCk7XG4gICAgfSxcbiAgICBjdXJyZW50VGFyZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMuX2N1cnJlbnRUYXJnZXQpO1xuICAgIH0sXG5cbiAgICB3aGVlbERlbHRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5fZXZlbnQ7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJtb3VzZXdoZWVsXCIgfHwgZS50eXBlID09PSBcIkRPTU1vdXNlU2Nyb2xsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoZS5kZXRhaWwpID9cbiAgICAgICAgICAgICAgICAoZS5kZXRhaWwgKiAtMSkgOlxuICAgICAgICAgICAgICAgIC8vIHdoZWVsRGVsdGEgYmV0d2VlbiAtODAgYW5kIDgwIHJlc3VsdCBpbiAtMSBvciAxXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZChlLndoZWVsRGVsdGEgLyA4MCkgfHwgKChlLndoZWVsRGVsdGEgPCAwKSA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFnZVg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9ldmVudCxcbiAgICAgICAgICAgIHZhbCA9IGUucGFnZVgsXG4gICAgICAgICAgICBkb2MsIGJvZHlTY3JvbGwsIGRvY1Njcm9sbDtcblxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvYyA9IFkuY29uZmlnLmRvYztcbiAgICAgICAgICAgIGJvZHlTY3JvbGwgPSBkb2MuYm9keSAmJiBkb2MuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgZG9jU2Nyb2xsID0gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICAgICAgICB2YWwgPSBlLmNsaWVudFggKyAoZG9jU2Nyb2xsIHx8IGJvZHlTY3JvbGwgfHwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG4gICAgcGFnZVk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9ldmVudCxcbiAgICAgICAgICAgIHZhbCA9IGUucGFnZVksXG4gICAgICAgICAgICBkb2MsIGJvZHlTY3JvbGwsIGRvY1Njcm9sbDtcblxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvYyA9IFkuY29uZmlnLmRvYztcbiAgICAgICAgICAgIGJvZHlTY3JvbGwgPSBkb2MuYm9keSAmJiBkb2MuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgICAgICBkb2NTY3JvbGwgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcblxuICAgICAgICAgICAgdmFsID0gZS5jbGllbnRZICsgKGRvY1Njcm9sbCB8fCBib2R5U2Nyb2xsIHx8IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogV3JhcHBlciBmdW5jdGlvbiBmb3IgT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgY3JlYXRlcyBhIHByb3BlcnR5IHdob3NlXG4gKiB2YWx1ZSB3aWxsIGJlIGNhbHVsYXRlZCBvbmx5IHdoZW4gYXNrZWQgZm9yLiAgQWZ0ZXIgY2FsY3VsYXRpbmcgdGhlIHZhbHVlLFxuICogdGhlIGdldHRlciB3bGwgYmUgcmVtb3ZlZCwgc28gaXQgd2lsbCBiZWhhdmUgYXMgYSBub3JtYWwgcHJvcGVydHkgYmV5b25kIHRoYXRcbiAqIHBvaW50LiAgQSBzZXR0ZXIgaXMgYWxzbyBhc3NpZ25lZCBzbyBhc3NpZ25pbmcgdG8gdGhlIHByb3BlcnR5IHdpbGwgY2xlYXJcbiAqIHRoZSBnZXR0ZXIsIHNvIGZvby5wcm9wID0gJ2EnOyBmb28ucHJvcDsgd29uJ3QgdHJpZ2dlciB0aGUgZ2V0dGVyLFxuICogb3ZlcndyaXRpbmcgdmFsdWUgJ2EnLlxuICpcbiAqIFVzZWQgb25seSBieSB0aGUgRE9NRXZlbnRGYWNhZGVzIHVzZWQgYnkgSUU4IHdoZW4gdGhlIFlVSSBjb25maWd1cmF0aW9uXG4gKiA8Y29kZT5sYXp5RXZlbnRGYWNhZGU8L2NvZGU+IGlzIHNldCB0byB0cnVlLlxuICpcbiAqIEBtZXRob2QgX2RlZmluZVxuICogQHBhcmFtIG8ge0RPTU9iamVjdH0gQSBET00gb2JqZWN0IHRvIGFkZCB0aGUgcHJvcGVydHkgdG9cbiAqIEBwYXJhbSBwcm9wIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBuZXcgcHJvcGVydHlcbiAqIEBwYXJhbSB2YWx1ZUZuIHtGdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gdGhlIGluaXRpYWwsIGRlZmF1bHRcbiAqICAgICAgICAgICAgICAgICAgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eS5cbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKi9cbklFTGF6eUZhY2FkZS5fZGVmaW5lID0gZnVuY3Rpb24gKG8sIHByb3AsIHZhbHVlRm4pIHtcbiAgICBmdW5jdGlvbiB2YWwodikge1xuICAgICAgICB2YXIgcmV0ID0gKGFyZ3VtZW50cy5sZW5ndGgpID8gdiA6IHZhbHVlRm4uY2FsbCh0aGlzKTtcblxuICAgICAgICBkZWxldGUgb1twcm9wXTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIHByb3AsIHtcbiAgICAgICAgICAgIHZhbHVlOiByZXQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIHByb3AsIHtcbiAgICAgICAgZ2V0OiB2YWwsXG4gICAgICAgIHNldDogdmFsLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn07XG5cbmlmIChpbXAgJiYgKCFpbXAuaGFzRmVhdHVyZSgnRXZlbnRzJywgJzIuMCcpKSkge1xuICAgIGlmICh1c2VMYXp5RmFjYWRlKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjYW4gdXNlIHRoZSBsYXp5IGZhY2FkZSBsb2dpY1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFkuY29uZmlnLmRvYy5jcmVhdGVFdmVudE9iamVjdCgpLCAneicsIHt9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdXNlTGF6eUZhY2FkZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgWS5ET01FdmVudEZhY2FkZSA9ICh1c2VMYXp5RmFjYWRlKSA/IElFTGF6eUZhY2FkZSA6IElFRXZlbnRGYWNhZGU7XG59XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcIm5vZGUtYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdldmVudC1iYXNlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLypcbiAqIERPTSBldmVudCBsaXN0ZW5lciBhYnN0cmFjdGlvbiBsYXllclxuICogQG1vZHVsZSBldmVudFxuICogQHN1Ym1vZHVsZSBldmVudC1iYXNlXG4gKi9cblxuLyoqXG4gKiBUaGUgZG9tcmVhZHkgZXZlbnQgZmlyZXMgYXQgdGhlIG1vbWVudCB0aGUgYnJvd3NlcidzIERPTSBpc1xuICogdXNhYmxlLiBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIGJlZm9yZSBpbWFnZXMgYXJlIGZ1bGx5XG4gKiBkb3dubG9hZGVkLCBhbGxvd2luZyB5b3UgdG8gcHJvdmlkZSBhIG1vcmUgcmVzcG9uc2l2ZSB1c2VyXG4gKiBpbnRlcmZhY2UuXG4gKlxuICogSW4gWVVJIDMsIGRvbXJlYWR5IHN1YnNjcmliZXJzIHdpbGwgYmUgbm90aWZpZWQgaW1tZWRpYXRlbHkgaWZcbiAqIHRoYXQgbW9tZW50IGhhcyBhbHJlYWR5IHBhc3NlZCB3aGVuIHRoZSBzdWJzY3JpcHRpb24gaXMgY3JlYXRlZC5cbiAqXG4gKiBPbmUgZXhjZXB0aW9uIGlzIGlmIHRoZSB5dWkuanMgZmlsZSBpcyBkeW5hbWljYWxseSBpbmplY3RlZCBpbnRvXG4gKiB0aGUgcGFnZS4gIElmIHRoaXMgaXMgZG9uZSwgeW91IG11c3QgdGVsbCB0aGUgWVVJIGluc3RhbmNlIHRoYXRcbiAqIHlvdSBkaWQgdGhpcyBpbiBvcmRlciBmb3IgRE9NUmVhZHkgKGFuZCB3aW5kb3cgbG9hZCBldmVudHMpIHRvXG4gKiBmaXJlIG5vcm1hbGx5LiAgVGhhdCBjb25maWd1cmF0aW9uIG9wdGlvbiBpcyAnaW5qZWN0ZWQnIC0tIHNldFxuICogaXQgdG8gdHJ1ZSBpZiB0aGUgeXVpLmpzIHNjcmlwdCBpcyBub3QgaW5jbHVkZWQgaW5saW5lLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlICdldmVudC1yZWFkeScgbW9kdWxlLCB3aGljaCBpcyBhXG4gKiBzdWJtb2R1bGUgb2YgJ2V2ZW50Jy5cbiAqXG4gKiBAZXZlbnQgZG9tcmVhZHlcbiAqIEBmb3IgWVVJXG4gKi9cblkucHVibGlzaCgnZG9tcmVhZHknLCB7XG4gICAgZmlyZU9uY2U6IHRydWUsXG4gICAgYXN5bmM6IHRydWVcbn0pO1xuXG5pZiAoWVVJLkVudi5ET01SZWFkeSkge1xuICAgIFkuZmlyZSgnZG9tcmVhZHknKTtcbn0gZWxzZSB7XG4gICAgWS5Eby5iZWZvcmUoZnVuY3Rpb24oKSB7IFkuZmlyZSgnZG9tcmVhZHknKTsgfSwgWVVJLkVudiwgJ19yZWFkeScpO1xufVxuXG4vKipcbiAqIEN1c3RvbSBldmVudCBlbmdpbmUsIERPTSBldmVudCBsaXN0ZW5lciBhYnN0cmFjdGlvbiBsYXllciwgc3ludGhldGljIERPTVxuICogZXZlbnRzLlxuICogQG1vZHVsZSBldmVudFxuICogQHN1Ym1vZHVsZSBldmVudC1iYXNlXG4gKi9cblxuLyoqXG4gKiBXcmFwcyBhIERPTSBldmVudCwgcHJvcGVydGllcyByZXF1aXJpbmcgYnJvd3NlciBhYnN0cmFjdGlvbiBhcmVcbiAqIGZpeGVkIGhlcmUuICBQcm92aWRzIGEgc2VjdXJpdHkgbGF5ZXIgd2hlbiByZXF1aXJlZC5cbiAqIEBjbGFzcyBET01FdmVudEZhY2FkZVxuICogQHBhcmFtIGV2IHtFdmVudH0gdGhlIERPTSBldmVudFxuICogQHBhcmFtIGN1cnJlbnRUYXJnZXQge0hUTUxFbGVtZW50fSB0aGUgZWxlbWVudCB0aGUgbGlzdGVuZXIgd2FzIGF0dGFjaGVkIHRvXG4gKiBAcGFyYW0gd3JhcHBlciB7Q3VzdG9tRXZlbnR9IHRoZSBjdXN0b20gZXZlbnQgd3JhcHBlciBmb3IgdGhpcyBET00gZXZlbnRcbiAqL1xuXG4gICAgdmFyIHVhID0gWS5VQSxcblxuICAgIEVNUFRZID0ge30sXG5cbiAgICAvKipcbiAgICAgKiB3ZWJraXQga2V5IHJlbWFwcGluZyByZXF1aXJlZCBmb3IgU2FmYXJpIDwgMy4xXG4gICAgICogQHByb3BlcnR5IHdlYmtpdEtleW1hcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgd2Via2l0S2V5bWFwID0ge1xuICAgICAgICA2MzIzMjogMzgsIC8vIHVwXG4gICAgICAgIDYzMjMzOiA0MCwgLy8gZG93blxuICAgICAgICA2MzIzNDogMzcsIC8vIGxlZnRcbiAgICAgICAgNjMyMzU6IDM5LCAvLyByaWdodFxuICAgICAgICA2MzI3NjogMzMsIC8vIHBhZ2UgdXBcbiAgICAgICAgNjMyNzc6IDM0LCAvLyBwYWdlIGRvd25cbiAgICAgICAgMjU6ICAgICA5LCAvLyBTSElGVC1UQUIgKFNhZmFyaSBwcm92aWRlcyBhIGRpZmZlcmVudCBrZXkgY29kZSBpblxuICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FzZSwgZXZlbiB0aG91Z2ggdGhlIHNoaWZ0S2V5IG1vZGlmaWVyIGlzIHNldClcbiAgICAgICAgNjMyNzI6IDQ2LCAvLyBkZWxldGVcbiAgICAgICAgNjMyNzM6IDM2LCAvLyBob21lXG4gICAgICAgIDYzMjc1OiAzNSAgLy8gZW5kXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB3cmFwcGVkIG5vZGUuICBJbnRlbmRlZCB0byBiZSB1c2VkIG9uIGV2ZW50IHRhcmdldHMsXG4gICAgICogc28gaXQgd2lsbCByZXR1cm4gdGhlIG5vZGUncyBwYXJlbnQgaWYgdGhlIHRhcmdldCBpcyBhIHRleHRcbiAgICAgKiBub2RlLlxuICAgICAqXG4gICAgICogSWYgYWNjZXNzaW5nIGEgcHJvcGVydHkgb2YgdGhlIG5vZGUgdGhyb3dzIGFuIGVycm9yLCB0aGlzIGlzXG4gICAgICogcHJvYmFibHkgdGhlIGFub255bW91cyBkaXYgd3JhcHBlciBHZWNrbyBhZGRzIGluc2lkZSB0ZXh0XG4gICAgICogbm9kZXMuICBUaGlzIGxpa2VseSB3aWxsIG9ubHkgb2NjdXIgd2hlbiBhdHRlbXB0aW5nIHRvIGFjY2Vzc1xuICAgICAqIHRoZSByZWxhdGVkVGFyZ2V0LiAgSW4gdGhpcyBjYXNlLCB3ZSBub3cgcmV0dXJuIG51bGwgYmVjYXVzZVxuICAgICAqIHRoZSBhbm9ueW1vdXMgZGl2IGlzIGNvbXBsZXRlbHkgdXNlbGVzcyBhbmQgd2UgZG8gbm90IGtub3dcbiAgICAgKiB3aGF0IHRoZSByZWxhdGVkIHRhcmdldCB3YXMgYmVjYXVzZSB3ZSBjYW4ndCBldmVuIGdldCB0b1xuICAgICAqIHRoZSBlbGVtZW50J3MgcGFyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlc29sdmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlc29sdmUgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIGlmICghbikge1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChuICYmIDMgPT0gbi5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gWS5vbmUobik7XG4gICAgfSxcblxuICAgIERPTUV2ZW50RmFjYWRlID0gZnVuY3Rpb24oZXYsIGN1cnJlbnRUYXJnZXQsIHdyYXBwZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlbnQgPSBldjtcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIgPSB3cmFwcGVyIHx8IEVNUFRZO1xuXG4gICAgICAgIC8vIGlmIG5vdCBsYXp5IGluaXRcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfTtcblxuWS5leHRlbmQoRE9NRXZlbnRGYWNhZGUsIE9iamVjdCwge1xuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGUgPSB0aGlzLl9ldmVudCxcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IHRoaXMuX3dyYXBwZXIub3ZlcnJpZGVzLFxuICAgICAgICAgICAgeCA9IGUucGFnZVgsXG4gICAgICAgICAgICB5ID0gZS5wYWdlWSxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gdGhpcy5fY3VycmVudFRhcmdldDtcblxuICAgICAgICB0aGlzLmFsdEtleSAgID0gZS5hbHRLZXk7XG4gICAgICAgIHRoaXMuY3RybEtleSAgPSBlLmN0cmxLZXk7XG4gICAgICAgIHRoaXMubWV0YUtleSAgPSBlLm1ldGFLZXk7XG4gICAgICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICAgICAgICB0aGlzLnR5cGUgICAgID0gKG92ZXJyaWRlcyAmJiBvdmVycmlkZXMudHlwZSkgfHwgZS50eXBlO1xuICAgICAgICB0aGlzLmNsaWVudFggID0gZS5jbGllbnRYO1xuICAgICAgICB0aGlzLmNsaWVudFkgID0gZS5jbGllbnRZO1xuXG4gICAgICAgIHRoaXMucGFnZVggPSB4O1xuICAgICAgICB0aGlzLnBhZ2VZID0geTtcblxuICAgICAgICAvLyBjaGFyQ29kZSBpcyB1bmtub3duIGluIGtleXVwLCBrZXlkb3duLiBrZXlDb2RlIGlzIHVua25vd24gaW4ga2V5cHJlc3MuXG4gICAgICAgIC8vIEZGIDMuNiAtIDgrPyBwYXNzIDAgZm9yIGtleUNvZGUgaW4ga2V5cHJlc3MgZXZlbnRzLlxuICAgICAgICAvLyBXZWJraXQsIEZGIDMuNi04Kz8sIGFuZCBJRTkrPyBwYXNzIDAgZm9yIGNoYXJDb2RlIGluIGtleWRvd24sIGtleXVwLlxuICAgICAgICAvLyBXZWJraXQgYW5kIElFOSs/IGR1cGxpY2F0ZSBjaGFyQ29kZSBpbiBrZXlDb2RlLlxuICAgICAgICAvLyBPcGVyYSBuZXZlciBzZXRzIGNoYXJDb2RlLCBhbHdheXMga2V5Q29kZSAodGhvdWdoIHdpdGggdGhlIGNoYXJDb2RlKS5cbiAgICAgICAgLy8gSUU2LTggZG9uJ3Qgc2V0IGNoYXJDb2RlIG9yIHdoaWNoLlxuICAgICAgICAvLyBBbGwgYnJvd3NlcnMgb3RoZXIgdGhhbiBJRTYtOCBzZXQgd2hpY2g9a2V5Q29kZSBpbiBrZXlkb3duLCBrZXl1cCwgYW5kXG4gICAgICAgIC8vIHdoaWNoPWNoYXJDb2RlIGluIGtleXByZXNzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBNb3JhbCBvZiB0aGUgc3Rvcnk6IChlLndoaWNoIHx8IGUua2V5Q29kZSkgd2lsbCBhbHdheXMgcmV0dXJuIHRoZVxuICAgICAgICAvLyBrbm93biBjb2RlIGZvciB0aGF0IGtleSBldmVudCBwaGFzZS4gZS5rZXlDb2RlIGlzIG9mdGVuIGRpZmZlcmVudCBpblxuICAgICAgICAvLyBrZXlwcmVzcyBmcm9tIGtleWRvd24gYW5kIGtleXVwLlxuICAgICAgICBjID0gZS5rZXlDb2RlIHx8IGUuY2hhckNvZGU7XG5cbiAgICAgICAgaWYgKHVhLndlYmtpdCAmJiAoYyBpbiB3ZWJraXRLZXltYXApKSB7XG4gICAgICAgICAgICBjID0gd2Via2l0S2V5bWFwW2NdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5rZXlDb2RlID0gYztcbiAgICAgICAgdGhpcy5jaGFyQ29kZSA9IGM7XG4gICAgICAgIC8vIEZpbGwgaW4gZS53aGljaCBmb3IgSUUgLSBpbXBsZW1lbnRlcnMgc2hvdWxkIGFsd2F5cyB1c2UgdGhpcyBvdmVyXG4gICAgICAgIC8vIGUua2V5Q29kZSBvciBlLmNoYXJDb2RlLlxuICAgICAgICB0aGlzLndoaWNoID0gZS53aGljaCB8fCBlLmNoYXJDb2RlIHx8IGM7XG4gICAgICAgIC8vIHRoaXMuYnV0dG9uID0gZS5idXR0b247XG4gICAgICAgIHRoaXMuYnV0dG9uID0gdGhpcy53aGljaDtcblxuICAgICAgICB0aGlzLnRhcmdldCA9IHJlc29sdmUoZS50YXJnZXQpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSByZXNvbHZlKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSByZXNvbHZlKGUucmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PSBcIm1vdXNld2hlZWxcIiB8fCBlLnR5cGUgPT0gXCJET01Nb3VzZVNjcm9sbFwiKSB7XG4gICAgICAgICAgICB0aGlzLndoZWVsRGVsdGEgPSAoZS5kZXRhaWwpID8gKGUuZGV0YWlsICogLTEpIDogTWF0aC5yb3VuZChlLndoZWVsRGVsdGEgLyA4MCkgfHwgKChlLndoZWVsRGVsdGEgPCAwKSA/IC0xIDogMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdG91Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoKGUsIGN1cnJlbnRUYXJnZXQsIHRoaXMuX3dyYXBwZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLl93cmFwcGVyLnN0b3BwZWQgPSAxO1xuICAgICAgICB0aGlzLnN0b3BwZWQgPSAxO1xuICAgIH0sXG5cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuX2V2ZW50O1xuICAgICAgICBpZiAoZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dyYXBwZXIuc3RvcHBlZCA9IDI7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IDI7XG4gICAgfSxcblxuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbihyZXR1cm5WYWx1ZSkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuX2V2ZW50O1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dyYXBwZXIucHJldmVudGVkID0gMTtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSAxO1xuICAgIH0sXG5cbiAgICBoYWx0OiBmdW5jdGlvbihpbW1lZGlhdGUpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG59KTtcblxuRE9NRXZlbnRGYWNhZGUucmVzb2x2ZSA9IHJlc29sdmU7XG5ZLkRPTTJFdmVudEZhY2FkZSA9IERPTUV2ZW50RmFjYWRlO1xuWS5ET01FdmVudEZhY2FkZSA9IERPTUV2ZW50RmFjYWRlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hdGl2ZSBldmVudFxuICAgICAqIEBwcm9wZXJ0eSBfZXZlbnRcbiAgICAgKiBAdHlwZSB7RE9NRXZlbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoZS5nLiBcImNsaWNrXCIpXG5cbiAgICBAcHJvcGVydHkgdHlwZVxuICAgIEB0eXBlIHtTdHJpbmd9XG4gICAgKiovXG5cbiAgICAvKipcbiAgICBgdHJ1ZWAgaWYgdGhlIFwiYWx0XCIgb3IgXCJvcHRpb25cIiBrZXkgaXMgcHJlc3NlZC5cblxuICAgIEBwcm9wZXJ0eSBhbHRLZXlcbiAgICBAdHlwZSB7Qm9vbGVhbn1cbiAgICAqKi9cblxuICAgIC8qKlxuICAgIGB0cnVlYCBpZiB0aGUgc2hpZnQga2V5IGlzIHByZXNzZWQuXG5cbiAgICBAcHJvcGVydHkgc2hpZnRLZXlcbiAgICBAdHlwZSB7Qm9vbGVhbn1cbiAgICAqKi9cblxuICAgIC8qKlxuICAgIGB0cnVlYCBpZiB0aGUgXCJXaW5kb3dzXCIga2V5IG9uIGEgV2luZG93cyBrZXlib2FyZCwgXCJjb21tYW5kXCIga2V5IG9uIGFuXG4gICAgQXBwbGUga2V5Ym9hcmQsIG9yIFwibWV0YVwiIGtleSBvbiBvdGhlciBrZXlib2FyZHMgaXMgcHJlc3NlZC5cblxuICAgIEBwcm9wZXJ0eSBtZXRhS2V5XG4gICAgQHR5cGUge0Jvb2xlYW59XG4gICAgKiovXG5cbiAgICAvKipcbiAgICBgdHJ1ZWAgaWYgdGhlIFwiQ3RybFwiIG9yIFwiY29udHJvbFwiIGtleSBpcyBwcmVzc2VkLlxuXG4gICAgQHByb3BlcnR5IGN0cmxLZXlcbiAgICBAdHlwZSB7Qm9vbGVhbn1cbiAgICAqKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBYIGxvY2F0aW9uIG9mIHRoZSBldmVudCBvbiB0aGUgcGFnZSAoaW5jbHVkaW5nIHNjcm9sbClcbiAgICAgKiBAcHJvcGVydHkgcGFnZVhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIFkgbG9jYXRpb24gb2YgdGhlIGV2ZW50IG9uIHRoZSBwYWdlIChpbmNsdWRpbmcgc2Nyb2xsKVxuICAgICAqIEBwcm9wZXJ0eSBwYWdlWVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgWCBsb2NhdGlvbiBvZiB0aGUgZXZlbnQgaW4gdGhlIHZpZXdwb3J0XG4gICAgICogQHByb3BlcnR5IGNsaWVudFhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIFkgbG9jYXRpb24gb2YgdGhlIGV2ZW50IGluIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwcm9wZXJ0eSBjbGllbnRZXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBrZXlDb2RlIGZvciBrZXkgZXZlbnRzLiAgVXNlcyBjaGFyQ29kZSBpZiBrZXlDb2RlIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgKiBAcHJvcGVydHkga2V5Q29kZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2hhckNvZGUgZm9yIGtleSBldmVudHMuICBTYW1lIGFzIGtleUNvZGVcbiAgICAgKiBAcHJvcGVydHkgY2hhckNvZGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJ1dHRvbiB0aGF0IHdhcyBwdXNoZWQuIDEgZm9yIGxlZnQgY2xpY2ssIDIgZm9yIG1pZGRsZSBjbGljaywgMyBmb3JcbiAgICAgKiByaWdodCBjbGljay4gIFRoaXMgaXMgb25seSByZWxpYWJseSBwb3B1bGF0ZWQgb24gYG1vdXNldXBgIGV2ZW50cy5cbiAgICAgKiBAcHJvcGVydHkgYnV0dG9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBidXR0b24gdGhhdCB3YXMgcHVzaGVkLiAgU2FtZSBhcyBidXR0b24uXG4gICAgICogQHByb3BlcnR5IHdoaWNoXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIE5vZGUgcmVmZXJlbmNlIGZvciB0aGUgdGFyZ2V0ZWQgZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB0YXJnZXRcbiAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIE5vZGUgcmVmZXJlbmNlIGZvciB0aGUgZWxlbWVudCB0aGF0IHRoZSBsaXN0ZW5lciB3YXMgYXR0YWNoZWQgdG8uXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRUYXJnZXRcbiAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIE5vZGUgcmVmZXJlbmNlIHRvIHRoZSByZWxhdGVkVGFyZ2V0XG4gICAgICogQHByb3BlcnR5IHJlbGF0ZWRUYXJnZXRcbiAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIE51bWJlciByZXByZXNlbnRpbmcgdGhlIGRpcmVjdGlvbiBhbmQgdmVsb2NpdHkgb2YgdGhlIG1vdmVtZW50IG9mIHRoZSBtb3VzZXdoZWVsLlxuICAgICAqIE5lZ2F0aXZlIGlzIGRvd24sIHRoZSBoaWdoZXIgdGhlIG51bWJlciwgdGhlIGZhc3Rlci4gIEFwcGxpZXMgdG8gdGhlIG1vdXNld2hlZWwgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IHdoZWVsRGVsdGFcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIHByb3BhZ2F0aW9uIHRvIHRoZSBuZXh0IGJ1YmJsZSB0YXJnZXRcbiAgICAgKiBAbWV0aG9kIHN0b3BQcm9wYWdhdGlvblxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIHByb3BhZ2F0aW9uIHRvIHRoZSBuZXh0IGJ1YmJsZSB0YXJnZXQgYW5kXG4gICAgICogcHJldmVudHMgYW55IGFkZGl0aW9uYWwgbGlzdGVuZXJzIGZyb20gYmVpbmcgZXhlY3R1ZWRcbiAgICAgKiBvbiB0aGUgY3VycmVudCB0YXJnZXQuXG4gICAgICogQG1ldGhvZCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBldmVudCdzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgKiBAbWV0aG9kIHByZXZlbnREZWZhdWx0XG4gICAgICogQHBhcmFtIHJldHVyblZhbHVlIHtzdHJpbmd9IHNldHMgdGhlIHJldHVyblZhbHVlIG9mIHRoZSBldmVudCB0byB0aGlzIHZhbHVlXG4gICAgICogKHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGZhbHNlIHZhbHVlKS4gIFRoaXMgY2FuIGJlIHVzZWQgdG8gYWRkIGEgY3VzdG9taXplZFxuICAgICAqIGNvbmZpcm1hdGlvbiBxdWVyeSB0byB0aGUgYmVmb3JldW5sb2FkIGV2ZW50KS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBldmVudCBwcm9wYWdhdGlvbiBhbmQgcHJldmVudHMgdGhlIGRlZmF1bHRcbiAgICAgKiBldmVudCBiZWhhdmlvci5cbiAgICAgKiBAbWV0aG9kIGhhbHRcbiAgICAgKiBAcGFyYW0gaW1tZWRpYXRlIHtib29sZWFufSBpZiB0cnVlIGFkZGl0aW9uYWwgbGlzdGVuZXJzXG4gICAgICogb24gdGhlIGN1cnJlbnQgdGFyZ2V0IHdpbGwgbm90IGJlIGV4ZWN1dGVkXG4gICAgICovXG4oZnVuY3Rpb24oKSB7XG5cbi8qKlxuICogVGhlIGV2ZW50IHV0aWxpdHkgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGFkZCBhbmQgcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyxcbiAqIGV2ZW50IGNsZWFuc2luZy4gIEl0IGFsc28gdHJpZXMgdG8gYXV0b21hdGljYWxseSByZW1vdmUgbGlzdGVuZXJzIGl0XG4gKiByZWdpc3RlcnMgZHVyaW5nIHRoZSB1bmxvYWQgZXZlbnQuXG4gKiBAbW9kdWxlIGV2ZW50XG4gKiBAbWFpbiBldmVudFxuICogQHN1Ym1vZHVsZSBldmVudC1iYXNlXG4gKi9cblxuLyoqXG4gKiBUaGUgZXZlbnQgdXRpbGl0eSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gYWRkIGFuZCByZW1vdmUgZXZlbnQgbGlzdGVuZXJzLFxuICogZXZlbnQgY2xlYW5zaW5nLiAgSXQgYWxzbyB0cmllcyB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSBsaXN0ZW5lcnMgaXRcbiAqIHJlZ2lzdGVycyBkdXJpbmcgdGhlIHVubG9hZCBldmVudC5cbiAqXG4gKiBAY2xhc3MgRXZlbnRcbiAqIEBzdGF0aWNcbiAqL1xuXG5ZLkVudi5ldnQuZG9tX3dyYXBwZXJzID0ge307XG5ZLkVudi5ldnQuZG9tX21hcCA9IHt9O1xuXG52YXIgX2V2ZW50ZW52ID0gWS5FbnYuZXZ0LFxuICAgIGNvbmZpZyA9IFkuY29uZmlnLFxuICAgIHdpbiA9IGNvbmZpZy53aW4sXG4gICAgYWRkID0gWVVJLkVudi5hZGQsXG4gICAgcmVtb3ZlID0gWVVJLkVudi5yZW1vdmUsXG5cbiAgICBvbkxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgWVVJLkVudi53aW5kb3dMb2FkZWQgPSB0cnVlO1xuICAgICAgICBZLkV2ZW50Ll9sb2FkKCk7XG4gICAgICAgIHJlbW92ZSh3aW4sIFwibG9hZFwiLCBvbkxvYWQpO1xuICAgIH0sXG5cbiAgICBvblVubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBZLkV2ZW50Ll91bmxvYWQoKTtcbiAgICB9LFxuXG4gICAgRVZFTlRfUkVBRFkgPSAnZG9tcmVhZHknLFxuXG4gICAgQ09NUEFUX0FSRyA9ICd+eXVpfDJ8Y29tcGF0ficsXG5cbiAgICBzaG91bGRJdGVyYXRlID0gZnVuY3Rpb24obykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVE9ETzogU2VlIGlmIHRoZXJlJ3MgYSBtb3JlIHBlcmZvcm1hbnQgd2F5IHRvIHJldHVybiB0cnVlIGVhcmx5IG9uIHRoaXMsIGZvciB0aGUgY29tbW9uIGNhc2VcbiAgICAgICAgICAgIHJldHVybiAobyAmJiB0eXBlb2YgbyAhPT0gXCJzdHJpbmdcIiAmJiBZLkxhbmcuaXNOdW1iZXIoby5sZW5ndGgpICYmICFvLnRhZ05hbWUgJiYgIVkuRE9NLmlzV2luZG93KG8pKTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIGFsaWFzZXMgdG8gc3VwcG9ydCBET00gZXZlbnQgc3Vic2NyaXB0aW9uIGNsZWFuIHVwIHdoZW4gdGhlIGxhc3RcbiAgICAvLyBzdWJzY3JpYmVyIGlzIGRldGFjaGVkLiBkZWxldGVBbmRDbGVhbiBvdmVycmlkZXMgdGhlIERPTSBldmVudCdzIHdyYXBwZXJcbiAgICAvLyBDdXN0b21FdmVudCBfZGVsZXRlIG1ldGhvZC5cbiAgICBfY2VQcm90b0RlbGV0ZSA9IFkuQ3VzdG9tRXZlbnQucHJvdG90eXBlLl9kZWxldGUsXG4gICAgX2RlbGV0ZUFuZENsZWFuID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgcmV0ID0gX2NlUHJvdG9EZWxldGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICBpZiAoIXRoaXMuaGFzU3VicygpKSB7XG4gICAgICAgICAgICBZLkV2ZW50Ll9jbGVhbih0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuRXZlbnQgPSBmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIFRydWUgYWZ0ZXIgdGhlIG9ubG9hZCBldmVudCBoYXMgZmlyZWRcbiAgICAgKiBAcHJvcGVydHkgX2xvYWRDb21wbGV0ZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX2xvYWRDb21wbGV0ZSA9ICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcG9sbCBhZnRlciB3aW5kb3cub25sb2FkLiAgVGhpcyBudW1iZXIgaXNcbiAgICAgKiBpbmNyZWFzZWQgaWYgYWRkaXRpb25hbCBsYXRlLWJvdW5kIGhhbmRsZXJzIGFyZSByZXF1ZXN0ZWQgYWZ0ZXJcbiAgICAgKiB0aGUgcGFnZSBsb2FkLlxuICAgICAqIEBwcm9wZXJ0eSBfcmV0cnlDb3VudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXRyeUNvdW50ID0gMCxcblxuICAgIC8qKlxuICAgICAqIG9uQXZhaWxhYmxlIGxpc3RlbmVyc1xuICAgICAqIEBwcm9wZXJ0eSBfYXZhaWxcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXZhaWwgPSBbXSxcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBldmVudCB3cmFwcGVycyBmb3IgRE9NIGV2ZW50cy4gIEtleSBpc1xuICAgICAqICdldmVudDonICsgRWxlbWVudCB1aWQgc3RhbXAgKyBldmVudCB0eXBlXG4gICAgICogQHByb3BlcnR5IF93cmFwcGVyc1xuICAgICAqIEB0eXBlIEN1c3RvbUV2ZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3dyYXBwZXJzID0gX2V2ZW50ZW52LmRvbV93cmFwcGVycyxcblxuICAgIF93aW5kb3dMb2FkS2V5ID0gbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBldmVudCB3cmFwcGVyIG1hcCBET00gZXZlbnRzLiAgS2V5IGlzXG4gICAgICogRWxlbWVudCB1aWQgc3RhbXAuICBFYWNoIGl0ZW0gaXMgYSBoYXNoIG9mIGN1c3RvbSBldmVudFxuICAgICAqIHdyYXBwZXJzIGFzIHByb3ZpZGVkIGluIHRoZSBfd3JhcHBlcnMgY29sbGVjdGlvbi4gIFRoaXNcbiAgICAgKiBwcm92aWRlcyB0aGUgaW5mcmFzdHJ1Y3R1cmUgZm9yIGdldExpc3RlbmVycy5cbiAgICAgKiBAcHJvcGVydHkgX2VsX2V2ZW50c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9lbF9ldmVudHMgPSBfZXZlbnRlbnYuZG9tX21hcDtcblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgd2Ugc2hvdWxkIGxvb2sgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIG5vdFxuICAgICAgICAgKiBpbiB0aGUgRE9NIGF0IHRoZSB0aW1lIHRoZSBldmVudCBpcyByZXF1ZXN0ZWQgYWZ0ZXIgdGhlIGRvY3VtZW50XG4gICAgICAgICAqIGhhcyBiZWVuIGxvYWRlZC4gIFRoZSBkZWZhdWx0IGlzIDEwMDBAYW1wOzQwIG1zLCBzbyBpdCB3aWxsIHBvbGxcbiAgICAgICAgICogZm9yIDQwIHNlY29uZHMgb3IgdW50aWwgYWxsIG91dHN0YW5kaW5nIGhhbmRsZXJzIGFyZSBib3VuZFxuICAgICAgICAgKiAod2hpY2hldmVyIGNvbWVzIGZpcnN0KS5cbiAgICAgICAgICogQHByb3BlcnR5IFBPTExfUkVUUllTXG4gICAgICAgICAqIEB0eXBlIGludFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgUE9MTF9SRVRSWVM6IDEwMDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb2xsIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiBAcHJvcGVydHkgUE9MTF9JTlRFUlZBTFxuICAgICAgICAgKiBAdHlwZSBpbnRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIFBPTExfSU5URVJWQUw6IDQwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGRMaXN0ZW5lci9yZW1vdmVMaXN0ZW5lciBjYW4gdGhyb3cgZXJyb3JzIGluIHVuZXhwZWN0ZWQgc2NlbmFyaW9zLlxuICAgICAgICAgKiBUaGVzZSBlcnJvcnMgYXJlIHN1cHByZXNzZWQsIHRoZSBtZXRob2QgcmV0dXJucyBmYWxzZSwgYW5kIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICogaXMgc2V0XG4gICAgICAgICAqIEBwcm9wZXJ0eSBsYXN0RXJyb3JcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSBFcnJvclxuICAgICAgICAgKi9cbiAgICAgICAgbGFzdEVycm9yOiBudWxsLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHBvbGwgaGFuZGxlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfaW50ZXJ2YWxcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2ludGVydmFsOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkb2N1bWVudCByZWFkeXN0YXRlIHBvbGwgaGFuZGxlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfZHJpXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgICBfZHJpOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHdoZW4gdGhlIGRvY3VtZW50IGlzIGluaXRpYWxseSB1c2FibGVcbiAgICAgICAgICogQHByb3BlcnR5IERPTVJlYWR5XG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgRE9NUmVhZHk6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kIHN0YXJ0SW50ZXJ2YWxcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRJbnRlcnZhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIUV2ZW50Ll9pbnRlcnZhbCkge1xuRXZlbnQuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoRXZlbnQuX3BvbGwsIEV2ZW50LlBPTExfSU5URVJWQUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGVjdXRlcyB0aGUgc3VwcGxpZWQgY2FsbGJhY2sgd2hlbiB0aGUgaXRlbSB3aXRoIHRoZSBzdXBwbGllZFxuICAgICAgICAgKiBpZCBpcyBmb3VuZC4gIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB0byBleGVjdXRlIGJlaGF2aW9yIGFzXG4gICAgICAgICAqIHNvb24gYXMgcG9zc2libGUgYXMgdGhlIHBhZ2UgbG9hZHMuICBJZiB5b3UgdXNlIHRoaXMgYWZ0ZXIgdGhlXG4gICAgICAgICAqIGluaXRpYWwgcGFnZSBsb2FkIGl0IHdpbGwgcG9sbCBmb3IgYSBmaXhlZCB0aW1lIGZvciB0aGUgZWxlbWVudC5cbiAgICAgICAgICogVGhlIG51bWJlciBvZiB0aW1lcyBpdCB3aWxsIHBvbGwgYW5kIHRoZSBmcmVxdWVuY3kgYXJlXG4gICAgICAgICAqIGNvbmZpZ3VyYWJsZS4gIEJ5IGRlZmF1bHQgaXQgd2lsbCBwb2xsIGZvciAxMCBzZWNvbmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5UaGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgd2l0aCBhIHNpbmdsZSBwYXJhbWV0ZXI6XG4gICAgICAgICAqIHRoZSBjdXN0b20gb2JqZWN0IHBhcmFtZXRlciwgaWYgcHJvdmlkZWQuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIG9uQXZhaWxhYmxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHxzdHJpbmdbXX0gICBpZCB0aGUgaWQgb2YgdGhlIGVsZW1lbnQsIG9yIGFuIGFycmF5XG4gICAgICAgICAqIG9mIGlkcyB0byBsb29rIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gd2hhdCB0byBleGVjdXRlIHdoZW4gdGhlIGVsZW1lbnQgaXMgZm91bmQuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgIHBfb2JqIGFuIG9wdGlvbmFsIG9iamVjdCB0byBiZSBwYXNzZWQgYmFjayBhc1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICBhIHBhcmFtZXRlciB0byBmbi5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufG9iamVjdH0gIHBfb3ZlcnJpZGUgSWYgc2V0IHRvIHRydWUsIGZuIHdpbGwgZXhlY3V0ZVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICBpbiB0aGUgY29udGV4dCBvZiBwX29iaiwgaWYgc2V0IHRvIGFuIG9iamVjdCBpdFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICB3aWxsIGV4ZWN1dGUgaW4gdGhlIGNvbnRleHQgb2YgdGhhdCBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIGNoZWNrQ29udGVudCB7Ym9vbGVhbn0gY2hlY2sgY2hpbGQgbm9kZSByZWFkaW5lc3MgKG9uQ29udGVudFJlYWR5KVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBZLm9uKFwiYXZhaWxhYmxlXCIpXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAVE9ETyBmaXggYXJndW1lbnRzXG4gICAgICAgIG9uQXZhaWxhYmxlOiBmdW5jdGlvbihpZCwgZm4sIHBfb2JqLCBwX292ZXJyaWRlLCBjaGVja0NvbnRlbnQsIGNvbXBhdCkge1xuXG4gICAgICAgICAgICB2YXIgYSA9IFkuQXJyYXkoaWQpLCBpLCBhdmFpbEhhbmRsZTtcblxuICAgICAgICAgICAgZm9yIChpPTA7IGk8YS5sZW5ndGg7IGk9aSsxKSB7XG4gICAgICAgICAgICAgICAgX2F2YWlsLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogICAgICAgICBhW2ldLFxuICAgICAgICAgICAgICAgICAgICBmbjogICAgICAgICBmbixcbiAgICAgICAgICAgICAgICAgICAgb2JqOiAgICAgICAgcF9vYmosXG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlOiAgIHBfb3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUmVhZHk6IGNoZWNrQ29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgY29tcGF0OiAgICAgY29tcGF0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfcmV0cnlDb3VudCA9IHRoaXMuUE9MTF9SRVRSWVM7XG5cbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdGhlIGZpcnN0IHRlc3QgdG8gYmUgaW1tZWRpYXRlLCBidXQgYXN5bmNcbiAgICAgICAgICAgIFkuY29uZmlnLndpbi5zZXRUaW1lb3V0KEV2ZW50Ll9wb2xsLCAwKTtcblxuICAgICAgICAgICAgYXZhaWxIYW5kbGUgPSBuZXcgWS5FdmVudEhhbmRsZSh7XG5cbiAgICAgICAgICAgICAgICBfZGVsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGJ5IHRoZSBldmVudCBzeXN0ZW0gZm9yIGxhenkgRE9NIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXZhaWxIYW5kbGUuaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEhhbmRsZS5oYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgajtcblxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdHJ5IHRvIHJlbW92ZSB0aGUgb25BdmFpbGFibGUgbGlzdGVuZXIocylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBfYXZhaWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVtpXSA9PT0gX2F2YWlsW2pdLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hdmFpbC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGF2YWlsSGFuZGxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXb3JrcyB0aGUgc2FtZSB3YXkgYXMgb25BdmFpbGFibGUsIGJ1dCBhZGRpdGlvbmFsbHkgY2hlY2tzIHRoZVxuICAgICAgICAgKiBzdGF0ZSBvZiBzaWJsaW5nIGVsZW1lbnRzIHRvIGRldGVybWluZSBpZiB0aGUgY29udGVudCBvZiB0aGVcbiAgICAgICAgICogYXZhaWxhYmxlIGVsZW1lbnQgaXMgc2FmZSB0byBtb2RpZnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCB3aXRoIGEgc2luZ2xlIHBhcmFtZXRlcjpcbiAgICAgICAgICogdGhlIGN1c3RvbSBvYmplY3QgcGFyYW1ldGVyLCBpZiBwcm92aWRlZC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgb25Db250ZW50UmVhZHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9ICAgaWQgdGhlIGlkIG9mIHRoZSBlbGVtZW50IHRvIGxvb2sgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiB3aGF0IHRvIGV4ZWN1dGUgd2hlbiB0aGUgZWxlbWVudCBpcyByZWFkeS5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9ICAgb2JqIGFuIG9wdGlvbmFsIG9iamVjdCB0byBiZSBwYXNzZWQgYmFjayBhc1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICBhIHBhcmFtZXRlciB0byBmbi5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufG9iamVjdH0gIG92ZXJyaWRlIElmIHNldCB0byB0cnVlLCBmbiB3aWxsIGV4ZWN1dGVcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgaW4gdGhlIGNvbnRleHQgb2YgcF9vYmouICBJZiBhbiBvYmplY3QsIGZuIHdpbGxcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgZXhlY3R1dGUgaW4gdGhlIGNvbnRleHQgb2YgdGhhdCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgWS5vbihcImNvbnRlbnRyZWFkeVwiKVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQFRPRE8gZml4IGFyZ3VtZW50c1xuICAgICAgICBvbkNvbnRlbnRSZWFkeTogZnVuY3Rpb24oaWQsIGZuLCBvYmosIG92ZXJyaWRlLCBjb21wYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBFdmVudC5vbkF2YWlsYWJsZShpZCwgZm4sIG9iaiwgb3ZlcnJpZGUsIHRydWUsIGNvbXBhdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhdHRhY2hcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICAgdHlwZSAgICAgVGhlIHR5cGUgb2YgZXZlbnQgdG8gYXBwZW5kXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgICAgICBUaGUgbWV0aG9kIHRoZSBldmVudCBpbnZva2VzXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fEFycmF5fE5vZGVMaXN0fSBlbCBBbiBpZCwgYW4gZWxlbWVudFxuICAgICAgICAgKiAgcmVmZXJlbmNlLCBvciBhIGNvbGxlY3Rpb24gb2YgaWRzIGFuZC9vciBlbGVtZW50cyB0byBhc3NpZ24gdGhlXG4gICAgICAgICAqICBsaXN0ZW5lciB0by5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9ICAgY29udGV4dCBvcHRpb25hbCBjb250ZXh0IG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW58b2JqZWN0fSAgYXJncyAwLi5uIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gYW4gb2JqZWN0IHRvIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGV0YWNoIHRoZSBsaXN0ZW5lclxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuXG4gICAgICAgIGF0dGFjaDogZnVuY3Rpb24odHlwZSwgZm4sIGVsLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gRXZlbnQuX2F0dGFjaChZLkFycmF5KGFyZ3VtZW50cywgMCwgdHJ1ZSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVXcmFwcGVyOiBmdW5jdGlvbiAoZWwsIHR5cGUsIGNhcHR1cmUsIGNvbXBhdCwgZmFjYWRlKSB7XG5cbiAgICAgICAgICAgIHZhciBjZXdyYXBwZXIsXG4gICAgICAgICAgICAgICAgZWsgID0gWS5zdGFtcChlbCksXG4gICAgICAgICAgICAgICAga2V5ID0gJ2V2ZW50OicgKyBlayArIHR5cGU7XG5cbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gZmFjYWRlKSB7XG4gICAgICAgICAgICAgICAga2V5ICs9ICduYXRpdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICBrZXkgKz0gJ2NhcHR1cmUnO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGNld3JhcHBlciA9IF93cmFwcGVyc1trZXldO1xuXG5cbiAgICAgICAgICAgIGlmICghY2V3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIENFIHdyYXBwZXJcbiAgICAgICAgICAgICAgICBjZXdyYXBwZXIgPSBZLnB1Ymxpc2goa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVtaXRGYWNhZGU6ZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRGbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNld3JhcHBlci5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2V3cmFwcGVyLm5vZGVSZWYgPSBjZXdyYXBwZXIubm9kZVJlZiB8fCBZLm9uZShjZXdyYXBwZXIuZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZXdyYXBwZXIubm9kZVJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY2V3cmFwcGVyLm92ZXJyaWRlcyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIGxhdGVyIHJlbW92ZUxpc3RlbmVyIGNhbGxzXG4gICAgICAgICAgICAgICAgY2V3cmFwcGVyLmVsID0gZWw7XG4gICAgICAgICAgICAgICAgY2V3cmFwcGVyLmtleSA9IGtleTtcbiAgICAgICAgICAgICAgICBjZXdyYXBwZXIuZG9ta2V5ID0gZWs7XG4gICAgICAgICAgICAgICAgY2V3cmFwcGVyLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGNld3JhcHBlci5mbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2V3cmFwcGVyLmZpcmUoRXZlbnQuZ2V0RXZlbnQoZSwgZWwsIChjb21wYXQgfHwgKGZhbHNlID09PSBmYWNhZGUpKSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2V3cmFwcGVyLmNhcHR1cmUgPSBjYXB0dXJlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsID09IHdpbiAmJiB0eXBlID09IFwibG9hZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdyBsb2FkIGhhcHBlbnMgb25jZVxuICAgICAgICAgICAgICAgICAgICBjZXdyYXBwZXIuZmlyZU9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfd2luZG93TG9hZEtleSA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2V3cmFwcGVyLl9kZWxldGUgPSBfZGVsZXRlQW5kQ2xlYW47XG5cbiAgICAgICAgICAgICAgICBfd3JhcHBlcnNba2V5XSA9IGNld3JhcHBlcjtcbiAgICAgICAgICAgICAgICBfZWxfZXZlbnRzW2VrXSA9IF9lbF9ldmVudHNbZWtdIHx8IHt9O1xuICAgICAgICAgICAgICAgIF9lbF9ldmVudHNbZWtdW2tleV0gPSBjZXdyYXBwZXI7XG5cbiAgICAgICAgICAgICAgICBhZGQoZWwsIHR5cGUsIGNld3JhcHBlci5mbiwgY2FwdHVyZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjZXdyYXBwZXI7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfYXR0YWNoOiBmdW5jdGlvbihhcmdzLCBjb25mKSB7XG5cbiAgICAgICAgICAgIHZhciBjb21wYXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlcywgb0VsLCBjZXdyYXBwZXIsIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZmlyZU5vdyA9IGZhbHNlLCByZXQsXG4gICAgICAgICAgICAgICAgdHlwZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgZm4gPSBhcmdzWzFdLFxuICAgICAgICAgICAgICAgIGVsID0gYXJnc1syXSB8fCB3aW4sXG4gICAgICAgICAgICAgICAgZmFjYWRlID0gY29uZiAmJiBjb25mLmZhY2FkZSxcbiAgICAgICAgICAgICAgICBjYXB0dXJlID0gY29uZiAmJiBjb25mLmNhcHR1cmUsXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzID0gY29uZiAmJiBjb25mLm92ZXJyaWRlcztcblxuICAgICAgICAgICAgaWYgKGFyZ3NbYXJncy5sZW5ndGgtMV0gPT09IENPTVBBVF9BUkcpIHtcbiAgICAgICAgICAgICAgICBjb21wYXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWZuIHx8ICFmbi5jYWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgZWwgYXJndW1lbnQgY2FuIGJlIGFuIGFycmF5IG9mIGVsZW1lbnRzIG9yIGVsZW1lbnQgaWRzLlxuICAgICAgICAgICAgaWYgKHNob3VsZEl0ZXJhdGUoZWwpKSB7XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVzPVtdO1xuXG4gICAgICAgICAgICAgICAgWS5lYWNoKGVsLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMl0gPSB2O1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVzLnB1c2goRXZlbnQuX2F0dGFjaChhcmdzLnNsaWNlKCksIGNvbmYpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiAoaGFuZGxlcy5sZW5ndGggPT09IDEpID8gaGFuZGxlc1swXSA6IGhhbmRsZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBZLkV2ZW50SGFuZGxlKGhhbmRsZXMpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZWwgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHdlIGFzc3VtZSBpdCBpc1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgdGhlIGlkIG9mIHRoZSBlbGVtZW50LiAgSWYgdGhlIHBhZ2UgaXMgbG9hZGVkXG4gICAgICAgICAgICAvLyB3ZSBjb252ZXJ0IGVsIHRvIHRoZSBhY3R1YWwgZWxlbWVudCwgb3RoZXJ3aXNlIHdlXG4gICAgICAgICAgICAvLyBkZWZlciBhdHRhY2hpbmcgdGhlIGV2ZW50IHVudGlsIHRoZSBlbGVtZW50IGlzXG4gICAgICAgICAgICAvLyByZWFkeVxuICAgICAgICAgICAgfSBlbHNlIGlmIChZLkxhbmcuaXNTdHJpbmcoZWwpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBvRWwgPSAoY29tcGF0KSA/IFkuRE9NLmJ5SWQoZWwpIDogWS5TZWxlY3Rvci5xdWVyeShlbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGF0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9FbCA9IFkuRE9NLmJ5SWQoZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgb0VsID0gWS5TZWxlY3Rvci5xdWVyeShlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvRWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb0VsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvRWwgPSBvRWxbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMl0gPSBvRWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50Ll9hdHRhY2goYXJncywgY29uZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob0VsKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZWwgPSBvRWw7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3QgZm91bmQgPSBkZWZlciBhZGRpbmcgdGhlIGV2ZW50IHVudGlsIHRoZSBlbGVtZW50IGlzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gRXZlbnQub25BdmFpbGFibGUoZWwsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuaGFuZGxlID0gRXZlbnQuX2F0dGFjaChhcmdzLCBjb25mKTtcblxuICAgICAgICAgICAgICAgICAgICB9LCBFdmVudCwgdHJ1ZSwgZmFsc2UsIGNvbXBhdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWxlbWVudCBzaG91bGQgYmUgYW4gaHRtbCBlbGVtZW50IG9yIG5vZGVcbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChZLk5vZGUgJiYgWS5pbnN0YW5jZU9mKGVsLCBZLk5vZGUpKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBZLk5vZGUuZ2V0RE9NTm9kZShlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNld3JhcHBlciA9IEV2ZW50Ll9jcmVhdGVXcmFwcGVyKGVsLCB0eXBlLCBjYXB0dXJlLCBjb21wYXQsIGZhY2FkZSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgWS5taXgoY2V3cmFwcGVyLm92ZXJyaWRlcywgb3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsID09IHdpbiAmJiB0eXBlID09IFwibG9hZFwiKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9hZCBpcyBjb21wbGV0ZSwgZmlyZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICAvLyBhbGwgc3Vic2NyaWJlcnMsIGluY2x1ZGluZyB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIG5vdGlmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChZVUkuRW52LndpbmRvd0xvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJlTm93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21wYXQpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0ID0gYXJnc1szXTtcblxuICAgICAgICAgICAgLy8gc2V0IGNvbnRleHQgdG8gdGhlIE5vZGUgaWYgbm90IHNwZWNpZmllZFxuICAgICAgICAgICAgLy8gcmV0ID0gY2V3cmFwcGVyLm9uLmFwcGx5KGNld3JhcHBlciwgdHJpbW1lZEFyZ3MpO1xuICAgICAgICAgICAgcmV0ID0gY2V3cmFwcGVyLl9vbihmbiwgY29udGV4dCwgKGFyZ3MubGVuZ3RoID4gNCkgPyBhcmdzLnNsaWNlKDQpIDogbnVsbCk7XG5cbiAgICAgICAgICAgIGlmIChmaXJlTm93KSB7XG4gICAgICAgICAgICAgICAgY2V3cmFwcGVyLmZpcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLiAgU3VwcG9ydHMgdGhlIHNpZ25hdHVyZSB0aGUgZXZlbnQgd2FzIGJvdW5kXG4gICAgICAgICAqIHdpdGgsIGJ1dCB0aGUgcHJlZmVycmVkIHdheSB0byByZW1vdmUgbGlzdGVuZXJzIGlzIHVzaW5nIHRoZSBoYW5kbGVcbiAgICAgICAgICogdGhhdCBpcyByZXR1cm5lZCB3aGVuIHVzaW5nIFkub25cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBkZXRhY2hcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZXZlbnQgdG8gcmVtb3ZlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgbWV0aG9kIHRoZSBldmVudCBpbnZva2VzLiAgSWYgZm4gaXNcbiAgICAgICAgICogdW5kZWZpbmVkLCB0aGVuIGFsbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIHR5cGUgb2YgZXZlbnQgYXJlXG4gICAgICAgICAqIHJlbW92ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fEFycmF5fE5vZGVMaXN0fEV2ZW50SGFuZGxlfSBlbCBBblxuICAgICAgICAgKiBldmVudCBoYW5kbGUsIGFuIGlkLCBhbiBlbGVtZW50IHJlZmVyZW5jZSwgb3IgYSBjb2xsZWN0aW9uXG4gICAgICAgICAqIG9mIGlkcyBhbmQvb3IgZWxlbWVudHMgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tLlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSB1bmJpbmQgd2FzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgZGV0YWNoOiBmdW5jdGlvbih0eXBlLCBmbiwgZWwsIG9iaikge1xuXG4gICAgICAgICAgICB2YXIgYXJncz1ZLkFycmF5KGFyZ3VtZW50cywgMCwgdHJ1ZSksIGNvbXBhdCwgbCwgb2ssIGksXG4gICAgICAgICAgICAgICAgaWQsIGNlO1xuXG4gICAgICAgICAgICBpZiAoYXJnc1thcmdzLmxlbmd0aC0xXSA9PT0gQ09NUEFUX0FSRykge1xuICAgICAgICAgICAgICAgIGNvbXBhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZS5kZXRhY2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5kZXRhY2goKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGVsIGFyZ3VtZW50IGNhbiBiZSBhIHN0cmluZ1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbCA9PSBcInN0cmluZ1wiKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBlbCA9IChjb21wYXQpID8gWS5ET00uYnlJZChlbCkgOiBZLmFsbChlbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhdCkge1xuICAgICAgICAgICAgICAgICAgICBlbCA9IFkuRE9NLmJ5SWQoZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gWS5TZWxlY3Rvci5xdWVyeShlbCk7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBlbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGwgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBlbFswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gRXZlbnQuZGV0YWNoLmFwcGx5KEV2ZW50LCBhcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsLmRldGFjaCkge1xuICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKDIsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5kZXRhY2guYXBwbHkoZWwsIGFyZ3MpO1xuICAgICAgICAgICAgLy8gVGhlIGVsIGFyZ3VtZW50IGNhbiBiZSBhbiBhcnJheSBvZiBlbGVtZW50cyBvciBlbGVtZW50IGlkcy5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSXRlcmF0ZShlbCkpIHtcbiAgICAgICAgICAgICAgICBvayA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChpPTAsIGw9ZWwubGVuZ3RoOyBpPGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzWzJdID0gZWxbaV07XG4gICAgICAgICAgICAgICAgICAgIG9rID0gKCBZLkV2ZW50LmRldGFjaC5hcHBseShZLkV2ZW50LCBhcmdzKSAmJiBvayApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0eXBlIHx8ICFmbiB8fCAhZm4uY2FsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudC5wdXJnZUVsZW1lbnQoZWwsIGZhbHNlLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWQgPSAnZXZlbnQ6JyArIFkuc3RhbXAoZWwpICsgdHlwZTtcbiAgICAgICAgICAgIGNlID0gX3dyYXBwZXJzW2lkXTtcblxuICAgICAgICAgICAgaWYgKGNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlLmRldGFjaChmbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kcyB0aGUgZXZlbnQgaW4gdGhlIHdpbmRvdyBvYmplY3QsIHRoZSBjYWxsZXIncyBhcmd1bWVudHMsIG9yXG4gICAgICAgICAqIGluIHRoZSBhcmd1bWVudHMgb2YgYW5vdGhlciBtZXRob2QgaW4gdGhlIGNhbGxzdGFjay4gIFRoaXMgaXNcbiAgICAgICAgICogZXhlY3V0ZWQgYXV0b21hdGljYWxseSBmb3IgZXZlbnRzIHJlZ2lzdGVyZWQgdGhyb3VnaCB0aGUgZXZlbnRcbiAgICAgICAgICogbWFuYWdlciwgc28gdGhlIGltcGxlbWVudGVyIHNob3VsZCBub3Qgbm9ybWFsbHkgbmVlZCB0byBleGVjdXRlXG4gICAgICAgICAqIHRoaXMgZnVuY3Rpb24gYXQgYWxsLlxuICAgICAgICAgKiBAbWV0aG9kIGdldEV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgdGhlIGV2ZW50IHBhcmFtZXRlciBmcm9tIHRoZSBoYW5kbGVyXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBlbGVtZW50IHRoZSBsaXN0ZW5lciB3YXMgYXR0YWNoZWQgdG9cbiAgICAgICAgICogQHJldHVybiB7RXZlbnR9IHRoZSBldmVudFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFdmVudDogZnVuY3Rpb24oZSwgZWwsIG5vRmFjYWRlKSB7XG4gICAgICAgICAgICB2YXIgZXYgPSBlIHx8IHdpbi5ldmVudDtcblxuICAgICAgICAgICAgcmV0dXJuIChub0ZhY2FkZSkgPyBldiA6XG4gICAgICAgICAgICAgICAgbmV3IFkuRE9NRXZlbnRGYWNhZGUoZXYsIGVsLCBfd3JhcHBlcnNbJ2V2ZW50OicgKyBZLnN0YW1wKGVsKSArIGUudHlwZV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZXMgYW4gdW5pcXVlIElEIGZvciB0aGUgZWxlbWVudCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5XG4gICAgICAgICAqIGhhdmUgb25lLlxuICAgICAgICAgKiBAbWV0aG9kIGdlbmVyYXRlSWRcbiAgICAgICAgICogQHBhcmFtIGVsIHRoZSBlbGVtZW50IHRvIGNyZWF0ZSB0aGUgaWQgZm9yXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlc3VsdGluZyBpZCBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBnZW5lcmF0ZUlkOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFkuRE9NLmdlbmVyYXRlSUQoZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSB3YW50IHRvIGJlIGFibGUgdG8gdXNlIGdldEVsZW1lbnRzQnlUYWdOYW1lIGFzIGEgY29sbGVjdGlvblxuICAgICAgICAgKiB0byBhdHRhY2ggYSBncm91cCBvZiBldmVudHMgdG8uICBVbmZvcnR1bmF0ZWx5LCBkaWZmZXJlbnRcbiAgICAgICAgICogYnJvd3NlcnMgcmV0dXJuIGRpZmZlcmVudCB0eXBlcyBvZiBjb2xsZWN0aW9ucy4gIFRoaXMgZnVuY3Rpb25cbiAgICAgICAgICogdGVzdHMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBvYmplY3QgaXMgYXJyYXktbGlrZS4gIEl0IHdpbGwgYWxzb1xuICAgICAgICAgKiBmYWlsIGlmIHRoZSBvYmplY3QgaXMgYW4gYXJyYXksIGJ1dCBpcyBlbXB0eS5cbiAgICAgICAgICogQG1ldGhvZCBfaXNWYWxpZENvbGxlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIG8gdGhlIG9iamVjdCB0byB0ZXN0XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyBhcnJheS1saWtlIGFuZCBwb3B1bGF0ZWRcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgd2FzIG5vdCBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9pc1ZhbGlkQ29sbGVjdGlvbjogc2hvdWxkSXRlcmF0ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaG9vayB1cCBhbnkgZGVmZXJyZWQgbGlzdGVuZXJzXG4gICAgICAgICAqIEBtZXRob2QgX2xvYWRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2xvYWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICghX2xvYWRDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIF9sb2FkQ29tcGxldGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gSnVzdCBpbiBjYXNlIERPTVJlYWR5IGRpZCBub3QgZ28gb2ZmIGZvciBzb21lIHJlYXNvblxuICAgICAgICAgICAgICAgIC8vIEUuX3JlYWR5KCk7XG4gICAgICAgICAgICAgICAgaWYgKFkuZmlyZSkge1xuICAgICAgICAgICAgICAgICAgICBZLmZpcmUoRVZFTlRfUkVBRFkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEF2YWlsYWJsZSBlbGVtZW50cyBtYXkgbm90IGhhdmUgYmVlbiBkZXRlY3RlZCBiZWZvcmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gd2luZG93IGxvYWQgZXZlbnQgZmlyZXMuIFRyeSB0byBmaW5kIHRoZW0gbm93IHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVzZXIgaXMgbW9yZSBsaWtlbHkgdG8gZ2V0IHRoZSBvbkF2YWlsYWJsZSBub3RpZmljYXRpb25zXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIHRoZSB3aW5kb3cgbG9hZCBub3RpZmljYXRpb25cbiAgICAgICAgICAgICAgICBFdmVudC5fcG9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb2xsaW5nIGZ1bmN0aW9uIHRoYXQgcnVucyBiZWZvcmUgdGhlIG9ubG9hZCBldmVudCBmaXJlcyxcbiAgICAgICAgICogYXR0ZW1wdGluZyB0byBhdHRhY2ggdG8gRE9NIE5vZGVzIGFzIHNvb24gYXMgdGhleSBhcmVcbiAgICAgICAgICogYXZhaWxhYmxlXG4gICAgICAgICAqIEBtZXRob2QgX3BvbGxcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3BvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKEV2ZW50LmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFkuVUEuaWUgJiYgIVlVSS5FbnYuRE9NUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAvLyBIb2xkIG9mZiBpZiBET01SZWFkeSBoYXMgbm90IGZpcmVkIGFuZCBjaGVjayBjdXJyZW50XG4gICAgICAgICAgICAgICAgLy8gcmVhZHlTdGF0ZSB0byBwcm90ZWN0IGFnYWluc3QgdGhlIElFIG9wZXJhdGlvbiBhYm9ydGVkXG4gICAgICAgICAgICAgICAgLy8gaXNzdWUuXG4gICAgICAgICAgICAgICAgRXZlbnQuc3RhcnRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRXZlbnQubG9ja2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8ga2VlcCB0cnlpbmcgdW50aWwgYWZ0ZXIgdGhlIHBhZ2UgaXMgbG9hZGVkLiAgV2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHBhZ2UgbG9hZCBzdGF0ZSBwcmlvciB0byB0cnlpbmcgdG8gYmluZCB0aGVcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzIHNvIHRoYXQgd2UgY2FuIGJlIGNlcnRhaW4gYWxsIGVsZW1lbnRzIGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gdGVzdGVkIGFwcHJvcHJpYXRlbHlcbiAgICAgICAgICAgIHZhciBpLCBsZW4sIGl0ZW0sIGVsLCBub3RBdmFpbCwgZXhlY3V0ZUl0ZW0sXG4gICAgICAgICAgICAgICAgdHJ5QWdhaW4gPSAhX2xvYWRDb21wbGV0ZTtcblxuICAgICAgICAgICAgaWYgKCF0cnlBZ2Fpbikge1xuICAgICAgICAgICAgICAgIHRyeUFnYWluID0gKF9yZXRyeUNvdW50ID4gMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9uQXZhaWxhYmxlXG4gICAgICAgICAgICBub3RBdmFpbCA9IFtdO1xuXG4gICAgICAgICAgICBleGVjdXRlSXRlbSA9IGZ1bmN0aW9uIChlbCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0LCBvdiA9IGl0ZW0ub3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29tcGF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5vdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gaXRlbS5vYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IG92O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5mbi5jYWxsKGNvbnRleHQsIGl0ZW0ub2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBpdGVtLm9iaiB8fCBZLm9uZShlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmZuLmFwcGx5KGNvbnRleHQsIChZLkxhbmcuaXNBcnJheShvdikpID8gb3YgOiBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gb25BdmFpbGFibGVcbiAgICAgICAgICAgIGZvciAoaT0wLGxlbj1fYXZhaWwubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IF9hdmFpbFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiAhaXRlbS5jaGVja1JlYWR5KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZWwgPSAoaXRlbS5jb21wYXQpID8gWS5ET00uYnlJZChpdGVtLmlkKSA6IFkub25lKGl0ZW0uaWQpO1xuICAgICAgICAgICAgICAgICAgICBlbCA9IChpdGVtLmNvbXBhdCkgPyBZLkRPTS5ieUlkKGl0ZW0uaWQpIDogWS5TZWxlY3Rvci5xdWVyeShpdGVtLmlkLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVJdGVtKGVsLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hdmFpbFtpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RBdmFpbC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvbkNvbnRlbnRSZWFkeVxuICAgICAgICAgICAgZm9yIChpPTAsbGVuPV9hdmFpbC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gX2F2YWlsW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0uY2hlY2tSZWFkeSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsID0gKGl0ZW0uY29tcGF0KSA/IFkuRE9NLmJ5SWQoaXRlbS5pZCkgOiBZLm9uZShpdGVtLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSAoaXRlbS5jb21wYXQpID8gWS5ET00uYnlJZChpdGVtLmlkKSA6IFkuU2VsZWN0b3IucXVlcnkoaXRlbS5pZCwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBhdmFpbGFibGUsIGJ1dCBub3QgbmVjZXNzYXJpbHkgcmVhZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIHNob3VsZCB3ZSB0ZXN0IHBhcmVudE5vZGUubmV4dFNpYmxpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2xvYWRDb21wbGV0ZSB8fCAoZWwuZ2V0ICYmIGVsLmdldCgnbmV4dFNpYmxpbmcnKSkgfHwgZWwubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlSXRlbShlbCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2F2YWlsW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEF2YWlsLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9yZXRyeUNvdW50ID0gKG5vdEF2YWlsLmxlbmd0aCA9PT0gMCkgPyAwIDogX3JldHJ5Q291bnQgLSAxO1xuXG4gICAgICAgICAgICBpZiAodHJ5QWdhaW4pIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBtYXkgbmVlZCB0byBzdHJpcCB0aGUgbnVsbGVkIG91dCBpdGVtcyBoZXJlXG4gICAgICAgICAgICAgICAgRXZlbnQuc3RhcnRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKEV2ZW50Ll9pbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgRXZlbnQuX2ludGVydmFsID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRXZlbnQubG9ja2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gdGhlIGdpdmVuIGVsZW1lbnQgdmlhIGFkZExpc3RlbmVyLlxuICAgICAgICAgKiBPcHRpb25hbGx5LCB0aGUgbm9kZSdzIGNoaWxkcmVuIGNhbiBhbHNvIGJlIHB1cmdlZC5cbiAgICAgICAgICogT3B0aW9uYWxseSwgeW91IGNhbiBzcGVjaWZ5IGEgc3BlY2lmaWMgdHlwZSBvZiBldmVudCB0byByZW1vdmUuXG4gICAgICAgICAqIEBtZXRob2QgcHVyZ2VFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBlbGVtZW50IHRvIHB1cmdlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzZSByZWN1cnNpdmVseSBwdXJnZSB0aGlzIGVsZW1lbnQncyBjaGlsZHJlblxuICAgICAgICAgKiBhcyB3ZWxsLiAgVXNlIHdpdGggY2F1dGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgb3B0aW9uYWwgdHlwZSBvZiBsaXN0ZW5lciB0byBwdXJnZS4gSWZcbiAgICAgICAgICogbGVmdCBvdXQsIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHB1cmdlRWxlbWVudDogZnVuY3Rpb24oZWwsIHJlY3Vyc2UsIHR5cGUpIHtcbiAgICAgICAgICAgIC8vIHZhciBvRWwgPSAoWS5MYW5nLmlzU3RyaW5nKGVsKSkgPyBZLm9uZShlbCkgOiBlbCxcbiAgICAgICAgICAgIHZhciBvRWwgPSAoWS5MYW5nLmlzU3RyaW5nKGVsKSkgPyAgWS5TZWxlY3Rvci5xdWVyeShlbCwgbnVsbCwgdHJ1ZSkgOiBlbCxcbiAgICAgICAgICAgICAgICBsaXMgPSBFdmVudC5nZXRMaXN0ZW5lcnMob0VsLCB0eXBlKSwgaSwgbGVuLCBjaGlsZHJlbiwgY2hpbGQ7XG5cbiAgICAgICAgICAgIGlmIChyZWN1cnNlICYmIG9FbCkge1xuICAgICAgICAgICAgICAgIGxpcyA9IGxpcyB8fCBbXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IFkuU2VsZWN0b3IucXVlcnkoJyonLCBvRWwpO1xuICAgICAgICAgICAgICAgIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBFdmVudC5nZXRMaXN0ZW5lcnMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpcyA9IGxpcy5jb25jYXQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGlzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbGlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc1tpXS5kZXRhY2hBbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgb2JqZWN0IHJlZmVyZW5jZXMgYW5kIHRoZSBET00gcHJveHkgc3Vic2NyaXB0aW9uIGZvclxuICAgICAgICAgKiBhIGdpdmVuIGV2ZW50IGZvciBhIERPTSBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIF9jbGVhblxuICAgICAgICAgKiBAcGFyYW0gd3JhcHBlciB7Q3VzdG9tRXZlbnR9IEN1c3RvbSBldmVudCBwcm94eSBmb3IgdGhlIERPTVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAgICAgKi9cbiAgICAgICAgX2NsZWFuOiBmdW5jdGlvbiAod3JhcHBlcikge1xuICAgICAgICAgICAgdmFyIGtleSAgICA9IHdyYXBwZXIua2V5LFxuICAgICAgICAgICAgICAgIGRvbWtleSA9IHdyYXBwZXIuZG9ta2V5O1xuXG4gICAgICAgICAgICByZW1vdmUod3JhcHBlci5lbCwgd3JhcHBlci50eXBlLCB3cmFwcGVyLmZuLCB3cmFwcGVyLmNhcHR1cmUpO1xuICAgICAgICAgICAgZGVsZXRlIF93cmFwcGVyc1trZXldO1xuICAgICAgICAgICAgZGVsZXRlIFkuX3l1aWV2dC5ldmVudHNba2V5XTtcbiAgICAgICAgICAgIGlmIChfZWxfZXZlbnRzW2RvbWtleV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2VsX2V2ZW50c1tkb21rZXldW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCFZLk9iamVjdC5zaXplKF9lbF9ldmVudHNbZG9ta2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9lbF9ldmVudHNbZG9ta2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYWxsIGxpc3RlbmVycyBhdHRhY2hlZCB0byB0aGUgZ2l2ZW4gZWxlbWVudCB2aWEgYWRkTGlzdGVuZXIuXG4gICAgICAgICAqIE9wdGlvbmFsbHksIHlvdSBjYW4gc3BlY2lmeSBhIHNwZWNpZmljIHR5cGUgb2YgZXZlbnQgdG8gcmV0dXJuLlxuICAgICAgICAgKiBAbWV0aG9kIGdldExpc3RlbmVyc1xuICAgICAgICAgKiBAcGFyYW0gZWwge0hUTUxFbGVtZW50fHN0cmluZ30gdGhlIGVsZW1lbnQgb3IgZWxlbWVudCBpZCB0byBpbnNwZWN0XG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9IG9wdGlvbmFsIHR5cGUgb2YgbGlzdGVuZXIgdG8gcmV0dXJuLiBJZlxuICAgICAgICAgKiBsZWZ0IG91dCwgYWxsIGxpc3RlbmVycyB3aWxsIGJlIHJldHVybmVkXG4gICAgICAgICAqIEByZXR1cm4ge0N1c3RvbUV2ZW50fSB0aGUgY3VzdG9tIGV2ZW50IHdyYXBwZXIgZm9yIHRoZSBET00gZXZlbnQocylcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGlzdGVuZXJzOiBmdW5jdGlvbihlbCwgdHlwZSkge1xuICAgICAgICAgICAgdmFyIGVrID0gWS5zdGFtcChlbCwgdHJ1ZSksIGV2dHMgPSBfZWxfZXZlbnRzW2VrXSxcbiAgICAgICAgICAgICAgICByZXN1bHRzPVtdICwga2V5ID0gKHR5cGUpID8gJ2V2ZW50OicgKyBlayArIHR5cGUgOiBudWxsLFxuICAgICAgICAgICAgICAgIGFkYXB0ZXJzID0gX2V2ZW50ZW52LnBsdWdpbnM7XG5cbiAgICAgICAgICAgIGlmICghZXZ0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gbG9vayBmb3Igc3ludGhldGljIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChhZGFwdGVyc1t0eXBlXSAmJiBhZGFwdGVyc1t0eXBlXS5ldmVudERlZikge1xuICAgICAgICAgICAgICAgICAgICBrZXkgKz0gJ19zeW50aCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGV2dHNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZXZ0c1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgbmF0aXZlIGV2ZW50cyBhcyB3ZWxsXG4gICAgICAgICAgICAgICAga2V5ICs9ICduYXRpdmUnO1xuICAgICAgICAgICAgICAgIGlmIChldnRzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGV2dHNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFkuZWFjaChldnRzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChyZXN1bHRzLmxlbmd0aCkgPyByZXN1bHRzIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgYnkgcGUuZXZlbnQuICBDYWxsZWRcbiAgICAgICAgICogYXV0b21hdGljYWxseSBkdXJpbmcgdGhlIHVubG9hZCBldmVudC5cbiAgICAgICAgICogQG1ldGhvZCBfdW5sb2FkXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF91bmxvYWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIFkuZWFjaChfd3JhcHBlcnMsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAodi50eXBlID09ICd1bmxvYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHYuZmlyZShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdi5kZXRhY2hBbGwoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVtb3ZlKHdpbiwgXCJ1bmxvYWRcIiwgb25VbmxvYWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgRE9NIGV2ZW50IGRpcmVjdGx5IHdpdGhvdXQgdGhlIGNhY2hpbmcsIGNsZWFudXAsIGNvbnRleHQgYWRqLCBldGNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBuYXRpdmVBZGRcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgICAgICB0aGUgZWxlbWVudCB0byBiaW5kIHRoZSBoYW5kbGVyIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIHR5cGUgICB0aGUgdHlwZSBvZiBldmVudCBoYW5kbGVyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259ICAgIGZuICAgICAgdGhlIGNhbGxiYWNrIHRvIGludm9rZVxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgY2FwdHVyZSBjYXB0dXJlIG9yIGJ1YmJsZSBwaGFzZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBuYXRpdmVBZGQ6IGFkZCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmFzaWMgcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgbmF0aXZlUmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsICAgICAgdGhlIGVsZW1lbnQgdG8gYmluZCB0aGUgaGFuZGxlciB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICB0eXBlICAgdGhlIHR5cGUgb2YgZXZlbnQgaGFuZGxlclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAgICBmbiAgICAgIHRoZSBjYWxsYmFjayB0byBpbnZva2VcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgIGNhcHR1cmUgY2FwdHVyZSBvciBidWJibGUgcGhhc2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgbmF0aXZlUmVtb3ZlOiByZW1vdmVcbiAgICB9O1xuXG59KCk7XG5cblkuRXZlbnQgPSBFdmVudDtcblxuaWYgKGNvbmZpZy5pbmplY3RlZCB8fCBZVUkuRW52LndpbmRvd0xvYWRlZCkge1xuICAgIG9uTG9hZCgpO1xufSBlbHNlIHtcbiAgICBhZGQod2luLCBcImxvYWRcIiwgb25Mb2FkKTtcbn1cblxuLy8gUHJvY2VzcyBvbkF2YWlsYWJsZS9vbkNvbnRlbnRSZWFkeSBpdGVtcyB3aGVuIHdoZW4gdGhlIERPTSBpcyByZWFkeSBpbiBJRVxuaWYgKFkuVUEuaWUpIHtcbiAgICBZLm9uKEVWRU5UX1JFQURZLCBFdmVudC5fcG9sbCk7XG5cbiAgICAvLyBJbiBJRTYgYW5kIGJlbG93LCBkZXRhY2ggZXZlbnQgaGFuZGxlcnMgd2hlbiB0aGUgcGFnZSBpcyB1bmxvYWRlZCBpblxuICAgIC8vIG9yZGVyIHRvIHRyeSBhbmQgcHJldmVudCBjcm9zcy1wYWdlIG1lbW9yeSBsZWFrcy4gVGhpcyBpc24ndCBkb25lIGluXG4gICAgLy8gb3RoZXIgYnJvd3NlcnMgYmVjYXVzZSBhKSBpdCdzIG5vdCBuZWNlc3NhcnksIGFuZCBiKSBpdCBicmVha3MgdGhlXG4gICAgLy8gYmFjay9mb3J3YXJkIGNhY2hlLlxuICAgIGlmIChZLlVBLmllIDwgNykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYWRkKHdpbiwgXCJ1bmxvYWRcIiwgb25VbmxvYWQpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuRXZlbnQuQ3VzdG9tID0gWS5DdXN0b21FdmVudDtcbkV2ZW50LlN1YnNjcmliZXIgPSBZLlN1YnNjcmliZXI7XG5FdmVudC5UYXJnZXQgPSBZLkV2ZW50VGFyZ2V0O1xuRXZlbnQuSGFuZGxlID0gWS5FdmVudEhhbmRsZTtcbkV2ZW50LkZhY2FkZSA9IFkuRXZlbnRGYWNhZGU7XG5cbkV2ZW50Ll9wb2xsKCk7XG5cbn0oKSk7XG5cbi8qKlxuICogRE9NIGV2ZW50IGxpc3RlbmVyIGFic3RyYWN0aW9uIGxheWVyXG4gKiBAbW9kdWxlIGV2ZW50XG4gKiBAc3VibW9kdWxlIGV2ZW50LWJhc2VcbiAqL1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBjYWxsYmFjayBhcyBzb29uIGFzIHRoZSBzcGVjaWZpZWQgZWxlbWVudFxuICogaXMgZGV0ZWN0ZWQgaW4gdGhlIERPTS4gIFRoaXMgZnVuY3Rpb24gZXhwZWN0cyBhIHNlbGVjdG9yXG4gKiBzdHJpbmcgZm9yIHRoZSBlbGVtZW50KHMpIHRvIGRldGVjdC4gIElmIHlvdSBhbHJlYWR5IGhhdmVcbiAqIGFuIGVsZW1lbnQgcmVmZXJlbmNlLCB5b3UgZG9uJ3QgbmVlZCB0aGlzIGV2ZW50LlxuICogQGV2ZW50IGF2YWlsYWJsZVxuICogQHBhcmFtIHR5cGUge3N0cmluZ30gJ2F2YWlsYWJsZSdcbiAqIEBwYXJhbSBmbiB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlLlxuICogQHBhcmFtIGVsIHtzdHJpbmd9IGFuIHNlbGVjdG9yIGZvciB0aGUgZWxlbWVudChzKSB0byBhdHRhY2hcbiAqIEBwYXJhbSBjb250ZXh0IG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgc3BlY2lmaWVzIHdoYXQgJ3RoaXMnIHJlZmVycyB0by5cbiAqIEBwYXJhbSBhcmdzKiAwLi5uIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3Mgb24gdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogVGhlc2UgYXJndW1lbnRzIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhlIGV2ZW50IG9iamVjdC5cbiAqIEByZXR1cm4ge0V2ZW50SGFuZGxlfSB0aGUgZGV0YWNoIGhhbmRsZVxuICogQGZvciBZVUlcbiAqL1xuWS5FbnYuZXZ0LnBsdWdpbnMuYXZhaWxhYmxlID0ge1xuICAgIG9uOiBmdW5jdGlvbih0eXBlLCBmbiwgaWQsIG8pIHtcbiAgICAgICAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/ICBZLkFycmF5KGFyZ3VtZW50cywgNCwgdHJ1ZSkgOiBudWxsO1xuICAgICAgICByZXR1cm4gWS5FdmVudC5vbkF2YWlsYWJsZS5jYWxsKFkuRXZlbnQsIGlkLCBmbiwgbywgYSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgY2FsbGJhY2sgYXMgc29vbiBhcyB0aGUgc3BlY2lmaWVkIGVsZW1lbnRcbiAqIGlzIGRldGVjdGVkIGluIHRoZSBET00gd2l0aCBhIG5leHRTaWJsaW5nIHByb3BlcnR5XG4gKiAoaW5kaWNhdGluZyB0aGF0IHRoZSBlbGVtZW50J3MgY2hpbGRyZW4gYXJlIGF2YWlsYWJsZSkuXG4gKiBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgYSBzZWxlY3RvclxuICogc3RyaW5nIGZvciB0aGUgZWxlbWVudChzKSB0byBkZXRlY3QuICBJZiB5b3UgYWxyZWFkeSBoYXZlXG4gKiBhbiBlbGVtZW50IHJlZmVyZW5jZSwgeW91IGRvbid0IG5lZWQgdGhpcyBldmVudC5cbiAqIEBldmVudCBjb250ZW50cmVhZHlcbiAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9ICdjb250ZW50cmVhZHknXG4gKiBAcGFyYW0gZm4ge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAqIEBwYXJhbSBlbCB7c3RyaW5nfSBhbiBzZWxlY3RvciBmb3IgdGhlIGVsZW1lbnQocykgdG8gYXR0YWNoLlxuICogQHBhcmFtIGNvbnRleHQgb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBzcGVjaWZpZXMgd2hhdCAndGhpcycgcmVmZXJzIHRvLlxuICogQHBhcmFtIGFyZ3MqIDAuLm4gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyBvbiB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBUaGVzZSBhcmd1bWVudHMgd2lsbCBiZSBhZGRlZCBhZnRlciB0aGUgZXZlbnQgb2JqZWN0LlxuICogQHJldHVybiB7RXZlbnRIYW5kbGV9IHRoZSBkZXRhY2ggaGFuZGxlXG4gKiBAZm9yIFlVSVxuICovXG5ZLkVudi5ldnQucGx1Z2lucy5jb250ZW50cmVhZHkgPSB7XG4gICAgb246IGZ1bmN0aW9uKHR5cGUsIGZuLCBpZCwgbykge1xuICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gWS5BcnJheShhcmd1bWVudHMsIDQsIHRydWUpIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIFkuRXZlbnQub25Db250ZW50UmVhZHkuY2FsbChZLkV2ZW50LCBpZCwgZm4sIG8sIGEpO1xuICAgIH1cbn07XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImV2ZW50LWN1c3RvbS1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2V2ZW50LWN1c3RvbS1iYXNlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBDdXN0b20gZXZlbnQgZW5naW5lLCBET00gZXZlbnQgbGlzdGVuZXIgYWJzdHJhY3Rpb24gbGF5ZXIsIHN5bnRoZXRpYyBET01cbiAqIGV2ZW50cy5cbiAqIEBtb2R1bGUgZXZlbnQtY3VzdG9tXG4gKi9cblxuWS5FbnYuZXZ0ID0ge1xuICAgIGhhbmRsZXM6IHt9LFxuICAgIHBsdWdpbnM6IHt9XG59O1xuXG4vKipcbiAqIEN1c3RvbSBldmVudCBlbmdpbmUsIERPTSBldmVudCBsaXN0ZW5lciBhYnN0cmFjdGlvbiBsYXllciwgc3ludGhldGljIERPTVxuICogZXZlbnRzLlxuICogQG1vZHVsZSBldmVudC1jdXN0b21cbiAqIEBzdWJtb2R1bGUgZXZlbnQtY3VzdG9tLWJhc2VcbiAqL1xuXG4vKipcbiAqIEFsbG93cyBmb3IgdGhlIGluc2VydGlvbiBvZiBtZXRob2RzIHRoYXQgYXJlIGV4ZWN1dGVkIGJlZm9yZSBvciBhZnRlclxuICogYSBzcGVjaWZpZWQgbWV0aG9kXG4gKiBAY2xhc3MgRG9cbiAqIEBzdGF0aWNcbiAqL1xuXG52YXIgRE9fQkVGT1JFID0gMCxcbiAgICBET19BRlRFUiA9IDEsXG5cbkRPID0ge1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgb2Ygb2JqZWN0cyB0b3VjaGVkIGJ5IHRoZSB1dGlsaXR5XG4gICAgICogQHByb3BlcnR5IG9ianNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGRlcHJlY2F0ZWQgU2luY2UgMy42LjAuIFRoZSBgX3l1aWFvcGAgcHJvcGVydHkgb24gdGhlIEFPUCdkIG9iamVjdFxuICAgICAqIHJlcGxhY2VzIHRoZSByb2xlIG9mIHRoaXMgcHJvcGVydHksIGJ1dCBpcyBjb25zaWRlcmVkIHRvIGJlIHByaXZhdGUsIGFuZFxuICAgICAqIGlzIG9ubHkgbWVudGlvbmVkIHRvIHByb3ZpZGUgYSBtaWdyYXRpb24gcGF0aC5cbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGEgdXNlIGNhc2Ugd2hpY2ggd2FycmFudHMgbWlncmF0aW9uIHRvIHRoZSBfeXVpYW9wIHByb3BlcnR5LFxuICAgICAqIHBsZWFzZSBmaWxlIGEgdGlja2V0IHRvIGxldCB1cyBrbm93IHdoYXQgaXQncyB1c2VkIGZvciBhbmQgd2UgY2FuIHNlZSBpZlxuICAgICAqIHdlIG5lZWQgdG8gZXhwb3NlIGhvb2tzIGZvciB0aGF0IGZ1bmN0aW9uYWxpdHkgbW9yZSBmb3JtYWxseS5cbiAgICAgKi9cbiAgICBvYmpzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogPHA+RXhlY3V0ZSB0aGUgc3VwcGxpZWQgbWV0aG9kIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLiAgV3JhcHBpbmdcbiAgICAgKiBmdW5jdGlvbiBtYXkgb3B0aW9uYWxseSByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIHRvXG4gICAgICogZnVydGhlciBhbHRlciBydW50aW1lIGJlaGF2aW9yOjwvcD5cbiAgICAgKiA8ZGw+XG4gICAgICogICAgIDxkdD48L2NvZGU+WS5Eby5IYWx0KG1lc3NhZ2UsIHJldHVyblZhbHVlKTwvY29kZT48L2R0PlxuICAgICAqICAgICAgICAgPGRkPkltbWVkaWF0bHkgc3RvcCBleGVjdXRpb24gYW5kIHJldHVyblxuICAgICAqICAgICAgICAgPGNvZGU+cmV0dXJuVmFsdWU8L2NvZGU+LiAgTm8gb3RoZXIgd3JhcHBpbmcgZnVuY3Rpb25zIHdpbGwgYmVcbiAgICAgKiAgICAgICAgIGV4ZWN1dGVkLjwvZGQ+XG4gICAgICogICAgIDxkdD48L2NvZGU+WS5Eby5BbHRlckFyZ3MobWVzc2FnZSwgbmV3QXJnQXJyYXkpPC9jb2RlPjwvZHQ+XG4gICAgICogICAgICAgICA8ZGQ+UmVwbGFjZSB0aGUgYXJndW1lbnRzIHRoYXQgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpbGwgYmVcbiAgICAgKiAgICAgICAgIGNhbGxlZCB3aXRoLjwvZGQ+XG4gICAgICogICAgIDxkdD48L2NvZGU+WS5Eby5QcmV2ZW50KG1lc3NhZ2UpPC9jb2RlPjwvZHQ+XG4gICAgICogICAgICAgICA8ZGQ+RG9uJ3QgZXhlY3V0ZSB0aGUgd3JhcHBlZCBmdW5jdGlvbi4gIE90aGVyIGJlZm9yZSBwaGFzZVxuICAgICAqICAgICAgICAgd3JhcHBlcnMgd2lsbCBiZSBleGVjdXRlZC48L2RkPlxuICAgICAqIDwvZGw+XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGJlZm9yZVxuICAgICAqIEBwYXJhbSBmbiB7RnVuY3Rpb259IHRoZSBmdW5jdGlvbiB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IGhvc3RpbmcgdGhlIG1ldGhvZCB0byBkaXNwbGFjZVxuICAgICAqIEBwYXJhbSBzRm4ge3N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBkaXNwbGFjZVxuICAgICAqIEBwYXJhbSBjIFRoZSBleGVjdXRpb24gY29udGV4dCBmb3IgZm5cbiAgICAgKiBAcGFyYW0gYXJnKiB7bWl4ZWR9IDAuLm4gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc3VwcGx5IHRvIHRoZSBzdWJzY3JpYmVyXG4gICAgICogd2hlbiB0aGUgZXZlbnQgZmlyZXMuXG4gICAgICogQHJldHVybiB7RXZlbnRIYW5kbGV9IGhhbmRsZSBmb3IgdGhlIHN1YnNjcmlwdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBiZWZvcmU6IGZ1bmN0aW9uKGZuLCBvYmosIHNGbiwgYykge1xuICAgICAgICB2YXIgZiA9IGZuLCBhO1xuICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgYSA9IFtmbiwgY10uY29uY2F0KFkuQXJyYXkoYXJndW1lbnRzLCA0LCB0cnVlKSk7XG4gICAgICAgICAgICBmID0gWS5yYmluZC5hcHBseShZLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbmplY3QoRE9fQkVGT1JFLCBmLCBvYmosIHNGbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIDxwPkV4ZWN1dGUgdGhlIHN1cHBsaWVkIG1ldGhvZCBhZnRlciB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLiAgV3JhcHBpbmdcbiAgICAgKiBmdW5jdGlvbiBtYXkgb3B0aW9uYWxseSByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIHRvXG4gICAgICogZnVydGhlciBhbHRlciBydW50aW1lIGJlaGF2aW9yOjwvcD5cbiAgICAgKiA8ZGw+XG4gICAgICogICAgIDxkdD48L2NvZGU+WS5Eby5IYWx0KG1lc3NhZ2UsIHJldHVyblZhbHVlKTwvY29kZT48L2R0PlxuICAgICAqICAgICAgICAgPGRkPkltbWVkaWF0bHkgc3RvcCBleGVjdXRpb24gYW5kIHJldHVyblxuICAgICAqICAgICAgICAgPGNvZGU+cmV0dXJuVmFsdWU8L2NvZGU+LiAgTm8gb3RoZXIgd3JhcHBpbmcgZnVuY3Rpb25zIHdpbGwgYmVcbiAgICAgKiAgICAgICAgIGV4ZWN1dGVkLjwvZGQ+XG4gICAgICogICAgIDxkdD48L2NvZGU+WS5Eby5BbHRlclJldHVybihtZXNzYWdlLCByZXR1cm5WYWx1ZSk8L2NvZGU+PC9kdD5cbiAgICAgKiAgICAgICAgIDxkZD5SZXR1cm4gPGNvZGU+cmV0dXJuVmFsdWU8L2NvZGU+IGluc3RlYWQgb2YgdGhlIHdyYXBwZWRcbiAgICAgKiAgICAgICAgIG1ldGhvZCdzIG9yaWdpbmFsIHJldHVybiB2YWx1ZS4gIFRoaXMgY2FuIGJlIGZ1cnRoZXIgYWx0ZXJlZCBieVxuICAgICAqICAgICAgICAgb3RoZXIgYWZ0ZXIgcGhhc2Ugd3JhcHBlcnMuPC9kZD5cbiAgICAgKiA8L2RsPlxuICAgICAqXG4gICAgICogPHA+VGhlIHN0YXRpYyBwcm9wZXJ0aWVzIDxjb2RlPlkuRG8ub3JpZ2luYWxSZXRWYWw8L2NvZGU+IGFuZFxuICAgICAqIDxjb2RlPlkuRG8uY3VycmVudFJldFZhbDwvY29kZT4gd2lsbCBiZSBwb3B1bGF0ZWQgZm9yIHJlZmVyZW5jZS48L3A+XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFmdGVyXG4gICAgICogQHBhcmFtIGZuIHtGdW5jdGlvbn0gdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0gb2JqIHRoZSBvYmplY3QgaG9zdGluZyB0aGUgbWV0aG9kIHRvIGRpc3BsYWNlXG4gICAgICogQHBhcmFtIHNGbiB7c3RyaW5nfSB0aGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGRpc3BsYWNlXG4gICAgICogQHBhcmFtIGMgVGhlIGV4ZWN1dGlvbiBjb250ZXh0IGZvciBmblxuICAgICAqIEBwYXJhbSBhcmcqIHttaXhlZH0gMC4ubiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzdXBwbHkgdG8gdGhlIHN1YnNjcmliZXJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gaGFuZGxlIGZvciB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGFmdGVyOiBmdW5jdGlvbihmbiwgb2JqLCBzRm4sIGMpIHtcbiAgICAgICAgdmFyIGYgPSBmbiwgYTtcbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgIGEgPSBbZm4sIGNdLmNvbmNhdChZLkFycmF5KGFyZ3VtZW50cywgNCwgdHJ1ZSkpO1xuICAgICAgICAgICAgZiA9IFkucmJpbmQuYXBwbHkoWSwgYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faW5qZWN0KERPX0FGVEVSLCBmLCBvYmosIHNGbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIHN1cHBsaWVkIG1ldGhvZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICAgKiBVc2VkIGJ5IDxjb2RlPmJlZm9yZTwvY29kZT4gYW5kIDxjb2RlPmFmdGVyPC9jb2RlPi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2luamVjdFxuICAgICAqIEBwYXJhbSB3aGVuIHtzdHJpbmd9IGJlZm9yZSBvciBhZnRlclxuICAgICAqIEBwYXJhbSBmbiB7RnVuY3Rpb259IHRoZSBmdW5jdGlvbiB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IGhvc3RpbmcgdGhlIG1ldGhvZCB0byBkaXNwbGFjZVxuICAgICAqIEBwYXJhbSBzRm4ge3N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBkaXNwbGFjZVxuICAgICAqIEBwYXJhbSBjIFRoZSBleGVjdXRpb24gY29udGV4dCBmb3IgZm5cbiAgICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gaGFuZGxlIGZvciB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgX2luamVjdDogZnVuY3Rpb24od2hlbiwgZm4sIG9iaiwgc0ZuKSB7XG4gICAgICAgIC8vIG9iamVjdCBpZFxuICAgICAgICB2YXIgaWQgPSBZLnN0YW1wKG9iaiksIG8sIHNpZDtcblxuICAgICAgICBpZiAoIW9iai5feXVpYW9wKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBtYXAgZW50cnkgZm9yIHRoZSBvYmogaWYgaXQgZG9lc24ndCBleGlzdCwgdG8gaG9sZCBvdmVycmlkZGVuIG1ldGhvZHNcbiAgICAgICAgICAgIG9iai5feXVpYW9wID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBvID0gb2JqLl95dWlhb3A7XG5cbiAgICAgICAgaWYgKCFvW3NGbl0pIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG1hcCBlbnRyeSBmb3IgdGhlIG1ldGhvZCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBvW3NGbl0gPSBuZXcgWS5Eby5NZXRob2Qob2JqLCBzRm4pO1xuXG4gICAgICAgICAgICAvLyByZS1yb3V0ZSB0aGUgbWV0aG9kIHRvIG91ciB3cmFwcGVyXG4gICAgICAgICAgICBvYmpbc0ZuXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvW3NGbl0uZXhlYy5hcHBseShvW3NGbl0sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlciBpZFxuICAgICAgICBzaWQgPSBpZCArIFkuc3RhbXAoZm4pICsgc0ZuO1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBjYWxsYmFja1xuICAgICAgICBvW3NGbl0ucmVnaXN0ZXIoc2lkLCBmbiwgd2hlbik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBZLkV2ZW50SGFuZGxlKG9bc0ZuXSwgc2lkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIGEgYmVmb3JlIG9yIGFmdGVyIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGV0YWNoXG4gICAgICogQHBhcmFtIGhhbmRsZSB7RXZlbnRIYW5kbGV9IHRoZSBzdWJzY3JpcHRpb24gaGFuZGxlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRldGFjaDogZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgIGlmIChoYW5kbGUuZGV0YWNoKSB7XG4gICAgICAgICAgICBoYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5ZLkRvID0gRE87XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ29udGFpbnMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSB3cmFwcGVkIG1ldGhvZCwgYWNjZXNzaWJsZVxuICogYnkgJ2FmdGVyJyBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHByb3BlcnR5IG9yaWdpbmFsUmV0VmFsXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMy4yLjBcbiAqL1xuXG4vKipcbiAqIENvbnRhaW5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByZXR1cm4gdmFsdWUsIGNvbnN1bWFibGUgYnlcbiAqICdhZnRlcicgZXZlbnQgbGlzdGVuZXJzLCBhbmQgdXBkYXRlZCBpZiBhbiBhZnRlciBzdWJzY3JpYmVyXG4gKiBjaGFuZ2VzIHRoZSByZXR1cm4gdmFsdWUgZ2VuZXJhdGVkIGJ5IHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSBjdXJyZW50UmV0VmFsXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMy4yLjBcbiAqL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIGEgZGlzcGxhY2VkIG1ldGhvZCB3aXRoIGFvcCBlbmFibGVkXG4gKiBAY2xhc3MgRG8uTWV0aG9kXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBvcGVyYXRlIG9uXG4gKiBAcGFyYW0gc0ZuIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gZGlzcGxhY2VcbiAqL1xuRE8uTWV0aG9kID0gZnVuY3Rpb24ob2JqLCBzRm4pIHtcbiAgICB0aGlzLm9iaiA9IG9iajtcbiAgICB0aGlzLm1ldGhvZE5hbWUgPSBzRm47XG4gICAgdGhpcy5tZXRob2QgPSBvYmpbc0ZuXTtcbiAgICB0aGlzLmJlZm9yZSA9IHt9O1xuICAgIHRoaXMuYWZ0ZXIgPSB7fTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBhb3Agc3Vic2NyaWJlclxuICogQG1ldGhvZCByZWdpc3RlclxuICogQHBhcmFtIHNpZCB7c3RyaW5nfSB0aGUgc3Vic2NyaWJlciBpZFxuICogQHBhcmFtIGZuIHtGdW5jdGlvbn0gdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB3aGVuIHtzdHJpbmd9IHdoZW4gdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb25cbiAqL1xuRE8uTWV0aG9kLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChzaWQsIGZuLCB3aGVuKSB7XG4gICAgaWYgKHdoZW4pIHtcbiAgICAgICAgdGhpcy5hZnRlcltzaWRdID0gZm47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iZWZvcmVbc2lkXSA9IGZuO1xuICAgIH1cbn07XG5cbi8qKlxuICogVW5yZWdpc3RlciBhIGFvcCBzdWJzY3JpYmVyXG4gKiBAbWV0aG9kIGRlbGV0ZVxuICogQHBhcmFtIHNpZCB7c3RyaW5nfSB0aGUgc3Vic2NyaWJlciBpZFxuICogQHBhcmFtIGZuIHtGdW5jdGlvbn0gdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB3aGVuIHtzdHJpbmd9IHdoZW4gdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb25cbiAqL1xuRE8uTWV0aG9kLnByb3RvdHlwZS5fZGVsZXRlID0gZnVuY3Rpb24gKHNpZCkge1xuICAgIGRlbGV0ZSB0aGlzLmJlZm9yZVtzaWRdO1xuICAgIGRlbGV0ZSB0aGlzLmFmdGVyW3NpZF07XG59O1xuXG4vKipcbiAqIDxwPkV4ZWN1dGUgdGhlIHdyYXBwZWQgbWV0aG9kLiAgQWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGludG8gdGhlIHdyYXBwaW5nXG4gKiBmdW5jdGlvbnMuICBJZiBhbnkgb2YgdGhlIGJlZm9yZSB3cmFwcGVycyByZXR1cm4gYW4gaW5zdGFuY2Ugb2ZcbiAqIDxjb2RlPlkuRG8uSGFsdDwvY29kZT4gb3IgPGNvZGU+WS5Eby5QcmV2ZW50PC9jb2RlPiwgbmVpdGhlciB0aGUgd3JhcHBlZFxuICogZnVuY3Rpb24gbm9yIGFueSBhZnRlciBwaGFzZSBzdWJzY3JpYmVycyB3aWxsIGJlIGV4ZWN1dGVkLjwvcD5cbiAqXG4gKiA8cD5UaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgd3JhcHBlZCBmdW5jdGlvbiBvciBvbmVcbiAqIHByb3ZpZGVkIGJ5IGEgd3JhcHBlciBmdW5jdGlvbiB2aWEgYW4gaW5zdGFuY2Ugb2YgPGNvZGU+WS5Eby5IYWx0PC9jb2RlPiBvclxuICogPGNvZGU+WS5Eby5BbHRlclJldHVybjwvY29kZT4uXG4gKlxuICogQG1ldGhvZCBleGVjXG4gKiBAcGFyYW0gYXJnKiB7YW55fSBBcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGUgd3JhcHBpbmcgYW5kIHdyYXBwZWQgZnVuY3Rpb25zXG4gKiBAcmV0dXJuIHthbnl9IFJldHVybiB2YWx1ZSBvZiB3cmFwcGVkIGZ1bmN0aW9uIHVubGVzcyBvdmVyd3JpdHRlbiAoc2VlIGFib3ZlKVxuICovXG5ETy5NZXRob2QucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYXJncyA9IFkuQXJyYXkoYXJndW1lbnRzLCAwLCB0cnVlKSxcbiAgICAgICAgaSwgcmV0LCBuZXdSZXQsXG4gICAgICAgIGJmID0gdGhpcy5iZWZvcmUsXG4gICAgICAgIGFmID0gdGhpcy5hZnRlcixcbiAgICAgICAgcHJldmVudGVkID0gZmFsc2U7XG5cbiAgICAvLyBleGVjdXRlIGJlZm9yZVxuICAgIGZvciAoaSBpbiBiZikge1xuICAgICAgICBpZiAoYmYuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHJldCA9IGJmW2ldLmFwcGx5KHRoaXMub2JqLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJldC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERPLkhhbHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0LnJldFZhbDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBETy5BbHRlckFyZ3M6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gcmV0Lm5ld0FyZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBETy5QcmV2ZW50OlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4ZWN1dGUgbWV0aG9kXG4gICAgaWYgKCFwcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0ID0gdGhpcy5tZXRob2QuYXBwbHkodGhpcy5vYmosIGFyZ3MpO1xuICAgIH1cblxuICAgIERPLm9yaWdpbmFsUmV0VmFsID0gcmV0O1xuICAgIERPLmN1cnJlbnRSZXRWYWwgPSByZXQ7XG5cbiAgICAvLyBleGVjdXRlIGFmdGVyIG1ldGhvZHMuXG4gICAgZm9yIChpIGluIGFmKSB7XG4gICAgICAgIGlmIChhZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgbmV3UmV0ID0gYWZbaV0uYXBwbHkodGhpcy5vYmosIGFyZ3MpO1xuICAgICAgICAgICAgLy8gU3RvcCBwcm9jZXNzaW5nIGlmIGEgSGFsdCBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAgICAgICAgIGlmIChuZXdSZXQgJiYgbmV3UmV0LmNvbnN0cnVjdG9yID09PSBETy5IYWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1JldC5yZXRWYWw7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYSBuZXcgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1JldCAmJiBuZXdSZXQuY29uc3RydWN0b3IgPT09IERPLkFsdGVyUmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3UmV0Lm5ld1JldFZhbDtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHN0YXRpYyByZXR2YWwgc3RhdGVcbiAgICAgICAgICAgICAgICBETy5jdXJyZW50UmV0VmFsID0gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUmV0dXJuIGFuIEFsdGVyQXJncyBvYmplY3Qgd2hlbiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGFyZ3VtZW50cyB0aGF0XG4gKiB3ZXJlIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvbi4gIFVzZWZ1bCBmb3IgRG8uYmVmb3JlIHN1YnNjcmliZXJzLiAgQW5cbiAqIGV4YW1wbGUgd291bGQgYmUgYSBzZXJ2aWNlIHRoYXQgc2NydWJzIG91dCBpbGxlZ2FsIGNoYXJhY3RlcnMgcHJpb3IgdG9cbiAqIGV4ZWN1dGluZyB0aGUgY29yZSBidXNpbmVzcyBsb2dpYy5cbiAqIEBjbGFzcyBEby5BbHRlckFyZ3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIG1zZyB7U3RyaW5nfSAob3B0aW9uYWwpIEV4cGxhbmF0aW9uIG9mIHRoZSBhbHRlcmVkIHJldHVybiB2YWx1ZVxuICogQHBhcmFtIG5ld0FyZ3Mge0FycmF5fSBDYWxsIHBhcmFtZXRlcnMgdG8gYmUgdXNlZCBmb3IgdGhlIG9yaWdpbmFsIG1ldGhvZFxuICogICAgICAgICAgICAgICAgICAgICAgICBpbnN0ZWFkIG9mIHRoZSBhcmd1bWVudHMgb3JpZ2luYWxseSBwYXNzZWQgaW4uXG4gKi9cbkRPLkFsdGVyQXJncyA9IGZ1bmN0aW9uKG1zZywgbmV3QXJncykge1xuICAgIHRoaXMubXNnID0gbXNnO1xuICAgIHRoaXMubmV3QXJncyA9IG5ld0FyZ3M7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBBbHRlclJldHVybiBvYmplY3Qgd2hlbiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIHJlc3VsdCByZXR1cm5lZFxuICogZnJvbSB0aGUgY29yZSBtZXRob2QgdG8gdGhlIGNhbGxlci4gIFVzZWZ1bCBmb3IgRG8uYWZ0ZXIgc3Vic2NyaWJlcnMuXG4gKiBAY2xhc3MgRG8uQWx0ZXJSZXR1cm5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIG1zZyB7U3RyaW5nfSAob3B0aW9uYWwpIEV4cGxhbmF0aW9uIG9mIHRoZSBhbHRlcmVkIHJldHVybiB2YWx1ZVxuICogQHBhcmFtIG5ld1JldFZhbCB7YW55fSBSZXR1cm4gdmFsdWUgcGFzc2VkIHRvIGNvZGUgdGhhdCBpbnZva2VkIHRoZSB3cmFwcGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAqL1xuRE8uQWx0ZXJSZXR1cm4gPSBmdW5jdGlvbihtc2csIG5ld1JldFZhbCkge1xuICAgIHRoaXMubXNnID0gbXNnO1xuICAgIHRoaXMubmV3UmV0VmFsID0gbmV3UmV0VmFsO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBIYWx0IG9iamVjdCB3aGVuIHlvdSB3YW50IHRvIHRlcm1pbmF0ZSB0aGUgZXhlY3V0aW9uXG4gKiBvZiBhbGwgc3Vic2VxdWVudCBzdWJzY3JpYmVycyBhcyB3ZWxsIGFzIHRoZSB3cmFwcGVkIG1ldGhvZFxuICogaWYgaXQgaGFzIG5vdCBleGVjdHVlZCB5ZXQuICBVc2VmdWwgZm9yIERvLmJlZm9yZSBzdWJzY3JpYmVycy5cbiAqIEBjbGFzcyBEby5IYWx0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBtc2cge1N0cmluZ30gKG9wdGlvbmFsKSBFeHBsYW5hdGlvbiBvZiB3aHkgdGhlIHRlcm1pbmF0aW9uIHdhcyBkb25lXG4gKiBAcGFyYW0gcmV0VmFsIHthbnl9IFJldHVybiB2YWx1ZSBwYXNzZWQgdG8gY29kZSB0aGF0IGludm9rZWQgdGhlIHdyYXBwZWRcbiAqICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICovXG5ETy5IYWx0ID0gZnVuY3Rpb24obXNnLCByZXRWYWwpIHtcbiAgICB0aGlzLm1zZyA9IG1zZztcbiAgICB0aGlzLnJldFZhbCA9IHJldFZhbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgUHJldmVudCBvYmplY3Qgd2hlbiB5b3Ugd2FudCB0byBwcmV2ZW50IHRoZSB3cmFwcGVkIGZ1bmN0aW9uXG4gKiBmcm9tIGV4ZWN1dGluZywgYnV0IHdhbnQgdGhlIHJlbWFpbmluZyBsaXN0ZW5lcnMgdG8gZXhlY3V0ZS4gIFVzZWZ1bFxuICogZm9yIERvLmJlZm9yZSBzdWJzY3JpYmVycy5cbiAqIEBjbGFzcyBEby5QcmV2ZW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBtc2cge1N0cmluZ30gKG9wdGlvbmFsKSBFeHBsYW5hdGlvbiBvZiB3aHkgdGhlIHRlcm1pbmF0aW9uIHdhcyBkb25lXG4gKi9cbkRPLlByZXZlbnQgPSBmdW5jdGlvbihtc2cpIHtcbiAgICB0aGlzLm1zZyA9IG1zZztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIEVycm9yIG9iamVjdCB3aGVuIHlvdSB3YW50IHRvIHRlcm1pbmF0ZSB0aGUgZXhlY3V0aW9uXG4gKiBvZiBhbGwgc3Vic2VxdWVudCBtZXRob2QgY2FsbHMuXG4gKiBAY2xhc3MgRG8uRXJyb3JcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIG1zZyB7U3RyaW5nfSAob3B0aW9uYWwpIEV4cGxhbmF0aW9uIG9mIHRoZSBhbHRlcmVkIHJldHVybiB2YWx1ZVxuICogQHBhcmFtIHJldFZhbCB7YW55fSBSZXR1cm4gdmFsdWUgcGFzc2VkIHRvIGNvZGUgdGhhdCBpbnZva2VkIHRoZSB3cmFwcGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAqIEBkZXByZWNhdGVkIHVzZSBZLkRvLkhhbHQgb3IgWS5Eby5QcmV2ZW50XG4gKi9cbkRPLkVycm9yID0gRE8uSGFsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEN1c3RvbSBldmVudCBlbmdpbmUsIERPTSBldmVudCBsaXN0ZW5lciBhYnN0cmFjdGlvbiBsYXllciwgc3ludGhldGljIERPTVxuICogZXZlbnRzLlxuICogQG1vZHVsZSBldmVudC1jdXN0b21cbiAqIEBzdWJtb2R1bGUgZXZlbnQtY3VzdG9tLWJhc2VcbiAqL1xuXG5cbi8vIHZhciBvbnN1YnNjcmliZVR5cGUgPSBcIl9ldmVudDpvbnN1YlwiLFxudmFyIFlBcnJheSA9IFkuQXJyYXksXG5cbiAgICBBRlRFUiA9ICdhZnRlcicsXG4gICAgQ09ORklHUyA9IFtcbiAgICAgICAgJ2Jyb2FkY2FzdCcsXG4gICAgICAgICdtb25pdG9yZWQnLFxuICAgICAgICAnYnViYmxlcycsXG4gICAgICAgICdjb250ZXh0JyxcbiAgICAgICAgJ2NvbnRleHRGbicsXG4gICAgICAgICdjdXJyZW50VGFyZ2V0JyxcbiAgICAgICAgJ2RlZmF1bHRGbicsXG4gICAgICAgICdkZWZhdWx0VGFyZ2V0T25seScsXG4gICAgICAgICdkZXRhaWxzJyxcbiAgICAgICAgJ2VtaXRGYWNhZGUnLFxuICAgICAgICAnZmlyZU9uY2UnLFxuICAgICAgICAnYXN5bmMnLFxuICAgICAgICAnaG9zdCcsXG4gICAgICAgICdwcmV2ZW50YWJsZScsXG4gICAgICAgICdwcmV2ZW50ZWRGbicsXG4gICAgICAgICdxdWV1YWJsZScsXG4gICAgICAgICdzaWxlbnQnLFxuICAgICAgICAnc3RvcHBlZEZuJyxcbiAgICAgICAgJ3RhcmdldCcsXG4gICAgICAgICd0eXBlJ1xuICAgIF0sXG5cbiAgICBDT05GSUdTX0hBU0ggPSBZQXJyYXkuaGFzaChDT05GSUdTKSxcblxuICAgIG5hdGl2ZVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXG4gICAgWVVJM19TSUdOQVRVUkUgPSA5LFxuICAgIFlVSV9MT0cgPSAneXVpOmxvZycsXG5cbiAgICBtaXhDb25maWdzID0gZnVuY3Rpb24ociwgcywgb3YpIHtcbiAgICAgICAgdmFyIHA7XG5cbiAgICAgICAgZm9yIChwIGluIHMpIHtcbiAgICAgICAgICAgIGlmIChDT05GSUdTX0hBU0hbcF0gJiYgKG92IHx8ICEocCBpbiByKSkpIHtcbiAgICAgICAgICAgICAgICByW3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG5cbi8qKlxuICogVGhlIEN1c3RvbUV2ZW50IGNsYXNzIGxldHMgeW91IGRlZmluZSBldmVudHMgZm9yIHlvdXIgYXBwbGljYXRpb25cbiAqIHRoYXQgY2FuIGJlIHN1YnNjcmliZWQgdG8gYnkgb25lIG9yIG1vcmUgaW5kZXBlbmRlbnQgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50LCB3aGljaCBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrXG4gKiB3aGVuIHRoZSBldmVudCBmaXJlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0cyBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqIEBjbGFzcyBDdXN0b21FdmVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuIC8qKlxuICogVGhlIHR5cGUgb2YgZXZlbnQsIHJldHVybmVkIHRvIHN1YnNjcmliZXJzIHdoZW4gdGhlIGV2ZW50IGZpcmVzXG4gKiBAcHJvcGVydHkgdHlwZVxuICogQHR5cGUgc3RyaW5nXG4gKi9cblxuLyoqXG4gKiBCeSBkZWZhdWx0IGFsbCBjdXN0b20gZXZlbnRzIGFyZSBsb2dnZWQgaW4gdGhlIGRlYnVnIGJ1aWxkLCBzZXQgc2lsZW50XG4gKiB0byB0cnVlIHRvIGRpc2FibGUgZGVidWcgb3V0cHUgZm9yIHRoaXMgZXZlbnQuXG4gKiBAcHJvcGVydHkgc2lsZW50XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cblxuWS5DdXN0b21FdmVudCA9IGZ1bmN0aW9uKHR5cGUsIGRlZmF1bHRzKSB7XG5cbiAgICB0aGlzLl9rZHMgPSBZLkN1c3RvbUV2ZW50LmtlZXBEZXByZWNhdGVkU3VicztcblxuICAgIHRoaXMuaWQgPSBZLmd1aWQoKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zaWxlbnQgPSB0aGlzLmxvZ1N5c3RlbSA9ICh0eXBlID09PSBZVUlfTE9HKTtcblxuICAgIGlmICh0aGlzLl9rZHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdWJzY3JpYmVycyB0byB0aGlzIGV2ZW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBzdWJzY3JpYmVyc1xuICAgICAgICAgKiBAdHlwZSBTdWJzY3JpYmVyIHt9XG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAnQWZ0ZXInIHN1YnNjcmliZXJzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhZnRlcnNcbiAgICAgICAgICogQHR5cGUgU3Vic2NyaWJlciB7fVxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IHt9O1xuICAgICAgICB0aGlzLmFmdGVycyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChkZWZhdWx0cykge1xuICAgICAgICBtaXhDb25maWdzKHRoaXMsIGRlZmF1bHRzLCB0cnVlKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFN0YXRpYyBmbGFnIHRvIGVuYWJsZSBwb3B1bGF0aW9uIG9mIHRoZSA8YSBocmVmPVwiI3Byb3BlcnR5X3N1YnNjcmliZXJzXCI+YHN1YnNjcmliZXJzYDwvYT5cbiAqIGFuZCAgPGEgaHJlZj1cIiNwcm9wZXJ0eV9zdWJzY3JpYmVyc1wiPmBhZnRlcnNgPC9hPiBwcm9wZXJ0aWVzIGhlbGQgb24gYSBgQ3VzdG9tRXZlbnRgIGluc3RhbmNlLlxuICpcbiAqIFRoZXNlIHByb3BlcnRpZXMgd2VyZSBjaGFuZ2VkIHRvIHByaXZhdGUgcHJvcGVydGllcyAoYF9zdWJzY3JpYmVyc2AgYW5kIGBfYWZ0ZXJzYCksIGFuZFxuICogY29udmVydGVkIGZyb20gb2JqZWN0cyB0byBhcnJheXMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKlxuICogU2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIHRydWUgd2lsbCBwb3B1bGF0ZSB0aGUgZGVwcmVjYXRlZCBgc3Vic2NyaWJlcnNgIGFuZCBgYWZ0ZXJzYFxuICogcHJvcGVydGllcyBmb3IgcGVvcGxlIHdobyBtYXkgYmUgdXNpbmcgdGhlbSAod2hpY2ggaXMgZXhwZWN0ZWQgdG8gYmUgcmFyZSkuIFRoZXJlIHdpbGxcbiAqIGJlIGEgcGVyZm9ybWFuY2UgaGl0LCBjb21wYXJlZCB0byB0aGUgbmV3IGFycmF5IGJhc2VkIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIElmIHlvdSBhcmUgdXNpbmcgdGhlc2UgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzIGZvciBhIHVzZSBjYXNlIHdoaWNoIHRoZSBwdWJsaWMgQVBJXG4gKiBkb2VzIG5vdCBzdXBwb3J0LCBwbGVhc2UgZmlsZSBhbiBlbmhhbmNlbWVudCByZXF1ZXN0LCBhbmQgd2UgY2FuIHByb3ZpZGUgYW4gYWx0ZXJuYXRlXG4gKiBwdWJsaWMgaW1wbGVtZW50YXRpb24gd2hpY2ggZG9lc24ndCBoYXZlIHRoZSBwZXJmb3JtYW5jZSBjb3N0IHJlcXVpcmVkIHRvIG1haW50aWFpbiB0aGVcbiAqIHByb3BlcnRpZXMgYXMgb2JqZWN0cy5cbiAqXG4gKiBAcHJvcGVydHkga2VlcERlcHJlY2F0ZWRTdWJzXG4gKiBAc3RhdGljXG4gKiBAZm9yIEN1c3RvbUV2ZW50XG4gKiBAdHlwZSBib29sZWFuXG4gKiBAZGVmYXVsdCBmYWxzZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuWS5DdXN0b21FdmVudC5rZWVwRGVwcmVjYXRlZFN1YnMgPSBmYWxzZTtcblxuWS5DdXN0b21FdmVudC5taXhDb25maWdzID0gbWl4Q29uZmlncztcblxuWS5DdXN0b21FdmVudC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogWS5DdXN0b21FdmVudCxcblxuICAgIC8qKlxuICAgICAqIE1vbml0b3Igd2hlbiBhbiBldmVudCBpcyBhdHRhY2hlZCBvciBkZXRhY2hlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBtb25pdG9yZWRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBJZiAwLCB0aGlzIGV2ZW50IGRvZXMgbm90IGJyb2FkY2FzdC4gIElmIDEsIHRoZSBZVUkgaW5zdGFuY2UgaXMgbm90aWZpZWRcbiAgICAgKiBldmVyeSB0aW1lIHRoaXMgZXZlbnQgZmlyZXMuICBJZiAyLCB0aGUgWVVJIGluc3RhbmNlIGFuZCB0aGUgWVVJIGdsb2JhbFxuICAgICAqIChpZiBldmVudCBpcyBlbmFibGVkIG9uIHRoZSBnbG9iYWwpIGFyZSBub3RpZmllZCBldmVyeSB0aW1lIHRoaXMgZXZlbnRcbiAgICAgKiBmaXJlcy5cbiAgICAgKiBAcHJvcGVydHkgYnJvYWRjYXN0XG4gICAgICogQHR5cGUgaW50XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGlzIGV2ZW50IHNob3VsZCBiZSBxdWV1ZWQgd2hlbiB0aGUgaG9zdCBpcyBhY3RpdmVseVxuICAgICAqIHByb2Nlc3NpbmcgYW4gZXZlbnQuICBUaGlzIHdpbGwgZWZmZWN0IGV4ZWN0dXRpb24gb3JkZXIgb2YgdGhlIGNhbGxiYWNrc1xuICAgICAqIGZvciB0aGUgdmFyaW91cyBldmVudHMuXG4gICAgICogQHByb3BlcnR5IHF1ZXVhYmxlXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGhhcyBmaXJlZCBpZiB0cnVlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZmlyZWRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2U7XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBhcmd1bWVudHMgdGhlIGN1c3RvbSBldmVudFxuICAgICAqIHdhcyBsYXN0IGZpcmVkIHdpdGguXG4gICAgICogQHByb3BlcnR5IGZpcmVkV2l0aFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IHNob3VsZCBvbmx5IGZpcmUgb25lIHRpbWUgaWYgdHJ1ZSwgYW5kIGlmXG4gICAgICogaXQgaGFzIGZpcmVkLCBhbnkgbmV3IHN1YnNjcmliZXJzIHNob3VsZCBiZSBub3RpZmllZFxuICAgICAqIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZpcmVPbmNlXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlO1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogZmlyZU9uY2UgbGlzdGVuZXJzIHdpbGwgZmlyZSBzeW5jcm9ub3VzbHkgdW5sZXNzIGFzeW5jXG4gICAgICogaXMgc2V0IHRvIHRydWVcbiAgICAgKiBAcHJvcGVydHkgYXN5bmNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZsYWcgZm9yIHN0b3BQcm9wYWdhdGlvbiB0aGF0IGlzIG1vZGlmaWVkIGR1cmluZyBmaXJlKClcbiAgICAgKiAxIG1lYW5zIHRvIHN0b3AgcHJvcGFnYXRpb24gdG8gYnViYmxlIHRhcmdldHMuICAyIG1lYW5zXG4gICAgICogdG8gYWxzbyBzdG9wIGFkZGl0aW9uYWwgc3Vic2NyaWJlcnMgb24gdGhpcyB0YXJnZXQuXG4gICAgICogQHByb3BlcnR5IHN0b3BwZWRcbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZsYWcgZm9yIHByZXZlbnREZWZhdWx0IHRoYXQgaXMgbW9kaWZpZWQgZHVyaW5nIGZpcmUoKS5cbiAgICAgKiBpZiBpdCBpcyBub3QgMCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIHRoaXMgZXZlbnRcbiAgICAgKiBAcHJvcGVydHkgcHJldmVudGVkXG4gICAgICogQHR5cGUgaW50XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGhvc3QgZm9yIHRoaXMgY3VzdG9tIGV2ZW50LiAgVGhpcyBpcyB1c2VkXG4gICAgICogdG8gZW5hYmxlIGV2ZW50IGJ1YmJsaW5nXG4gICAgICogQHByb3BlcnR5IGhvc3RcbiAgICAgKiBAdHlwZSBFdmVudFRhcmdldFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBoYXZlIGZpcmUsIGJ1dCBvbmx5IGlmIHRoZSBkZWZhdWx0IGFjdGlvbiB3YXMgbm90XG4gICAgICogcHJldmVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0Rm5cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmxhZyBmb3IgdGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmx5IGlmIHRoZVxuICAgICAqIGZpcmluZyBldmVudCBpcyB0aGUgY3VycmVudCB0YXJnZXQuIFRoaXMgaGFwcGVucyBvbmx5XG4gICAgICogd2hlbiB1c2luZyBjdXN0b20gZXZlbnQgZGVsZWdhdGlvbiBhbmQgc2V0dGluZyB0aGVcbiAgICAgKiBmbGFnIHRvIGB0cnVlYCBtaW1pY3MgdGhlIGJlaGF2aW9yIG9mIGV2ZW50IGRlbGVnYXRpb25cbiAgICAgKiBpbiB0aGUgRE9NLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRlZmF1bHRUYXJnZXRPbmx5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiBhIHN1YnNjcmliZXIgY2FsbHNcbiAgICAgKiBzdG9wUHJvcGFnYXRpb24gb3Igc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG4gICAgICogQHByb3BlcnR5IHN0b3BwZWRGblxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiBhIHN1YnNjcmliZXIgY2FsbHNcbiAgICAgKiBwcmV2ZW50RGVmYXVsdFxuICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50ZWRGblxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3Vic2NyaWJlcnMgdG8gdGhpcyBldmVudFxuICAgICAqIEBwcm9wZXJ0eSBfc3Vic2NyaWJlcnNcbiAgICAgKiBAdHlwZSBTdWJzY3JpYmVyIFtdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqICdBZnRlcicgc3Vic2NyaWJlcnNcbiAgICAgKiBAcHJvcGVydHkgX2FmdGVyc1xuICAgICAqIEB0eXBlIFN1YnNjcmliZXIgW11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSBjdXN0b20gZXZlbnQgd2lsbCBkZWxpdmVyIGFuIEV2ZW50RmFjYWRlIG9iamVjdFxuICAgICAqIHRoYXQgaXMgc2ltaWxhciB0byBhIERPTSBldmVudCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IGVtaXRGYWNhZGVcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIG11bHRpcGxlIG9wdGlvbnMgZm9yIGxpc3RlbmVyIHNpZ25hdHVyZXMgaW4gb3JkZXIgdG9cbiAgICAgKiBwb3J0IFlVSSAyIGFwcHMuXG4gICAgICogQHByb3BlcnR5IHNpZ25hdHVyZVxuICAgICAqIEB0eXBlIGludFxuICAgICAqIEBkZWZhdWx0IDlcbiAgICAgKi9cbiAgICBzaWduYXR1cmUgOiBZVUkzX1NJR05BVFVSRSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZXh0IHRoZSB0aGUgZXZlbnQgd2lsbCBmaXJlIGZyb20gYnkgZGVmYXVsdC4gIERlZmF1bHRzIHRvIHRoZSBZVUlcbiAgICAgKiBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkgY29udGV4dFxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnRleHQgOiBZLFxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgZXZlbnQncyBkZWZhdWx0IGZ1bmN0aW9uXG4gICAgICogY2FuIGJlIGNhbmNlbGxlZCBieSBhIHN1YnNjcmliZXIgYnkgZXhlY3V0aW5nIHByZXZlbnREZWZhdWx0KClcbiAgICAgKiBvbiB0aGUgZXZlbnQgZmFjYWRlXG4gICAgICogQHByb3BlcnR5IHByZXZlbnRhYmxlXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBwcmV2ZW50YWJsZSA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgYSBzdWJzY3JpYmVyIGNhbiBzdG9wIHRoZSBldmVudCBwcm9wYWdhdGlvblxuICAgICAqIHZpYSBzdG9wUHJvcGFnYXRpb24oKSwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIG9yIGhhbHQoKVxuICAgICAqXG4gICAgICogRXZlbnRzIGNhbiBvbmx5IGJ1YmJsZSBpZiBlbWl0RmFjYWRlIGlzIHRydWUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYnViYmxlc1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgYnViYmxlcyA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3Vic2NyaWJlcnMgZm9yIHRoaXMgZXZlbnQgYXMgdGhlIHN1bSBvZiB0aGUgb24oKVxuICAgICAqIHN1YnNjcmliZXJzIGFuZCBhZnRlcigpIHN1YnNjcmliZXJzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBoYXNTdWJzXG4gICAgICogQHJldHVybiBOdW1iZXJcbiAgICAgKi9cbiAgICBoYXNTdWJzOiBmdW5jdGlvbih3aGVuKSB7XG4gICAgICAgIHZhciBzID0gMCxcbiAgICAgICAgICAgIGEgPSAwLFxuICAgICAgICAgICAgc3VicyA9IHRoaXMuX3N1YnNjcmliZXJzLFxuICAgICAgICAgICAgYWZ0ZXJzID0gdGhpcy5fYWZ0ZXJzLFxuICAgICAgICAgICAgc2liID0gdGhpcy5zaWJsaW5nO1xuXG4gICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICBzID0gc3Vicy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWZ0ZXJzKSB7XG4gICAgICAgICAgICBhID0gYWZ0ZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWIpIHtcbiAgICAgICAgICAgIHN1YnMgPSBzaWIuX3N1YnNjcmliZXJzO1xuICAgICAgICAgICAgYWZ0ZXJzID0gc2liLl9hZnRlcnM7XG5cbiAgICAgICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICAgICAgcyArPSBzdWJzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFmdGVycykge1xuICAgICAgICAgICAgICAgIGEgKz0gYWZ0ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gKHdoZW4gPT09ICdhZnRlcicpID8gYSA6IHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHMgKyBhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW9uaXRvciB0aGUgZXZlbnQgc3RhdGUgZm9yIHRoZSBzdWJzY3JpYmVkIGV2ZW50LiAgVGhlIGZpcnN0IHBhcmFtZXRlclxuICAgICAqIGlzIHdoYXQgc2hvdWxkIGJlIG1vbml0b3JlZCwgdGhlIHJlc3QgYXJlIHRoZSBub3JtYWwgcGFyYW1ldGVycyB3aGVuXG4gICAgICogc3Vic2NyaWJpbmcgdG8gYW4gZXZlbnQuXG4gICAgICogQG1ldGhvZCBtb25pdG9yXG4gICAgICogQHBhcmFtIHdoYXQge3N0cmluZ30gd2hhdCB0byBtb25pdG9yICgnZGV0YWNoJywgJ2F0dGFjaCcsICdwdWJsaXNoJykuXG4gICAgICogQHJldHVybiB7RXZlbnRIYW5kbGV9IHJldHVybiB2YWx1ZSBmcm9tIHRoZSBtb25pdG9yIGV2ZW50IHN1YnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBtb25pdG9yOiBmdW5jdGlvbih3aGF0KSB7XG4gICAgICAgIHRoaXMubW9uaXRvcmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmlkICsgJ3wnICsgdGhpcy50eXBlICsgJ18nICsgd2hhdCxcbiAgICAgICAgICAgIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIGFyZ3NbMF0gPSB0eXBlO1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0Lm9uLmFwcGx5KHRoaXMuaG9zdCwgYXJncyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgb2YgdGhlIHN1YnNjcmliZXJzIHRvIHRoaXMgZXZlbnQgYW5kIGFueSBzaWJsaW5nIGV2ZW50XG4gICAgICogQG1ldGhvZCBnZXRTdWJzXG4gICAgICogQHJldHVybiB7QXJyYXl9IGZpcnN0IGl0ZW0gaXMgdGhlIG9uIHN1YnNjcmliZXJzLCBzZWNvbmQgdGhlIGFmdGVyLlxuICAgICAqL1xuICAgIGdldFN1YnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzaWJsaW5nID0gdGhpcy5zaWJsaW5nLFxuICAgICAgICAgICAgc3VicyA9IHRoaXMuX3N1YnNjcmliZXJzLFxuICAgICAgICAgICAgYWZ0ZXJzID0gdGhpcy5fYWZ0ZXJzLFxuICAgICAgICAgICAgc2libGluZ1N1YnMsXG4gICAgICAgICAgICBzaWJsaW5nQWZ0ZXJzO1xuXG4gICAgICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICAgICAgICBzaWJsaW5nU3VicyA9IHNpYmxpbmcuX3N1YnNjcmliZXJzO1xuICAgICAgICAgICAgc2libGluZ0FmdGVycyA9IHNpYmxpbmcuX2FmdGVycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWJsaW5nU3Vicykge1xuICAgICAgICAgICAgaWYgKHN1YnMpIHtcbiAgICAgICAgICAgICAgICBzdWJzID0gc3Vicy5jb25jYXQoc2libGluZ1N1YnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJzID0gc2libGluZ1N1YnMuY29uY2F0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3Vicykge1xuICAgICAgICAgICAgICAgIHN1YnMgPSBzdWJzLmNvbmNhdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2libGluZ0FmdGVycykge1xuICAgICAgICAgICAgaWYgKGFmdGVycykge1xuICAgICAgICAgICAgICAgIGFmdGVycyA9IGFmdGVycy5jb25jYXQoc2libGluZ0FmdGVycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFmdGVycyA9IHNpYmxpbmdBZnRlcnMuY29uY2F0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXJzKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJzID0gYWZ0ZXJzLmNvbmNhdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZnRlcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbc3VicywgYWZ0ZXJzXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLiAgT25seSBhcHBsaWVzIHRoZSBDT05GSUcgd2hpdGVsaXN0XG4gICAgICogQG1ldGhvZCBhcHBseUNvbmZpZ1xuICAgICAqIEBwYXJhbSBvIGhhc2ggb2YgcHJvcGVydGllcyB0byBhcHBseS5cbiAgICAgKiBAcGFyYW0gZm9yY2Uge2Jvb2xlYW59IGlmIHRydWUsIHByb3BlcnRpZXMgdGhhdCBleGlzdCBvbiB0aGUgZXZlbnRcbiAgICAgKiB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICAgICAqL1xuICAgIGFwcGx5Q29uZmlnOiBmdW5jdGlvbihvLCBmb3JjZSkge1xuICAgICAgICBtaXhDb25maWdzKHRoaXMsIG8sIGZvcmNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBTdWJzY3JpcHRpb24gZm9yIHN1YnNjcmliaW5nIGZ1bmN0aW9uLCBjb250ZXh0LCBhbmQgYm91bmRcbiAgICAgKiBhcmd1bWVudHMuICBJZiB0aGlzIGlzIGEgZmlyZU9uY2UgZXZlbnQsIHRoZSBzdWJzY3JpYmVyIGlzIGltbWVkaWF0ZWx5XG4gICAgICogbm90aWZpZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9vblxuICAgICAqIEBwYXJhbSBmbiB7RnVuY3Rpb259IFN1YnNjcmlwdGlvbiBjYWxsYmFja1xuICAgICAqIEBwYXJhbSBbY29udGV4dF0ge09iamVjdH0gT3ZlcnJpZGUgYHRoaXNgIGluIHRoZSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSBbYXJnc10ge0FycmF5fSBib3VuZCBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgYWZ0ZXIgdGhlIGFyZ3VtZW50cyBnZW5lcmF0ZWQgYnkgZmlyZSgpXG4gICAgICogQHBhcmFtIFt3aGVuXSB7U3RyaW5nfSBcImFmdGVyXCIgdG8gc2xvdCBpbnRvIGFmdGVyIHN1YnNjcmliZXJzXG4gICAgICogQHJldHVybiB7RXZlbnRIYW5kbGV9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9vbjogZnVuY3Rpb24oZm4sIGNvbnRleHQsIGFyZ3MsIHdoZW4pIHtcblxuXG4gICAgICAgIHZhciBzID0gbmV3IFkuU3Vic2NyaWJlcihmbiwgY29udGV4dCwgYXJncywgd2hlbiksXG4gICAgICAgICAgICBmaXJlZFdpdGg7XG5cbiAgICAgICAgaWYgKHRoaXMuZmlyZU9uY2UgJiYgdGhpcy5maXJlZCkge1xuXG4gICAgICAgICAgICBmaXJlZFdpdGggPSB0aGlzLmZpcmVkV2l0aDtcblxuICAgICAgICAgICAgLy8gSXQncyBhIGxpdHRsZSB1Z2x5IGZvciB0aGlzIHRvIGtub3cgYWJvdXQgZmFjYWRlcyxcbiAgICAgICAgICAgIC8vIGJ1dCBnaXZlbiB0aGUgY3VycmVudCBicmVha3VwLCBub3QgbXVjaCBjaG9pY2Ugd2l0aG91dFxuICAgICAgICAgICAgLy8gbW92aW5nIGEgd2hvbGUgbG90IG9mIHN0dWZmIGFyb3VuZC5cbiAgICAgICAgICAgIGlmICh0aGlzLmVtaXRGYWNhZGUgJiYgdGhpcy5fYWRkRmFjYWRlVG9BcmdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRmFjYWRlVG9BcmdzKGZpcmVkV2l0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgWS5jb25maWcud2luLnNldFRpbWVvdXQoWS5iaW5kKHRoaXMuX25vdGlmeSwgdGhpcywgcywgZmlyZWRXaXRoKSwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeShzLCBmaXJlZFdpdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdoZW4gPT09IEFGVEVSKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2FmdGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FmdGVycyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWZ0ZXJzLnB1c2gocyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZXJzLnB1c2gocyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fa2RzKSB7XG4gICAgICAgICAgICBpZiAod2hlbiA9PT0gQUZURVIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFmdGVyc1tzLmlkXSA9IHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnNbcy5pZF0gPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBZLkV2ZW50SGFuZGxlKHRoaXMsIHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZm9yIHRoaXMgZXZlbnRcbiAgICAgKiBAbWV0aG9kIHN1YnNjcmliZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlLlxuICAgICAqIEByZXR1cm4ge0V2ZW50SGFuZGxlfSBVbnN1YnNjcmliZSBoYW5kbGUuXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIG9uLlxuICAgICAqL1xuICAgIHN1YnNjcmliZTogZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGEgPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIpID8gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uKGZuLCBjb250ZXh0LCBhLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciB0aGlzIGV2ZW50XG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IG9wdGlvbmFsIGV4ZWN1dGlvbiBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IGFyZyogMC4ubiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzdXBwbHkgdG8gdGhlIHN1YnNjcmliZXJcbiAgICAgKiB3aGVuIHRoZSBldmVudCBmaXJlcy5cbiAgICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gQW4gb2JqZWN0IHdpdGggYSBkZXRhY2ggbWV0aG9kIHRvIGRldGNoIHRoZSBoYW5kbGVyKHMpLlxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgYSA9IChhcmd1bWVudHMubGVuZ3RoID4gMikgPyBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLm1vbml0b3JlZCAmJiB0aGlzLmhvc3QpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdC5fbW9uaXRvcignYXR0YWNoJywgdGhpcywge1xuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3VtZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX29uKGZuLCBjb250ZXh0LCBhLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciB0aGlzIGV2ZW50IGFmdGVyIHRoZSBub3JtYWwgc3Vic2NyaWJlcnMgaGF2ZSBiZWVuIG5vdGlmaWVkIGFuZFxuICAgICAqIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGhhcyBiZWVuIGFwcGxpZWQuICBJZiBhIG5vcm1hbCBzdWJzY3JpYmVyIHByZXZlbnRzIHRoZVxuICAgICAqIGRlZmF1bHQgYmVoYXZpb3IsIGl0IGFsc28gcHJldmVudHMgYWZ0ZXIgbGlzdGVuZXJzIGZyb20gZmlyaW5nLlxuICAgICAqIEBtZXRob2QgYWZ0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBvcHRpb25hbCBleGVjdXRpb24gY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge21peGVkfSBhcmcqIDAuLm4gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc3VwcGx5IHRvIHRoZSBzdWJzY3JpYmVyXG4gICAgICogd2hlbiB0aGUgZXZlbnQgZmlyZXMuXG4gICAgICogQHJldHVybiB7RXZlbnRIYW5kbGV9IGhhbmRsZSBVbnN1YnNjcmliZSBoYW5kbGUuXG4gICAgICovXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBhID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyKSA/IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbihmbiwgY29udGV4dCwgYSwgQUZURVIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggbGlzdGVuZXJzLlxuICAgICAqIEBtZXRob2QgZGV0YWNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gIFRoZSBzdWJzY3JpYmVkIGZ1bmN0aW9uIHRvIHJlbW92ZSwgaWYgbm90IHN1cHBsaWVkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIGFsbCB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgY29udGV4dCBUaGUgY29udGV4dCBvYmplY3QgcGFzc2VkIHRvIHN1YnNjcmliZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJldHVybnMgdGhlIG51bWJlciBvZiBzdWJzY3JpYmVycyB1bnN1YnNjcmliZWQuXG4gICAgICovXG4gICAgZGV0YWNoOiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBoYW5kbGVcbiAgICAgICAgaWYgKGZuICYmIGZuLmRldGFjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmRldGFjaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksIHMsXG4gICAgICAgICAgICBmb3VuZCA9IDAsXG4gICAgICAgICAgICBzdWJzID0gdGhpcy5fc3Vic2NyaWJlcnMsXG4gICAgICAgICAgICBhZnRlcnMgPSB0aGlzLl9hZnRlcnM7XG5cbiAgICAgICAgaWYgKHN1YnMpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IHN1YnMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHMgPSBzdWJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzICYmICghZm4gfHwgZm4gPT09IHMuZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGV0ZShzLCBzdWJzLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWZ0ZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBhZnRlcnMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHMgPSBhZnRlcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHMgJiYgKCFmbiB8fCBmbiA9PT0gcy5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsZXRlKHMsIGFmdGVycywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggbGlzdGVuZXJzLlxuICAgICAqIEBtZXRob2QgdW5zdWJzY3JpYmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgVGhlIHN1YnNjcmliZWQgZnVuY3Rpb24gdG8gcmVtb3ZlLCBpZiBub3Qgc3VwcGxpZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgYWxsIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBjb250ZXh0IFRoZSBjb250ZXh0IG9iamVjdCBwYXNzZWQgdG8gc3Vic2NyaWJlLlxuICAgICAqIEByZXR1cm4ge2ludHx1bmRlZmluZWR9IHJldHVybnMgdGhlIG51bWJlciBvZiBzdWJzY3JpYmVycyB1bnN1YnNjcmliZWQuXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGRldGFjaC5cbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgYSBzaW5nbGUgc3Vic2NyaWJlclxuICAgICAqIEBtZXRob2QgX25vdGlmeVxuICAgICAqIEBwYXJhbSB7U3Vic2NyaWJlcn0gcyB0aGUgc3Vic2NyaWJlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIHRoZSBhcmd1bWVudHMgYXJyYXkgdG8gYXBwbHkgdG8gdGhlIGxpc3RlbmVyLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfbm90aWZ5OiBmdW5jdGlvbihzLCBhcmdzLCBlZikge1xuXG5cbiAgICAgICAgdmFyIHJldDtcblxuICAgICAgICByZXQgPSBzLm5vdGlmeShhcmdzLCB0aGlzKTtcblxuICAgICAgICBpZiAoZmFsc2UgPT09IHJldCB8fCB0aGlzLnN0b3BwZWQgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9nZ2VyIGFic3RyYWN0aW9uIHRvIGNlbnRyYWxpemUgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZSBzaWxlbnQgZmxhZ1xuICAgICAqIEBtZXRob2QgbG9nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1zZyBtZXNzYWdlIHRvIGxvZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0IGxvZyBjYXRlZ29yeS5cbiAgICAgKi9cbiAgICBsb2c6IGZ1bmN0aW9uKG1zZywgY2F0KSB7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBzdWJzY3JpYmVycy4gIFRoZSBjYWxsYmFjayBmdW5jdGlvbnMgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZyb20gdGhlIGNvbnRleHQgc3BlY2lmaWVkIHdoZW4gdGhlIGV2ZW50IHdhcyBjcmVhdGVkLCBhbmQgd2l0aCB0aGVcbiAgICAgKiBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgKiAgIDx1bD5cbiAgICAgKiAgIDxsaT5UaGUgdHlwZSBvZiBldmVudDwvbGk+XG4gICAgICogICA8bGk+QWxsIG9mIHRoZSBhcmd1bWVudHMgZmlyZSgpIHdhcyBleGVjdXRlZCB3aXRoIGFzIGFuIGFycmF5PC9saT5cbiAgICAgKiAgIDxsaT5UaGUgY3VzdG9tIG9iamVjdCAoaWYgYW55KSB0aGF0IHdhcyBwYXNzZWQgaW50byB0aGUgc3Vic2NyaWJlKClcbiAgICAgKiAgICAgICBtZXRob2Q8L2xpPlxuICAgICAqICAgPC91bD5cbiAgICAgKiBAbWV0aG9kIGZpcmVcbiAgICAgKiBAcGFyYW0ge09iamVjdCp9IGFyZ3VtZW50cyBhbiBhcmJpdHJhcnkgc2V0IG9mIHBhcmFtZXRlcnMgdG8gcGFzcyB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBoYW5kbGVyLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGZhbHNlIGlmIG9uZSBvZiB0aGUgc3Vic2NyaWJlcnMgcmV0dXJuZWQgZmFsc2UsXG4gICAgICogICAgICAgICAgICAgICAgICAgdHJ1ZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmaXJlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBwdXNoIGlzIHRoZSBmYXN0ZXN0IHdheSB0byBnbyBmcm9tIGFyZ3VtZW50cyB0byBhcnJheXNcbiAgICAgICAgLy8gZm9yIG1vc3QgYnJvd3NlcnMgY3VycmVudGx5XG4gICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL3B1c2gtdnMtY29uY2F0LXZzLXNsaWNlLzJcblxuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZmlyZShhcmdzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBmb3IgYGZpcmVgLCB3aGljaCBpcyBjYW4gYmUgdXNlZCBkaXJlY3RseSBieVxuICAgICAqIGBFdmVudFRhcmdldGAgYW5kIG90aGVyIGV2ZW50IG1vZHVsZSBjbGFzc2VzIHdoaWNoIGhhdmUgYWxyZWFkeSBjb252ZXJ0ZWQgZnJvbVxuICAgICAqIGFuIGBhcmd1bWVudHNgIGxpc3QgdG8gYW4gYXJyYXksIHRvIGF2b2lkIHRoZSByZXBlYXRlZCBvdmVyaGVhZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2ZpcmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFycmF5IG9mIGFyZ3VtZW50cyBwYXNzZWQgdG8gYmUgcGFzc2VkIHRvIGhhbmRsZXJzLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGZhbHNlIGlmIG9uZSBvZiB0aGUgc3Vic2NyaWJlcnMgcmV0dXJuZWQgZmFsc2UsIHRydWUgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIF9maXJlOiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZmlyZU9uY2UgJiYgdGhpcy5maXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgZG9lc24ndCBoYXBwZW4gaWYgdGhlIGV2ZW50IGlzbid0IHB1Ymxpc2hlZFxuICAgICAgICAgICAgLy8gdGhpcy5ob3N0Ll9tb25pdG9yKCdmaXJlJywgdGhpcy50eXBlLCBhcmdzKTtcblxuICAgICAgICAgICAgdGhpcy5maXJlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmZpcmVPbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlZFdpdGggPSBhcmdzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5lbWl0RmFjYWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyZUNvbXBsZXgoYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcmVTaW1wbGUoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIGZvciBub3RpZnlpbmcgc3Vic2NyaWJlcnMgb2Ygbm9uLWVtaXRGYWNhZGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBmaXJlU2ltcGxlXG4gICAgICogQHBhcmFtIGFyZ3Mge0FycmF5fSBBcmd1bWVudHMgcGFzc2VkIHRvIGZpcmUoKVxuICAgICAqIEByZXR1cm4gQm9vbGVhbiBmYWxzZSBpZiBhIHN1YnNjcmliZXIgcmV0dXJuZWQgZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZmlyZVNpbXBsZTogZnVuY3Rpb24oYXJncykge1xuICAgICAgICB0aGlzLnN0b3BwZWQgPSAwO1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmhhc1N1YnMoKSkge1xuICAgICAgICAgICAgdmFyIHN1YnMgPSB0aGlzLmdldFN1YnMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2NTdWJzKHN1YnNbMF0sIGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5fcHJvY1N1YnMoc3Vic1sxXSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnJvYWRjYXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9icm9hZGNhc3QoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcHBlZCA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gUmVxdWlyZXMgdGhlIGV2ZW50LWN1c3RvbS1jb21wbGV4IG1vZHVsZSBmb3IgZnVsbCBmdW5jaXRvbmFsaXR5LlxuICAgIGZpcmVDb21wbGV4OiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdIHx8IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5maXJlU2ltcGxlKGFyZ3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyBhIGxpc3Qgb2Ygc3Vic2NyaWJlcnMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9wcm9jU3Vic1xuICAgICAqIEBwYXJhbSBzdWJzIHtBcnJheX0gTGlzdCBvZiBzdWJzY3JpYmVyc1xuICAgICAqIEBwYXJhbSBhcmdzIHtBcnJheX0gQXJndW1lbnRzIHBhc3NlZCB0byBmaXJlKClcbiAgICAgKiBAcGFyYW0gZWYge31cbiAgICAgKiBAcmV0dXJuIEJvb2xlYW4gZmFsc2UgaWYgYSBzdWJzY3JpYmVyIHJldHVybnMgZmFsc2Ugb3Igc3RvcHMgdGhlIGV2ZW50XG4gICAgICogICAgICAgICAgICAgIHByb3BhZ2F0aW9uIHZpYSBlLnN0b3BQcm9wYWdhdGlvbigpLFxuICAgICAqICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBvciBlLmhhbHQoKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2NTdWJzOiBmdW5jdGlvbihzdWJzLCBhcmdzLCBlZikge1xuICAgICAgICB2YXIgcywgaSwgbDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBzdWJzW2ldO1xuICAgICAgICAgICAgaWYgKHMgJiYgcy5mbikge1xuICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gdGhpcy5fbm90aWZ5KHMsIGFyZ3MsIGVmKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhlIFlVSSBpbnN0YW5jZSBpZiB0aGUgZXZlbnQgaXMgY29uZmlndXJlZCB3aXRoIGJyb2FkY2FzdCA9IDEsXG4gICAgICogYW5kIGJvdGggdGhlIFlVSSBpbnN0YW5jZSBhbmQgWS5HbG9iYWwgaWYgY29uZmlndXJlZCB3aXRoIGJyb2FkY2FzdCA9IDIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9icm9hZGNhc3RcbiAgICAgKiBAcGFyYW0gYXJncyB7QXJyYXl9IEFyZ3VtZW50cyBzZW50IHRvIGZpcmUoKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Jyb2FkY2FzdDogZnVuY3Rpb24oYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuc3RvcHBlZCAmJiB0aGlzLmJyb2FkY2FzdCkge1xuXG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3MuY29uY2F0KCk7XG4gICAgICAgICAgICBhLnVuc2hpZnQodGhpcy50eXBlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaG9zdCAhPT0gWSkge1xuICAgICAgICAgICAgICAgIFkuZmlyZS5hcHBseShZLCBhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuYnJvYWRjYXN0ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgWS5HbG9iYWwuZmlyZS5hcHBseShZLkdsb2JhbCwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzXG4gICAgICogQG1ldGhvZCB1bnN1YnNjcmliZUFsbFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgdW5zdWJzY3JpYmVkLlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSBkZXRhY2hBbGwuXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXRhY2hBbGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzXG4gICAgICogQG1ldGhvZCBkZXRhY2hBbGxcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIHVuc3Vic2NyaWJlZC5cbiAgICAgKi9cbiAgICBkZXRhY2hBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXRhY2goKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgc3Vic2NyaWJlciBmcm9tIHRoZSBpbnRlcm5hbCBzdG9yZSBvZiBvbigpIGFuZCBhZnRlcigpXG4gICAgICogc3Vic2NyaWJlcnMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kZWxldGVcbiAgICAgKiBAcGFyYW0gcyBzdWJzY3JpYmVyIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gc3VicyAob3B0aW9uYWwpIG9uIG9yIGFmdGVyIHN1YnNjcmliZXIgYXJyYXlcbiAgICAgKiBAcGFyYW0gaW5kZXggKG9wdGlvbmFsKSBUaGUgaW5kZXggZm91bmQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVsZXRlOiBmdW5jdGlvbihzLCBzdWJzLCBpKSB7XG4gICAgICAgIHZhciB3aGVuID0gcy5fd2hlbjtcblxuICAgICAgICBpZiAoIXN1YnMpIHtcbiAgICAgICAgICAgIHN1YnMgPSAod2hlbiA9PT0gQUZURVIpID8gdGhpcy5fYWZ0ZXJzIDogdGhpcy5fc3Vic2NyaWJlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3Vicykge1xuICAgICAgICAgICAgaSA9IFlBcnJheS5pbmRleE9mKHN1YnMsIHMsIDApO1xuXG4gICAgICAgICAgICBpZiAocyAmJiBzdWJzW2ldID09PSBzKSB7XG4gICAgICAgICAgICAgICAgc3Vicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fa2RzKSB7XG4gICAgICAgICAgICBpZiAod2hlbiA9PT0gQUZURVIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5hZnRlcnNbcy5pZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN1YnNjcmliZXJzW3MuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubW9uaXRvcmVkICYmIHRoaXMuaG9zdCkge1xuICAgICAgICAgICAgdGhpcy5ob3N0Ll9tb25pdG9yKCdkZXRhY2gnLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgc3ViOiBzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICBzLmRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogU3RvcmVzIHRoZSBzdWJzY3JpYmVyIGluZm9ybWF0aW9uIHRvIGJlIHVzZWQgd2hlbiB0aGUgZXZlbnQgZmlyZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgICAgICBUaGUgd3JhcHBlZCBmdW5jdGlvbiB0byBleGVjdXRlLlxuICogQHBhcmFtIHtPYmplY3R9ICAgY29udGV4dCAgVGhlIHZhbHVlIG9mIHRoZSBrZXl3b3JkICd0aGlzJyBpbiB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzKiAgICAgICAwLi5uIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHN1cHBseSB0aGUgbGlzdGVuZXIuXG4gKlxuICogQGNsYXNzIFN1YnNjcmliZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5ZLlN1YnNjcmliZXIgPSBmdW5jdGlvbihmbiwgY29udGV4dCwgYXJncywgd2hlbikge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGZpcmVzXG4gICAgICogVGhpcyBpcyB3cmFwcGVkIGJ5IFkucmJpbmQgaWYgb2JqIHdhcyBzdXBwbGllZC5cbiAgICAgKiBAcHJvcGVydHkgZm5cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqL1xuICAgIHRoaXMuZm4gPSBmbjtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsICd0aGlzJyBrZXl3b3JkIGZvciB0aGUgbGlzdGVuZXJcbiAgICAgKiBAcHJvcGVydHkgY29udGV4dFxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBVbmlxdWUgc3Vic2NyaWJlciBpZFxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMuaWQgPSBZLmd1aWQoKTtcblxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHByb3BhZ2F0ZSB0byB0aGUgc3Vic2NyaWJlclxuICAgICAqIEBwcm9wZXJ0eSBhcmdzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuXG4gICAgdGhpcy5fd2hlbiA9IHdoZW47XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZXZlbnRzIGZvciBhIGdpdmVuIGZpcmUgdHJhbnNhY3Rpb24uXG4gICAgICogQHByb3BlcnR5IGV2ZW50c1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICAvLyB0aGlzLmV2ZW50cyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGxpc3RlbmVyIG9ubHkgcmVhY3RzIHRvIHRoZSBldmVudCBvbmNlXG4gICAgICogQHByb3BlcnR5IG9uY2VcbiAgICAgKi9cbiAgICAvLyB0aGlzLm9uY2UgPSBmYWxzZTtcblxufTtcblxuWS5TdWJzY3JpYmVyLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogWS5TdWJzY3JpYmVyLFxuXG4gICAgX25vdGlmeTogZnVuY3Rpb24oYywgYXJncywgY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsZXRlZCAmJiAhdGhpcy5wb3N0cG9uZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc3Rwb25lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZuO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBvc3Rwb25lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHRoaXMuYXJncywgcmV0O1xuICAgICAgICBzd2l0Y2ggKGNlLnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuZm4uY2FsbChjLCBjZS50eXBlLCBhcmdzLCBjKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLmZuLmNhbGwoYywgYXJnc1swXSB8fCBudWxsLCBjKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGEgfHwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgYSA9IChhKSA/IGFyZ3MuY29uY2F0KGEpIDogYXJncztcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5mbi5hcHBseShjLCBhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSB0aGlzLmZuLmNhbGwoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25jZSkge1xuICAgICAgICAgICAgY2UuX2RlbGV0ZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBzdWJzY3JpYmVyLlxuICAgICAqIEBtZXRob2Qgbm90aWZ5XG4gICAgICogQHBhcmFtIGFyZ3Mge0FycmF5fSBBcmd1bWVudHMgYXJyYXkgZm9yIHRoZSBzdWJzY3JpYmVyLlxuICAgICAqIEBwYXJhbSBjZSB7Q3VzdG9tRXZlbnR9IFRoZSBjdXN0b20gZXZlbnQgdGhhdCBzZW50IHRoZSBub3RpZmljYXRpb24uXG4gICAgICovXG4gICAgbm90aWZ5OiBmdW5jdGlvbihhcmdzLCBjZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICAgIHJldCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICBjID0gKGNlLmNvbnRleHRGbikgPyBjZS5jb250ZXh0Rm4oKSA6IGNlLmNvbnRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmx5IGNhdGNoIGVycm9ycyBpZiB3ZSB3aWxsIG5vdCByZS10aHJvdyB0aGVtLlxuICAgICAgICBpZiAoWS5jb25maWcgJiYgWS5jb25maWcudGhyb3dGYWlsKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLl9ub3RpZnkoYywgYXJncywgY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9ub3RpZnkoYywgYXJncywgY2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIFkuZXJyb3IodGhpcyArICcgZmFpbGVkOiAnICsgZS5tZXNzYWdlLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZm4gYW5kIG9iaiBtYXRjaCB0aGlzIG9iamVjdHMgcHJvcGVydGllcy5cbiAgICAgKiBVc2VkIGJ5IHRoZSB1bnN1YnNjcmliZSBtZXRob2QgdG8gbWF0Y2ggdGhlIHJpZ2h0IHN1YnNjcmliZXIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvbnRhaW5zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgb3B0aW9uYWwgJ3RoaXMnIGtleXdvcmQgZm9yIHRoZSBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzdXBwbGllZCBhcmd1bWVudHMgbWF0Y2ggdGhpc1xuICAgICAqICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIncyBzaWduYXR1cmUuXG4gICAgICovXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLmZuID09PSBmbikgJiYgdGhpcy5jb250ZXh0ID09PSBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5mbiA9PT0gZm4pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbHVlT2YgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuXG59O1xuLyoqXG4gKiBSZXR1cm4gdmFsdWUgZnJvbSBhbGwgc3Vic2NyaWJlIG9wZXJhdGlvbnNcbiAqIEBjbGFzcyBFdmVudEhhbmRsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldnQgdGhlIGN1c3RvbSBldmVudC5cbiAqIEBwYXJhbSB7U3Vic2NyaWJlcn0gc3ViIHRoZSBzdWJzY3JpYmVyLlxuICovXG5ZLkV2ZW50SGFuZGxlID0gZnVuY3Rpb24oZXZ0LCBzdWIpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXN0b20gZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBldnRcbiAgICAgKiBAdHlwZSBDdXN0b21FdmVudFxuICAgICAqL1xuICAgIHRoaXMuZXZ0ID0gZXZ0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN1YnNjcmliZXIgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc3ViXG4gICAgICogQHR5cGUgU3Vic2NyaWJlclxuICAgICAqL1xuICAgIHRoaXMuc3ViID0gc3ViO1xufTtcblxuWS5FdmVudEhhbmRsZS5wcm90b3R5cGUgPSB7XG4gICAgYmF0Y2g6IGZ1bmN0aW9uKGYsIGMpIHtcbiAgICAgICAgZi5jYWxsKGMgfHwgdGhpcywgdGhpcyk7XG4gICAgICAgIGlmIChZLkxhbmcuaXNBcnJheSh0aGlzLmV2dCkpIHtcbiAgICAgICAgICAgIFkuQXJyYXkuZWFjaCh0aGlzLmV2dCwgZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICAgIGguYmF0Y2guY2FsbChjIHx8IGgsIGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgdGhpcyBzdWJzY3JpYmVyXG4gICAgICogQG1ldGhvZCBkZXRhY2hcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2YgZGV0YWNoZWQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgZGV0YWNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGV2dCA9IHRoaXMuZXZ0LCBkZXRhY2hlZCA9IDAsIGk7XG4gICAgICAgIGlmIChldnQpIHtcbiAgICAgICAgICAgIGlmIChZLkxhbmcuaXNBcnJheShldnQpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkZXRhY2hlZCArPSBldnRbaV0uZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldnQuX2RlbGV0ZSh0aGlzLnN1Yik7XG4gICAgICAgICAgICAgICAgZGV0YWNoZWQgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGV0YWNoZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vbml0b3IgdGhlIGV2ZW50IHN0YXRlIGZvciB0aGUgc3Vic2NyaWJlZCBldmVudC4gIFRoZSBmaXJzdCBwYXJhbWV0ZXJcbiAgICAgKiBpcyB3aGF0IHNob3VsZCBiZSBtb25pdG9yZWQsIHRoZSByZXN0IGFyZSB0aGUgbm9ybWFsIHBhcmFtZXRlcnMgd2hlblxuICAgICAqIHN1YnNjcmliaW5nIHRvIGFuIGV2ZW50LlxuICAgICAqIEBtZXRob2QgbW9uaXRvclxuICAgICAqIEBwYXJhbSB3aGF0IHtzdHJpbmd9IHdoYXQgdG8gbW9uaXRvciAoJ2F0dGFjaCcsICdkZXRhY2gnLCAncHVibGlzaCcpLlxuICAgICAqIEByZXR1cm4ge0V2ZW50SGFuZGxlfSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbW9uaXRvciBldmVudCBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgbW9uaXRvcjogZnVuY3Rpb24od2hhdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldnQubW9uaXRvci5hcHBseSh0aGlzLmV2dCwgYXJndW1lbnRzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEN1c3RvbSBldmVudCBlbmdpbmUsIERPTSBldmVudCBsaXN0ZW5lciBhYnN0cmFjdGlvbiBsYXllciwgc3ludGhldGljIERPTVxuICogZXZlbnRzLlxuICogQG1vZHVsZSBldmVudC1jdXN0b21cbiAqIEBzdWJtb2R1bGUgZXZlbnQtY3VzdG9tLWJhc2VcbiAqL1xuXG4vKipcbiAqIEV2ZW50VGFyZ2V0IHByb3ZpZGVzIHRoZSBpbXBsZW1lbnRhdGlvbiBmb3IgYW55IG9iamVjdCB0b1xuICogcHVibGlzaCwgc3Vic2NyaWJlIGFuZCBmaXJlIHRvIGN1c3RvbSBldmVudHMsIGFuZCBhbHNvXG4gKiBhbG93cyBvdGhlciBFdmVudFRhcmdldHMgdG8gdGFyZ2V0IHRoZSBvYmplY3Qgd2l0aCBldmVudHNcbiAqIHNvdXJjZWQgZnJvbSB0aGUgb3RoZXIgb2JqZWN0LlxuICogRXZlbnRUYXJnZXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIFkuYXVnbWVudCB0byB3cmFwXG4gKiBFdmVudEN1c3RvbSBpbiBhbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgZXZlbnRzIHRvIGJlIGxpc3RlbmVkIHRvXG4gKiBhbmQgZmlyZWQgYnkgbmFtZS4gIFRoaXMgbWFrZXMgaXQgcG9zc2libGUgZm9yIGltcGxlbWVudGluZyBjb2RlIHRvXG4gKiBzdWJzY3JpYmUgdG8gYW4gZXZlbnQgdGhhdCBlaXRoZXIgaGFzIG5vdCBiZWVuIGNyZWF0ZWQgeWV0LCBvciB3aWxsXG4gKiBub3QgYmUgY3JlYXRlZCBhdCBhbGwuXG4gKiBAY2xhc3MgRXZlbnRUYXJnZXRcbiAqIEBwYXJhbSBvcHRzIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAqIEBjb25maWcgZW1pdEZhY2FkZSB7Ym9vbGVhbn0gaWYgdHJ1ZSwgYWxsIGV2ZW50cyB3aWxsIGVtaXQgZXZlbnRcbiAqIGZhY2FkZSBwYXlsb2FkcyBieSBkZWZhdWx0IChkZWZhdWx0IGZhbHNlKVxuICogQGNvbmZpZyBwcmVmaXgge1N0cmluZ30gdGhlIHByZWZpeCB0byBhcHBseSB0byBub24tcHJlZml4ZWQgZXZlbnQgbmFtZXNcbiAqL1xuXG52YXIgTCA9IFkuTGFuZyxcbiAgICBQUkVGSVhfREVMSU1JVEVSID0gJzonLFxuICAgIENBVEVHT1JZX0RFTElNSVRFUiA9ICd8JyxcbiAgICBBRlRFUl9QUkVGSVggPSAnfkFGVEVSficsXG4gICAgV0lMRF9UWVBFX1JFID0gLyguKj8pKDopKC4qPykvLFxuXG4gICAgX3dpbGRUeXBlID0gWS5jYWNoZWQoZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZS5yZXBsYWNlKFdJTERfVFlQRV9SRSwgXCIqJDIkM1wiKTtcbiAgICB9KSxcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBpbnN0YW5jZSBoYXMgYSBwcmVmaXggYXR0cmlidXRlIGFuZCB0aGVcbiAgICAgKiBldmVudCB0eXBlIGlzIG5vdCBwcmVmaXhlZCwgdGhlIGluc3RhbmNlIHByZWZpeCBpc1xuICAgICAqIGFwcGxpZWQgdG8gdGhlIHN1cHBsaWVkIHR5cGUuXG4gICAgICogQG1ldGhvZCBfZ2V0VHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFR5cGUgPSBmdW5jdGlvbih0eXBlLCBwcmUpIHtcblxuICAgICAgICBpZiAoIXByZSB8fCAhdHlwZSB8fCB0eXBlLmluZGV4T2YoUFJFRklYX0RFTElNSVRFUikgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJlICsgUFJFRklYX0RFTElNSVRFUiArIHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgZGV0YWNoIGtleSAoaWYgcHJvdmlkZWQpLFxuICAgICAqIGFuZCB0aGUgcHJlZml4ZWQgZXZlbnQgbmFtZSBmcm9tIF9nZXRUeXBlXG4gICAgICogWS5vbignZGV0YWNoY2F0ZWdvcnl8IG1lbnU6Y2xpY2snLCBmbilcbiAgICAgKiBAbWV0aG9kIF9wYXJzZVR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wYXJzZVR5cGUgPSBZLmNhY2hlZChmdW5jdGlvbih0eXBlLCBwcmUpIHtcblxuICAgICAgICB2YXIgdCA9IHR5cGUsIGRldGFjaGNhdGVnb3J5LCBhZnRlciwgaTtcblxuICAgICAgICBpZiAoIUwuaXNTdHJpbmcodCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG5cbiAgICAgICAgaSA9IHQuaW5kZXhPZihBRlRFUl9QUkVGSVgpO1xuXG4gICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgIGFmdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHQgPSB0LnN1YnN0cihBRlRFUl9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgPSB0LmluZGV4T2YoQ0FURUdPUllfREVMSU1JVEVSKTtcblxuICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICBkZXRhY2hjYXRlZ29yeSA9IHQuc3Vic3RyKDAsIChpKSk7XG4gICAgICAgICAgICB0ID0gdC5zdWJzdHIoaSsxKTtcbiAgICAgICAgICAgIGlmICh0ID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICB0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRldGFjaCBjYXRlZ29yeSwgZnVsbCB0eXBlIHdpdGggaW5zdGFuY2UgcHJlZml4LCBpcyB0aGlzIGFuIGFmdGVyIGxpc3RlbmVyLCBzaG9ydCB0eXBlXG4gICAgICAgIHJldHVybiBbZGV0YWNoY2F0ZWdvcnksIChwcmUpID8gX2dldFR5cGUodCwgcHJlKSA6IHQsIGFmdGVyLCB0XTtcbiAgICB9KSxcblxuICAgIEVUID0gZnVuY3Rpb24ob3B0cykge1xuXG4gICAgICAgIHZhciBldFN0YXRlID0gdGhpcy5feXVpZXZ0LFxuICAgICAgICAgICAgZXRDb25maWc7XG5cbiAgICAgICAgaWYgKCFldFN0YXRlKSB7XG4gICAgICAgICAgICBldFN0YXRlID0gdGhpcy5feXVpZXZ0ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50czoge30sICAgIC8vIFBFUkY6IE5vdCBtdWNoIHBvaW50IGluc3RhbnRpYXRpbmcgbGF6aWx5LiBXZSdyZSBib3VuZCB0byBoYXZlIGV2ZW50c1xuICAgICAgICAgICAgICAgIHRhcmdldHM6IG51bGwsIC8vIFBFUkY6IEluc3RhbnRpYXRlIGxhemlseSwgaWYgdXNlciBhY3R1YWxseSBhZGRzIHRhcmdldCxcbiAgICAgICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hhaW46IFkuY29uZmlnLmNoYWluXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZXRDb25maWcgPSBldFN0YXRlLmNvbmZpZztcblxuICAgICAgICBpZiAob3B0cykge1xuICAgICAgICAgICAgbWl4Q29uZmlncyhldENvbmZpZywgb3B0cywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmNoYWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBldFN0YXRlLmNoYWluID0gb3B0cy5jaGFpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdHMucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgZXRDb25maWcucHJlZml4ID0gb3B0cy5wcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5FVC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogRVQsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gdG8gYSBjdXN0b20gZXZlbnQgaG9zdGVkIGJ5IHRoaXMgb2JqZWN0IG9uZSB0aW1lLlxuICAgICAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgdG8gPGNvZGU+b248L2NvZGU+IGV4Y2VwdCB0aGVcbiAgICAgKiBsaXN0ZW5lciBpcyBpbW1lZGlhdGVsbHkgZGV0YWNoZWQgd2hlbiBpdCBpcyBleGVjdXRlZC5cbiAgICAgKiBAbWV0aG9kIG9uY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBpbiByZXNwb25zZSB0byB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIE92ZXJyaWRlIGB0aGlzYCBvYmplY3QgaW4gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0FueX0gW2FyZypdIDAuLm4gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc3VwcGx5IHRvIHRoZSBzdWJzY3JpYmVyXG4gICAgICogQHJldHVybiB7RXZlbnRIYW5kbGV9IEEgc3Vic2NyaXB0aW9uIGhhbmRsZSBjYXBhYmxlIG9mIGRldGFjaGluZyB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICovXG4gICAgb25jZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLm9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGhhbmRsZS5iYXRjaChmdW5jdGlvbihoYW5kKSB7XG4gICAgICAgICAgICBpZiAoaGFuZC5zdWIpIHtcbiAgICAgICAgICAgICAgICBoYW5kLnN1Yi5vbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpc3RlbiB0byBhIGN1c3RvbSBldmVudCBob3N0ZWQgYnkgdGhpcyBvYmplY3Qgb25lIHRpbWUuXG4gICAgICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCB0byA8Y29kZT5hZnRlcjwvY29kZT4gZXhjZXB0IHRoZVxuICAgICAqIGxpc3RlbmVyIGlzIGltbWVkaWF0ZWxseSBkZXRhY2hlZCB3aGVuIGl0IGlzIGV4ZWN1dGVkLlxuICAgICAqIEBtZXRob2Qgb25jZUFmdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgaW4gcmVzcG9uc2UgdG8gdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBPdmVycmlkZSBgdGhpc2Agb2JqZWN0IGluIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtBbnl9IFthcmcqXSAwLi5uIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHN1cHBseSB0byB0aGUgc3Vic2NyaWJlclxuICAgICAqIEByZXR1cm4ge0V2ZW50SGFuZGxlfSBBIHN1YnNjcmlwdGlvbiBoYW5kbGUgY2FwYWJsZSBvZiBkZXRhY2hpbmcgdGhhdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvbmNlQWZ0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGFuZGxlID0gdGhpcy5hZnRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBoYW5kbGUuYmF0Y2goZnVuY3Rpb24oaGFuZCkge1xuICAgICAgICAgICAgaWYgKGhhbmQuc3ViKSB7XG4gICAgICAgICAgICAgICAgaGFuZC5zdWIub25jZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgdHlwZSBwYXJhbWV0ZXIgcGFzc2VkIHRvICdvbicgYW5kIHBhcnNlcyBvdXQgdGhlXG4gICAgICogdmFyaW91cyBwaWVjZXMgdGhhdCBjb3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdHlwZS4gIElmIHRoZVxuICAgICAqIGV2ZW50IHR5cGUgaXMgcGFzc2VkIHdpdGhvdXQgYSBwcmVmaXgsIGl0IHdpbGwgYmUgZXhwYW5kZWRcbiAgICAgKiB0byBpbmNsdWRlIHRoZSBwcmVmaXggb25lIGlzIHN1cHBsaWVkIG9yIHRoZSBldmVudCB0YXJnZXRcbiAgICAgKiBpcyBjb25maWd1cmVkIHdpdGggYSBkZWZhdWx0IHByZWZpeC5cbiAgICAgKiBAbWV0aG9kIHBhcnNlVHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmVdIFRoZSBwcmVmaXguIERlZmF1bHRzIHRvIHRoaXMuX3l1aWV2dC5jb25maWcucHJlZml4XG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IGNvbnRhaW5pbmc6XG4gICAgICogICogdGhlIGRldGFjaCBjYXRlZ29yeSwgaWYgc3VwcGxpZWQsXG4gICAgICogICogdGhlIHByZWZpeGVkIGV2ZW50IHR5cGUsXG4gICAgICogICogd2hldGhlciBvciBub3QgdGhpcyBpcyBhbiBhZnRlciBsaXN0ZW5lcixcbiAgICAgKiAgKiB0aGUgc3VwcGxpZWQgZXZlbnQgdHlwZVxuICAgICAqL1xuICAgIHBhcnNlVHlwZTogZnVuY3Rpb24odHlwZSwgcHJlKSB7XG4gICAgICAgIHJldHVybiBfcGFyc2VUeXBlKHR5cGUsIHByZSB8fCB0aGlzLl95dWlldnQuY29uZmlnLnByZWZpeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGEgY3VzdG9tIGV2ZW50IGZpcmVkIGJ5IHRoaXMgb2JqZWN0IG9yXG4gICAgICogZnJvbSBhbiBvYmplY3QgdGhhdCBidWJibGVzIGl0cyBldmVudHMgdG8gdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbnMgZm9yIGV2ZW50cyBwdWJsaXNoZWQgd2l0aCBgZW1pdEZhY2FkZSA9IHRydWVgIHdpbGxcbiAgICAgKiByZWNlaXZlIGFuIGBFdmVudEZhY2FkZWAgYXMgdGhlIGZpcnN0IGFyZ3VtZW50ICh0eXBpY2FsbHkgbmFtZWQgXCJlXCIpLlxuICAgICAqIFRoZXNlIGNhbGxiYWNrcyBjYW4gdGhlbiBjYWxsIGBlLnByZXZlbnREZWZhdWx0KClgIHRvIGRpc2FibGUgdGhlXG4gICAgICogYmVoYXZpb3IgcHVibGlzaGVkIHRvIHRoYXQgZXZlbnQncyBgZGVmYXVsdEZuYC4gIFNlZSB0aGUgYEV2ZW50RmFjYWRlYFxuICAgICAqIEFQSSBmb3IgYWxsIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLiBTdWJzY3JpYmVycyB0b1xuICAgICAqIG5vbi1gZW1pdEZhY2FkZWAgZXZlbnRzIHdpbGwgcmVjZWl2ZSB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byBgZmlyZSgpYFxuICAgICAqIGFmdGVyIHRoZSBldmVudCBuYW1lLlxuICAgICAqXG4gICAgICogVG8gc3Vic2NyaWJlIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLCBwYXNzIGFuIG9iamVjdCBhcyB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudCwgd2hlcmUgdGhlIGtleTp2YWx1ZSBwYWlycyBjb3JyZXNwb25kIHRvIHRoZSBldmVudE5hbWU6Y2FsbGJhY2ssXG4gICAgICogb3IgcGFzcyBhbiBhcnJheSBvZiBldmVudCBuYW1lcyBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gc3Vic2NyaWJlIHRvXG4gICAgICogYWxsIGxpc3RlZCBldmVudHMgd2l0aCB0aGUgc2FtZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIFJldHVybmluZyBgZmFsc2VgIGZyb20gYSBjYWxsYmFjayBpcyBzdXBwb3J0ZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG9cbiAgICAgKiBjYWxsaW5nIGBlLnByZXZlbnREZWZhdWx0KCk7IGUuc3RvcFByb3BhZ2F0aW9uKCk7YC4gIEhvd2V2ZXIsIGl0IGlzXG4gICAgICogcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBldmVudCBtZXRob2RzIHdoZW5ldmVyIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIGluIHJlc3BvbnNlIHRvIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gT3ZlcnJpZGUgYHRoaXNgIG9iamVjdCBpbiBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7QW55fSBbYXJnKl0gMC4ubiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzdXBwbHkgdG8gdGhlIHN1YnNjcmliZXJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gQSBzdWJzY3JpcHRpb24gaGFuZGxlIGNhcGFibGUgb2YgZGV0YWNoaW5nIHRoYXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKHR5cGUsIGZuLCBjb250ZXh0KSB7XG5cbiAgICAgICAgdmFyIHl1aWV2dCA9IHRoaXMuX3l1aWV2dCxcbiAgICAgICAgICAgIHBhcnRzID0gX3BhcnNlVHlwZSh0eXBlLCB5dWlldnQuY29uZmlnLnByZWZpeCksIGYsIGMsIGFyZ3MsIHJldCwgY2UsXG4gICAgICAgICAgICBkZXRhY2hjYXRlZ29yeSwgaGFuZGxlLCBzdG9yZSA9IFkuRW52LmV2dC5oYW5kbGVzLCBhZnRlciwgYWRhcHQsIHNob3J0dHlwZSxcbiAgICAgICAgICAgIE5vZGUgPSBZLk5vZGUsIG4sIGRvbWV2ZW50LCBpc0FycjtcblxuICAgICAgICAvLyBmdWxsIG5hbWUsIGFyZ3MsIGRldGFjaGNhdGVnb3J5LCBhZnRlclxuICAgICAgICB0aGlzLl9tb25pdG9yKCdhdHRhY2gnLCBwYXJ0c1sxXSwge1xuICAgICAgICAgICAgYXJnczogYXJndW1lbnRzLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IHBhcnRzWzBdLFxuICAgICAgICAgICAgYWZ0ZXI6IHBhcnRzWzJdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChMLmlzT2JqZWN0KHR5cGUpKSB7XG5cbiAgICAgICAgICAgIGlmIChMLmlzRnVuY3Rpb24odHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWS5Eby5iZWZvcmUuYXBwbHkoWS5EbywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZiA9IGZuO1xuICAgICAgICAgICAgYyA9IGNvbnRleHQ7XG4gICAgICAgICAgICBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgcmV0ID0gW107XG5cbiAgICAgICAgICAgIGlmIChMLmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpc0FyciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFmdGVyID0gdHlwZS5fYWZ0ZXI7XG4gICAgICAgICAgICBkZWxldGUgdHlwZS5fYWZ0ZXI7XG5cbiAgICAgICAgICAgIFkuZWFjaCh0eXBlLCBmdW5jdGlvbih2LCBrKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoTC5pc09iamVjdCh2KSkge1xuICAgICAgICAgICAgICAgICAgICBmID0gdi5mbiB8fCAoKEwuaXNGdW5jdGlvbih2KSkgPyB2IDogZik7XG4gICAgICAgICAgICAgICAgICAgIGMgPSB2LmNvbnRleHQgfHwgYztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbnYgPSAoYWZ0ZXIpID8gQUZURVJfUFJFRklYIDogJyc7XG5cbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gbnYgKyAoKGlzQXJyKSA/IHYgOiBrKTtcbiAgICAgICAgICAgICAgICBhcmdzWzFdID0gZjtcbiAgICAgICAgICAgICAgICBhcmdzWzJdID0gYztcblxuICAgICAgICAgICAgICAgIHJldC5wdXNoKHRoaXMub24uYXBwbHkodGhpcywgYXJncykpO1xuXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuICh5dWlldnQuY2hhaW4pID8gdGhpcyA6IG5ldyBZLkV2ZW50SGFuZGxlKHJldCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRhY2hjYXRlZ29yeSA9IHBhcnRzWzBdO1xuICAgICAgICBhZnRlciA9IHBhcnRzWzJdO1xuICAgICAgICBzaG9ydHR5cGUgPSBwYXJ0c1szXTtcblxuICAgICAgICAvLyBleHRyYSByZWRpcmVjdGlvbiBzbyB3ZSBjYXRjaCBhZGFwdG9yIGV2ZW50cyB0b28uICB0YWtlIGEgbG9vayBhdCB0aGlzLlxuICAgICAgICBpZiAoTm9kZSAmJiBZLmluc3RhbmNlT2YodGhpcywgTm9kZSkgJiYgKHNob3J0dHlwZSBpbiBOb2RlLkRPTV9FVkVOVFMpKSB7XG4gICAgICAgICAgICBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoMiwgMCwgTm9kZS5nZXRET01Ob2RlKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybiBZLm9uLmFwcGx5KFksIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IHBhcnRzWzFdO1xuXG4gICAgICAgIGlmIChZLmluc3RhbmNlT2YodGhpcywgWVVJKSkge1xuXG4gICAgICAgICAgICBhZGFwdCA9IFkuRW52LmV2dC5wbHVnaW5zW3R5cGVdO1xuICAgICAgICAgICAgYXJncyAgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgICAgICBhcmdzWzBdID0gc2hvcnR0eXBlO1xuXG4gICAgICAgICAgICBpZiAoTm9kZSkge1xuICAgICAgICAgICAgICAgIG4gPSBhcmdzWzJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKFkuaW5zdGFuY2VPZihuLCBZLk5vZGVMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBuID0gWS5Ob2RlTGlzdC5nZXRET01Ob2RlcyhuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFkuaW5zdGFuY2VPZihuLCBOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBuID0gTm9kZS5nZXRET01Ob2RlKG4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbWV2ZW50ID0gKHNob3J0dHlwZSBpbiBOb2RlLkRPTV9FVkVOVFMpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZXMgYm90aCBET00gZXZlbnRzIGFuZCBldmVudCBwbHVnaW5zLlxuICAgICAgICAgICAgICAgIGlmIChkb21ldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzWzJdID0gbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciB0aGUgZXhpc3RhbmNlIG9mIGFuIGV2ZW50IGFkYXB0b3JcbiAgICAgICAgICAgIGlmIChhZGFwdCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZSA9IGFkYXB0Lm9uLmFwcGx5KFksIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoIXR5cGUpIHx8IGRvbWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlID0gWS5FdmVudC5fYXR0YWNoKGFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgY2UgPSB5dWlldnQuZXZlbnRzW3R5cGVdIHx8IHRoaXMucHVibGlzaCh0eXBlKTtcbiAgICAgICAgICAgIGhhbmRsZSA9IGNlLl9vbihmbiwgY29udGV4dCwgKGFyZ3VtZW50cy5sZW5ndGggPiAzKSA/IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKSA6IG51bGwsIChhZnRlcikgPyAnYWZ0ZXInIDogdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IE1vcmUgcm9idXN0IHJlZ2V4LCBhY2NvdW50aW5nIGZvciBjYXRlZ29yeVxuICAgICAgICAgICAgaWYgKHR5cGUuaW5kZXhPZihcIio6XCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1NpYmxpbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXRhY2hjYXRlZ29yeSkge1xuICAgICAgICAgICAgc3RvcmVbZGV0YWNoY2F0ZWdvcnldID0gc3RvcmVbZGV0YWNoY2F0ZWdvcnldIHx8IHt9O1xuICAgICAgICAgICAgc3RvcmVbZGV0YWNoY2F0ZWdvcnldW3R5cGVdID0gc3RvcmVbZGV0YWNoY2F0ZWdvcnldW3R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgc3RvcmVbZGV0YWNoY2F0ZWdvcnldW3R5cGVdLnB1c2goaGFuZGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoeXVpZXZ0LmNoYWluKSA/IHRoaXMgOiBoYW5kbGU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3Vic2NyaWJlIHRvIGFuIGV2ZW50XG4gICAgICogQG1ldGhvZCBzdWJzY3JpYmVcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2Ugb25cbiAgICAgKi9cbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggb25lIG9yIG1vcmUgbGlzdGVuZXJzIHRoZSBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnRcbiAgICAgKiBAbWV0aG9kIGRldGFjaFxuICAgICAqIEBwYXJhbSB0eXBlIHtzdHJpbmd8T2JqZWN0fSAgIEVpdGhlciB0aGUgaGFuZGxlIHRvIHRoZSBzdWJzY3JpYmVyIG9yIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSBvZiBldmVudC4gIElmIHRoZSB0eXBlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBpcyBub3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGF0dGVtcHQgdG8gcmVtb3ZlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgbGlzdGVuZXIgZnJvbSBhbGwgaG9zdGVkIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gZm4gICB7RnVuY3Rpb259IFRoZSBzdWJzY3JpYmVkIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlLCBpZiBub3RcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcGxpZWQsIGFsbCBzdWJzY3JpYmVycyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIGNvbnRleHQgIHtPYmplY3R9ICAgVGhlIGN1c3RvbSBvYmplY3QgcGFzc2VkIHRvIHN1YnNjcmliZS4gIFRoaXMgaXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsLCBidXQgaWYgc3VwcGxpZWQgd2lsbCBiZSB1c2VkIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBkaXNhbWJpZ3VhdGUgbXVsdGlwbGUgbGlzdGVuZXJzIHRoYXQgYXJlIHRoZSBzYW1lXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAoZS5nLiwgeW91IHN1YnNjcmliZSBtYW55IG9iamVjdCB1c2luZyBhIGZ1bmN0aW9uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGF0IGxpdmVzIG9uIHRoZSBwcm90b3R5cGUpXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IHRoZSBob3N0XG4gICAgICovXG4gICAgZGV0YWNoOiBmdW5jdGlvbih0eXBlLCBmbiwgY29udGV4dCkge1xuXG4gICAgICAgIHZhciBldnRzID0gdGhpcy5feXVpZXZ0LmV2ZW50cyxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBOb2RlID0gWS5Ob2RlLFxuICAgICAgICAgICAgaXNOb2RlID0gTm9kZSAmJiAoWS5pbnN0YW5jZU9mKHRoaXMsIE5vZGUpKTtcblxuICAgICAgICAvLyBkZXRhY2hBbGwgZGlzYWJsZWQgb24gdGhlIFkgaW5zdGFuY2UuXG4gICAgICAgIGlmICghdHlwZSAmJiAodGhpcyAhPT0gWSkpIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBldnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2dHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0c1tpXS5kZXRhY2goZm4sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICAgICAgICBZLkV2ZW50LnB1cmdlRWxlbWVudChOb2RlLmdldERPTU5vZGUodGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0cyA9IF9wYXJzZVR5cGUodHlwZSwgdGhpcy5feXVpZXZ0LmNvbmZpZy5wcmVmaXgpLFxuICAgICAgICBkZXRhY2hjYXRlZ29yeSA9IEwuaXNBcnJheShwYXJ0cykgPyBwYXJ0c1swXSA6IG51bGwsXG4gICAgICAgIHNob3J0dHlwZSA9IChwYXJ0cykgPyBwYXJ0c1szXSA6IG51bGwsXG4gICAgICAgIGFkYXB0LCBzdG9yZSA9IFkuRW52LmV2dC5oYW5kbGVzLCBkZXRhY2hob3N0LCBjYXQsIGFyZ3MsXG4gICAgICAgIGNlLFxuXG4gICAgICAgIGtleURldGFjaGVyID0gZnVuY3Rpb24obGNhdCwgbHR5cGUsIGhvc3QpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVzID0gbGNhdFtsdHlwZV0sIGNlLCBpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBoYW5kbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlID0gaGFuZGxlc1tpXS5ldnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZS5ob3N0ID09PSBob3N0IHx8IGNlLmVsID09PSBob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVzW2ldLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkZXRhY2hjYXRlZ29yeSkge1xuXG4gICAgICAgICAgICBjYXQgPSBzdG9yZVtkZXRhY2hjYXRlZ29yeV07XG4gICAgICAgICAgICB0eXBlID0gcGFydHNbMV07XG4gICAgICAgICAgICBkZXRhY2hob3N0ID0gKGlzTm9kZSkgPyBZLk5vZGUuZ2V0RE9NTm9kZSh0aGlzKSA6IHRoaXM7XG5cbiAgICAgICAgICAgIGlmIChjYXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlEZXRhY2hlcihjYXQsIHR5cGUsIGRldGFjaGhvc3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiBjYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXQuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlEZXRhY2hlcihjYXQsIGksIGRldGFjaGhvc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBldmVudCBoYW5kbGUsIHVzZSBpdCB0byBkZXRhY2hcbiAgICAgICAgfSBlbHNlIGlmIChMLmlzT2JqZWN0KHR5cGUpICYmIHR5cGUuZGV0YWNoKSB7XG4gICAgICAgICAgICB0eXBlLmRldGFjaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIC8vIGV4dHJhIHJlZGlyZWN0aW9uIHNvIHdlIGNhdGNoIGFkYXB0b3IgZXZlbnRzIHRvby4gIHRha2UgYSBsb29rIGF0IHRoaXMuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlICYmICgoIXNob3J0dHlwZSkgfHwgKHNob3J0dHlwZSBpbiBOb2RlLkRPTV9FVkVOVFMpKSkge1xuICAgICAgICAgICAgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgIGFyZ3NbMl0gPSBOb2RlLmdldERPTU5vZGUodGhpcyk7XG4gICAgICAgICAgICBZLmRldGFjaC5hcHBseShZLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRhcHQgPSBZLkVudi5ldnQucGx1Z2luc1tzaG9ydHR5cGVdO1xuXG4gICAgICAgIC8vIFRoZSBZVUkgaW5zdGFuY2UgaGFuZGxlcyBET00gZXZlbnRzIGFuZCBhZGFwdG9yc1xuICAgICAgICBpZiAoWS5pbnN0YW5jZU9mKHRoaXMsIFlVSSkpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIGFkYXB0b3Igc3BlY2lmaWMgZGV0YWNoIGNvZGUgaWZcbiAgICAgICAgICAgIGlmIChhZGFwdCAmJiBhZGFwdC5kZXRhY2gpIHtcbiAgICAgICAgICAgICAgICBhZGFwdC5kZXRhY2guYXBwbHkoWSwgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAvLyBET00gZXZlbnQgZm9ya1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdHlwZSB8fCAoIWFkYXB0ICYmIE5vZGUgJiYgKHR5cGUgaW4gTm9kZS5ET01fRVZFTlRTKSkpIHtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gdHlwZTtcbiAgICAgICAgICAgICAgICBZLkV2ZW50LmRldGFjaC5hcHBseShZLkV2ZW50LCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNlID0gZXZ0c1t0eXBlXTtcbiAgICAgICAgY2UgPSBldnRzW3BhcnRzWzFdXTtcbiAgICAgICAgaWYgKGNlKSB7XG4gICAgICAgICAgICBjZS5kZXRhY2goZm4sIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRldGFjaCBhIGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCB1bnN1YnNjcmliZVxuICAgICAqIEBkZXByZWNhdGVkIHVzZSBkZXRhY2hcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50LiAgSWYgdGhlIGV2ZW50IHR5cGVcbiAgICAgKiBpcyBub3Qgc3BlY2lmaWVkLCBhbGwgbGlzdGVuZXJzIGZyb20gYWxsIGhvc3RlZCBjdXN0b20gZXZlbnRzIHdpbGxcbiAgICAgKiBiZSByZW1vdmVkLlxuICAgICAqIEBtZXRob2QgZGV0YWNoQWxsXG4gICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gICBUaGUgdHlwZSwgb3IgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBkZXRhY2hBbGw6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWNoKHR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50LiAgSWYgdGhlIGV2ZW50IHR5cGVcbiAgICAgKiBpcyBub3Qgc3BlY2lmaWVkLCBhbGwgbGlzdGVuZXJzIGZyb20gYWxsIGhvc3RlZCBjdXN0b20gZXZlbnRzIHdpbGxcbiAgICAgKiBiZSByZW1vdmVkLlxuICAgICAqIEBtZXRob2QgdW5zdWJzY3JpYmVBbGxcbiAgICAgKiBAcGFyYW0gdHlwZSB7U3RyaW5nfSAgIFRoZSB0eXBlLCBvciBuYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBkZXByZWNhdGVkIHVzZSBkZXRhY2hBbGxcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGFjaEFsbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGN1c3RvbSBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuICBJZiBhIGN1c3RvbSBldmVudFxuICAgICAqIGJ5IHRoYXQgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBub3QgYmUgcmUtY3JlYXRlZC4gIEluIGVpdGhlclxuICAgICAqIGNhc2UgdGhlIGN1c3RvbSBldmVudCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcHVibGlzaFxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gdGhlIHR5cGUsIG9yIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIG9wdHMge29iamVjdH0gb3B0aW9uYWwgY29uZmlnIHBhcmFtcy4gIFZhbGlkIHByb3BlcnRpZXMgYXJlOlxuICAgICAqXG4gICAgICogIDx1bD5cbiAgICAgKiAgICA8bGk+XG4gICAgICogICAnYnJvYWRjYXN0Jzogd2hldGhlciBvciBub3QgdGhlIFlVSSBpbnN0YW5jZSBhbmQgWVVJIGdsb2JhbCBhcmUgbm90aWZpZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQgKGZhbHNlKVxuICAgICAqICAgIDwvbGk+XG4gICAgICogICAgPGxpPlxuICAgICAqICAgJ2J1YmJsZXMnOiB3aGV0aGVyIG9yIG5vdCB0aGlzIGV2ZW50IGJ1YmJsZXMgKHRydWUpXG4gICAgICogICAgICAgICAgICAgIEV2ZW50cyBjYW4gb25seSBidWJibGUgaWYgZW1pdEZhY2FkZSBpcyB0cnVlLlxuICAgICAqICAgIDwvbGk+XG4gICAgICogICAgPGxpPlxuICAgICAqICAgJ2NvbnRleHQnOiB0aGUgZGVmYXVsdCBleGVjdXRpb24gY29udGV4dCBmb3IgdGhlIGxpc3RlbmVycyAodGhpcylcbiAgICAgKiAgICA8L2xpPlxuICAgICAqICAgIDxsaT5cbiAgICAgKiAgICdkZWZhdWx0Rm4nOiB0aGUgZGVmYXVsdCBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhpcyBldmVudCBmaXJlcyBpZiBwcmV2ZW50RGVmYXVsdCB3YXMgbm90IGNhbGxlZFxuICAgICAqICAgIDwvbGk+XG4gICAgICogICAgPGxpPlxuICAgICAqICAgJ2VtaXRGYWNhZGUnOiB3aGV0aGVyIG9yIG5vdCB0aGlzIGV2ZW50IGVtaXRzIGEgZmFjYWRlIChmYWxzZSlcbiAgICAgKiAgICA8L2xpPlxuICAgICAqICAgIDxsaT5cbiAgICAgKiAgICdwcmVmaXgnOiB0aGUgcHJlZml4IGZvciB0aGlzIHRhcmdldHMgZXZlbnRzLCBlLmcuLCAnbWVudScgaW4gJ21lbnU6Y2xpY2snXG4gICAgICogICAgPC9saT5cbiAgICAgKiAgICA8bGk+XG4gICAgICogICAnZmlyZU9uY2UnOiBpZiBhbiBldmVudCBpcyBjb25maWd1cmVkIHRvIGZpcmUgb25jZSwgbmV3IHN1YnNjcmliZXJzIGFmdGVyXG4gICAgICogICB0aGUgZmlyZSB3aWxsIGJlIG5vdGlmaWVkIGltbWVkaWF0ZWx5LlxuICAgICAqICAgIDwvbGk+XG4gICAgICogICAgPGxpPlxuICAgICAqICAgJ2FzeW5jJzogZmlyZU9uY2UgZXZlbnQgbGlzdGVuZXJzIHdpbGwgZmlyZSBzeW5jaHJvbm91c2x5IGlmIHRoZSBldmVudCBoYXMgYWxyZWFkeVxuICAgICAqICAgIGZpcmVkIHVubGVzcyBhc3luYyBpcyB0cnVlLlxuICAgICAqICAgIDwvbGk+XG4gICAgICogICAgPGxpPlxuICAgICAqICAgJ3ByZXZlbnRhYmxlJzogd2hldGhlciBvciBub3QgcHJldmVudERlZmF1bHQoKSBoYXMgYW4gZWZmZWN0ICh0cnVlKVxuICAgICAqICAgIDwvbGk+XG4gICAgICogICAgPGxpPlxuICAgICAqICAgJ3ByZXZlbnRlZEZuJzogYSBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIHdoZW4gcHJldmVudERlZmF1bHQgaXMgY2FsbGVkXG4gICAgICogICAgPC9saT5cbiAgICAgKiAgICA8bGk+XG4gICAgICogICAncXVldWFibGUnOiB3aGV0aGVyIG9yIG5vdCB0aGlzIGV2ZW50IGNhbiBiZSBxdWV1ZWQgZHVyaW5nIGJ1YmJsaW5nIChmYWxzZSlcbiAgICAgKiAgICA8L2xpPlxuICAgICAqICAgIDxsaT5cbiAgICAgKiAgICdzaWxlbnQnOiBpZiBzaWxlbnQgaXMgdHJ1ZSwgZGVidWcgbWVzc2FnZXMgYXJlIG5vdCBwcm92aWRlZCBmb3IgdGhpcyBldmVudC5cbiAgICAgKiAgICA8L2xpPlxuICAgICAqICAgIDxsaT5cbiAgICAgKiAgICdzdG9wcGVkRm4nOiBhIGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgd2hlbiBzdG9wUHJvcGFnYXRpb24gaXMgY2FsbGVkXG4gICAgICogICAgPC9saT5cbiAgICAgKlxuICAgICAqICAgIDxsaT5cbiAgICAgKiAgICdtb25pdG9yZWQnOiBzcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBldmVudCBzaG91bGQgc2VuZCBub3RpZmljYXRpb25zIGFib3V0XG4gICAgICogICB3aGVuIHRoZSBldmVudCBoYXMgYmVlbiBhdHRhY2hlZCwgZGV0YWNoZWQsIG9yIHB1Ymxpc2hlZC5cbiAgICAgKiAgICA8L2xpPlxuICAgICAqICAgIDxsaT5cbiAgICAgKiAgICd0eXBlJzogdGhlIGV2ZW50IHR5cGUgKHZhbGlkIG9wdGlvbiBpZiBub3QgcHJvdmlkZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBwdWJsaXNoKVxuICAgICAqICAgIDwvbGk+XG4gICAgICogIDwvdWw+XG4gICAgICpcbiAgICAgKiAgQHJldHVybiB7Q3VzdG9tRXZlbnR9IHRoZSBjdXN0b20gZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIHB1Ymxpc2g6IGZ1bmN0aW9uKHR5cGUsIG9wdHMpIHtcblxuICAgICAgICB2YXIgcmV0LFxuICAgICAgICAgICAgZXRTdGF0ZSA9IHRoaXMuX3l1aWV2dCxcbiAgICAgICAgICAgIGV0Q29uZmlnID0gZXRTdGF0ZS5jb25maWcsXG4gICAgICAgICAgICBwcmUgPSBldENvbmZpZy5wcmVmaXg7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiKSAge1xuICAgICAgICAgICAgaWYgKHByZSkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBfZ2V0VHlwZSh0eXBlLCBwcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0ID0gdGhpcy5fcHVibGlzaCh0eXBlLCBldENvbmZpZywgb3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSB7fTtcblxuICAgICAgICAgICAgWS5lYWNoKHR5cGUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBfZ2V0VHlwZShrLCBwcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRba10gPSB0aGlzLl9wdWJsaXNoKGssIGV0Q29uZmlnLCB2IHx8IG9wdHMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCB0eXBlLCBnaXZlbiBhIHNob3J0IHR5cGUgc3RyaW5nLlxuICAgICAqIFRoYXQgaXMsIHJldHVybnMgXCJmb286YmFyXCIgd2hlbiBnaXZlbiBcImJhclwiIGlmIFwiZm9vXCIgaXMgdGhlIGNvbmZpZ3VyZWQgcHJlZml4LlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBtZXRob2QsIHVubGlrZSBfZ2V0VHlwZSwgZG9lcyBubyBjaGVja2luZyBvZiB0aGUgdmFsdWUgcGFzc2VkIGluLCBhbmRcbiAgICAgKiBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggdGhlIGxvdyBsZXZlbCBfcHVibGlzaCgpIG1ldGhvZCwgZm9yIGNyaXRpY2FsIHBhdGhcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMgd2hpY2ggbmVlZCB0byBmYXN0LXRyYWNrIHB1Ymxpc2ggZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9nZXRGdWxsVHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHNob3J0IHR5cGUgdG8gcHJlZml4XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcHJlZml4ZWQgdHlwZSwgaWYgYSBwcmVmaXggaXMgc2V0LCBvdGhlcndpc2UgdGhlIHR5cGUgcGFzc2VkIGluXG4gICAgICovXG4gICAgX2dldEZ1bGxUeXBlIDogZnVuY3Rpb24odHlwZSkge1xuXG4gICAgICAgIHZhciBwcmUgPSB0aGlzLl95dWlldnQuY29uZmlnLnByZWZpeDtcblxuICAgICAgICBpZiAocHJlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlICsgUFJFRklYX0RFTElNSVRFUiArIHR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93IGxldmVsIGV2ZW50IHB1Ymxpc2ggaW1wbGVtZW50YXRpb24uIEl0IGV4cGVjdHMgYWxsIHRoZSBtYXNzYWdpbmcgdG8gaGF2ZSBiZWVuIGRvbmVcbiAgICAgKiBvdXRzaWRlIG9mIHRoaXMgbWV0aG9kLiBlLmcuIHRoZSBgdHlwZWAgdG8gYGZ1bGxUeXBlYCBjb252ZXJzaW9uLiBJdCdzIGRlc2lnbmVkIHRvIGJlIGEgZmFzdFxuICAgICAqIHBhdGggcHVibGlzaCwgd2hpY2ggY2FuIGJlIHVzZWQgYnkgY3JpdGljYWwgY29kZSBwYXRocyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfcHVibGlzaFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZ1bGxUeXBlIFRoZSBwcmVmaXhlZCB0eXBlIG9mIHRoZSBldmVudCB0byBwdWJsaXNoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldE9wdHMgVGhlIEV2ZW50VGFyZ2V0IHNwZWNpZmljIGNvbmZpZ3VyYXRpb24gdG8gbWl4IGludG8gdGhlIHB1Ymxpc2hlZCBldmVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2VPcHRzIFRoZSBwdWJsaXNoIHNwZWNpZmljIGNvbmZpZ3VyYXRpb24gdG8gbWl4IGludG8gdGhlIHB1Ymxpc2hlZCBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtDdXN0b21FdmVudH0gVGhlIHB1Ymxpc2hlZCBldmVudC4gSWYgY2FsbGVkIHdpdGhvdXQgYGV0T3B0c2Agb3IgYGNlT3B0c2AsIHRoaXMgd2lsbFxuICAgICAqIGJlIHRoZSBkZWZhdWx0IGBDdXN0b21FdmVudGAgaW5zdGFuY2UsIGFuZCBjYW4gYmUgY29uZmlndXJlZCBpbmRlcGVuZGVudGx5LlxuICAgICAqL1xuICAgIF9wdWJsaXNoIDogZnVuY3Rpb24oZnVsbFR5cGUsIGV0T3B0cywgY2VPcHRzKSB7XG5cbiAgICAgICAgdmFyIGNlLFxuICAgICAgICAgICAgZXRTdGF0ZSA9IHRoaXMuX3l1aWV2dCxcbiAgICAgICAgICAgIGV0Q29uZmlnID0gZXRTdGF0ZS5jb25maWcsXG4gICAgICAgICAgICBob3N0ID0gZXRDb25maWcuaG9zdCxcbiAgICAgICAgICAgIGNvbnRleHQgPSBldENvbmZpZy5jb250ZXh0LFxuICAgICAgICAgICAgZXZlbnRzID0gZXRTdGF0ZS5ldmVudHM7XG5cbiAgICAgICAgY2UgPSBldmVudHNbZnVsbFR5cGVdO1xuXG4gICAgICAgIC8vIFBFUkY6IEhhdGUgdG8gcHVsbCB0aGUgY2hlY2sgb3V0IG9mIG1vbml0b3IsIGJ1dCB0cnlpbmcgdG8ga2VlcCBjcml0aWNhbCBwYXRoIHRpZ2h0LlxuICAgICAgICBpZiAoKGV0Q29uZmlnLm1vbml0b3JlZCAmJiAhY2UpIHx8IChjZSAmJiBjZS5tb25pdG9yZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb25pdG9yKCdwdWJsaXNoJywgZnVsbFR5cGUsIHtcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmd1bWVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjZSkge1xuICAgICAgICAgICAgLy8gUHVibGlzaCBldmVudFxuICAgICAgICAgICAgY2UgPSBldmVudHNbZnVsbFR5cGVdID0gbmV3IFkuQ3VzdG9tRXZlbnQoZnVsbFR5cGUsIGV0T3B0cyk7XG5cbiAgICAgICAgICAgIGlmICghZXRPcHRzKSB7XG4gICAgICAgICAgICAgICAgY2UuaG9zdCA9IGhvc3Q7XG4gICAgICAgICAgICAgICAgY2UuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2VPcHRzKSB7XG4gICAgICAgICAgICBtaXhDb25maWdzKGNlLCBjZU9wdHMsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIGV2ZW50IG1vbml0b3Jpbmcgc3lzdGVtLlxuICAgICAqIFlvdSBjYW4gbW9uaXRvciAnYXR0YWNoJywgJ2RldGFjaCcsICdmaXJlJywgYW5kICdwdWJsaXNoJy5cbiAgICAgKiBXaGVuIGNvbmZpZ3VyZWQsIHRoZXNlIGV2ZW50cyBnZW5lcmF0ZSBhbiBldmVudC4gIGNsaWNrIC0+XG4gICAgICogY2xpY2tfYXR0YWNoLCBjbGlja19kZXRhY2gsIGNsaWNrX3B1Ymxpc2ggLS0gdGhlc2UgY2FuXG4gICAgICogYmUgc3Vic2NyaWJlZCB0byBsaWtlIG90aGVyIGV2ZW50cyB0byBtb25pdG9yIHRoZSBldmVudFxuICAgICAqIHN5c3RlbS4gIEluaXZpZHVhbCBwdWJsaXNoZWQgZXZlbnRzIGNhbiBoYXZlIG1vbml0b3JpbmdcbiAgICAgKiB0dXJuZWQgb24gb3Igb2ZmIChwdWJsaXNoIGNhbid0IGJlIHR1cm5lZCBvZmYgYmVmb3JlIGl0XG4gICAgICogaXQgcHVibGlzaGVkKSBieSBzZXR0aW5nIHRoZSBldmVudHMgJ21vbml0b3InIGNvbmZpZy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX21vbml0b3JcbiAgICAgKiBAcGFyYW0gd2hhdCB7U3RyaW5nfSAnYXR0YWNoJywgJ2RldGFjaCcsICdmaXJlJywgb3IgJ3B1Ymxpc2gnXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSB7U3RyaW5nfEN1c3RvbUV2ZW50fSBUaGUgcHJlZml4ZWQgbmFtZSBvZiB0aGUgZXZlbnQgYmVpbmcgbW9uaXRvcmVkLCBvciB0aGUgQ3VzdG9tRXZlbnQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBvIHtPYmplY3R9IEluZm9ybWF0aW9uIGFib3V0IHRoZSBldmVudCBpbnRlcmFjdGlvbiwgc3VjaCBhc1xuICAgICAqICAgICAgICAgICAgICAgICAgZmlyZSgpIGFyZ3MsIHN1YnNjcmlwdGlvbiBjYXRlZ29yeSwgcHVibGlzaCBjb25maWdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb25pdG9yOiBmdW5jdGlvbih3aGF0LCBldmVudFR5cGUsIG8pIHtcbiAgICAgICAgdmFyIG1vbml0b3JldnQsIGNlLCB0eXBlO1xuXG4gICAgICAgIGlmIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnRUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGV2ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBjZSA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRUeXBlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2UgPSBldmVudFR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGV2ZW50VHlwZS50eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHRoaXMuX3l1aWV2dC5jb25maWcubW9uaXRvcmVkICYmICghY2UgfHwgY2UubW9uaXRvcmVkKSkgfHwgKGNlICYmIGNlLm1vbml0b3JlZCkpIHtcbiAgICAgICAgICAgICAgICBtb25pdG9yZXZ0ID0gdHlwZSArICdfJyArIHdoYXQ7XG4gICAgICAgICAgICAgICAgby5tb25pdG9yZWQgPSB3aGF0O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZS5jYWxsKHRoaXMsIG1vbml0b3JldnQsIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgYSBjdXN0b20gZXZlbnQgYnkgbmFtZS4gIFRoZSBjYWxsYmFjayBmdW5jdGlvbnMgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZyb20gdGhlIGNvbnRleHQgc3BlY2lmaWVkIHdoZW4gdGhlIGV2ZW50IHdhcyBjcmVhdGVkLCBhbmQgd2l0aCB0aGVcbiAgICAgKiBmb2xsb3dpbmcgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZXZlbnQgdHlwZSwgYW5kIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwYXNzZWQgdG8gdGhlIGxpc3RlbmVycyBhcyBwYXJhbWV0ZXJzLiAgSWYgdGhlIGZpcnN0IG9mIHRoZXNlIGlzIGFuXG4gICAgICogb2JqZWN0IGxpdGVyYWwsIGFuZCB0aGUgZXZlbnQgaXMgY29uZmlndXJlZCB0byBlbWl0IGFuIGV2ZW50IGZhY2FkZSxcbiAgICAgKiB0aGF0IG9iamVjdCBpcyBtaXhlZCBpbnRvIHRoZSBldmVudCBmYWNhZGUgYW5kIHRoZSBmYWNhZGUgaXMgcHJvdmlkZWRcbiAgICAgKiBpbiBwbGFjZSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAqXG4gICAgICogSWYgdGhlIGN1c3RvbSBldmVudCBvYmplY3QgaGFzbid0IGJlZW4gY3JlYXRlZCwgdGhlbiB0aGUgZXZlbnQgaGFzbid0XG4gICAgICogYmVlbiBwdWJsaXNoZWQgYW5kIGl0IGhhcyBubyBzdWJzY3JpYmVycy4gIEZvciBwZXJmb3JtYW5jZSBzYWtlLCB3ZVxuICAgICAqIGltbWVkaWF0ZSBleGl0IGluIHRoaXMgY2FzZS4gIFRoaXMgbWVhbnMgdGhlIGV2ZW50IHdvbid0IGJ1YmJsZSwgc29cbiAgICAgKiBpZiB0aGUgaW50ZW50aW9uIGlzIHRoYXQgYSBidWJibGUgdGFyZ2V0IGJlIG5vdGlmaWVkLCB0aGUgZXZlbnQgbXVzdFxuICAgICAqIGJlIHB1Ymxpc2hlZCBvbiB0aGlzIG9iamVjdCBmaXJzdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZmlyZVxuICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd8T2JqZWN0fSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIG9yIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zXG4gICAgICogYSAndHlwZScgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIGFyZ3VtZW50cyB7T2JqZWN0Kn0gYW4gYXJiaXRyYXJ5IHNldCBvZiBwYXJhbWV0ZXJzIHRvIHBhc3MgdG9cbiAgICAgKiB0aGUgaGFuZGxlci4gIElmIHRoZSBmaXJzdCBvZiB0aGVzZSBpcyBhbiBvYmplY3QgbGl0ZXJhbCBhbmQgdGhlIGV2ZW50IGlzXG4gICAgICogY29uZmlndXJlZCB0byBlbWl0IGFuIGV2ZW50IGZhY2FkZSwgdGhlIGV2ZW50IGZhY2FkZSB3aWxsIHJlcGxhY2UgdGhhdFxuICAgICAqIHBhcmFtZXRlciBhZnRlciB0aGUgcHJvcGVydGllcyB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgYXJlIGNvcGllZCB0b1xuICAgICAqIHRoZSBldmVudCBmYWNhZGUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgd2hvbGUgbGlmZWN5Y2xlIG9mIHRoZSBldmVudCB3ZW50IHRocm91Z2gsXG4gICAgICogZmFsc2UgaWYgYXQgYW55IHBvaW50IHRoZSBldmVudCBwcm9wYWdhdGlvbiB3YXMgaGFsdGVkLlxuICAgICAqL1xuICAgIGZpcmU6IGZ1bmN0aW9uKHR5cGUpIHtcblxuICAgICAgICB2YXIgdHlwZUluY2x1ZGVkID0gKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiKSxcbiAgICAgICAgICAgIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIHQgPSB0eXBlLFxuICAgICAgICAgICAgeXVpZXZ0ID0gdGhpcy5feXVpZXZ0LFxuICAgICAgICAgICAgZXRDb25maWcgPSB5dWlldnQuY29uZmlnLFxuICAgICAgICAgICAgcHJlID0gZXRDb25maWcucHJlZml4LFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgY2UsXG4gICAgICAgICAgICBjZTIsXG4gICAgICAgICAgICBhcmdzO1xuXG4gICAgICAgIGlmICh0eXBlSW5jbHVkZWQgJiYgYXJnQ291bnQgPD0gMykge1xuXG4gICAgICAgICAgICAvLyBQRVJGOiBUcnkgdG8gYXZvaWQgc2xpY2UvaXRlcmF0aW9uIGZvciB0aGUgY29tbW9uIHNpZ25hdHVyZXNcblxuICAgICAgICAgICAgLy8gTW9zdCBjb21tb25cbiAgICAgICAgICAgIGlmIChhcmdDb3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbYXJndW1lbnRzWzFdXTsgLy8gZmlyZShcImZvb1wiLCB7fSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTsgLy8gZmlyZShcImZvb1wiLCB7fSwgb3B0cylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFtdOyAvLyBmaXJlKFwiZm9vXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgKCh0eXBlSW5jbHVkZWQpID8gMSA6IDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHlwZUluY2x1ZGVkKSB7XG4gICAgICAgICAgICB0ID0gKHR5cGUgJiYgdHlwZS50eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmUpIHtcbiAgICAgICAgICAgIHQgPSBfZ2V0VHlwZSh0LCBwcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2UgPSB5dWlldnQuZXZlbnRzW3RdO1xuXG4gICAgICAgIGlmICh0aGlzLl9oYXNTaWJsaW5ncykge1xuICAgICAgICAgICAgY2UyID0gdGhpcy5nZXRTaWJsaW5nKHQsIGNlKTtcblxuICAgICAgICAgICAgaWYgKGNlMiAmJiAhY2UpIHtcbiAgICAgICAgICAgICAgICBjZSA9IHRoaXMucHVibGlzaCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBFUkY6IHRyeWluZyB0byBhdm9pZCBmdW5jdGlvbiBjYWxsLCBzaW5jZSB0aGlzIGlzIGEgY3JpdGljYWwgcGF0aFxuICAgICAgICBpZiAoKGV0Q29uZmlnLm1vbml0b3JlZCAmJiAoIWNlIHx8IGNlLm1vbml0b3JlZCkpIHx8IChjZSAmJiBjZS5tb25pdG9yZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb25pdG9yKCdmaXJlJywgKGNlIHx8IHQpLCB7XG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzIGV2ZW50IGhhcyBub3QgYmVlbiBwdWJsaXNoZWQgb3Igc3Vic2NyaWJlZCB0b1xuICAgICAgICBpZiAoIWNlKSB7XG4gICAgICAgICAgICBpZiAoeXVpZXZ0Lmhhc1RhcmdldHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWJibGUoeyB0eXBlOiB0IH0sIGFyZ3MsIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgdGhlcmUgaXMgbm90aGluZyB0byBiZSBkb25lXG4gICAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoY2UyKSB7XG4gICAgICAgICAgICAgICAgY2Uuc2libGluZyA9IGNlMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0ID0gY2UuX2ZpcmUoYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHl1aWV2dC5jaGFpbikgPyB0aGlzIDogcmV0O1xuICAgIH0sXG5cbiAgICBnZXRTaWJsaW5nOiBmdW5jdGlvbih0eXBlLCBjZSkge1xuICAgICAgICB2YXIgY2UyO1xuXG4gICAgICAgIC8vIGRlbGVnYXRlIHRvICo6dHlwZSBldmVudHMgaWYgdGhlcmUgYXJlIHN1YnNjcmliZXJzXG4gICAgICAgIGlmICh0eXBlLmluZGV4T2YoUFJFRklYX0RFTElNSVRFUikgPiAtMSkge1xuICAgICAgICAgICAgdHlwZSA9IF93aWxkVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIGNlMiA9IHRoaXMuZ2V0RXZlbnQodHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoY2UyKSB7XG4gICAgICAgICAgICAgICAgY2UyLmFwcGx5Q29uZmlnKGNlKTtcbiAgICAgICAgICAgICAgICBjZTIuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNlMi5icm9hZGNhc3QgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VzdG9tIGV2ZW50IG9mIHRoZSBwcm92aWRlZCB0eXBlIGhhcyBiZWVuIGNyZWF0ZWQsIGFcbiAgICAgKiBmYWxzeSB2YWx1ZSBvdGhlcndpc2VcbiAgICAgKiBAbWV0aG9kIGdldEV2ZW50XG4gICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gdGhlIHR5cGUsIG9yIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHByZWZpeGVkIHtTdHJpbmd9IGlmIHRydWUsIHRoZSB0eXBlIGlzIHByZWZpeGVkIGFscmVhZHlcbiAgICAgKiBAcmV0dXJuIHtDdXN0b21FdmVudH0gdGhlIGN1c3RvbSBldmVudCBvciBudWxsXG4gICAgICovXG4gICAgZ2V0RXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHByZWZpeGVkKSB7XG4gICAgICAgIHZhciBwcmUsIGU7XG5cbiAgICAgICAgaWYgKCFwcmVmaXhlZCkge1xuICAgICAgICAgICAgcHJlID0gdGhpcy5feXVpZXZ0LmNvbmZpZy5wcmVmaXg7XG4gICAgICAgICAgICB0eXBlID0gKHByZSkgPyBfZ2V0VHlwZSh0eXBlLCBwcmUpIDogdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBlID0gdGhpcy5feXVpZXZ0LmV2ZW50cztcbiAgICAgICAgcmV0dXJuIGVbdHlwZV0gfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGEgY3VzdG9tIGV2ZW50IGhvc3RlZCBieSB0aGlzIG9iamVjdC4gIFRoZVxuICAgICAqIHN1cHBsaWVkIGNhbGxiYWNrIHdpbGwgZXhlY3V0ZSBhZnRlciBhbnkgbGlzdGVuZXJzIGFkZFxuICAgICAqIHZpYSB0aGUgc3Vic2NyaWJlIG1ldGhvZCwgYW5kIGFmdGVyIHRoZSBkZWZhdWx0IGZ1bmN0aW9uLFxuICAgICAqIGlmIGNvbmZpZ3VyZWQgZm9yIHRoZSBldmVudCwgaGFzIGV4ZWN1dGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZnRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIGluIHJlc3BvbnNlIHRvIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gT3ZlcnJpZGUgYHRoaXNgIG9iamVjdCBpbiBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7QW55fSBbYXJnKl0gMC4ubiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzdXBwbHkgdG8gdGhlIHN1YnNjcmliZXJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gQSBzdWJzY3JpcHRpb24gaGFuZGxlIGNhcGFibGUgb2YgZGV0YWNoaW5nIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25cbiAgICAgKi9cbiAgICBhZnRlcjogZnVuY3Rpb24odHlwZSwgZm4pIHtcblxuICAgICAgICB2YXIgYSA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICBzd2l0Y2ggKEwudHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBZLkRvLmFmdGVyLmFwcGx5KFkuRG8sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAvLyAgICAgWUFycmF5LmVhY2goYVswXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgLy8gICAgICAgICB2ID0gQUZURVJfUFJFRklYICsgdjtcbiAgICAgICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgICAgIC8vICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgYVswXS5fYWZ0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhWzBdID0gQUZURVJfUFJFRklYICsgdHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm9uLmFwcGx5KHRoaXMsIGEpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjYWxsYmFjayBiZWZvcmUgYSBET00gZXZlbnQsIGN1c3RvbSBldmVudFxuICAgICAqIG9yIG1ldGhvZC4gIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLCBpdFxuICAgICAqIGlzIGFzc3VtZWQgdGhlIHRhcmdldCBpcyBhIG1ldGhvZC4gIEZvciBET00gYW5kIGN1c3RvbVxuICAgICAqIGV2ZW50cywgdGhpcyBpcyBhbiBhbGlhcyBmb3IgWS5vbi5cbiAgICAgKlxuICAgICAqIEZvciBET00gYW5kIGN1c3RvbSBldmVudHM6XG4gICAgICogdHlwZSwgY2FsbGJhY2ssIGNvbnRleHQsIDAtbiBhcmd1bWVudHNcbiAgICAgKlxuICAgICAqIEZvciBtZXRob2RzOlxuICAgICAqIGNhbGxiYWNrLCBvYmplY3QgKG1ldGhvZCBob3N0KSwgbWV0aG9kTmFtZSwgY29udGV4dCwgMC1uIGFyZ3VtZW50c1xuICAgICAqXG4gICAgICogQG1ldGhvZCBiZWZvcmVcbiAgICAgKiBAcmV0dXJuIGRldGFjaCBoYW5kbGVcbiAgICAgKi9cbiAgICBiZWZvcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxufTtcblxuWS5FdmVudFRhcmdldCA9IEVUO1xuXG4vLyBtYWtlIFkgYW4gZXZlbnQgdGFyZ2V0XG5ZLm1peChZLCBFVC5wcm90b3R5cGUpO1xuRVQuY2FsbChZLCB7IGJ1YmJsZXM6IGZhbHNlIH0pO1xuXG5ZVUkuRW52Lmdsb2JhbEV2ZW50cyA9IFlVSS5FbnYuZ2xvYmFsRXZlbnRzIHx8IG5ldyBFVCgpO1xuXG4vKipcbiAqIEhvc3RzIFlVSSBwYWdlIGxldmVsIGV2ZW50cy4gIFRoaXMgaXMgd2hlcmUgZXZlbnRzIGJ1YmJsZSB0b1xuICogd2hlbiB0aGUgYnJvYWRjYXN0IGNvbmZpZyBpcyBzZXQgdG8gMi4gIFRoaXMgcHJvcGVydHkgaXNcbiAqIG9ubHkgYXZhaWxhYmxlIGlmIHRoZSBjdXN0b20gZXZlbnQgbW9kdWxlIGlzIGxvYWRlZC5cbiAqIEBwcm9wZXJ0eSBHbG9iYWxcbiAqIEB0eXBlIEV2ZW50VGFyZ2V0XG4gKiBAZm9yIFlVSVxuICovXG5ZLkdsb2JhbCA9IFlVSS5FbnYuZ2xvYmFsRXZlbnRzO1xuXG4vLyBAVE9ETyBpbXBsZW1lbnQgYSBnbG9iYWwgbmFtZXNwYWNlIGZ1bmN0aW9uIG9uIFkuR2xvYmFsP1xuXG4vKipcbmBZLm9uKClgIGNhbiBkbyBtYW55IHRoaW5nczpcblxuPHVsPlxuICAgIDxsaT5TdWJzY3JpYmUgdG8gY3VzdG9tIGV2ZW50cyBgcHVibGlzaGBlZCBhbmQgYGZpcmVgZCBmcm9tIFk8L2xpPlxuICAgIDxsaT5TdWJzY3JpYmUgdG8gY3VzdG9tIGV2ZW50cyBgcHVibGlzaGBlZCB3aXRoIGBicm9hZGNhc3RgIDEgb3IgMiBhbmRcbiAgICAgICAgYGZpcmVgZCBmcm9tIGFueSBvYmplY3QgaW4gdGhlIFlVSSBpbnN0YW5jZSBzYW5kYm94PC9saT5cbiAgICA8bGk+U3Vic2NyaWJlIHRvIERPTSBldmVudHM8L2xpPlxuICAgIDxsaT5TdWJzY3JpYmUgdG8gdGhlIGV4ZWN1dGlvbiBvZiBhIG1ldGhvZCBvbiBhbnkgb2JqZWN0LCBlZmZlY3RpdmVseVxuICAgIHRyZWF0aW5nIHRoYXQgbWV0aG9kIGFzIGFuIGV2ZW50PC9saT5cbjwvdWw+XG5cbkZvciBjdXN0b20gZXZlbnQgc3Vic2NyaXB0aW9ucywgcGFzcyB0aGUgY3VzdG9tIGV2ZW50IG5hbWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG5hbmQgY2FsbGJhY2sgYXMgdGhlIHNlY29uZC4gVGhlIGB0aGlzYCBvYmplY3QgaW4gdGhlIGNhbGxiYWNrIHdpbGwgYmUgYFlgIHVubGVzc1xuYW4gb3ZlcnJpZGUgaXMgcGFzc2VkIGFzIHRoZSB0aGlyZCBhcmd1bWVudC5cblxuICAgIFkub24oJ2lvOmNvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBZLk15QXBwLnVwZGF0ZVN0YXR1cygnVHJhbnNhY3Rpb24gY29tcGxldGUnKTtcbiAgICB9KTtcblxuVG8gc3Vic2NyaWJlIHRvIERPTSBldmVudHMsIHBhc3MgdGhlIG5hbWUgb2YgYSBET00gZXZlbnQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG5hbmQgYSBDU1Mgc2VsZWN0b3Igc3RyaW5nIGFzIHRoZSB0aGlyZCBhcmd1bWVudCBhZnRlciB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5BbHRlcm5hdGVseSwgdGhlIHRoaXJkIGFyZ3VtZW50IGNhbiBiZSBhIGBOb2RlYCwgYE5vZGVMaXN0YCwgYEhUTUxFbGVtZW50YCxcbmFycmF5LCBvciBzaW1wbHkgb21pdHRlZCAodGhlIGRlZmF1bHQgaXMgdGhlIGB3aW5kb3dgIG9iamVjdCkuXG5cbiAgICBZLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBwcm9jZWVkIHdpdGggYWpheCBmb3JtIHN1Ym1pc3Npb25cbiAgICAgICAgdmFyIHVybCA9IHRoaXMuZ2V0KCdhY3Rpb24nKTtcbiAgICAgICAgLi4uXG4gICAgfSwgJyNteS1mb3JtJyk7XG5cblRoZSBgdGhpc2Agb2JqZWN0IGluIERPTSBldmVudCBjYWxsYmFja3Mgd2lsbCBiZSB0aGUgYE5vZGVgIHRhcmdldGVkIGJ5IHRoZSBDU1NcbnNlbGVjdG9yIG9yIG90aGVyIGlkZW50aWZpZXIuXG5cbmBvbigpYCBzdWJzY3JpYmVycyBmb3IgRE9NIGV2ZW50cyBvciBjdXN0b20gZXZlbnRzIGBwdWJsaXNoYGVkIHdpdGggYVxuYGRlZmF1bHRGbmAgY2FuIHByZXZlbnQgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2l0aCBgZS5wcmV2ZW50RGVmYXVsdCgpYCBmcm9tIHRoZVxuZXZlbnQgb2JqZWN0IHBhc3NlZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIHRoZSBzdWJzY3JpcHRpb24gY2FsbGJhY2suXG5cblRvIHN1YnNjcmliZSB0byB0aGUgZXhlY3V0aW9uIG9mIGFuIG9iamVjdCBtZXRob2QsIHBhc3MgYXJndW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNhbGwgc2lnbmF0dXJlIGZvclxuPGEgaHJlZj1cIi4uL2NsYXNzZXMvRG8uaHRtbCNtZXRob2RzX2JlZm9yZVwiPmBZLkRvLmJlZm9yZSguLi4pYDwvYT4uXG5cbk5PVEU6IFRoZSBmb3JtYWwgcGFyYW1ldGVyIGxpc3QgYmVsb3cgaXMgZm9yIGV2ZW50cywgbm90IGZvciBmdW5jdGlvblxuaW5qZWN0aW9uLiAgU2VlIGBZLkRvLmJlZm9yZWAgZm9yIHRoYXQgc2lnbmF0dXJlLlxuXG5AbWV0aG9kIG9uXG5AcGFyYW0ge1N0cmluZ30gdHlwZSBET00gb3IgY3VzdG9tIGV2ZW50IG5hbWVcbkBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIGluIHJlc3BvbnNlIHRvIHRoZSBldmVudFxuQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBPdmVycmlkZSBgdGhpc2Agb2JqZWN0IGluIGNhbGxiYWNrXG5AcGFyYW0ge0FueX0gW2FyZypdIDAuLm4gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc3VwcGx5IHRvIHRoZSBzdWJzY3JpYmVyXG5AcmV0dXJuIHtFdmVudEhhbmRsZX0gQSBzdWJzY3JpcHRpb24gaGFuZGxlIGNhcGFibGUgb2YgZGV0YWNoaW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblxuQHNlZSBEby5iZWZvcmVcbkBmb3IgWVVJXG4qKi9cblxuLyoqXG5MaXN0ZW4gZm9yIGFuIGV2ZW50IG9uZSB0aW1lLiAgRXF1aXZhbGVudCB0byBgb24oKWAsIGV4Y2VwdCB0aGF0XG50aGUgbGlzdGVuZXIgaXMgaW1tZWRpYXRlbHkgZGV0YWNoZWQgd2hlbiBleGVjdXRlZC5cblxuU2VlIHRoZSA8YSBocmVmPVwiI21ldGhvZHNfb25cIj5gb24oKWAgbWV0aG9kPC9hPiBmb3IgYWRkaXRpb25hbCBzdWJzY3JpcHRpb25cbm9wdGlvbnMuXG5cbkBzZWUgb25cbkBtZXRob2Qgb25jZVxuQHBhcmFtIHtTdHJpbmd9IHR5cGUgRE9NIG9yIGN1c3RvbSBldmVudCBuYW1lXG5AcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBpbiByZXNwb25zZSB0byB0aGUgZXZlbnRcbkBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gT3ZlcnJpZGUgYHRoaXNgIG9iamVjdCBpbiBjYWxsYmFja1xuQHBhcmFtIHtBbnl9IFthcmcqXSAwLi5uIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHN1cHBseSB0byB0aGUgc3Vic2NyaWJlclxuQHJldHVybiB7RXZlbnRIYW5kbGV9IEEgc3Vic2NyaXB0aW9uIGhhbmRsZSBjYXBhYmxlIG9mIGRldGFjaGluZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25cbkBmb3IgWVVJXG4qKi9cblxuLyoqXG5MaXN0ZW4gZm9yIGFuIGV2ZW50IG9uZSB0aW1lLiAgRXF1aXZhbGVudCB0byBgb25jZSgpYCwgZXhjZXB0LCBsaWtlIGBhZnRlcigpYCxcbnRoZSBzdWJzY3JpcHRpb24gY2FsbGJhY2sgZXhlY3V0ZXMgYWZ0ZXIgYWxsIGBvbigpYCBzdWJzY3JpYmVycyBhbmQgdGhlIGV2ZW50J3NcbmBkZWZhdWx0Rm5gIChpZiBjb25maWd1cmVkKSBoYXZlIGV4ZWN1dGVkLiAgTGlrZSBgYWZ0ZXIoKWAgaWYgYW55IGBvbigpYCBwaGFzZVxuc3Vic2NyaWJlciBjYWxscyBgZS5wcmV2ZW50RGVmYXVsdCgpYCwgbmVpdGhlciB0aGUgYGRlZmF1bHRGbmAgbm9yIHRoZSBgYWZ0ZXIoKWBcbnN1YnNjcmliZXJzIHdpbGwgZXhlY3V0ZS5cblxuVGhlIGxpc3RlbmVyIGlzIGltbWVkaWF0ZWx5IGRldGFjaGVkIHdoZW4gZXhlY3V0ZWQuXG5cblNlZSB0aGUgPGEgaHJlZj1cIiNtZXRob2RzX29uXCI+YG9uKClgIG1ldGhvZDwvYT4gZm9yIGFkZGl0aW9uYWwgc3Vic2NyaXB0aW9uXG5vcHRpb25zLlxuXG5Ac2VlIG9uY2VcbkBtZXRob2Qgb25jZUFmdGVyXG5AcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgY3VzdG9tIGV2ZW50IG5hbWVcbkBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIGluIHJlc3BvbnNlIHRvIHRoZSBldmVudFxuQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBPdmVycmlkZSBgdGhpc2Agb2JqZWN0IGluIGNhbGxiYWNrXG5AcGFyYW0ge0FueX0gW2FyZypdIDAuLm4gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc3VwcGx5IHRvIHRoZSBzdWJzY3JpYmVyXG5AcmV0dXJuIHtFdmVudEhhbmRsZX0gQSBzdWJzY3JpcHRpb24gaGFuZGxlIGNhcGFibGUgb2YgZGV0YWNoaW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblxuQGZvciBZVUlcbioqL1xuXG4vKipcbkxpa2UgYG9uKClgLCB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgc3Vic2NyaXB0aW9uIHRvIGEgY3VzdG9tIGV2ZW50IG9yIHRvIHRoZVxuZXhlY3V0aW9uIG9mIGEgbWV0aG9kIG9uIGFuIG9iamVjdC5cblxuRm9yIGV2ZW50cywgYGFmdGVyKClgIHN1YnNjcmliZXJzIGFyZSBleGVjdXRlZCBhZnRlciB0aGUgZXZlbnQnc1xuYGRlZmF1bHRGbmAgdW5sZXNzIGBlLnByZXZlbnREZWZhdWx0KClgIHdhcyBjYWxsZWQgZnJvbSBhbiBgb24oKWAgc3Vic2NyaWJlci5cblxuU2VlIHRoZSA8YSBocmVmPVwiI21ldGhvZHNfb25cIj5gb24oKWAgbWV0aG9kPC9hPiBmb3IgYWRkaXRpb25hbCBzdWJzY3JpcHRpb25cbm9wdGlvbnMuXG5cbk5PVEU6IFRoZSBzdWJzY3JpcHRpb24gc2lnbmF0dXJlIHNob3duIGlzIGZvciBldmVudHMsIG5vdCBmb3IgZnVuY3Rpb25cbmluamVjdGlvbi4gIFNlZSA8YSBocmVmPVwiLi4vY2xhc3Nlcy9Eby5odG1sI21ldGhvZHNfYWZ0ZXJcIj5gWS5Eby5hZnRlcmA8L2E+XG5mb3IgdGhhdCBzaWduYXR1cmUuXG5cbkBzZWUgb25cbkBzZWUgRG8uYWZ0ZXJcbkBtZXRob2QgYWZ0ZXJcbkBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBjdXN0b20gZXZlbnQgbmFtZVxuQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgaW4gcmVzcG9uc2UgdG8gdGhlIGV2ZW50XG5AcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIE92ZXJyaWRlIGB0aGlzYCBvYmplY3QgaW4gY2FsbGJhY2tcbkBwYXJhbSB7QW55fSBbYXJncypdIDAuLm4gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc3VwcGx5IHRvIHRoZSBzdWJzY3JpYmVyXG5AcmV0dXJuIHtFdmVudEhhbmRsZX0gQSBzdWJzY3JpcHRpb24gaGFuZGxlIGNhcGFibGUgb2YgZGV0YWNoaW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblxuQGZvciBZVUlcbioqL1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJvb3BcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnZXZlbnQtY3VzdG9tLWNvbXBsZXgnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG5cbi8qKlxuICogQWRkcyBldmVudCBmYWNhZGVzLCBwcmV2ZW50YWJsZSBkZWZhdWx0IGJlaGF2aW9yLCBhbmQgYnViYmxpbmcuXG4gKiBldmVudHMuXG4gKiBAbW9kdWxlIGV2ZW50LWN1c3RvbVxuICogQHN1Ym1vZHVsZSBldmVudC1jdXN0b20tY29tcGxleFxuICovXG5cbnZhciBGQUNBREUsXG4gICAgRkFDQURFX0tFWVMsXG4gICAgWU9iamVjdCA9IFkuT2JqZWN0LFxuICAgIGtleSxcbiAgICBFTVBUWSA9IHt9LFxuICAgIENFUHJvdG8gPSBZLkN1c3RvbUV2ZW50LnByb3RvdHlwZSxcbiAgICBFVFByb3RvID0gWS5FdmVudFRhcmdldC5wcm90b3R5cGUsXG5cbiAgICBtaXhGYWNhZGVQcm9wcyA9IGZ1bmN0aW9uKGZhY2FkZSwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgcDtcblxuICAgICAgICBmb3IgKHAgaW4gcGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKCEoRkFDQURFX0tFWVMuaGFzT3duUHJvcGVydHkocCkpKSB7XG4gICAgICAgICAgICAgICAgZmFjYWRlW3BdID0gcGF5bG9hZFtwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbi8qKlxuICogV3JhcHMgYW5kIHByb3RlY3RzIGEgY3VzdG9tIGV2ZW50IGZvciB1c2Ugd2hlbiBlbWl0RmFjYWRlIGlzIHNldCB0byB0cnVlLlxuICogUmVxdWlyZXMgdGhlIGV2ZW50LWN1c3RvbS1jb21wbGV4IG1vZHVsZVxuICogQGNsYXNzIEV2ZW50RmFjYWRlXG4gKiBAcGFyYW0gZSB7RXZlbnR9IHRoZSBjdXN0b20gZXZlbnRcbiAqIEBwYXJhbSBjdXJyZW50VGFyZ2V0IHtIVE1MRWxlbWVudH0gdGhlIGVsZW1lbnQgdGhlIGxpc3RlbmVyIHdhcyBhdHRhY2hlZCB0b1xuICovXG5cblkuRXZlbnRGYWNhZGUgPSBmdW5jdGlvbihlLCBjdXJyZW50VGFyZ2V0KSB7XG5cbiAgICBpZiAoIWUpIHtcbiAgICAgICAgZSA9IEVNUFRZO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50ID0gZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIGZpcmVcbiAgICAgKiBAcHJvcGVydHkgZGV0YWlsc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdGhpcy5kZXRhaWxzID0gZS5kZXRhaWxzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHR5cGUsIHRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGZpcmUoKSBwYXlsb2FkXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBlLnR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVhbCBldmVudCB0eXBlXG4gICAgICogQHByb3BlcnR5IF90eXBlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90eXBlID0gZS50eXBlO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBOb2RlIHJlZmVyZW5jZSBmb3IgdGhlIHRhcmdldGVkIGV2ZW50dGFyZ2V0XG4gICAgICogQHByb3BlcnR5IHRhcmdldFxuICAgICAqIEB0eXBlIE5vZGVcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgLyoqXG4gICAgICogTm9kZSByZWZlcmVuY2UgZm9yIHRoZSBlbGVtZW50IHRoYXQgdGhlIGxpc3RlbmVyIHdhcyBhdHRhY2hlZCB0by5cbiAgICAgKiBAcHJvcGVydHkgY3VycmVudFRhcmdldFxuICAgICAqIEB0eXBlIE5vZGVcbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuXG4gICAgLyoqXG4gICAgICogTm9kZSByZWZlcmVuY2UgdG8gdGhlIHJlbGF0ZWRUYXJnZXRcbiAgICAgKiBAcHJvcGVydHkgcmVsYXRlZFRhcmdldFxuICAgICAqIEB0eXBlIE5vZGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG5cbn07XG5cblkubWl4KFkuRXZlbnRGYWNhZGUucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgcHJvcGFnYXRpb24gdG8gdGhlIG5leHQgYnViYmxlIHRhcmdldFxuICAgICAqIEBtZXRob2Qgc3RvcFByb3BhZ2F0aW9uXG4gICAgICovXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBwcm9wYWdhdGlvbiB0byB0aGUgbmV4dCBidWJibGUgdGFyZ2V0IGFuZFxuICAgICAqIHByZXZlbnRzIGFueSBhZGRpdGlvbmFsIGxpc3RlbmVycyBmcm9tIGJlaW5nIGV4ZWN0dWVkXG4gICAgICogb24gdGhlIGN1cnJlbnQgdGFyZ2V0LlxuICAgICAqIEBtZXRob2Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG4gICAgICovXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBldmVudCdzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgKiBAbWV0aG9kIHByZXZlbnREZWZhdWx0XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBldmVudCBwcm9wYWdhdGlvbiBhbmQgcHJldmVudHMgdGhlIGRlZmF1bHRcbiAgICAgKiBldmVudCBiZWhhdmlvci5cbiAgICAgKiBAbWV0aG9kIGhhbHRcbiAgICAgKiBAcGFyYW0gaW1tZWRpYXRlIHtib29sZWFufSBpZiB0cnVlIGFkZGl0aW9uYWwgbGlzdGVuZXJzXG4gICAgICogb24gdGhlIGN1cnJlbnQgdGFyZ2V0IHdpbGwgbm90IGJlIGV4ZWN1dGVkXG4gICAgICovXG4gICAgaGFsdDogZnVuY3Rpb24oaW1tZWRpYXRlKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50LmhhbHQoaW1tZWRpYXRlKTtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSAxO1xuICAgICAgICB0aGlzLnN0b3BwZWQgPSAoaW1tZWRpYXRlKSA/IDIgOiAxO1xuICAgIH1cblxufSk7XG5cbkNFUHJvdG8uZmlyZUNvbXBsZXggPSBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICB2YXIgZXMsXG4gICAgICAgIGVmLFxuICAgICAgICBxLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgY2UsXG4gICAgICAgIHJldCA9IHRydWUsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgc3VicyxcbiAgICAgICAgb25zLFxuICAgICAgICBhZnRlcnMsXG4gICAgICAgIGFmdGVyUXVldWUsXG4gICAgICAgIHBvc3Rwb25lZCxcbiAgICAgICAgcHJldmVudGVkLFxuICAgICAgICBwcmV2ZW50ZWRGbixcbiAgICAgICAgZGVmYXVsdEZuLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaG9zdCA9IHNlbGYuaG9zdCB8fCBzZWxmLFxuICAgICAgICBuZXh0LFxuICAgICAgICBvbGRidWJibGUsXG4gICAgICAgIHN0YWNrID0gc2VsZi5zdGFjayxcbiAgICAgICAgeXVpZXZ0ID0gaG9zdC5feXVpZXZ0LFxuICAgICAgICBoYXNQb3RlbnRpYWxTdWJzY3JpYmVycztcblxuICAgIGlmIChzdGFjaykge1xuXG4gICAgICAgIC8vIHF1ZXVlIHRoaXMgZXZlbnQgaWYgdGhlIGN1cnJlbnQgaXRlbSBpbiB0aGUgcXVldWUgYnViYmxlc1xuICAgICAgICBpZiAoc2VsZi5xdWV1YWJsZSAmJiBzZWxmLnR5cGUgIT09IHN0YWNrLm5leHQudHlwZSkge1xuXG4gICAgICAgICAgICBpZiAoIXN0YWNrLnF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucXVldWUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnF1ZXVlLnB1c2goW3NlbGYsIGFyZ3NdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNQb3RlbnRpYWxTdWJzY3JpYmVycyA9IHNlbGYuaGFzU3VicygpIHx8IHl1aWV2dC5oYXNUYXJnZXRzIHx8IHNlbGYuYnJvYWRjYXN0O1xuXG4gICAgc2VsZi50YXJnZXQgPSBzZWxmLnRhcmdldCB8fCBob3N0O1xuICAgIHNlbGYuY3VycmVudFRhcmdldCA9IGhvc3Q7XG5cbiAgICBzZWxmLmRldGFpbHMgPSBhcmdzLmNvbmNhdCgpO1xuXG4gICAgaWYgKGhhc1BvdGVudGlhbFN1YnNjcmliZXJzKSB7XG5cbiAgICAgICAgZXMgPSBzdGFjayB8fCB7XG5cbiAgICAgICAgICAgaWQ6IHNlbGYuaWQsIC8vIGlkIG9mIHRoZSBmaXJzdCBldmVudCBpbiB0aGUgc3RhY2tcbiAgICAgICAgICAgbmV4dDogc2VsZixcbiAgICAgICAgICAgc2lsZW50OiBzZWxmLnNpbGVudCxcbiAgICAgICAgICAgc3RvcHBlZDogMCxcbiAgICAgICAgICAgcHJldmVudGVkOiAwLFxuICAgICAgICAgICBidWJibGluZzogbnVsbCxcbiAgICAgICAgICAgdHlwZTogc2VsZi50eXBlLFxuICAgICAgICAgICAvLyBkZWZhdWx0Rm5RdWV1ZTogbmV3IFkuUXVldWUoKSxcbiAgICAgICAgICAgZGVmYXVsdFRhcmdldE9ubHk6IHNlbGYuZGVmYXVsdFRhcmdldE9ubHlcblxuICAgICAgICB9O1xuXG4gICAgICAgIHN1YnMgPSBzZWxmLmdldFN1YnMoKTtcbiAgICAgICAgb25zID0gc3Vic1swXTtcbiAgICAgICAgYWZ0ZXJzID0gc3Vic1sxXTtcblxuICAgICAgICBzZWxmLnN0b3BwZWQgPSAoc2VsZi50eXBlICE9PSBlcy50eXBlKSA/IDAgOiBlcy5zdG9wcGVkO1xuICAgICAgICBzZWxmLnByZXZlbnRlZCA9IChzZWxmLnR5cGUgIT09IGVzLnR5cGUpID8gMCA6IGVzLnByZXZlbnRlZDtcblxuICAgICAgICBpZiAoc2VsZi5zdG9wcGVkRm4pIHtcbiAgICAgICAgICAgIC8vIFBFUkYgVE9ETzogQ2FuIHdlIHJlcGxhY2Ugd2l0aCBjYWxsYmFjaywgbGlrZSBwcmV2ZW50ZWRGbi4gTG9vayBpbnRvIGhpc3RvcnlcbiAgICAgICAgICAgIGV2ZW50cyA9IG5ldyBZLkV2ZW50VGFyZ2V0KHtcbiAgICAgICAgICAgICAgICBmaXJlT25jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBob3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRzID0gZXZlbnRzO1xuICAgICAgICAgICAgZXZlbnRzLm9uKCdzdG9wcGVkJywgc2VsZi5zdG9wcGVkRm4pO1xuICAgICAgICB9XG5cblxuICAgICAgICBzZWxmLl9mYWNhZGUgPSBudWxsOyAvLyBraWxsIGZhY2FkZSB0byBlbGltaW5hdGUgc3RhbGUgcHJvcGVydGllc1xuXG4gICAgICAgIGVmID0gc2VsZi5fY3JlYXRlRmFjYWRlKGFyZ3MpO1xuXG4gICAgICAgIGlmIChvbnMpIHtcbiAgICAgICAgICAgIHNlbGYuX3Byb2NTdWJzKG9ucywgYXJncywgZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnViYmxlIGlmIHRoaXMgaXMgaG9zdGVkIGluIGFuIGV2ZW50IHRhcmdldCBhbmQgcHJvcGFnYXRpb24gaGFzIG5vdCBiZWVuIHN0b3BwZWRcbiAgICAgICAgaWYgKHNlbGYuYnViYmxlcyAmJiBob3N0LmJ1YmJsZSAmJiAhc2VsZi5zdG9wcGVkKSB7XG4gICAgICAgICAgICBvbGRidWJibGUgPSBlcy5idWJibGluZztcblxuICAgICAgICAgICAgZXMuYnViYmxpbmcgPSBzZWxmLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChlcy50eXBlICE9PSBzZWxmLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBlcy5zdG9wcGVkID0gMDtcbiAgICAgICAgICAgICAgICBlcy5wcmV2ZW50ZWQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXQgPSBob3N0LmJ1YmJsZShzZWxmLCBhcmdzLCBudWxsLCBlcyk7XG5cbiAgICAgICAgICAgIHNlbGYuc3RvcHBlZCA9IE1hdGgubWF4KHNlbGYuc3RvcHBlZCwgZXMuc3RvcHBlZCk7XG4gICAgICAgICAgICBzZWxmLnByZXZlbnRlZCA9IE1hdGgubWF4KHNlbGYucHJldmVudGVkLCBlcy5wcmV2ZW50ZWQpO1xuXG4gICAgICAgICAgICBlcy5idWJibGluZyA9IG9sZGJ1YmJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZlbnRlZCA9IHNlbGYucHJldmVudGVkO1xuXG4gICAgICAgIGlmIChwcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHByZXZlbnRlZEZuID0gc2VsZi5wcmV2ZW50ZWRGbjtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50ZWRGbikge1xuICAgICAgICAgICAgICAgIHByZXZlbnRlZEZuLmFwcGx5KGhvc3QsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdEZuID0gc2VsZi5kZWZhdWx0Rm47XG5cbiAgICAgICAgICAgIGlmIChkZWZhdWx0Rm4gJiYgKCghc2VsZi5kZWZhdWx0VGFyZ2V0T25seSAmJiAhZXMuZGVmYXVsdFRhcmdldE9ubHkpIHx8IGhvc3QgPT09IGVmLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Rm4uYXBwbHkoaG9zdCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBicm9hZGNhc3QgbGlzdGVuZXJzIGFyZSBmaXJlZCBhcyBkaXNjcmVldCBldmVudHMgb24gdGhlXG4gICAgICAgIC8vIFlVSSBpbnN0YW5jZSBhbmQgcG90ZW50aWFsbHkgdGhlIFlVSSBnbG9iYWwuXG4gICAgICAgIGlmIChzZWxmLmJyb2FkY2FzdCkge1xuICAgICAgICAgICAgc2VsZi5fYnJvYWRjYXN0KGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFmdGVycyAmJiAhc2VsZi5wcmV2ZW50ZWQgJiYgc2VsZi5zdG9wcGVkIDwgMikge1xuXG4gICAgICAgICAgICAvLyBRdWV1ZSB0aGUgYWZ0ZXJcbiAgICAgICAgICAgIGFmdGVyUXVldWUgPSBlcy5hZnRlclF1ZXVlO1xuXG4gICAgICAgICAgICBpZiAoZXMuaWQgPT09IHNlbGYuaWQgfHwgc2VsZi50eXBlICE9PSB5dWlldnQuYnViYmxpbmcpIHtcblxuICAgICAgICAgICAgICAgIHNlbGYuX3Byb2NTdWJzKGFmdGVycywgYXJncywgZWYpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChuZXh0ID0gYWZ0ZXJRdWV1ZS5sYXN0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc3Rwb25lZCA9IGFmdGVycztcblxuICAgICAgICAgICAgICAgIGlmIChlcy5leGVjRGVmYXVsdENudCkge1xuICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZWQgPSBZLm1lcmdlKHBvc3Rwb25lZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgWS5lYWNoKHBvc3Rwb25lZCwgZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5wb3N0cG9uZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFmdGVyUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXMuYWZ0ZXJRdWV1ZSA9IG5ldyBZLlF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXMuYWZ0ZXJRdWV1ZS5hZGQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2NTdWJzKHBvc3Rwb25lZCwgYXJncywgZWYpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnRhcmdldCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGVzLmlkID09PSBzZWxmLmlkKSB7XG5cbiAgICAgICAgICAgIHF1ZXVlID0gZXMucXVldWU7XG5cbiAgICAgICAgICAgIGlmIChxdWV1ZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjZSA9IHFbMF07XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCB1cCBzdGFjayB0byBhbGxvdyB0aGUgbmV4dCBpdGVtIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgICBlcy5uZXh0ID0gY2U7XG4gICAgICAgICAgICAgICAgICAgIGNlLl9maXJlKHFbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5zdGFjayA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSAhKHNlbGYuc3RvcHBlZCk7XG5cbiAgICAgICAgaWYgKHNlbGYudHlwZSAhPT0geXVpZXZ0LmJ1YmJsaW5nKSB7XG4gICAgICAgICAgICBlcy5zdG9wcGVkID0gMDtcbiAgICAgICAgICAgIGVzLnByZXZlbnRlZCA9IDA7XG4gICAgICAgICAgICBzZWxmLnN0b3BwZWQgPSAwO1xuICAgICAgICAgICAgc2VsZi5wcmV2ZW50ZWQgPSAwO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0Rm4gPSBzZWxmLmRlZmF1bHRGbjtcblxuICAgICAgICBpZihkZWZhdWx0Rm4pIHtcbiAgICAgICAgICAgIGVmID0gc2VsZi5fY3JlYXRlRmFjYWRlKGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAoKCFzZWxmLmRlZmF1bHRUYXJnZXRPbmx5KSB8fCAoaG9zdCA9PT0gZWYudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRGbi5hcHBseShob3N0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEtpbGwgdGhlIGNhY2hlZCBmYWNhZGUgdG8gZnJlZSB1cCBtZW1vcnkuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIGhhdmUgdGhlIGZhY2FkZSBmcm9tIHRoZSBsYXN0IGZpcmUsIHNpdHRpbmcgYXJvdW5kIGZvcmV2ZXIuXG4gICAgc2VsZi5fZmFjYWRlID0gbnVsbDtcblxuICAgIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgX2hhc1BvdGVudGlhbFN1YnNjcmliZXJzXG4gKiBAZm9yIEN1c3RvbUV2ZW50XG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZXZlbnQgaGFzIHBvdGVudGlhbCBzdWJzY3JpYmVycyBvciBub3RcbiAqL1xuQ0VQcm90by5faGFzUG90ZW50aWFsU3Vic2NyaWJlcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNTdWJzKCkgfHwgdGhpcy5ob3N0Ll95dWlldnQuaGFzVGFyZ2V0cyB8fCB0aGlzLmJyb2FkY2FzdDtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgdXRpbGl0eSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IGZhY2FkZSBpbnN0YW5jZSBhbmRcbiAqIGluc2VydCBpdCBpbnRvIHRoZSBmaXJlIGFyZ3VtZW50IGxpc3QsIGFjY291bnRpbmcgZm9yIGFueSBwYXlsb2FkXG4gKiBtZXJnaW5nIHdoaWNoIG5lZWRzIHRvIGhhcHBlbi5cbiAqXG4gKiBUaGlzIHVzZWQgdG8gYmUgY2FsbGVkIGBfZ2V0RmFjYWRlYCwgYnV0IHRoZSBuYW1lIHNlZW1lZCBpbmFwcHJvcHJpYXRlXG4gKiB3aGVuIGl0IHdhcyB1c2VkIHdpdGhvdXQgYSBuZWVkIGZvciB0aGUgcmV0dXJuIHZhbHVlLlxuICpcbiAqIEBtZXRob2QgX2NyZWF0ZUZhY2FkZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBmaXJlQXJncyB7QXJyYXl9IFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIFwiZmlyZVwiLCB3aGljaCBuZWVkIHRvIGJlXG4gKiBzaGlmdGVkIChhbmQgcG90ZW50aWFsbHkgbWVyZ2VkKSB3aGVuIHRoZSBmYWNhZGUgaXMgYWRkZWQuXG4gKiBAcmV0dXJuIHtFdmVudEZhY2FkZX0gVGhlIGV2ZW50IGZhY2FkZSBjcmVhdGVkLlxuICovXG5cbi8vIFRPRE86IFJlbW92ZSAocHJpdmF0ZSkgX2dldEZhY2FkZSBhbGlhcywgb25jZSBzeW50aGV0aWMuanMgaXMgdXBkYXRlZC5cbkNFUHJvdG8uX2NyZWF0ZUZhY2FkZSA9IENFUHJvdG8uX2dldEZhY2FkZSA9IGZ1bmN0aW9uKGZpcmVBcmdzKSB7XG5cbiAgICB2YXIgdXNlckFyZ3MgPSB0aGlzLmRldGFpbHMsXG4gICAgICAgIGZpcnN0QXJnID0gdXNlckFyZ3MgJiYgdXNlckFyZ3NbMF0sXG4gICAgICAgIGZpcnN0QXJnSXNPYmogPSAoZmlyc3RBcmcgJiYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJvYmplY3RcIikpLFxuICAgICAgICBlZiA9IHRoaXMuX2ZhY2FkZTtcblxuICAgIGlmICghZWYpIHtcbiAgICAgICAgZWYgPSBuZXcgWS5FdmVudEZhY2FkZSh0aGlzLCB0aGlzLmN1cnJlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIGlmIChmaXJzdEFyZ0lzT2JqKSB7XG4gICAgICAgIC8vIHByb3RlY3QgdGhlIGV2ZW50IGZhY2FkZSBwcm9wZXJ0aWVzXG4gICAgICAgIG1peEZhY2FkZVByb3BzKGVmLCBmaXJzdEFyZyk7XG5cbiAgICAgICAgLy8gQWxsb3cgdGhlIGV2ZW50IHR5cGUgdG8gYmUgZmFrZWQgaHR0cDovL3l1aWxpYnJhcnkuY29tL3Byb2plY3RzL3l1aTMvdGlja2V0LzI1MjgzNzZcbiAgICAgICAgaWYgKGZpcnN0QXJnLnR5cGUpIHtcbiAgICAgICAgICAgIGVmLnR5cGUgPSBmaXJzdEFyZy50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcmVBcmdzKSB7XG4gICAgICAgICAgICBmaXJlQXJnc1swXSA9IGVmO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZpcmVBcmdzKSB7XG4gICAgICAgICAgICBmaXJlQXJncy51bnNoaWZ0KGVmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgZGV0YWlscyBmaWVsZCB3aXRoIHRoZSBhcmd1bWVudHNcbiAgICBlZi5kZXRhaWxzID0gdGhpcy5kZXRhaWxzO1xuXG4gICAgLy8gdXNlIHRoZSBvcmlnaW5hbCB0YXJnZXQgd2hlbiB0aGUgZXZlbnQgYnViYmxlZCB0byB0aGlzIHRhcmdldFxuICAgIGVmLnRhcmdldCA9IHRoaXMub3JpZ2luYWxUYXJnZXQgfHwgdGhpcy50YXJnZXQ7XG5cbiAgICBlZi5jdXJyZW50VGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0O1xuICAgIGVmLnN0b3BwZWQgPSAwO1xuICAgIGVmLnByZXZlbnRlZCA9IDA7XG5cbiAgICB0aGlzLl9mYWNhZGUgPSBlZjtcblxuICAgIHJldHVybiB0aGlzLl9mYWNhZGU7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIG1hbmlwdWxhdGUgdGhlIGFyZ3MgYXJyYXkgcGFzc2VkIGluLCB0byBhZGQgdGhlIGV2ZW50IGZhY2FkZSxcbiAqIGlmIGl0J3Mgbm90IGFscmVhZHkgdGhlIGZpcnN0IGFyZy5cbiAqXG4gKiBAbWV0aG9kIF9hZGRGYWNhZGVUb0FyZ3NcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBUaGUgYXJndW1lbnRzIHRvIG1hbmlwdWxhdGVcbiAqL1xuQ0VQcm90by5fYWRkRmFjYWRlVG9BcmdzID0gZnVuY3Rpb24oYXJncykge1xuICAgIHZhciBlID0gYXJnc1swXTtcblxuICAgIC8vIFRyeWluZyBub3QgdG8gdXNlIGluc3RhbmNlb2YsIGp1c3QgdG8gYXZvaWQgcG90ZW50aWFsIGNyb3NzIFkgZWRnZSBjYXNlIGlzc3Vlcy5cbiAgICBpZiAoIShlICYmIGUuaGFsdCAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBlLnN0b3BQcm9wYWdhdGlvbiAmJiBlLl9ldmVudCkpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlRmFjYWRlKGFyZ3MpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU3RvcCBwcm9wYWdhdGlvbiB0byBidWJibGUgdGFyZ2V0c1xuICogQGZvciBDdXN0b21FdmVudFxuICogQG1ldGhvZCBzdG9wUHJvcGFnYXRpb25cbiAqL1xuQ0VQcm90by5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSAxO1xuICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICAgIHRoaXMuc3RhY2suc3RvcHBlZCA9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLmV2ZW50cykge1xuICAgICAgICB0aGlzLmV2ZW50cy5maXJlKCdzdG9wcGVkJywgdGhpcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTdG9wcyBwcm9wYWdhdGlvbiB0byBidWJibGUgdGFyZ2V0cywgYW5kIHByZXZlbnRzIGFueSByZW1haW5pbmdcbiAqIHN1YnNjcmliZXJzIG9uIHRoZSBjdXJyZW50IHRhcmdldCBmcm9tIGV4ZWN1dGluZy5cbiAqIEBtZXRob2Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG4gKi9cbkNFUHJvdG8uc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gMjtcbiAgICBpZiAodGhpcy5zdGFjaykge1xuICAgICAgICB0aGlzLnN0YWNrLnN0b3BwZWQgPSAyO1xuICAgIH1cbiAgICBpZiAodGhpcy5ldmVudHMpIHtcbiAgICAgICAgdGhpcy5ldmVudHMuZmlyZSgnc3RvcHBlZCcsIHRoaXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUHJldmVudHMgdGhlIGV4ZWN1dGlvbiBvZiB0aGlzIGV2ZW50J3MgZGVmYXVsdEZuXG4gKiBAbWV0aG9kIHByZXZlbnREZWZhdWx0XG4gKi9cbkNFUHJvdG8ucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wcmV2ZW50YWJsZSkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IDE7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnByZXZlbnRlZCA9IDE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFN0b3BzIHRoZSBldmVudCBwcm9wYWdhdGlvbiBhbmQgcHJldmVudHMgdGhlIGRlZmF1bHRcbiAqIGV2ZW50IGJlaGF2aW9yLlxuICogQG1ldGhvZCBoYWx0XG4gKiBAcGFyYW0gaW1tZWRpYXRlIHtib29sZWFufSBpZiB0cnVlIGFkZGl0aW9uYWwgbGlzdGVuZXJzXG4gKiBvbiB0aGUgY3VycmVudCB0YXJnZXQgd2lsbCBub3QgYmUgZXhlY3V0ZWRcbiAqL1xuQ0VQcm90by5oYWx0ID0gZnVuY3Rpb24oaW1tZWRpYXRlKSB7XG4gICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICB0aGlzLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMucHJldmVudERlZmF1bHQoKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFub3RoZXIgRXZlbnRUYXJnZXQgYXMgYSBidWJibGUgdGFyZ2V0LiAgQnViYmxlIG9yZGVyXG4gKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciByZWdpc3RlcmVkLiAgTXVsdGlwbGUgdGFyZ2V0cyBjYW5cbiAqIGJlIHNwZWNpZmllZC5cbiAqXG4gKiBFdmVudHMgY2FuIG9ubHkgYnViYmxlIGlmIGVtaXRGYWNhZGUgaXMgdHJ1ZS5cbiAqXG4gKiBJbmNsdWRlZCBpbiB0aGUgZXZlbnQtY3VzdG9tLWNvbXBsZXggc3VibW9kdWxlLlxuICpcbiAqIEBtZXRob2QgYWRkVGFyZ2V0XG4gKiBAY2hhaW5hYmxlXG4gKiBAcGFyYW0gbyB7RXZlbnRUYXJnZXR9IHRoZSB0YXJnZXQgdG8gYWRkXG4gKiBAZm9yIEV2ZW50VGFyZ2V0XG4gKi9cbkVUUHJvdG8uYWRkVGFyZ2V0ID0gZnVuY3Rpb24obykge1xuICAgIHZhciBldFN0YXRlID0gdGhpcy5feXVpZXZ0O1xuXG4gICAgaWYgKCFldFN0YXRlLnRhcmdldHMpIHtcbiAgICAgICAgZXRTdGF0ZS50YXJnZXRzID0ge307XG4gICAgfVxuXG4gICAgZXRTdGF0ZS50YXJnZXRzW1kuc3RhbXAobyldID0gbztcbiAgICBldFN0YXRlLmhhc1RhcmdldHMgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgYnViYmxlIHRhcmdldHMgZm9yIHRoaXMgb2JqZWN0LlxuICogQG1ldGhvZCBnZXRUYXJnZXRzXG4gKiBAcmV0dXJuIEV2ZW50VGFyZ2V0W11cbiAqL1xuRVRQcm90by5nZXRUYXJnZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldHMgPSB0aGlzLl95dWlldnQudGFyZ2V0cztcbiAgICByZXR1cm4gdGFyZ2V0cyA/IFlPYmplY3QudmFsdWVzKHRhcmdldHMpIDogW107XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBidWJibGUgdGFyZ2V0XG4gKiBAbWV0aG9kIHJlbW92ZVRhcmdldFxuICogQGNoYWluYWJsZVxuICogQHBhcmFtIG8ge0V2ZW50VGFyZ2V0fSB0aGUgdGFyZ2V0IHRvIHJlbW92ZVxuICogQGZvciBFdmVudFRhcmdldFxuICovXG5FVFByb3RvLnJlbW92ZVRhcmdldCA9IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMuX3l1aWV2dC50YXJnZXRzO1xuXG4gICAgaWYgKHRhcmdldHMpIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldHNbWS5zdGFtcChvLCB0cnVlKV07XG5cbiAgICAgICAgaWYgKFlPYmplY3Quc2l6ZSh0YXJnZXRzKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5feXVpZXZ0Lmhhc1RhcmdldHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQcm9wYWdhdGUgYW4gZXZlbnQuICBSZXF1aXJlcyB0aGUgZXZlbnQtY3VzdG9tLWNvbXBsZXggbW9kdWxlLlxuICogQG1ldGhvZCBidWJibGVcbiAqIEBwYXJhbSBldnQge0N1c3RvbUV2ZW50fSB0aGUgY3VzdG9tIGV2ZW50IHRvIHByb3BhZ2F0ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIGFnZ3JlZ2F0ZWQgcmV0dXJuIHZhbHVlIGZyb20gRXZlbnQuQ3VzdG9tLmZpcmVcbiAqIEBmb3IgRXZlbnRUYXJnZXRcbiAqL1xuRVRQcm90by5idWJibGUgPSBmdW5jdGlvbihldnQsIGFyZ3MsIHRhcmdldCwgZXMpIHtcblxuICAgIHZhciB0YXJncyA9IHRoaXMuX3l1aWV2dC50YXJnZXRzLFxuICAgICAgICByZXQgPSB0cnVlLFxuICAgICAgICB0LFxuICAgICAgICBjZSxcbiAgICAgICAgaSxcbiAgICAgICAgYmMsXG4gICAgICAgIGNlMixcbiAgICAgICAgdHlwZSA9IGV2dCAmJiBldnQudHlwZSxcbiAgICAgICAgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQgfHwgKGV2dCAmJiBldnQudGFyZ2V0KSB8fCB0aGlzLFxuICAgICAgICBvbGRidWJibGU7XG5cbiAgICBpZiAoIWV2dCB8fCAoKCFldnQuc3RvcHBlZCkgJiYgdGFyZ3MpKSB7XG5cbiAgICAgICAgZm9yIChpIGluIHRhcmdzKSB7XG4gICAgICAgICAgICBpZiAodGFyZ3MuaGFzT3duUHJvcGVydHkoaSkpIHtcblxuICAgICAgICAgICAgICAgIHQgPSB0YXJnc1tpXTtcblxuICAgICAgICAgICAgICAgIGNlID0gdC5feXVpZXZ0LmV2ZW50c1t0eXBlXTtcblxuICAgICAgICAgICAgICAgIGlmICh0Ll9oYXNTaWJsaW5ncykge1xuICAgICAgICAgICAgICAgICAgICBjZTIgPSB0LmdldFNpYmxpbmcodHlwZSwgY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjZTIgJiYgIWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlID0gdC5wdWJsaXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9sZGJ1YmJsZSA9IHQuX3l1aWV2dC5idWJibGluZztcbiAgICAgICAgICAgICAgICB0Ll95dWlldnQuYnViYmxpbmcgPSB0eXBlO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBldmVudCB3YXMgbm90IHB1Ymxpc2hlZCBvbiB0aGUgYnViYmxlIHRhcmdldCxcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBwcm9wYWdhdGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgaWYgKCFjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5feXVpZXZ0Lmhhc1RhcmdldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuYnViYmxlKGV2dCwgYXJncywgb3JpZ2luYWxUYXJnZXQsIGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2Uuc2libGluZyA9IGNlMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgb3JpZ2luYWwgdGFyZ2V0IHRvIHRoYXQgdGhlIHRhcmdldCBwYXlsb2FkIG9uIHRoZSBmYWNhZGUgaXMgY29ycmVjdC5cbiAgICAgICAgICAgICAgICAgICAgY2UudGFyZ2V0ID0gb3JpZ2luYWxUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNlLm9yaWdpbmFsVGFyZ2V0ID0gb3JpZ2luYWxUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNlLmN1cnJlbnRUYXJnZXQgPSB0O1xuICAgICAgICAgICAgICAgICAgICBiYyA9IGNlLmJyb2FkY2FzdDtcbiAgICAgICAgICAgICAgICAgICAgY2UuYnJvYWRjYXN0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBwdWJsaXNoIG1heSBub3QgaGF2ZSBlbWl0RmFjYWRlIHRydWUgLS0gdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGRuJ3QgYmUgd2hhdCB0aGUgaW1wbGVtZW50ZXIgbWVhbnQgdG8gZG9cbiAgICAgICAgICAgICAgICAgICAgY2UuZW1pdEZhY2FkZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgY2Uuc3RhY2sgPSBlcztcblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBTZWUgd2hhdCdzIGdldHRpbmcgaW4gdGhlIHdheSBvZiBjaGFuZ2luZyB0aGlzIHRvIHVzZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbW9yZSBwZXJmb3JtYW50IGNlLl9maXJlKGFyZ3MgfHwgZXZ0LmRldGFpbHMgfHwgW10pLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyBpbiBXaWRnZXQgUGFyZW50L0NoaWxkIHRlc3RzIGlzIG5vdCBoYXBweSBpZiB3ZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgaXQgLSBtYXliZSBldnQuZGV0YWlscyByZWxhdGVkP1xuICAgICAgICAgICAgICAgICAgICByZXQgPSByZXQgJiYgY2UuZmlyZS5hcHBseShjZSwgYXJncyB8fCBldnQuZGV0YWlscyB8fCBbXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2UuYnJvYWRjYXN0ID0gYmM7XG4gICAgICAgICAgICAgICAgICAgIGNlLm9yaWdpbmFsVGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wUHJvcGFnYXRpb24oKSB3YXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChjZS5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHQuX3l1aWV2dC5idWJibGluZyA9IG9sZGJ1YmJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgX2hhc1BvdGVudGlhbFN1YnNjcmliZXJzXG4gKiBAZm9yIEV2ZW50VGFyZ2V0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGZ1bGxUeXBlIFRoZSBmdWxseSBwcmVmaXhlZCB0eXBlIG5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGV2ZW50IGhhcyBwb3RlbnRpYWwgc3Vic2NyaWJlcnMgb3Igbm90XG4gKi9cbkVUUHJvdG8uX2hhc1BvdGVudGlhbFN1YnNjcmliZXJzID0gZnVuY3Rpb24oZnVsbFR5cGUpIHtcblxuICAgIHZhciBldFN0YXRlID0gdGhpcy5feXVpZXZ0LFxuICAgICAgICBlID0gZXRTdGF0ZS5ldmVudHNbZnVsbFR5cGVdO1xuXG4gICAgaWYgKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuaGFzU3VicygpIHx8IGV0U3RhdGUuaGFzVGFyZ2V0cyAgfHwgZS5icm9hZGNhc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbkZBQ0FERSA9IG5ldyBZLkV2ZW50RmFjYWRlKCk7XG5GQUNBREVfS0VZUyA9IHt9O1xuXG4vLyBGbGF0dGVuIHdoaXRlbGlzdFxuZm9yIChrZXkgaW4gRkFDQURFKSB7XG4gICAgRkFDQURFX0tFWVNba2V5XSA9IHRydWU7XG59XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImV2ZW50LWN1c3RvbS1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2V2ZW50LWRlbGVnYXRlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGRlbGVnYXRpb24gc3VwcG9ydCB0byB0aGUgbGlicmFyeS5cbiAqXG4gKiBAbW9kdWxlIGV2ZW50XG4gKiBAc3VibW9kdWxlIGV2ZW50LWRlbGVnYXRlXG4gKi9cblxudmFyIHRvQXJyYXkgICAgICAgICAgPSBZLkFycmF5LFxuICAgIFlMYW5nICAgICAgICAgICAgPSBZLkxhbmcsXG4gICAgaXNTdHJpbmcgICAgICAgICA9IFlMYW5nLmlzU3RyaW5nLFxuICAgIGlzT2JqZWN0ICAgICAgICAgPSBZTGFuZy5pc09iamVjdCxcbiAgICBpc0FycmF5ICAgICAgICAgID0gWUxhbmcuaXNBcnJheSxcbiAgICBzZWxlY3RvclRlc3QgICAgID0gWS5TZWxlY3Rvci50ZXN0LFxuICAgIGRldGFjaENhdGVnb3JpZXMgPSBZLkVudi5ldnQuaGFuZGxlcztcblxuLyoqXG4gKiA8cD5TZXRzIHVwIGV2ZW50IGRlbGVnYXRpb24gb24gYSBjb250YWluZXIgZWxlbWVudC4gIFRoZSBkZWxlZ2F0ZWQgZXZlbnRcbiAqIHdpbGwgdXNlIGEgc3VwcGxpZWQgc2VsZWN0b3Igb3IgZmlsdGVyaW5nIGZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGV2ZW50XG4gKiByZWZlcmVuY2VzIGF0IGxlYXN0IG9uZSBub2RlIHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIHN1YnNjcmlwdGlvblxuICogY2FsbGJhY2suPC9wPlxuICpcbiAqIDxwPlNlbGVjdG9yIHN0cmluZyBmaWx0ZXJzIHdpbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2sgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZWRcbiAqIGZyb20gYSBub2RlIHRoYXQgbWF0Y2hlcyBpdCBvciBpcyBjb250YWluZWQgaW4gYSBub2RlIHRoYXQgbWF0Y2hlcyBpdC5cbiAqIEZ1bmN0aW9uIGZpbHRlcnMgYXJlIGNhbGxlZCBmb3IgZWFjaCBOb2RlIHVwIHRoZSBwYXJlbnQgYXhpcyB0byB0aGVcbiAqIHN1YnNjcmliaW5nIGNvbnRhaW5lciBub2RlLCBhbmQgcmVjZWl2ZSBhdCBlYWNoIGxldmVsIHRoZSBOb2RlIGFuZCB0aGUgZXZlbnRcbiAqIG9iamVjdC4gIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRydWUgKG9yIGEgdHJ1dGh5IHZhbHVlKSBpZiB0aGF0IE5vZGVcbiAqIHNob3VsZCB0cmlnZ2VyIHRoZSBzdWJzY3JpcHRpb24gY2FsbGJhY2suICBOb3RlLCBpdCBpcyBwb3NzaWJsZSBmb3IgZmlsdGVyc1xuICogdG8gbWF0Y2ggbXVsdGlwbGUgTm9kZXMgZm9yIGEgc2luZ2xlIGV2ZW50LiAgSW4gdGhpcyBjYXNlLCB0aGUgZGVsZWdhdGVcbiAqIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2ggbWF0Y2hpbmcgTm9kZS48L3A+XG4gKlxuICogPHA+Rm9yIGVhY2ggbWF0Y2hpbmcgTm9kZSwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgd2l0aCBpdHMgJ3RoaXMnXG4gKiBvYmplY3Qgc2V0IHRvIHRoZSBOb2RlIG1hdGNoZWQgYnkgdGhlIGZpbHRlciAodW5sZXNzIGEgc3BlY2lmaWMgY29udGV4dCB3YXNcbiAqIHByb3ZpZGVkIGR1cmluZyBzdWJzY3JpcHRpb24pLCBhbmQgdGhlIHByb3ZpZGVkIGV2ZW50J3NcbiAqIDxjb2RlPmN1cnJlbnRUYXJnZXQ8L2NvZGU+IHdpbGwgYWxzbyBiZSBzZXQgdG8gdGhlIG1hdGNoaW5nIE5vZGUuICBUaGVcbiAqIGNvbnRhaW5pbmcgTm9kZSBmcm9tIHdoaWNoIHRoZSBzdWJzY3JpcHRpb24gd2FzIG9yaWdpbmFsbHkgbWFkZSBjYW4gYmVcbiAqIHJlZmVyZW5jZWQgYXMgPGNvZGU+ZS5jb250YWluZXI8L2NvZGU+LlxuICpcbiAqIEBtZXRob2QgZGVsZWdhdGVcbiAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9IHRoZSBldmVudCB0eXBlIHRvIGRlbGVnYXRlXG4gKiBAcGFyYW0gZm4ge0Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZS4gIFRoaXMgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICB3aWxsIGJlIHByb3ZpZGVkIHRoZSBldmVudCBvYmplY3QgZm9yIHRoZSBkZWxlZ2F0ZWQgZXZlbnQuXG4gKiBAcGFyYW0gZWwge1N0cmluZ3xub2RlfSB0aGUgZWxlbWVudCB0aGF0IGlzIHRoZSBkZWxlZ2F0aW9uIGNvbnRhaW5lclxuICogQHBhcmFtIGZpbHRlciB7c3RyaW5nfEZ1bmN0aW9ufSBhIHNlbGVjdG9yIHRoYXQgbXVzdCBtYXRjaCB0aGUgdGFyZ2V0IG9mIHRoZVxuICogICAgICAgICAgICAgIGV2ZW50IG9yIGEgZnVuY3Rpb24gdG8gdGVzdCB0YXJnZXQgYW5kIGl0cyBwYXJlbnRzIGZvciBhIG1hdGNoXG4gKiBAcGFyYW0gY29udGV4dCBvcHRpb25hbCBhcmd1bWVudCB0aGF0IHNwZWNpZmllcyB3aGF0ICd0aGlzJyByZWZlcnMgdG8uXG4gKiBAcGFyYW0gYXJncyogMC4ubiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIG9uIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICBUaGVzZSBhcmd1bWVudHMgd2lsbCBiZSBhZGRlZCBhZnRlciB0aGUgZXZlbnQgb2JqZWN0LlxuICogQHJldHVybiB7RXZlbnRIYW5kbGV9IHRoZSBkZXRhY2ggaGFuZGxlXG4gKiBAc3RhdGljXG4gKiBAZm9yIEV2ZW50XG4gKi9cbmZ1bmN0aW9uIGRlbGVnYXRlKHR5cGUsIGZuLCBlbCwgZmlsdGVyKSB7XG4gICAgdmFyIGFyZ3MgICAgID0gdG9BcnJheShhcmd1bWVudHMsIDAsIHRydWUpLFxuICAgICAgICBxdWVyeSAgICA9IGlzU3RyaW5nKGVsKSA/IGVsIDogbnVsbCxcbiAgICAgICAgdHlwZUJpdHMsIHN5bnRoLCBjb250YWluZXIsIGNhdGVnb3JpZXMsIGNhdCwgaSwgbGVuLCBoYW5kbGVzLCBoYW5kbGU7XG5cbiAgICAvLyBTdXBwb3J0IFkuZGVsZWdhdGUoeyBjbGljazogZm5BLCBrZXk6IGZuQiB9LCBlbCwgZmlsdGVyLCAuLi4pO1xuICAgIC8vIGFuZCBZLmRlbGVnYXRlKFsnY2xpY2snLCAna2V5J10sIGZuLCBlbCwgZmlsdGVyLCAuLi4pO1xuICAgIGlmIChpc09iamVjdCh0eXBlKSkge1xuICAgICAgICBoYW5kbGVzID0gW107XG5cbiAgICAgICAgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHR5cGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gdHlwZVtpXTtcbiAgICAgICAgICAgICAgICBoYW5kbGVzLnB1c2goWS5kZWxlZ2F0ZS5hcHBseShZLCBhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBZLmRlbGVnYXRlKHsnY2xpY2snLCBmbn0sIGVsLCBmaWx0ZXIpID0+XG4gICAgICAgICAgICAvLyBZLmRlbGVnYXRlKCdjbGljaycsIGZuLCBlbCwgZmlsdGVyKVxuICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpOyAvLyBvbmUgYXJnIGJlY29tZXMgdHdvOyBuZWVkIHRvIG1ha2Ugc3BhY2VcblxuICAgICAgICAgICAgZm9yIChpIGluIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzWzBdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSA9IHR5cGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXMucHVzaChZLmRlbGVnYXRlLmFwcGx5KFksIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFkuRXZlbnRIYW5kbGUoaGFuZGxlcyk7XG4gICAgfVxuXG4gICAgdHlwZUJpdHMgPSB0eXBlLnNwbGl0KC9cXHwvKTtcblxuICAgIGlmICh0eXBlQml0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNhdCAgPSB0eXBlQml0cy5zaGlmdCgpO1xuICAgICAgICBhcmdzWzBdID0gdHlwZSA9IHR5cGVCaXRzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgc3ludGggPSBZLk5vZGUuRE9NX0VWRU5UU1t0eXBlXTtcblxuICAgIGlmIChpc09iamVjdChzeW50aCkgJiYgc3ludGguZGVsZWdhdGUpIHtcbiAgICAgICAgaGFuZGxlID0gc3ludGguZGVsZWdhdGUuYXBwbHkoc3ludGgsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgICAgaWYgKCF0eXBlIHx8ICFmbiB8fCAhZWwgfHwgIWZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyID0gKHF1ZXJ5KSA/IFkuU2VsZWN0b3IucXVlcnkocXVlcnksIG51bGwsIHRydWUpIDogZWw7XG5cbiAgICAgICAgaWYgKCFjb250YWluZXIgJiYgaXNTdHJpbmcoZWwpKSB7XG4gICAgICAgICAgICBoYW5kbGUgPSBZLm9uKCdhdmFpbGFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgWS5taXgoaGFuZGxlLCBZLmRlbGVnYXRlLmFwcGx5KFksIGFyZ3MpLCB0cnVlKTtcbiAgICAgICAgICAgIH0sIGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFuZGxlICYmIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoMiwgMiwgY29udGFpbmVyKTsgLy8gcmVtb3ZlIHRoZSBmaWx0ZXJcblxuICAgICAgICAgICAgaGFuZGxlID0gWS5FdmVudC5fYXR0YWNoKGFyZ3MsIHsgZmFjYWRlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGhhbmRsZS5zdWIuZmlsdGVyICA9IGZpbHRlcjtcbiAgICAgICAgICAgIGhhbmRsZS5zdWIuX25vdGlmeSA9IGRlbGVnYXRlLm5vdGlmeVN1YjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGUgJiYgY2F0KSB7XG4gICAgICAgIGNhdGVnb3JpZXMgPSBkZXRhY2hDYXRlZ29yaWVzW2NhdF0gIHx8IChkZXRhY2hDYXRlZ29yaWVzW2NhdF0gPSB7fSk7XG4gICAgICAgIGNhdGVnb3JpZXMgPSBjYXRlZ29yaWVzW3R5cGVdIHx8IChjYXRlZ29yaWVzW3R5cGVdID0gW10pO1xuICAgICAgICBjYXRlZ29yaWVzLnB1c2goaGFuZGxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlO1xufVxuXG4vKipcbk92ZXJyaWRlcyB0aGUgPGNvZGU+X25vdGlmeTwvY29kZT4gbWV0aG9kIG9uIHRoZSBub3JtYWwgRE9NIHN1YnNjcmlwdGlvbiB0b1xuaW5qZWN0IHRoZSBmaWx0ZXJpbmcgbG9naWMgYW5kIG9ubHkgcHJvY2VlZCBpbiB0aGUgY2FzZSBvZiBhIG1hdGNoLlxuXG5UaGlzIG1ldGhvZCBpcyBob3N0ZWQgYXMgYSBwcml2YXRlIHByb3BlcnR5IG9mIHRoZSBgZGVsZWdhdGVgIG1ldGhvZFxuKGUuZy4gYFkuZGVsZWdhdGUubm90aWZ5U3ViYClcblxuQG1ldGhvZCBub3RpZnlTdWJcbkBwYXJhbSB0aGlzT2JqIHtPYmplY3R9IGRlZmF1bHQgJ3RoaXMnIG9iamVjdCBmb3IgdGhlIGNhbGxiYWNrXG5AcGFyYW0gYXJncyB7QXJyYXl9IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGV2ZW50J3MgPGNvZGU+ZmlyZSgpPC9jb2RlPlxuQHBhcmFtIGNlIHtDdXN0b21FdmVudH0gdGhlIGN1c3RvbSBldmVudCBtYW5hZ2luZyB0aGUgRE9NIHN1YnNjcmlwdGlvbnMgZm9yXG4gICAgICAgICAgICAgdGhlIHN1YnNjcmliZWQgZXZlbnQgb24gdGhlIHN1YnNjcmliaW5nIG5vZGUuXG5AcmV0dXJuIHtCb29sZWFufSBmYWxzZSBpZiB0aGUgZXZlbnQgd2FzIHN0b3BwZWRcbkBwcml2YXRlXG5Ac3RhdGljXG5Ac2luY2UgMy4yLjBcbioqL1xuZGVsZWdhdGUubm90aWZ5U3ViID0gZnVuY3Rpb24gKHRoaXNPYmosIGFyZ3MsIGNlKSB7XG4gICAgLy8gUHJlc2VydmUgYXJncyBmb3Igb3RoZXIgc3Vic2NyaWJlcnNcbiAgICBhcmdzID0gYXJncy5zbGljZSgpO1xuICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIHRoaXMuYXJncyk7XG4gICAgfVxuXG4gICAgLy8gT25seSBub3RpZnkgc3VicyBpZiB0aGUgZXZlbnQgb2NjdXJyZWQgb24gYSB0YXJnZXRlZCBlbGVtZW50XG4gICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBkZWxlZ2F0ZS5fYXBwbHlGaWx0ZXIodGhpcy5maWx0ZXIsIGFyZ3MsIGNlKSxcbiAgICAgICAgLy9jb250YWluZXIgICAgID0gZS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICBlLCBpLCBsZW4sIHJldDtcblxuICAgIGlmIChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIC8vIFN1cHBvcnQgbXVsdGlwbGUgbWF0Y2hlcyB1cCB0aGUgdGhlIGNvbnRhaW5lciBzdWJ0cmVlXG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPSB0b0FycmF5KGN1cnJlbnRUYXJnZXQpO1xuXG4gICAgICAgIC8vIFRoZSBzZWNvbmQgYXJnIGlzIHRoZSBjdXJyZW50VGFyZ2V0LCBidXQgd2UnbGwgYmUgcmV1c2luZyB0aGlzXG4gICAgICAgIC8vIGZhY2FkZSwgcmVwbGFjaW5nIHRoZSBjdXJyZW50VGFyZ2V0IGZvciBlYWNoIHVzZSwgc28gaXQgZG9lc24ndFxuICAgICAgICAvLyBtYXR0ZXIgd2hhdCBlbGVtZW50IHdlIHNlZWQgaXQgd2l0aC5cbiAgICAgICAgZSA9IGFyZ3NbMF0gPSBuZXcgWS5ET01FdmVudEZhY2FkZShhcmdzWzBdLCBjZS5lbCwgY2UpO1xuXG4gICAgICAgIGUuY29udGFpbmVyID0gWS5vbmUoY2UuZWwpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGN1cnJlbnRUYXJnZXQubGVuZ3RoOyBpIDwgbGVuICYmICFlLnN0b3BwZWQ7ICsraSkge1xuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gWS5vbmUoY3VycmVudFRhcmdldFtpXSk7XG5cbiAgICAgICAgICAgIHJldCA9IHRoaXMuZm4uYXBwbHkodGhpcy5jb250ZXh0IHx8IGUuY3VycmVudFRhcmdldCwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7IC8vIHN0b3AgZnVydGhlciBub3RpZmljYXRpb25zXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn07XG5cbi8qKlxuQ29tcGlsZXMgYSBzZWxlY3RvciBzdHJpbmcgaW50byBhIGZpbHRlciBmdW5jdGlvbiB0byBpZGVudGlmeSB3aGV0aGVyXG5Ob2RlcyBhbG9uZyB0aGUgcGFyZW50IGF4aXMgb2YgYW4gZXZlbnQncyB0YXJnZXQgc2hvdWxkIHRyaWdnZXIgZXZlbnRcbm5vdGlmaWNhdGlvbi5cblxuVGhpcyBmdW5jdGlvbiBpcyBtZW1vaXplZCwgc28gcHJldmlvdXNseSBjb21waWxlZCBmaWx0ZXIgZnVuY3Rpb25zIGFyZVxucmV0dXJuZWQgaWYgdGhlIHNhbWUgc2VsZWN0b3Igc3RyaW5nIGlzIHByb3ZpZGVkLlxuXG5UaGlzIGZ1bmN0aW9uIG1heSBiZSB1c2VmdWwgd2hlbiBkZWZpbmluZyBzeW50aGV0aWMgZXZlbnRzIGZvciBkZWxlZ2F0ZVxuaGFuZGxpbmcuXG5cbkhvc3RlZCBhcyBhIHByb3BlcnR5IG9mIHRoZSBgZGVsZWdhdGVgIG1ldGhvZCAoZS5nLiBgWS5kZWxlZ2F0ZS5jb21waWxlRmlsdGVyYCkuXG5cbkBtZXRob2QgY29tcGlsZUZpbHRlclxuQHBhcmFtIHNlbGVjdG9yIHtTdHJpbmd9IHRoZSBzZWxlY3RvciBzdHJpbmcgdG8gYmFzZSB0aGUgZmlsdHJhdGlvbiBvblxuQHJldHVybiB7RnVuY3Rpb259XG5Ac2luY2UgMy4yLjBcbkBzdGF0aWNcbioqL1xuZGVsZWdhdGUuY29tcGlsZUZpbHRlciA9IFkuY2FjaGVkKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBlKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvclRlc3QodGFyZ2V0Ll9ub2RlLCBzZWxlY3RvcixcbiAgICAgICAgICAgIChlLmN1cnJlbnRUYXJnZXQgPT09IGUudGFyZ2V0KSA/IG51bGwgOiBlLmN1cnJlbnRUYXJnZXQuX25vZGUpO1xuICAgIH07XG59KTtcblxuLyoqXG5SZWdleCB0byB0ZXN0IGZvciBkaXNhYmxlZCBlbGVtZW50cyBkdXJpbmcgZmlsdGVyaW5nLiBUaGlzIGlzIG9ubHkgcmVsZXZhbnQgdG9cbklFIHRvIG5vcm1hbGl6ZSBiZWhhdmlvciB3aXRoIG90aGVyIGJyb3dzZXJzLCB3aGljaCBzd2FsbG93IGV2ZW50cyB0aGF0IG9jY3VyXG50byBkaXNhYmxlZCBlbGVtZW50cy4gSUUgZmlyZXMgdGhlIGV2ZW50IGZyb20gdGhlIHBhcmVudCBlbGVtZW50IGluc3RlYWQgb2YgdGhlXG5vcmlnaW5hbCB0YXJnZXQsIHRob3VnaCBpdCBkb2VzIHByZXNlcnZlIGBldmVudC5zcmNFbGVtZW50YCBhcyB0aGUgZGlzYWJsZWRcbmVsZW1lbnQuIElFIGFsc28gc3VwcG9ydHMgZGlzYWJsZWQgb24gYDxhPmAsIGJ1dCB0aGUgZXZlbnQgc3RpbGwgYnViYmxlcywgc28gaXRcbmFjdHMgbW9yZSBsaWtlIGBlLnByZXZlbnREZWZhdWx0KClgIHBsdXMgc3R5bGluZy4gVGhhdCBpc3N1ZSBpcyBub3QgaGFuZGxlZCBoZXJlXG5iZWNhdXNlIG90aGVyIGJyb3dzZXJzIGZpcmUgdGhlIGV2ZW50IG9uIHRoZSBgPGE+YCwgc28gZGVsZWdhdGUgaXMgc3VwcG9ydGVkIGluXG5ib3RoIGNhc2VzLlxuXG5AcHJvcGVydHkgX2Rpc2FibGVkUkVcbkB0eXBlIHtSZWdFeHB9XG5AcHJvdGVjdGVkXG5Ac2luY2UgMy44LjFcbioqL1xuZGVsZWdhdGUuX2Rpc2FibGVkUkUgPSAvXig/OmJ1dHRvbnxpbnB1dHxzZWxlY3R8dGV4dGFyZWEpJC9pO1xuXG4vKipcbldhbGtzIHVwIHRoZSBwYXJlbnQgYXhpcyBvZiBhbiBldmVudCdzIHRhcmdldCwgYW5kIHRlc3RzIGVhY2ggZWxlbWVudFxuYWdhaW5zdCBhIHN1cHBsaWVkIGZpbHRlciBmdW5jdGlvbi4gIElmIGFueSBOb2RlcywgaW5jbHVkaW5nIHRoZSBjb250YWluZXIsXG5zYXRpc2Z5IHRoZSBmaWx0ZXIsIHRoZSBkZWxlZ2F0ZWQgY2FsbGJhY2sgd2lsbCBiZSB0cmlnZ2VyZWQgZm9yIGVhY2guXG5cbkhvc3RlZCBhcyBhIHByb3RlY3RlZCBwcm9wZXJ0eSBvZiB0aGUgYGRlbGVnYXRlYCBtZXRob2QgKGUuZy5cbmBZLmRlbGVnYXRlLl9hcHBseUZpbHRlcmApLlxuXG5AbWV0aG9kIF9hcHBseUZpbHRlclxuQHBhcmFtIGZpbHRlciB7RnVuY3Rpb259IGJvb2xlYW4gZnVuY3Rpb24gdG8gdGVzdCBmb3IgaW5jbHVzaW9uIGluIGV2ZW50XG4gICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblxuQHBhcmFtIGFyZ3Mge0FycmF5fSB0aGUgYXJndW1lbnRzIHRoYXQgd291bGQgYmUgcGFzc2VkIHRvIHN1YnNjcmliZXJzXG5AcGFyYW0gY2UgICB7Q3VzdG9tRXZlbnR9IHRoZSBET00gZXZlbnQgd3JhcHBlclxuQHJldHVybiB7Tm9kZXxOb2RlW118dW5kZWZpbmVkfSBUaGUgTm9kZSBvciBOb2RlcyB0aGF0IHNhdGlzZnkgdGhlIGZpbHRlclxuQHByb3RlY3RlZFxuKiovXG5kZWxlZ2F0ZS5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyLCBhcmdzLCBjZSkge1xuICAgIHZhciBlICAgICAgICAgPSBhcmdzWzBdLFxuICAgICAgICBjb250YWluZXIgPSBjZS5lbCwgLy8gZmFjYWRlbGVzcyBldmVudHMgaW4gSUUsIGhhdmUgbm8gZS5jdXJyZW50VGFyZ2V0XG4gICAgICAgIHRhcmdldCAgICA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcbiAgICAgICAgbWF0Y2ggICAgID0gW10sXG4gICAgICAgIGlzQ29udGFpbmVyID0gZmFsc2U7XG5cbiAgICAvLyBzYWZhcmkgc3ZnIGVsZW1lbnQgZml4IC1iY1xuICAgIGlmICh0eXBlb2YgU1ZHRWxlbWVudEluc3RhbmNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIXRhcmdldC5ub2RlVHlwZSAmJiB0YXJnZXQuY29ycmVzcG9uZGluZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCB8fCB0YXJnZXQuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNvbHZlIHRleHQgbm9kZXMgdG8gdGhlaXIgY29udGFpbmluZyBlbGVtZW50XG4gICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBGb3IgSUUuIElFIHByb3BhZ2F0ZXMgZXZlbnRzIGZyb20gdGhlIHBhcmVudCBlbGVtZW50IG9mIGRpc2FibGVkXG4gICAgLy8gZWxlbWVudHMsIHdoZXJlIG90aGVyIGJyb3dzZXJzIHN3YWxsb3cgdGhlIGV2ZW50IGVudGlyZWx5LiBUbyBub3JtYWxpemVcbiAgICAvLyB0aGlzIGluIElFLCBmaWx0ZXJpbmcgZm9yIG1hdGNoaW5nIGVsZW1lbnRzIHNob3VsZCBhYm9ydCBpZiB0aGUgdGFyZ2V0XG4gICAgLy8gaXMgYSBkaXNhYmxlZCBmb3JtIGNvbnRyb2wuXG4gICAgaWYgKHRhcmdldC5kaXNhYmxlZCAmJiBkZWxlZ2F0ZS5fZGlzYWJsZWRSRS50ZXN0KHRhcmdldC5ub2RlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cblxuICAgIC8vIHBhc3NpbmcgdGFyZ2V0IGFzIHRoZSBmaXJzdCBhcmcgcmF0aGVyIHRoYW4gbGVhdmluZyB3ZWxsIGVub3VnaCBhbG9uZVxuICAgIC8vIG1ha2luZyAndGhpcycgaW4gdGhlIGZpbHRlciBmdW5jdGlvbiByZWZlciB0byB0aGUgdGFyZ2V0LiAgVGhpcyBpcyB0b1xuICAgIC8vIHN1cHBvcnQgYm91bmQgZmlsdGVyIGZ1bmN0aW9ucy5cbiAgICBhcmdzLnVuc2hpZnQodGFyZ2V0KTtcblxuICAgIGlmIChpc1N0cmluZyhmaWx0ZXIpKSB7XG4gICAgICAgIHdoaWxlICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlzQ29udGFpbmVyID0gKHRhcmdldCA9PT0gY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RvclRlc3QodGFyZ2V0LCBmaWx0ZXIsIChpc0NvbnRhaW5lciA/IG51bGw6IGNvbnRhaW5lcikpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2gucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaWx0ZXIgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlciBjb2RlIGFuZCBzaG91bGQgcmVjZWl2ZSB3cmFwcGVyc1xuICAgICAgICBhcmdzWzBdID0gWS5vbmUodGFyZ2V0KTtcbiAgICAgICAgYXJnc1sxXSA9IG5ldyBZLkRPTUV2ZW50RmFjYWRlKGUsIGNvbnRhaW5lciwgY2UpO1xuXG4gICAgICAgIHdoaWxlICh0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vIGZpbHRlcih0YXJnZXQsIGUsIGV4dHJhIGFyZ3MuLi4pIC0gdGhpcyA9PT0gdGFyZ2V0XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmFwcGx5KGFyZ3NbMF0sIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2gucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICBhcmdzWzBdID0gWS5vbmUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzWzFdID0gZTsgLy8gcmVzdG9yZSB0aGUgcmF3IERPTSBldmVudFxuICAgIH1cblxuICAgIGlmIChtYXRjaC5sZW5ndGggPD0gMSkge1xuICAgICAgICBtYXRjaCA9IG1hdGNoWzBdOyAvLyBzaW5nbGUgbWF0Y2ggb3IgdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHRoZSB0YXJnZXRcbiAgICBhcmdzLnNoaWZ0KCk7XG5cbiAgICByZXR1cm4gbWF0Y2g7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgZXZlbnQgZGVsZWdhdGlvbiBvbiBhIGNvbnRhaW5lciBlbGVtZW50LiAgVGhlIGRlbGVnYXRlZCBldmVudFxuICogd2lsbCB1c2UgYSBzdXBwbGllZCBmaWx0ZXIgdG8gdGVzdCBpZiB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIGV4ZWN1dGVkLlxuICogVGhpcyBmaWx0ZXIgY2FuIGJlIGVpdGhlciBhIHNlbGVjdG9yIHN0cmluZyBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICogYSBOb2RlIHRvIHVzZSBhcyB0aGUgY3VycmVudFRhcmdldCBmb3IgdGhlIGV2ZW50LlxuICpcbiAqIFRoZSBldmVudCBvYmplY3QgZm9yIHRoZSBkZWxlZ2F0ZWQgZXZlbnQgaXMgc3VwcGxpZWQgdG8gdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi4gIEl0IGlzIG1vZGlmaWVkIHNsaWdodGx5IGluIG9yZGVyIHRvIHN1cHBvcnQgYWxsIHByb3BlcnRpZXNcbiAqIHRoYXQgbWF5IGJlIG5lZWRlZCBmb3IgZXZlbnQgZGVsZWdhdGlvbi4gICdjdXJyZW50VGFyZ2V0JyBpcyBzZXQgdG9cbiAqIHRoZSBlbGVtZW50IHRoYXQgbWF0Y2hlZCB0aGUgc2VsZWN0b3Igc3RyaW5nIGZpbHRlciBvciB0aGUgTm9kZSByZXR1cm5lZFxuICogZnJvbSB0aGUgZmlsdGVyIGZ1bmN0aW9uLiAgJ2NvbnRhaW5lcicgaXMgc2V0IHRvIHRoZSBlbGVtZW50IHRoYXQgdGhlXG4gKiBsaXN0ZW5lciBpcyBkZWxlZ2F0ZWQgZnJvbSAodGhpcyBub3JtYWxseSB3b3VsZCBiZSB0aGUgJ2N1cnJlbnRUYXJnZXQnKS5cbiAqXG4gKiBGaWx0ZXIgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGFyZ3VtZW50cyB0aGF0IHdvdWxkIGJlIHBhc3NlZCB0b1xuICogdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLCBpbmNsdWRpbmcgdGhlIGV2ZW50IG9iamVjdCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLlxuICogVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gZmFsc2UgKG9yIGEgZmFsc2V5IHZhbHVlKSBpZiB0aGUgc3VjY2VzcyBjcml0ZXJpYVxuICogYXJlbid0IG1ldCwgYW5kIHRoZSBOb2RlIHRvIHVzZSBhcyB0aGUgZXZlbnQncyBjdXJyZW50VGFyZ2V0IGFuZCAndGhpcydcbiAqIG9iamVjdCBpZiB0aGV5IGFyZS5cbiAqXG4gKiBAbWV0aG9kIGRlbGVnYXRlXG4gKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSB0aGUgZXZlbnQgdHlwZSB0byBkZWxlZ2F0ZVxuICogQHBhcmFtIGZuIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuICBUaGlzIGZ1bmN0aW9uXG4gKiB3aWxsIGJlIHByb3ZpZGVkIHRoZSBldmVudCBvYmplY3QgZm9yIHRoZSBkZWxlZ2F0ZWQgZXZlbnQuXG4gKiBAcGFyYW0gZWwge3N0cmluZ3xub2RlfSB0aGUgZWxlbWVudCB0aGF0IGlzIHRoZSBkZWxlZ2F0aW9uIGNvbnRhaW5lclxuICogQHBhcmFtIGZpbHRlciB7c3RyaW5nfGZ1bmN0aW9ufSBhIHNlbGVjdG9yIHRoYXQgbXVzdCBtYXRjaCB0aGUgdGFyZ2V0IG9mIHRoZVxuICogZXZlbnQgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBOb2RlIG9yIGZhbHNlLlxuICogQHBhcmFtIGNvbnRleHQgb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBzcGVjaWZpZXMgd2hhdCAndGhpcycgcmVmZXJzIHRvLlxuICogQHBhcmFtIGFyZ3MqIDAuLm4gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyBvbiB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBUaGVzZSBhcmd1bWVudHMgd2lsbCBiZSBhZGRlZCBhZnRlciB0aGUgZXZlbnQgb2JqZWN0LlxuICogQHJldHVybiB7RXZlbnRIYW5kbGV9IHRoZSBkZXRhY2ggaGFuZGxlXG4gKiBAZm9yIFlVSVxuICovXG5ZLmRlbGVnYXRlID0gWS5FdmVudC5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJub2RlLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnZXZlbnQtZmxpY2snLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIFRoZSBnZXN0dXJlcyBtb2R1bGUgcHJvdmlkZXMgZ2VzdHVyZSBldmVudHMgc3VjaCBhcyBcImZsaWNrXCIsIHdoaWNoIG5vcm1hbGl6ZSB1c2VyIGludGVyYWN0aW9uc1xuICogYWNyb3NzIHRvdWNoIGFuZCBtb3VzZSBvciBwb2ludGVyIGJhc2VkIGlucHV0IGRldmljZXMuIFRoaXMgbGF5ZXIgY2FuIGJlIHVzZWQgYnkgYXBwbGljYXRpb24gZGV2ZWxvcGVyc1xuICogdG8gYnVpbGQgaW5wdXQgZGV2aWNlIGFnbm9zdGljIGNvbXBvbmVudHMgd2hpY2ggYmVoYXZlIHRoZSBzYW1lIGluIHJlc3BvbnNlIHRvIGVpdGhlciB0b3VjaCBvciBtb3VzZSBiYXNlZFxuICogaW50ZXJhY3Rpb24uXG4gKlxuICogPHA+RG9jdW1lbnRhdGlvbiBmb3IgZXZlbnRzIGFkZGVkIGJ5IHRoaXMgbW9kdWxlIGNhbiBiZSBmb3VuZCBpbiB0aGUgZXZlbnQgZG9jdW1lbnQgZm9yIHRoZSA8YSBocmVmPVwiLi4vY2xhc3Nlcy9ZVUkuaHRtbCNldmVudHNcIj5ZVUk8L2E+IGdsb2JhbC48L3A+XG4gKlxuICpcbiBAZXhhbXBsZVxuXG4gICAgIFlVSSgpLnVzZSgnZXZlbnQtZmxpY2snLCBmdW5jdGlvbiAoWSkge1xuICAgICAgICAgWS5vbmUoJyNteU5vZGUnKS5vbignZmxpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgfSk7XG4gICAgIH0pO1xuXG4gKlxuICogQG1vZHVsZSBldmVudC1nZXN0dXJlc1xuICovXG5cbi8qKlxuICogQWRkcyBzdXBwb3J0IGZvciBhIFwiZmxpY2tcIiBldmVudCwgd2hpY2ggaXMgZmlyZWQgYXQgdGhlIGVuZCBvZiBhIHRvdWNoIG9yIG1vdXNlIGJhc2VkIGZsaWNrIGdlc3R1cmUsIGFuZCBwcm92aWRlc1xuICogdmVsb2NpdHkgb2YgdGhlIGZsaWNrLCBhbG9uZyB3aXRoIGRpc3RhbmNlIGFuZCB0aW1lIGluZm9ybWF0aW9uLlxuICpcbiAqIDxwPkRvY3VtZW50YXRpb24gZm9yIHRoZSBmbGljayBldmVudCBjYW4gYmUgZm91bmQgb24gdGhlIDxhIGhyZWY9XCIuLi9jbGFzc2VzL1lVSS5odG1sI2V2ZW50X2ZsaWNrXCI+WVVJPC9hPiBnbG9iYWwsXG4gKiBhbG9uZyB3aXRoIHRoZSBvdGhlciBzdXBwb3J0ZWQgZXZlbnRzLjwvcD5cbiAqXG4gKiBAbW9kdWxlIGV2ZW50LWdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIGV2ZW50LWZsaWNrXG4gKi9cbnZhciBHRVNUVVJFX01BUCA9IFkuRXZlbnQuX0dFU1RVUkVfTUFQLFxuICAgIEVWRU5UID0ge1xuICAgICAgICBzdGFydDogR0VTVFVSRV9NQVAuc3RhcnQsXG4gICAgICAgIGVuZDogR0VTVFVSRV9NQVAuZW5kLFxuICAgICAgICBtb3ZlOiBHRVNUVVJFX01BUC5tb3ZlXG4gICAgfSxcbiAgICBTVEFSVCA9IFwic3RhcnRcIixcbiAgICBFTkQgPSBcImVuZFwiLFxuICAgIE1PVkUgPSBcIm1vdmVcIixcblxuICAgIE9XTkVSX0RPQ1VNRU5UID0gXCJvd25lckRvY3VtZW50XCIsXG4gICAgTUlOX1ZFTE9DSVRZID0gXCJtaW5WZWxvY2l0eVwiLFxuICAgIE1JTl9ESVNUQU5DRSA9IFwibWluRGlzdGFuY2VcIixcbiAgICBQUkVWRU5UX0RFRkFVTFQgPSBcInByZXZlbnREZWZhdWx0XCIsXG5cbiAgICBfRkxJQ0tfU1RBUlQgPSBcIl9mc1wiLFxuICAgIF9GTElDS19TVEFSVF9IQU5ETEUgPSBcIl9mc2hcIixcbiAgICBfRkxJQ0tfRU5EX0hBTkRMRSA9IFwiX2ZlaFwiLFxuICAgIF9GTElDS19NT1ZFX0hBTkRMRSA9IFwiX2ZtaFwiLFxuXG4gICAgTk9ERV9UWVBFID0gXCJub2RlVHlwZVwiO1xuXG4vKipcbiAqIFNldHMgdXAgYSBcImZsaWNrXCIgZXZlbnQsIHRoYXQgaXMgZmlyZWQgd2hlbmV2ZXIgdGhlIHVzZXIgaW5pdGlhdGVzIGEgZmxpY2sgZ2VzdHVyZSBvbiB0aGUgbm9kZVxuICogd2hlcmUgdGhlIGxpc3RlbmVyIGlzIGF0dGFjaGVkLiBUaGUgc3Vic2NyaWJlciBjYW4gc3BlY2lmeSBhIG1pbmltdW0gZGlzdGFuY2Ugb3IgdmVsb2NpdHkgZm9yXG4gKiB3aGljaCB0aGUgZXZlbnQgaXMgdG8gYmUgZmlyZWQuIFRoZSBzdWJzY3JpYmVyIGNhbiBhbHNvIHNwZWNpZnkgaWYgdGhlcmUgaXMgYSBwYXJ0aWN1bGFyIGF4aXMgd2hpY2hcbiAqIHRoZXkgYXJlIGludGVyZXN0ZWQgaW4gLSBcInhcIiBvciBcInlcIi4gSWYgbm8gYXhpcyBpcyBzcGVjaWZpZWQsIHRoZSBheGlzIGFsb25nIHdoaWNoIHRoZXJlIHdhcyBtb3N0IGRpc3RhbmNlXG4gKiBjb3ZlcmVkIGlzIHVzZWQuXG4gKlxuICogPHA+SXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIFkuYmluZCB0byBzZXQgdXAgY29udGV4dCBhbmQgYWRkaXRpb25hbCBhcmd1bWVudHMgZm9yIHlvdXIgZXZlbnQgaGFuZGxlcixcbiAqIGhvd2V2ZXIgaWYgeW91IHdhbnQgdG8gcGFzcyB0aGUgY29udGV4dCBhbmQgYXJndW1lbnRzIGFzIGFkZGl0aW9uYWwgc2lnbmF0dXJlIGFyZ3VtZW50cyB0byBcIm9uXCIsXG4gKiB5b3UgbmVlZCB0byBwcm92aWRlIGEgbnVsbCB2YWx1ZSBmb3IgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBlLmc6IDxjb2RlPm5vZGUub24oXCJmbGlja1wiLCBmbiwgbnVsbCwgY29udGV4dCwgYXJnMSwgYXJnMiwgYXJnMyk8L2NvZGU+PC9wPlxuICpcbiAqIEBldmVudCBmbGlja1xuICogQGZvciBZVUlcbiAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9IFwiZmxpY2tcIlxuICogQHBhcmFtIGZuIHtmdW5jdGlvbn0gVGhlIG1ldGhvZCB0aGUgZXZlbnQgaW52b2tlcy4gSXQgcmVjZWl2ZXMgYW4gZXZlbnQgZmFjYWRlIHdpdGggYW4gZS5mbGljayBvYmplY3QgY29udGFpbmluZyB0aGUgZmxpY2sgcmVsYXRlZCBwcm9wZXJ0aWVzOiBlLmZsaWNrLnRpbWUsIGUuZmxpY2suZGlzdGFuY2UsIGUuZmxpY2sudmVsb2NpdHkgYW5kIGUuZmxpY2suYXhpcywgZS5mbGljay5zdGFydC5cbiAqIEBwYXJhbSBjZmcge09iamVjdH0gT3B0aW9uYWwuIEFuIG9iamVjdCB3aGljaCBzcGVjaWZpZXMgYW55IG9mIHRoZSBmb2xsb3dpbmc6XG4gKiA8ZGw+XG4gKiA8ZHQ+bWluRGlzdGFuY2UgKGluIHBpeGVscywgZGVmYXVsdHMgdG8gMTApPC9kdD5cbiAqIDxkZD5UaGUgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLCB3aGljaCB3b3VsZCBxdWFsaWZ5IHRoZSBnZXN0dXJlIGFzIGEgZmxpY2suPC9kZD5cbiAqIDxkdD5taW5WZWxvY2l0eSAoaW4gcGl4ZWxzL21zLCBkZWZhdWx0cyB0byAwKTwvZHQ+XG4gKiA8ZGQ+VGhlIG1pbmltdW0gdmVsb2NpdHkgd2hpY2ggd291bGQgcXVhbGlmeSB0aGUgZ2VzdHVyZSBhcyBhIGZsaWNrLjwvZGQ+XG4gKiA8ZHQ+cHJldmVudERlZmF1bHQgKGRlZmF1bHRzIHRvIGZhbHNlKTwvZHQ+XG4gKiA8ZGQ+Q2FuIGJlIHNldCB0byB0cnVlL2ZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBiZWhhdmlvciBhcyBzb29uIGFzIHRoZSB0b3VjaHN0YXJ0L3RvdWNoZW5kIG9yIG1vdXNlZG93bi9tb3VzZXVwIGlzIHJlY2VpdmVkIHNvIHRoYXQgdGhpbmdzIGxpa2Ugc2Nyb2xsaW5nIG9yIHRleHQgc2VsZWN0aW9uIGNhbiBiZVxuICogcHJldmVudGVkLiBUaGlzIHByb3BlcnR5IGNhbiBhbHNvIGJlIHNldCB0byBhIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIHRydWUgb3IgZmFsc2UsIGJhc2VkIG9uIHRoZSBldmVudCBmYWNhZGUgcGFzc2VkIHRvIGl0LjwvZGQ+XG4gKiA8ZHQ+YXhpcyAobm8gZGVmYXVsdCk8L2R0PlxuICogPGRkPkNhbiBiZSBzZXQgdG8gXCJ4XCIgb3IgXCJ5XCIgaWYgeW91IHdhbnQgdG8gY29uc3RyYWluIHRoZSBmbGljayB2ZWxvY2l0eSBhbmQgZGlzdGFuY2UgdG8gYSBzaW5nbGUgYXhpcy4gSWYgbm90XG4gKiBkZWZpbmVkLCB0aGUgYXhpcyBhbG9uZyB3aGljaCB0aGUgbWF4aW11bSBkaXN0YW5jZSB3YXMgY292ZXJlZCBpcyB1c2VkLjwvZGQ+XG4gKiA8L2RsPlxuICogQHJldHVybiB7RXZlbnRIYW5kbGV9IHRoZSBkZXRhY2ggaGFuZGxlXG4gKi9cblxuWS5FdmVudC5kZWZpbmUoJ2ZsaWNrJywge1xuXG4gICAgb246IGZ1bmN0aW9uIChub2RlLCBzdWJzY3JpYmVyLCBjZSkge1xuXG4gICAgICAgIHZhciBzdGFydEhhbmRsZSA9IG5vZGUub24oRVZFTlRbU1RBUlRdLFxuICAgICAgICAgICAgdGhpcy5fb25TdGFydCxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgICAgIGNlKTtcblxuICAgICAgICBzdWJzY3JpYmVyW19GTElDS19TVEFSVF9IQU5ETEVdID0gc3RhcnRIYW5kbGU7XG4gICAgfSxcblxuICAgIGRldGFjaDogZnVuY3Rpb24gKG5vZGUsIHN1YnNjcmliZXIsIGNlKSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0SGFuZGxlID0gc3Vic2NyaWJlcltfRkxJQ0tfU1RBUlRfSEFORExFXSxcbiAgICAgICAgICAgIGVuZEhhbmRsZSA9IHN1YnNjcmliZXJbX0ZMSUNLX0VORF9IQU5ETEVdO1xuXG4gICAgICAgIGlmIChzdGFydEhhbmRsZSkge1xuICAgICAgICAgICAgc3RhcnRIYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgICAgICBzdWJzY3JpYmVyW19GTElDS19TVEFSVF9IQU5ETEVdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmRIYW5kbGUpIHtcbiAgICAgICAgICAgIGVuZEhhbmRsZS5kZXRhY2goKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXJbX0ZMSUNLX0VORF9IQU5ETEVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwcm9jZXNzQXJnczogZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgcGFyYW1zID0gKGFyZ3MubGVuZ3RoID4gMykgPyBZLm1lcmdlKGFyZ3Muc3BsaWNlKDMsIDEpWzBdKSA6IHt9O1xuXG4gICAgICAgIGlmICghKE1JTl9WRUxPQ0lUWSBpbiBwYXJhbXMpKSB7XG4gICAgICAgICAgICBwYXJhbXNbTUlOX1ZFTE9DSVRZXSA9IHRoaXMuTUlOX1ZFTE9DSVRZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoTUlOX0RJU1RBTkNFIGluIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHBhcmFtc1tNSU5fRElTVEFOQ0VdID0gdGhpcy5NSU5fRElTVEFOQ0U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShQUkVWRU5UX0RFRkFVTFQgaW4gcGFyYW1zKSkge1xuICAgICAgICAgICAgcGFyYW1zW1BSRVZFTlRfREVGQVVMVF0gPSB0aGlzLlBSRVZFTlRfREVGQVVMVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIF9vblN0YXJ0OiBmdW5jdGlvbihlLCBub2RlLCBzdWJzY3JpYmVyLCBjZSkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRydWUsIC8vIGFsd2F5cyB0cnVlIGZvciBtb3VzZVxuICAgICAgICAgICAgZW5kSGFuZGxlLFxuICAgICAgICAgICAgbW92ZUhhbmRsZSxcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gc3Vic2NyaWJlci5fZXh0cmEucHJldmVudERlZmF1bHQsXG4gICAgICAgICAgICBvcmlnRSA9IGU7XG5cbiAgICAgICAgaWYgKGUudG91Y2hlcykge1xuICAgICAgICAgICAgc3RhcnQgPSAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSk7XG4gICAgICAgICAgICBlID0gZS50b3VjaGVzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0KSB7XG5cbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnREZWZhdWx0IGlzIGEgYm9vbGVhbiBvciBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmICghcHJldmVudERlZmF1bHQuY2FsbCB8fCBwcmV2ZW50RGVmYXVsdChlKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnRS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5mbGljayA9IHtcbiAgICAgICAgICAgICAgICB0aW1lIDogbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN1YnNjcmliZXJbX0ZMSUNLX1NUQVJUXSA9IGU7XG5cbiAgICAgICAgICAgIGVuZEhhbmRsZSA9IHN1YnNjcmliZXJbX0ZMSUNLX0VORF9IQU5ETEVdO1xuXG4gICAgICAgICAgICBkb2MgPSAobm9kZS5nZXQoTk9ERV9UWVBFKSA9PT0gOSkgPyBub2RlIDogbm9kZS5nZXQoT1dORVJfRE9DVU1FTlQpO1xuICAgICAgICAgICAgaWYgKCFlbmRIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICBlbmRIYW5kbGUgPSBkb2Mub24oRVZFTlRbRU5EXSwgWS5iaW5kKHRoaXMuX29uRW5kLCB0aGlzKSwgbnVsbCwgbm9kZSwgc3Vic2NyaWJlciwgY2UpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJbX0ZMSUNLX0VORF9IQU5ETEVdID0gZW5kSGFuZGxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJzY3JpYmVyW19GTElDS19NT1ZFX0hBTkRMRV0gPSBkb2Mub25jZShFVkVOVFtNT1ZFXSwgWS5iaW5kKHRoaXMuX29uTW92ZSwgdGhpcyksIG51bGwsIG5vZGUsIHN1YnNjcmliZXIsIGNlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25Nb3ZlOiBmdW5jdGlvbihlLCBub2RlLCBzdWJzY3JpYmVyLCBjZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBzdWJzY3JpYmVyW19GTElDS19TVEFSVF07XG5cbiAgICAgICAgLy8gU3RhcnQgdGltaW5nIGZyb20gZmlyc3QgbW92ZS5cbiAgICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0LmZsaWNrKSB7XG4gICAgICAgICAgICBzdGFydC5mbGljay50aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uRW5kOiBmdW5jdGlvbihlLCBub2RlLCBzdWJzY3JpYmVyLCBjZSkge1xuXG4gICAgICAgIHZhciBlbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICBzdGFydCA9IHN1YnNjcmliZXJbX0ZMSUNLX1NUQVJUXSxcbiAgICAgICAgICAgIHZhbGlkID0gISFzdGFydCxcbiAgICAgICAgICAgIGVuZEV2ZW50ID0gZSxcbiAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIHh5RGlzdGFuY2UsXG4gICAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICAgIHZlbG9jaXR5LFxuICAgICAgICAgICAgYXhpcyxcbiAgICAgICAgICAgIG1vdmVIYW5kbGUgPSBzdWJzY3JpYmVyW19GTElDS19NT1ZFX0hBTkRMRV07XG5cbiAgICAgICAgaWYgKG1vdmVIYW5kbGUpIHtcbiAgICAgICAgICAgIG1vdmVIYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgICAgICBkZWxldGUgc3Vic2NyaWJlcltfRkxJQ0tfTU9WRV9IQU5ETEVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkKSB7XG5cbiAgICAgICAgICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSAxICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kRXZlbnQgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsaWQpIHtcblxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHN1YnNjcmliZXIuX2V4dHJhO1xuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gcGFyYW1zW1BSRVZFTlRfREVGQVVMVF07XG5cbiAgICAgICAgICAgICAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudERlZmF1bHQgaXMgYSBib29sZWFuIG9yIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmVudERlZmF1bHQuY2FsbCB8fCBwcmV2ZW50RGVmYXVsdChlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gc3RhcnQuZmxpY2sudGltZTtcbiAgICAgICAgICAgICAgICBlbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgICAgICAgICB4eURpc3RhbmNlID0gW1xuICAgICAgICAgICAgICAgICAgICBlbmRFdmVudC5wYWdlWCAtIHN0YXJ0LnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICBlbmRFdmVudC5wYWdlWSAtIHN0YXJ0LnBhZ2VZXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYXhpcykge1xuICAgICAgICAgICAgICAgICAgICBheGlzID0gcGFyYW1zLmF4aXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcyA9IChNYXRoLmFicyh4eURpc3RhbmNlWzBdKSA+PSBNYXRoLmFicyh4eURpc3RhbmNlWzFdKSkgPyAneCcgOiAneSc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSB4eURpc3RhbmNlWyhheGlzID09PSAneCcpID8gMCA6IDFdO1xuICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gKHRpbWUgIT09IDApID8gZGlzdGFuY2UvdGltZSA6IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUodmVsb2NpdHkpICYmIChNYXRoLmFicyhkaXN0YW5jZSkgPj0gcGFyYW1zW01JTl9ESVNUQU5DRV0pICYmIChNYXRoLmFicyh2ZWxvY2l0eSkgID49IHBhcmFtc1tNSU5fVkVMT0NJVFldKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGUudHlwZSA9IFwiZmxpY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgZS5mbGljayA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6dGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5OnZlbG9jaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpczogYXhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBjZS5maXJlKGUpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcltfRkxJQ0tfU1RBUlRdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBNSU5fVkVMT0NJVFkgOiAwLFxuICAgIE1JTl9ESVNUQU5DRSA6IDAsXG4gICAgUFJFVkVOVF9ERUZBVUxUIDogZmFsc2Vcbn0pO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJub2RlLWJhc2VcIiwgXCJldmVudC10b3VjaFwiLCBcImV2ZW50LXN5bnRoZXRpY1wiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdldmVudC1mb2N1cycsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogQWRkcyBidWJibGluZyBhbmQgZGVsZWdhdGlvbiBzdXBwb3J0IHRvIERPTSBldmVudHMgZm9jdXMgYW5kIGJsdXIuXG4gKlxuICogQG1vZHVsZSBldmVudFxuICogQHN1Ym1vZHVsZSBldmVudC1mb2N1c1xuICovXG52YXIgRXZlbnQgICAgPSBZLkV2ZW50LFxuXG4gICAgWUxhbmcgICAgPSBZLkxhbmcsXG5cbiAgICBpc1N0cmluZyA9IFlMYW5nLmlzU3RyaW5nLFxuXG4gICAgYXJyYXlJbmRleCA9IFkuQXJyYXkuaW5kZXhPZixcblxuICAgIHVzZUFjdGl2YXRlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIENoYW5naW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyB0ZXN0LCBzbyB0aGF0IGl0IGRvZXNuJ3QgdXNlIGlubGluZSBKUyBpbiBIVE1MLFxuICAgICAgICAvLyB3aGljaCB0aHJvd3MgYW4gZXhjZXB0aW9uIGluIFdpbjggcGFja2FnZWQgYXBwcywgZHVlIHRvIGFkZGl0aW9uYWwgc2VjdXJpdHkgcmVzdHJpY3Rpb25zOlxuICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL2hoNDY1MzgwLmFzcHgjZGlmZmVyZW5jZXNcblxuICAgICAgICB2YXIgc3VwcG9ydGVkID0gZmFsc2UsXG4gICAgICAgICAgICBkb2MgPSBZLmNvbmZpZy5kb2MsXG4gICAgICAgICAgICBwO1xuXG4gICAgICAgIGlmIChkb2MpIHtcblxuICAgICAgICAgICAgcCA9IGRvYy5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICAgICAgICAgIHAuc2V0QXR0cmlidXRlKFwib25iZWZvcmVhY3RpdmF0ZVwiLCBcIjtcIik7XG5cbiAgICAgICAgICAgIC8vIG9uYmVmb3JlYWN0aXZhdGUgaXMgYSBmdW5jdGlvbiBpbiBJRTgrLlxuICAgICAgICAgICAgLy8gb25iZWZvcmVhY3RpdmF0ZSBpcyBhIHN0cmluZyBpbiBJRTYsNyAodW5mb3J0dW5hdGUsIG90aGVyd2lzZSB3ZSBjb3VsZCBoYXZlIGp1c3QgY2hlY2tlZCBmb3IgZnVuY3Rpb24gYmVsb3cpLlxuICAgICAgICAgICAgLy8gb25iZWZvcmVhY3RpdmF0ZSBpcyBhIGZ1bmN0aW9uIGluIElFMTAsIGluIGEgV2luOCBBcHAgZW52aXJvbm1lbnQgKG5vIGV4Y2VwdGlvbiBydW5uaW5nIHRoZSB0ZXN0KS5cblxuICAgICAgICAgICAgLy8gb25iZWZvcmVhY3RpdmF0ZSBpcyB1bmRlZmluZWQgaW4gV2Via2l0L0dlY2tvLlxuICAgICAgICAgICAgLy8gb25iZWZvcmVhY3RpdmF0ZSBpcyBhIGZ1bmN0aW9uIGluIFdlYmtpdC9HZWNrbyBpZiBpdCdzIGEgc3VwcG9ydGVkIGV2ZW50IChlLmcuIG9uY2xpY2spLlxuXG4gICAgICAgICAgICBzdXBwb3J0ZWQgPSAocC5vbmJlZm9yZWFjdGl2YXRlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICB9KCkpO1xuXG5mdW5jdGlvbiBkZWZpbmUodHlwZSwgcHJveHksIGRpcmVjdEV2ZW50KSB7XG4gICAgdmFyIG5vZGVEYXRhS2V5ID0gJ18nICsgdHlwZSArICdOb3RpZmllcnMnO1xuXG4gICAgWS5FdmVudC5kZWZpbmUodHlwZSwge1xuXG4gICAgICAgIF91c2VBY3RpdmF0ZSA6IHVzZUFjdGl2YXRlLFxuXG4gICAgICAgIF9hdHRhY2g6IGZ1bmN0aW9uIChlbCwgbm90aWZpZXIsIGRlbGVnYXRlKSB7XG4gICAgICAgICAgICBpZiAoWS5ET00uaXNXaW5kb3coZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50Ll9hdHRhY2goW3R5cGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWVyLmZpcmUoZSk7XG4gICAgICAgICAgICAgICAgfSwgZWxdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50Ll9hdHRhY2goXG4gICAgICAgICAgICAgICAgICAgIFtwcm94eSwgdGhpcy5fcHJveHksIGVsLCB0aGlzLCBub3RpZmllciwgZGVsZWdhdGVdLFxuICAgICAgICAgICAgICAgICAgICB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Byb3h5OiBmdW5jdGlvbiAoZSwgbm90aWZpZXIsIGRlbGVnYXRlKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ICAgICAgICA9IGUudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICAgICAgbm90aWZpZXJzICAgICA9IHRhcmdldC5nZXREYXRhKG5vZGVEYXRhS2V5KSxcbiAgICAgICAgICAgICAgICB5dWlkICAgICAgICAgID0gWS5zdGFtcChjdXJyZW50VGFyZ2V0Ll9ub2RlKSxcbiAgICAgICAgICAgICAgICBkZWZlciAgICAgICAgID0gKHVzZUFjdGl2YXRlIHx8IHRhcmdldCAhPT0gY3VycmVudFRhcmdldCksXG4gICAgICAgICAgICAgICAgZGlyZWN0U3ViO1xuXG4gICAgICAgICAgICBub3RpZmllci5jdXJyZW50VGFyZ2V0ID0gKGRlbGVnYXRlKSA/IHRhcmdldCA6IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBub3RpZmllci5jb250YWluZXIgICAgID0gKGRlbGVnYXRlKSA/IGN1cnJlbnRUYXJnZXQgOiBudWxsO1xuXG4gICAgICAgICAgICAvLyBNYWludGFpbiBhIGxpc3QgdG8gaGFuZGxlIHN1YnNjcmlwdGlvbnMgZnJvbSBuZXN0ZWRcbiAgICAgICAgICAgIC8vIGNvbnRhaW5lcnMgZGl2I2E+ZGl2I2I+aW5wdXQgI2Eub24oZm9jdXMuLikgI2Iub24oZm9jdXMuLiksXG4gICAgICAgICAgICAvLyB1c2Ugb25lIGZvY3VzIG9yIGJsdXIgc3Vic2NyaXB0aW9uIHRoYXQgZmlyZXMgbm90aWZpZXJzIGZyb21cbiAgICAgICAgICAgIC8vICNiIHRoZW4gI2EgdG8gZW11bGF0ZSBidWJibGUgc2VxdWVuY2UuXG4gICAgICAgICAgICBpZiAoIW5vdGlmaWVycykge1xuICAgICAgICAgICAgICAgIG5vdGlmaWVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXREYXRhKG5vZGVEYXRhS2V5LCBub3RpZmllcnMpO1xuXG4gICAgICAgICAgICAgICAgLy8gb25seSBzdWJzY3JpYmUgdG8gdGhlIGVsZW1lbnQncyBmb2N1cyBpZiB0aGUgdGFyZ2V0IGlzXG4gICAgICAgICAgICAgICAgLy8gbm90IHRoZSBjdXJyZW50IHRhcmdldCAoXG4gICAgICAgICAgICAgICAgaWYgKGRlZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdFN1YiA9IEV2ZW50Ll9hdHRhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICBbZGlyZWN0RXZlbnQsIHRoaXMuX25vdGlmeSwgdGFyZ2V0Ll9ub2RlXSkuc3ViO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RTdWIub25jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBvbGQgSUUsIGRlZmVyIGlzIGFsd2F5cyB0cnVlLiAgSW4gY2FwdHVyZS1waGFzZSBicm93c2VycyxcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVsZWdhdGUgc3Vic2NyaXB0aW9ucyB3aWxsIGJlIGVuY291bnRlcmVkIGZpcnN0LCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgZXN0YWJsaXNoIHRoZSBub3RpZmllcnMgZGF0YSBhbmQgZGlyZWN0IHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBub2RlLiAgSWYgdGhlcmUgaXMgYWxzbyBhIGRpcmVjdCBzdWJzY3JpcHRpb24gdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gbm9kZSdzIGZvY3VzL2JsdXIsIGl0IHNob3VsZCBub3QgY2FsbCBfbm90aWZ5IGJlY2F1c2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gZGlyZWN0IHN1YnNjcmlwdGlvbiBmcm9tIHRoZSBkZWxlZ2F0ZSBzdWIocykgZXhpc3RzLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgY2FsbCBfbm90aWZ5LiAgU28gdGhpcyBhdm9pZHMgX25vdGlmeSBiZWluZyBjYWxsZWRcbiAgICAgICAgICAgICAgICAvLyB0d2ljZSwgdW5uZWNlc3NhcmlseS5cbiAgICAgICAgICAgICAgICBkZWZlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbm90aWZpZXJzW3l1aWRdKSB7XG4gICAgICAgICAgICAgICAgbm90aWZpZXJzW3l1aWRdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vdGlmaWVyc1t5dWlkXS5wdXNoKG5vdGlmaWVyKTtcblxuICAgICAgICAgICAgaWYgKCFkZWZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfbm90aWZ5OiBmdW5jdGlvbiAoZSwgY29udGFpbmVyKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldCxcbiAgICAgICAgICAgICAgICBub3RpZmllckRhdGEgID0gY3VycmVudFRhcmdldC5nZXREYXRhKG5vZGVEYXRhS2V5KSxcbiAgICAgICAgICAgICAgICBheGlzTm9kZXMgICAgID0gY3VycmVudFRhcmdldC5hbmNlc3RvcnMoKSxcbiAgICAgICAgICAgICAgICBkb2MgICAgICAgICAgID0gY3VycmVudFRhcmdldC5nZXQoJ293bmVyRG9jdW1lbnQnKSxcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZXMgICAgID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgdG8gZXNjYXBlIGxvb3BzIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aWZpZXJzIHRvIGNvbnNpZGVyXG4gICAgICAgICAgICAgICAgY291bnQgICAgICAgICA9IG5vdGlmaWVyRGF0YSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBZLk9iamVjdC5rZXlzKG5vdGlmaWVyRGF0YSkubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgdGFyZ2V0LCBub3RpZmllcnMsIG5vdGlmaWVyLCB5dWlkLCBtYXRjaCwgdG1wLCBpLCBsZW4sIHN1YiwgcmV0O1xuXG4gICAgICAgICAgICAvLyBjbGVhciB0aGUgbm90aWZpY2F0aW9ucyBsaXN0IChtYWlubHkgZm9yIGRlbGVnYXRpb24pXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0LmNsZWFyRGF0YShub2RlRGF0YUtleSk7XG5cbiAgICAgICAgICAgIC8vIE9yZGVyIHRoZSBkZWxlZ2F0ZSBzdWJzIGJ5IHRoZWlyIHBsYWNlbWVudCBpbiB0aGUgcGFyZW50IGF4aXNcbiAgICAgICAgICAgIGF4aXNOb2Rlcy5wdXNoKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQuZ2V0KCdvd25lckRvY3VtZW50JykgcmV0dXJucyBudWxsXG4gICAgICAgICAgICAvLyB3aGljaCB3ZSdsbCB1c2UgdG8gcHJldmVudCBoYXZpbmcgZHVwbGljYXRlIE5vZGVzIGluIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICAgICAgYXhpc05vZGVzLnVuc2hpZnQoZG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYW5jZXN0b3JzKCkgcmV0dXJucyB0aGUgTm9kZXMgZnJvbSB0b3AgdG8gYm90dG9tXG4gICAgICAgICAgICBheGlzTm9kZXMuX25vZGVzLnJldmVyc2UoKTtcblxuICAgICAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNvdW50IGZvciBzdGVwIDJcbiAgICAgICAgICAgICAgICB0bXAgPSBjb3VudDtcbiAgICAgICAgICAgICAgICBheGlzTm9kZXMuc29tZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeXVpZCAgICAgID0gWS5zdGFtcChub2RlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWVycyA9IG5vdGlmaWVyRGF0YVt5dWlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGksIGxlbjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobm90aWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm90aWZpZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGlmaWVyc1tpXS5oYW5kbGUuc3ViLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZXMucHVzaChub3RpZmllcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhY291bnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY291bnQgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdhbGsgdXAgdGhlIHBhcmVudCBheGlzLCBub3RpZnlpbmcgZGlyZWN0IHN1YnNjcmlwdGlvbnMgYW5kXG4gICAgICAgICAgICAvLyB0ZXN0aW5nIGRlbGVnYXRlIGZpbHRlcnMuXG4gICAgICAgICAgICB3aGlsZSAoY291bnQgJiYgKHRhcmdldCA9IGF4aXNOb2Rlcy5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHl1aWQgPSBZLnN0YW1wKHRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICBub3RpZmllcnMgPSBub3RpZmllckRhdGFbeXVpZF07XG5cbiAgICAgICAgICAgICAgICBpZiAobm90aWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vdGlmaWVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpZXIgPSBub3RpZmllcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIgICAgICA9IG5vdGlmaWVyLmhhbmRsZS5zdWI7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCAgICA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldCA9IHRhcmdldDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yi5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHN1Yi5maWx0ZXIuYXBwbHkodGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGFyZ2V0LCBlXS5jb25jYXQoc3ViLmFyZ3MgfHwgW10pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGxvbmdlciBuZWNlc3NhcnkgdG8gdGVzdCBhZ2FpbnN0IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWxlZ2F0ZSBzdWJzY3JpcHRpb24gZm9yIHRoZSBub2RlcyBhbG9uZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJlbnQgYXhpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZXMuc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUluZGV4KGRlbGVnYXRlcywgbm90aWZpZXIpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIGZvciBkaXJlY3Qgc3Vic1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY29udGFpbmVyID0gbm90aWZpZXIuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IG5vdGlmaWVyLmZpcmUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IGUuc3RvcHBlZCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vdGlmaWVyc1t5dWlkXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZS5zdG9wcGVkICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGVnYXRlcyBjb21lIGFmdGVyIHN1YnMgdGFyZ2V0aW5nIHRoaXMgc3BlY2lmaWMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkgd291bGQgbm90IG5vcm1hbGx5IHJlcG9ydCB1bnRpbCB0aGV5J2RcbiAgICAgICAgICAgICAgICAgICAgLy8gYnViYmxlZCB0byB0aGUgY29udGFpbmVyIG5vZGUuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRlbGVnYXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpZXIgPSBkZWxlZ2F0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSBub3RpZmllci5oYW5kbGUuc3ViO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViLmZpbHRlci5hcHBseSh0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RhcmdldCwgZV0uY29uY2F0KHN1Yi5hcmdzIHx8IFtdKSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY29udGFpbmVyID0gbm90aWZpZXIuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBub3RpZmllci5maXJlKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSB8fCBlLnN0b3BwZWQgPT09IDIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBlLnN0b3BQcm9wYWdhdGlvbigpIGlzIGNhbGxlZCwgbm90aWZ5IGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGVnYXRlIHN1YnMgZnJvbSB0aGUgc2FtZSBjb250YWluZXIsIGJ1dCBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uY2UgdGhlIGNvbnRhaW5lciBjaGFuZ2VzLiBUaGlzIGVtdWxhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsZWdhdGUoKSBiZWhhdmlvciBmb3IgZXZlbnRzIGxpa2UgJ2NsaWNrJyB3aGljaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvbid0IG5vdGlmeSBkZWxlZ2F0ZXMgaGlnaGVyIHVwIHRoZSBwYXJlbnQgYXhpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZS5zdG9wcGVkICYmIGRlbGVnYXRlc1tpKzFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlc1tpKzFdLmNvbnRhaW5lciAhPT0gbm90aWZpZXIuY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGUuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uIChub2RlLCBzdWIsIG5vdGlmaWVyKSB7XG4gICAgICAgICAgICBzdWIuaGFuZGxlID0gdGhpcy5fYXR0YWNoKG5vZGUuX25vZGUsIG5vdGlmaWVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uIChub2RlLCBzdWIpIHtcbiAgICAgICAgICAgIHN1Yi5oYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uIChub2RlLCBzdWIsIG5vdGlmaWVyLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgc3ViLmZpbHRlciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFkuU2VsZWN0b3IudGVzdCh0YXJnZXQuX25vZGUsIGZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPT09IHRhcmdldCA/IG51bGwgOiBub2RlLl9ub2RlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWIuaGFuZGxlID0gdGhpcy5fYXR0YWNoKG5vZGUuX25vZGUsIG5vdGlmaWVyLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hEZWxlZ2F0ZTogZnVuY3Rpb24gKG5vZGUsIHN1Yikge1xuICAgICAgICAgICAgc3ViLmhhbmRsZS5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgIH0sIHRydWUpO1xufVxuXG4vLyBGb3IgSUUsIHdlIG5lZWQgdG8gZGVmZXIgdG8gZm9jdXNpbiByYXRoZXIgdGhhbiBmb2N1cyBiZWNhdXNlXG4vLyBgZWwuZm9jdXMoKTsgZG9Tb21ldGhpbmcoKTtgIGV4ZWN1dGVzIGVsLm9uYmVmb3JlYWN0aXZhdGUsIGVsLm9uYWN0aXZhdGUsXG4vLyBlbC5vbmZvY3VzaW4sIGRvU29tZXRoaW5nLCB0aGVuIGVsLm9uZm9jdXMuICBBbGwgb3RoZXJzIHN1cHBvcnQgY2FwdHVyZVxuLy8gcGhhc2UgZm9jdXMsIHdoaWNoIGV4ZWN1dGVzIGJlZm9yZSBkb1NvbWV0aGluZy4gIFRvIGd1YXJhbnRlZSBjb25zaXN0ZW50XG4vLyBiZWhhdmlvciBmb3IgdGhpcyB1c2UgY2FzZSwgSUUncyBkaXJlY3Qgc3Vic2NyaXB0aW9ucyBhcmUgbWFkZSBhZ2FpbnN0XG4vLyBmb2N1c2luIHNvIHN1YnNjcmliZXJzIHdpbGwgYmUgbm90aWZpZWQgYmVmb3JlIGpzIGZvbGxvd2luZyBlbC5mb2N1cygpIGlzXG4vLyBleGVjdXRlZC5cbmlmICh1c2VBY3RpdmF0ZSkge1xuICAgIC8vICAgICBuYW1lICAgICBjYXB0dXJlIHBoYXNlICAgICAgIGRpcmVjdCBzdWJzY3JpcHRpb25cbiAgICBkZWZpbmUoXCJmb2N1c1wiLCBcImJlZm9yZWFjdGl2YXRlXCIsICAgXCJmb2N1c2luXCIpO1xuICAgIGRlZmluZShcImJsdXJcIiwgIFwiYmVmb3JlZGVhY3RpdmF0ZVwiLCBcImZvY3Vzb3V0XCIpO1xufSBlbHNlIHtcbiAgICBkZWZpbmUoXCJmb2N1c1wiLCBcImZvY3VzXCIsIFwiZm9jdXNcIik7XG4gICAgZGVmaW5lKFwiYmx1clwiLCAgXCJibHVyXCIsICBcImJsdXJcIik7XG59XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImV2ZW50LXN5bnRoZXRpY1wiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdldmVudC1ob3ZlcicsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogQWRkcyBzdXBwb3J0IGZvciBhIFwiaG92ZXJcIiBldmVudC4gIFRoZSBldmVudCBwcm92aWRlcyBhIGNvbnZlbmllbmNlIHdyYXBwZXJcbiAqIGZvciBzdWJzY3JpYmluZyBzZXBhcmF0ZWx5IHRvIG1vdXNlZW50ZXIgYW5kIG1vdXNlbGVhdmUuICBUaGUgc2lnbmF0dXJlIGZvclxuICogc3Vic2NyaWJpbmcgdG8gdGhlIGV2ZW50IGlzPC9wPlxuICpcbiAqIDxwcmU+PGNvZGU+bm9kZS5vbihcImhvdmVyXCIsIG92ZXJGbiwgb3V0Rm4pO1xuICogbm9kZS5kZWxlZ2F0ZShcImhvdmVyXCIsIG92ZXJGbiwgb3V0Rm4sIFwiLmZpbHRlclNlbGVjdG9yXCIpO1xuICogWS5vbihcImhvdmVyXCIsIG92ZXJGbiwgb3V0Rm4sIFwiLnRhcmdldFNlbGVjdG9yXCIpO1xuICogWS5kZWxlZ2F0ZShcImhvdmVyXCIsIG92ZXJGbiwgb3V0Rm4sIFwiI2NvbnRhaW5lclwiLCBcIi5maWx0ZXJTZWxlY3RvclwiKTtcbiAqIDwvY29kZT48L3ByZT5cbiAqXG4gKiA8cD5BZGRpdGlvbmFsbHksIGZvciBjb21wYXRpYmlsaXR5IHdpdGggYSBtb3JlIHR5cGljYWwgc3Vic2NyaXB0aW9uXG4gKiBzaWduYXR1cmUsIHRoZSBmb2xsb3dpbmcgYXJlIGFsc28gc3VwcG9ydGVkOjwvcD5cbiAqXG4gKiA8cHJlPjxjb2RlPlkub24oXCJob3ZlclwiLCBvdmVyRm4sIFwiLnRhcmdldFNlbGVjdG9yXCIsIG91dEZuKTtcbiAqIFkuZGVsZWdhdGUoXCJob3ZlclwiLCBvdmVyRm4sIFwiI2NvbnRhaW5lclwiLCBvdXRGbiwgXCIuZmlsdGVyU2VsZWN0b3JcIik7XG4gKiA8L2NvZGU+PC9wcmU+XG4gKlxuICogQG1vZHVsZSBldmVudFxuICogQHN1Ym1vZHVsZSBldmVudC1ob3ZlclxuICovXG52YXIgaXNGdW5jdGlvbiA9IFkuTGFuZy5pc0Z1bmN0aW9uLFxuICAgIG5vb3AgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICBjb25mID0ge1xuICAgICAgICBwcm9jZXNzQXJnczogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIC8vIFkuZGVsZWdhdGUoJ2hvdmVyJywgb3Zlciwgb3V0LCAnI2NvbnRhaW5lcicsICcuZmlsdGVyJylcbiAgICAgICAgICAgIC8vIGNvbWVzIGluIGFzIFsnaG92ZXInLCBvdmVyLCBvdXQsICcjY29udGFpbmVyJywgJy5maWx0ZXInXSwgYnV0XG4gICAgICAgICAgICAvLyBub2RlLmRlbGVnYXRlKCdob3ZlcicsIG92ZXIsIG91dCwgJy5maWx0ZXInKVxuICAgICAgICAgICAgLy8gY29tZXMgaW4gYXMgWydob3ZlcicsIG92ZXIsIGNvbnRhaW5lckVsLCBvdXQsICcuZmlsdGVyJ11cbiAgICAgICAgICAgIHZhciBpID0gaXNGdW5jdGlvbihhcmdzWzJdKSA/IDIgOiAzO1xuXG4gICAgICAgICAgICByZXR1cm4gKGlzRnVuY3Rpb24oYXJnc1tpXSkpID8gYXJncy5zcGxpY2UoaSwxKVswXSA6IG5vb3A7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uIChub2RlLCBzdWIsIG5vdGlmaWVyLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gKHN1Yi5hcmdzKSA/IHN1Yi5hcmdzLnNsaWNlKCkgOiBbXTtcblxuICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuXG4gICAgICAgICAgICBzdWIuX2RldGFjaCA9IG5vZGVbKGZpbHRlcikgPyBcImRlbGVnYXRlXCIgOiBcIm9uXCJdKHtcbiAgICAgICAgICAgICAgICBtb3VzZWVudGVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnBoYXNlID0gJ292ZXInO1xuICAgICAgICAgICAgICAgICAgICBub3RpZmllci5maXJlKGUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW91c2VsZWF2ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNPYmogPSBzdWIuY29udGV4dCB8fCB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBlO1xuXG4gICAgICAgICAgICAgICAgICAgIGUudHlwZSA9ICdob3Zlcic7XG4gICAgICAgICAgICAgICAgICAgIGUucGhhc2UgPSAnb3V0JztcbiAgICAgICAgICAgICAgICAgICAgc3ViLl9leHRyYS5hcHBseSh0aGlzT2JqLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmaWx0ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaDogZnVuY3Rpb24gKG5vZGUsIHN1Yiwgbm90aWZpZXIpIHtcbiAgICAgICAgICAgIHN1Yi5fZGV0YWNoLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuY29uZi5kZWxlZ2F0ZSA9IGNvbmYub247XG5jb25mLmRldGFjaERlbGVnYXRlID0gY29uZi5kZXRhY2g7XG5cblkuRXZlbnQuZGVmaW5lKFwiaG92ZXJcIiwgY29uZik7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImV2ZW50LW1vdXNlZW50ZXJcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnZXZlbnQta2V5JywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBGdW5jdGlvbmFsaXR5IHRvIGxpc3RlbiBmb3Igb25lIG9yIG1vcmUgc3BlY2lmaWMga2V5IGNvbWJpbmF0aW9ucy5cbiAqIEBtb2R1bGUgZXZlbnRcbiAqIEBzdWJtb2R1bGUgZXZlbnQta2V5XG4gKi9cblxudmFyIEFMVCAgICAgID0gXCIrYWx0XCIsXG4gICAgQ1RSTCAgICAgPSBcIitjdHJsXCIsXG4gICAgTUVUQSAgICAgPSBcIittZXRhXCIsXG4gICAgU0hJRlQgICAgPSBcIitzaGlmdFwiLFxuXG4gICAgdHJpbSAgICAgPSBZLkxhbmcudHJpbSxcblxuICAgIGV2ZW50RGVmID0ge1xuICAgICAgICBLRVlfTUFQOiB7XG4gICAgICAgICAgICBlbnRlciAgICA6IDEzLFxuICAgICAgICAgICAgc3BhY2UgICAgOiAzMixcbiAgICAgICAgICAgIGVzYyAgICAgIDogMjcsXG4gICAgICAgICAgICBiYWNrc3BhY2U6IDgsXG4gICAgICAgICAgICB0YWIgICAgICA6IDksXG4gICAgICAgICAgICBwYWdldXAgICA6IDMzLFxuICAgICAgICAgICAgcGFnZWRvd24gOiAzNFxuICAgICAgICB9LFxuXG4gICAgICAgIF90eXBlUkU6IC9eKHVwfGRvd258cHJlc3MpOi8sXG4gICAgICAgIF9rZXlzUkU6IC9eKD86dXB8ZG93bnxwcmVzcyk6fFxcKyhhbHR8Y3RybHxtZXRhfHNoaWZ0KS9nLFxuXG4gICAgICAgIHByb2Nlc3NBcmdzOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgdmFyIHNwZWMgPSBhcmdzLnNwbGljZSgzLDEpWzBdLFxuICAgICAgICAgICAgICAgIG1vZHMgPSBZLkFycmF5Lmhhc2goc3BlYy5tYXRjaCgvXFwrKD86YWx0fGN0cmx8bWV0YXxzaGlmdClcXGIvZykgfHwgW10pLFxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5fdHlwZVJFLnRlc3Qoc3BlYykgPyBSZWdFeHAuJDEgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtb2RzOiBtb2RzLFxuICAgICAgICAgICAgICAgICAgICBrZXlzOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCB0eXBlIGFuZCBtb2RpZmllcnMgZnJvbSBzcGVjLCBsZWF2aW5nIG9ubHkga2V5Q29kZXNcbiAgICAgICAgICAgICAgICBiaXRzID0gc3BlYy5yZXBsYWNlKHRoaXMuX2tleXNSRSwgJycpLFxuICAgICAgICAgICAgICAgIGNociwgdWMsIGxjLCBpO1xuXG4gICAgICAgICAgICBpZiAoYml0cykge1xuICAgICAgICAgICAgICAgIGJpdHMgPSBiaXRzLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICAgICAgICBjb25maWcua2V5cyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IG5lZWQgdG8gc3VwcG9ydCAnNjUsZXNjJyA9PiBrZXlwcmVzcywga2V5ZG93blxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGJpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hyID0gdHJpbShiaXRzW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjYXRjaCBzbG9wcHkgZmlsdGVycywgdHJhaWxpbmcgY29tbWFzLCBldGMgJ2EsLCdcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm9uLW51bWVyaWNzIGFyZSBzaW5nbGUgY2hhcmFjdGVycyBvciBrZXkgbmFtZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjaHIgPT0gY2hyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcua2V5c1tjaHJdID0gbW9kcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxjID0gY2hyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLktFWV9NQVBbbGNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmtleXNbdGhpcy5LRVlfTUFQW2xjXV0gPSBtb2RzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiAnNjUsZW50ZXInIGRlZmF1bHRzIGtleWRvd24gZm9yIGJvdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy50eXBlID0gXCJkb3duXCI7IC8vIHNhZmVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IENoYXJhY3RlciBtYXBwaW5nIG9ubHkgd29ya3MgZm9yIGtleXByZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnRzLiBPdGhlcndpc2UsIGl0IHVzZXMgU3RyaW5nLmZyb21DaGFyQ29kZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUga2V5Q29kZSwgd2hpY2ggaXMgd3JvbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyID0gY2hyLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1YyAgPSBjaHIudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RzW1wiK3NoaWZ0XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNociA9IHVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBzdHVwaWQgYXNzdW1wdGlvbiB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGtleWNvZGUgb2YgdGhlIGxvd2VyIGNhc2UgPT0gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhckNvZGUgb2YgdGhlIHVwcGVyIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIChrZXk6NjUsY2hhcjo5NyksIEEgKGtleTo2NSxjaGFyOjY1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5rZXlzW2Noci5jaGFyQ29kZUF0KDApXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaHIgPT09IHVjKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1cHBlciBjYXNlIGNoYXJzIGdldCArc2hpZnQgZnJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWS5tZXJnZShtb2RzLCB7IFwiK3NoaWZ0XCI6IHRydWUgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjb25maWcudHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy50eXBlID0gXCJwcmVzc1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uOiBmdW5jdGlvbiAobm9kZSwgc3ViLCBub3RpZmllciwgZmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIgc3BlYyAgID0gc3ViLl9leHRyYSxcbiAgICAgICAgICAgICAgICB0eXBlICAgPSBcImtleVwiICsgc3BlYy50eXBlLFxuICAgICAgICAgICAgICAgIGtleXMgICA9IHNwZWMua2V5cyxcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAoZmlsdGVyKSA/IFwiZGVsZWdhdGVcIiA6IFwib25cIjtcblxuICAgICAgICAgICAgLy8gTm90ZTogd2l0aG91dCBzcGVjaWZ5aW5nIGFueSBrZXlDb2RlcywgdGhpcyBiZWNvbWVzIGFcbiAgICAgICAgICAgIC8vIGhvcnJpYmx5IGluZWZmaWNpZW50IGFsaWFzIGZvciAna2V5ZG93bicgKGV0IGFsKSwgYnV0IElcbiAgICAgICAgICAgIC8vIGNhbid0IGFib3J0IHRoaXMgc3Vic2NyaXB0aW9uIGZvciBhIHNpbXBsZVxuICAgICAgICAgICAgLy8gWS5vbigna2V5cHJlc3MnLCAuLi4pO1xuICAgICAgICAgICAgLy8gUGxlYXNlIHVzZSBrZXlDb2RlcyBvciBqdXN0IHN1YnNjcmliZSBkaXJlY3RseSB0byBrZXlkb3duLFxuICAgICAgICAgICAgLy8ga2V5dXAsIG9yIGtleXByZXNzXG4gICAgICAgICAgICBzdWIuX2RldGFjaCA9IG5vZGVbbWV0aG9kXSh0eXBlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzID8ga2V5c1tlLndoaWNoXSA6IHNwZWMubW9kcztcblxuICAgICAgICAgICAgICAgIGlmIChrZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFrZXlbQUxUXSAgIHx8IChrZXlbQUxUXSAgICYmIGUuYWx0S2V5KSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFrZXlbQ1RSTF0gIHx8IChrZXlbQ1RSTF0gICYmIGUuY3RybEtleSkpICYmXG4gICAgICAgICAgICAgICAgICAgICgha2V5W01FVEFdICB8fCAoa2V5W01FVEFdICAmJiBlLm1ldGFLZXkpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWtleVtTSElGVF0gfHwgKGtleVtTSElGVF0gJiYgZS5zaGlmdEtleSkpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpZXIuZmlyZShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmaWx0ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaDogZnVuY3Rpb24gKG5vZGUsIHN1Yiwgbm90aWZpZXIpIHtcbiAgICAgICAgICAgIHN1Yi5fZGV0YWNoLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuZXZlbnREZWYuZGVsZWdhdGUgPSBldmVudERlZi5vbjtcbmV2ZW50RGVmLmRldGFjaERlbGVnYXRlID0gZXZlbnREZWYuZGV0YWNoO1xuXG4vKipcbiAqIDxwPkFkZCBhIGtleSBsaXN0ZW5lci4gIFRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgYmUgbm90aWZpZWQgaWYgdGhlXG4gKiBrZXlzdHJva2UgZGV0ZWN0ZWQgbWVldHMgdGhlIHN1cHBsaWVkIHNwZWNpZmljYXRpb24uICBUaGVcbiAqIHNwZWNpZmljYXRpb24gaXMgYSBzdHJpbmcgdGhhdCBpcyBkZWZpbmVkIGFzOjwvcD5cbiAqXG4gKiA8ZGw+XG4gKiAgIDxkdD5zcGVjPC9kdD5cbiAqICAgPGRkPjxjb2RlPlt7dHlwZX06XXtjb2RlfVsse2NvZGV9XSo8L2NvZGU+PC9kZD5cbiAqICAgPGR0PnR5cGU8L2R0PlxuICogICA8ZGQ+PGNvZGU+XCJkb3duXCIsIFwidXBcIiwgb3IgXCJwcmVzc1wiPC9jb2RlPjwvZGQ+XG4gKiAgIDxkdD5jb2RlPC9kdD5cbiAqICAgPGRkPjxjb2RlPntrZXlDb2RlfGNoYXJhY3RlcnxrZXlOYW1lfVsre21vZGlmaWVyfV0qPC9jb2RlPjwvZGQ+XG4gKiAgIDxkdD5tb2RpZmllcjwvZHQ+XG4gKiAgIDxkZD48Y29kZT5cInNoaWZ0XCIsIFwiY3RybFwiLCBcImFsdFwiLCBvciBcIm1ldGFcIjwvY29kZT48L2RkPlxuICogICA8ZHQ+a2V5TmFtZTwvZHQ+XG4gKiAgIDxkZD48Y29kZT5cImVudGVyXCIsIFwic3BhY2VcIiwgXCJiYWNrc3BhY2VcIiwgXCJlc2NcIiwgXCJ0YWJcIiwgXCJwYWdldXBcIiwgb3IgXCJwYWdlZG93blwiPC9jb2RlPjwvZGQ+XG4gKiA8L2RsPlxuICpcbiAqIDxwPkV4YW1wbGVzOjwvcD5cbiAqIDx1bD5cbiAqICAgPGxpPjxjb2RlPlkub24oXCJrZXlcIiwgY2FsbGJhY2ssIFwicHJlc3M6MTIsNjUrc2hpZnQrY3RybFwiLCBcIiNteS1pbnB1dFwiKTs8L2NvZGU+PC9saT5cbiAqICAgPGxpPjxjb2RlPlkuZGVsZWdhdGUoXCJrZXlcIiwgcHJldmVudFN1Ym1pdCwgXCIjZm9ybXNcIiwgXCJlbnRlclwiLCBcImlucHV0W3R5cGU9dGV4dF1cIik7PC9jb2RlPjwvbGk+XG4gKiAgIDxsaT48Y29kZT5ZLm9uZShcImRvY1wiKS5vbihcImtleVwiLCB2aU5hdiwgXCJqLGssbCw7XCIpOzwvY29kZT48L2xpPlxuICogPC91bD5cbiAqXG4gKiBAZXZlbnQga2V5XG4gKiBAZm9yIFlVSVxuICogQHBhcmFtIHR5cGUge3N0cmluZ30gJ2tleSdcbiAqIEBwYXJhbSBmbiB7ZnVuY3Rpb259IHRoZSBmdW5jdGlvbiB0byBleGVjdXRlXG4gKiBAcGFyYW0gaWQge3N0cmluZ3xIVE1MRWxlbWVudHxjb2xsZWN0aW9ufSB0aGUgZWxlbWVudChzKSB0byBiaW5kXG4gKiBAcGFyYW0gc3BlYyB7c3RyaW5nfSB0aGUga2V5Q29kZSBhbmQgbW9kaWZpZXIgc3BlY2lmaWNhdGlvblxuICogQHBhcmFtIG8gb3B0aW9uYWwgY29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSBhcmdzIDAuLm4gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHtFdmVudC5IYW5kbGV9IHRoZSBkZXRhY2ggaGFuZGxlXG4gKi9cblkuRXZlbnQuZGVmaW5lKCdrZXknLCBldmVudERlZiwgdHJ1ZSk7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImV2ZW50LXN5bnRoZXRpY1wiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdldmVudC1tb3VzZWVudGVyJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiA8cD5BZGRzIHN1YnNjcmlwdGlvbiBhbmQgZGVsZWdhdGlvbiBzdXBwb3J0IGZvciBtb3VzZWVudGVyIGFuZCBtb3VzZWxlYXZlXG4gKiBldmVudHMuICBVbmxpa2UgbW91c2VvdmVyIGFuZCBtb3VzZW91dCwgdGhlc2UgZXZlbnRzIGFyZW4ndCBmaXJlZCBmcm9tIGNoaWxkXG4gKiBlbGVtZW50cyBvZiBhIHN1YnNjcmliZWQgbm9kZS48L3A+XG4gKlxuICogPHA+VGhpcyBhdm9pZHMgcmVjZWl2aW5nIHRocmVlIG1vdXNlb3ZlciBub3RpZmljYXRpb25zIGZyb20gYSBzZXR1cCBsaWtlPC9wPlxuICpcbiAqIDxwcmU+PGNvZGU+ZGl2I2NvbnRhaW5lciA+IHAgPiBhW2hyZWZdPC9jb2RlPjwvcHJlPlxuICpcbiAqIDxwPndoZXJlPC9wPlxuICpcbiAqIDxwcmU+PGNvZGU+WS5vbmUoJyNjb250YWluZXInKS5vbignbW91c2VvdmVyJywgY2FsbGJhY2spPC9jb2RlPjwvcHJlPlxuICpcbiAqIDxwPldoZW4gdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIGxpbmssIG9uZSBtb3VzZW92ZXIgZXZlbnQgaXMgZmlyZWQgZnJvbVxuICogI2NvbnRhaW5lciwgdGhlbiB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBwLCBhbm90aGVyIG1vdXNlb3ZlciBldmVudCBpc1xuICogZmlyZWQgYW5kIGJ1YmJsZXMgdG8gI2NvbnRhaW5lciwgY2F1c2luZyBhIHNlY29uZCBub3RpZmljYXRpb24sIGFuZCBmaW5hbGx5XG4gKiB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBsaW5rLCBhIHRoaXJkIG1vdXNlb3ZlciBldmVudCBpcyBmaXJlZCBhbmRcbiAqIGJ1YmJsZXMgdG8gI2NvbnRhaW5lciBmb3IgYSB0aGlyZCBub3RpZmljYXRpb24uPC9wPlxuICpcbiAqIDxwPkJ5IGNvbnRyYXN0LCB1c2luZyBtb3VzZWVudGVyIGluc3RlYWQgb2YgbW91c2VvdmVyLCB0aGUgY2FsbGJhY2sgd291bGQgYmVcbiAqIGV4ZWN1dGVkIG9ubHkgb25jZSB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBvdmVyICNjb250YWluZXIuPC9wPlxuICpcbiAqIEBtb2R1bGUgZXZlbnRcbiAqIEBzdWJtb2R1bGUgZXZlbnQtbW91c2VlbnRlclxuICovXG5cbnZhciBkb21FdmVudFByb3hpZXMgPSBZLkVudi5ldnQuZG9tX3dyYXBwZXJzLFxuICAgIGNvbnRhaW5zID0gWS5ET00uY29udGFpbnMsXG4gICAgdG9BcnJheSA9IFkuQXJyYXksXG4gICAgbm9vcCA9IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgY29uZmlnID0ge1xuICAgICAgICBwcm94eVR5cGU6IFwibW91c2VvdmVyXCIsXG4gICAgICAgIHJlbFByb3BlcnR5OiBcImZyb21FbGVtZW50XCIsXG5cbiAgICAgICAgX25vdGlmeTogZnVuY3Rpb24gKGUsIHByb3BlcnR5LCBub3RpZmllcikge1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5fbm9kZSxcbiAgICAgICAgICAgICAgICByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0IHx8IGVbcHJvcGVydHldO1xuXG4gICAgICAgICAgICBpZiAoZWwgIT09IHJlbGF0ZWQgJiYgIWNvbnRhaW5zKGVsLCByZWxhdGVkKSkge1xuICAgICAgICAgICAgICAgIG5vdGlmaWVyLmZpcmUobmV3IFkuRE9NRXZlbnRGYWNhZGUoZSwgZWwsXG4gICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50UHJveGllc1snZXZlbnQ6JyArIFkuc3RhbXAoZWwpICsgZS50eXBlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uOiBmdW5jdGlvbiAobm9kZSwgc3ViLCBub3RpZmllcikge1xuICAgICAgICAgICAgdmFyIGVsID0gWS5Ob2RlLmdldERPTU5vZGUobm9kZSksXG4gICAgICAgICAgICAgICAgYXJncyA9IFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm94eVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeSxcbiAgICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWVyXTtcblxuICAgICAgICAgICAgc3ViLmhhbmRsZSA9IFkuRXZlbnQuX2F0dGFjaChhcmdzLCB7IGZhY2FkZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAvLyBub2RlLm9uKHRoaXMucHJveHlUeXBlLCBub3RpZnksIG51bGwsIG5vdGlmaWVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uIChub2RlLCBzdWIpIHtcbiAgICAgICAgICAgIHN1Yi5oYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uIChub2RlLCBzdWIsIG5vdGlmaWVyLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IFkuTm9kZS5nZXRET01Ob2RlKG5vZGUpLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJveHlUeXBlLFxuICAgICAgICAgICAgICAgICAgICBub29wLFxuICAgICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpZXJcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBzdWIuaGFuZGxlID0gWS5FdmVudC5fYXR0YWNoKGFyZ3MsIHsgZmFjYWRlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHN1Yi5oYW5kbGUuc3ViLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgICAgIHN1Yi5oYW5kbGUuc3ViLnJlbFByb3BlcnR5ID0gdGhpcy5yZWxQcm9wZXJ0eTtcbiAgICAgICAgICAgIHN1Yi5oYW5kbGUuc3ViLl9ub3RpZnkgPSB0aGlzLl9maWx0ZXJOb3RpZnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2ZpbHRlck5vdGlmeTogZnVuY3Rpb24gKHRoaXNPYmosIGFyZ3MsIGNlKSB7XG4gICAgICAgICAgICBhcmdzID0gYXJncy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJncykge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCB0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudFRhcmdldCA9IFkuZGVsZWdhdGUuX2FwcGx5RmlsdGVyKHRoaXMuZmlsdGVyLCBhcmdzLCBjZSksXG4gICAgICAgICAgICAgICAgcmVsYXRlZCA9IGFyZ3NbMF0ucmVsYXRlZFRhcmdldCB8fCBhcmdzWzBdW3RoaXMucmVsUHJvcGVydHldLFxuICAgICAgICAgICAgICAgIGUsIGksIGxlbiwgcmV0LCBjdDtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gdG9BcnJheShjdXJyZW50VGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGN1cnJlbnRUYXJnZXQubGVuZ3RoICYmICghZSB8fCAhZS5zdG9wcGVkKTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0ID0gY3VycmVudFRhcmdldFswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWlucyhjdCwgcmVsYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgWS5ET01FdmVudEZhY2FkZShhcmdzWzBdLCBjdCwgY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY29udGFpbmVyID0gWS5vbmUoY2UuZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gWS5vbmUoY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aGVyZSBpcyBub3RpZmllcj8gYXJncz8gdGhpcy5ub3RpZmllcj9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGFyZ3NbMV0uZmlyZShlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hEZWxlZ2F0ZTogZnVuY3Rpb24gKG5vZGUsIHN1Yikge1xuICAgICAgICAgICAgc3ViLmhhbmRsZS5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgIH07XG5cblkuRXZlbnQuZGVmaW5lKFwibW91c2VlbnRlclwiLCBjb25maWcsIHRydWUpO1xuWS5FdmVudC5kZWZpbmUoXCJtb3VzZWxlYXZlXCIsIFkubWVyZ2UoY29uZmlnLCB7XG4gICAgcHJveHlUeXBlOiBcIm1vdXNlb3V0XCIsXG4gICAgcmVsUHJvcGVydHk6IFwidG9FbGVtZW50XCJcbn0pLCB0cnVlKTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiZXZlbnQtc3ludGhldGljXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2V2ZW50LW1vdXNld2hlZWwnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIEFkZHMgbW91c2V3aGVlbCBldmVudCBzdXBwb3J0XG4gKiBAbW9kdWxlIGV2ZW50XG4gKiBAc3VibW9kdWxlIGV2ZW50LW1vdXNld2hlZWxcbiAqL1xudmFyIERPTV9NT1VTRV9TQ1JPTEwgPSAnRE9NTW91c2VTY3JvbGwnLFxuICAgIGZpeEFyZ3MgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBhID0gWS5BcnJheShhcmdzLCAwLCB0cnVlKSwgdGFyZ2V0O1xuICAgICAgICBpZiAoWS5VQS5nZWNrbykge1xuICAgICAgICAgICAgYVswXSA9IERPTV9NT1VTRV9TQ1JPTEw7XG4gICAgICAgICAgICB0YXJnZXQgPSBZLmNvbmZpZy53aW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBZLmNvbmZpZy5kb2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYS5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICBhWzJdID0gdGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYS5zcGxpY2UoMiwgMCwgdGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbi8qKlxuICogTW91c2V3aGVlbCBldmVudC4gIFRoaXMgbGlzdGVuZXIgaXMgYXV0b21hdGljYWxseSBhdHRhY2hlZCB0byB0aGVcbiAqIGNvcnJlY3QgdGFyZ2V0LCBzbyBvbmUgc2hvdWxkIG5vdCBiZSBzdXBwbGllZC4gIE1vdXNlIHdoZWVsXG4gKiBkaXJlY3Rpb24gYW5kIHZlbG9jaXR5IGlzIHN0b3JlZCBpbiB0aGUgJ3doZWVsRGVsdGEnIGZpZWxkLlxuICogQGV2ZW50IG1vdXNld2hlZWxcbiAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9ICdtb3VzZXdoZWVsJ1xuICogQHBhcmFtIGZuIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSBjb250ZXh0IG9wdGlvbmFsIGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gYXJncyAwLi5uIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gdGhlIGxpc3RlbmVyLlxuICogQHJldHVybiB7RXZlbnRIYW5kbGV9IHRoZSBkZXRhY2ggaGFuZGxlXG4gKiBAZm9yIFlVSVxuICovXG5ZLkVudi5ldnQucGx1Z2lucy5tb3VzZXdoZWVsID0ge1xuICAgIG9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFkuRXZlbnQuX2F0dGFjaChmaXhBcmdzKGFyZ3VtZW50cykpO1xuICAgIH0sXG5cbiAgICBkZXRhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gWS5FdmVudC5kZXRhY2guYXBwbHkoWS5FdmVudCwgZml4QXJncyhhcmd1bWVudHMpKTtcbiAgICB9XG59O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJub2RlLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnZXZlbnQtbW92ZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogQWRkcyBsb3dlciBsZXZlbCBzdXBwb3J0IGZvciBcImdlc3R1cmVtb3Zlc3RhcnRcIiwgXCJnZXN0dXJlbW92ZVwiIGFuZCBcImdlc3R1cmVtb3ZlZW5kXCIgZXZlbnRzLCB3aGljaCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgZHJhZy9kcm9wXG4gKiBpbnRlcmFjdGlvbnMgd2hpY2ggd29yayBhY3Jvc3MgdG91Y2ggYW5kIG1vdXNlIGlucHV0IGRldmljZXMuIFRoZXkgY29ycmVzcG9uZCB0byBcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaG1vdmVcIiBhbmQgXCJ0b3VjaGVuZFwiIG9uIGEgdG91Y2ggaW5wdXRcbiAqIGRldmljZSwgYW5kIFwibW91c2Vkb3duXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2V1cFwiIG9uIGEgbW91c2UgYmFzZWQgaW5wdXQgZGV2aWNlLlxuICpcbiAqIDxwPkRvY3VtZW50YXRpb24gZm9yIHRoZSBnZXN0dXJlbW92ZSB0cmlwbGV0IG9mIGV2ZW50cyBjYW4gYmUgZm91bmQgb24gdGhlIDxhIGhyZWY9XCIuLi9jbGFzc2VzL1lVSS5odG1sI2V2ZW50X2dlc3R1cmVtb3ZlXCI+WVVJPC9hPiBnbG9iYWwsXG4gKiBhbG9uZyB3aXRoIHRoZSBvdGhlciBzdXBwb3J0ZWQgZXZlbnRzLjwvcD5cblxuIEBleGFtcGxlXG5cbiAgICAgWVVJKCkudXNlKCdldmVudC1tb3ZlJywgZnVuY3Rpb24gKFkpIHtcbiAgICAgICAgIFkub25lKCcjbXlOb2RlJykub24oJ2dlc3R1cmVtb3Zlc3RhcnQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgfSk7XG4gICAgICAgICBZLm9uZSgnI215Tm9kZScpLm9uKCdnZXN0dXJlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICB9KTtcbiAgICAgICAgIFkub25lKCcjbXlOb2RlJykub24oJ2dlc3R1cmVtb3ZlZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgIH0pO1xuICAgICB9KTtcblxuICogQG1vZHVsZSBldmVudC1nZXN0dXJlc1xuICogQHN1Ym1vZHVsZSBldmVudC1tb3ZlXG4gKi9cblxuXG4gdmFyIEdFU1RVUkVfTUFQID0gWS5FdmVudC5fR0VTVFVSRV9NQVAsXG4gICAgIEVWRU5UID0ge1xuICAgICAgICAgc3RhcnQ6IEdFU1RVUkVfTUFQLnN0YXJ0LFxuICAgICAgICAgZW5kOiBHRVNUVVJFX01BUC5lbmQsXG4gICAgICAgICBtb3ZlOiBHRVNUVVJFX01BUC5tb3ZlXG4gICAgIH0sXG4gICAgU1RBUlQgPSBcInN0YXJ0XCIsXG4gICAgTU9WRSA9IFwibW92ZVwiLFxuICAgIEVORCA9IFwiZW5kXCIsXG5cbiAgICBHRVNUVVJFX01PVkUgPSBcImdlc3R1cmVcIiArIE1PVkUsXG4gICAgR0VTVFVSRV9NT1ZFX0VORCA9IEdFU1RVUkVfTU9WRSArIEVORCxcbiAgICBHRVNUVVJFX01PVkVfU1RBUlQgPSBHRVNUVVJFX01PVkUgKyBTVEFSVCxcblxuICAgIF9NT1ZFX1NUQVJUX0hBTkRMRSA9IFwiX21zaFwiLFxuICAgIF9NT1ZFX0hBTkRMRSA9IFwiX21oXCIsXG4gICAgX01PVkVfRU5EX0hBTkRMRSA9IFwiX21laFwiLFxuXG4gICAgX0RFTF9NT1ZFX1NUQVJUX0hBTkRMRSA9IFwiX2Rtc2hcIixcbiAgICBfREVMX01PVkVfSEFORExFID0gXCJfZG1oXCIsXG4gICAgX0RFTF9NT1ZFX0VORF9IQU5ETEUgPSBcIl9kbWVoXCIsXG5cbiAgICBfTU9WRV9TVEFSVCA9IFwiX21zXCIsXG4gICAgX01PVkUgPSBcIl9tXCIsXG5cbiAgICBNSU5fVElNRSA9IFwibWluVGltZVwiLFxuICAgIE1JTl9ESVNUQU5DRSA9IFwibWluRGlzdGFuY2VcIixcbiAgICBQUkVWRU5UX0RFRkFVTFQgPSBcInByZXZlbnREZWZhdWx0XCIsXG4gICAgQlVUVE9OID0gXCJidXR0b25cIixcbiAgICBPV05FUl9ET0NVTUVOVCA9IFwib3duZXJEb2N1bWVudFwiLFxuXG4gICAgQ1VSUkVOVF9UQVJHRVQgPSBcImN1cnJlbnRUYXJnZXRcIixcbiAgICBUQVJHRVQgPSBcInRhcmdldFwiLFxuXG4gICAgTk9ERV9UWVBFID0gXCJub2RlVHlwZVwiLFxuICAgIFNVUFBPUlRTX1BPSU5URVIgPSBZLmNvbmZpZy53aW4gJiYgKFwibXNQb2ludGVyRW5hYmxlZFwiIGluIFkuY29uZmlnLndpbi5uYXZpZ2F0b3IpLFxuICAgIE1TX1RPVUNIX0FDVElPTl9DT1VOVCA9ICdtc1RvdWNoQWN0aW9uQ291bnQnLFxuICAgIE1TX0lOSVRfVE9VQ0hfQUNUSU9OID0gJ21zSW5pdFRvdWNoQWN0aW9uJyxcblxuICAgIF9kZWZBcmdzUHJvY2Vzc29yID0gZnVuY3Rpb24oc2UsIGFyZ3MsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBpQ29uZmlnID0gKGRlbGVnYXRlKSA/IDQgOiAzLFxuICAgICAgICAgICAgY29uZmlnID0gKGFyZ3MubGVuZ3RoID4gaUNvbmZpZykgPyBZLm1lcmdlKGFyZ3Muc3BsaWNlKGlDb25maWcsMSlbMF0pIDoge307XG5cbiAgICAgICAgaWYgKCEoUFJFVkVOVF9ERUZBVUxUIGluIGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZ1tQUkVWRU5UX0RFRkFVTFRdID0gc2UuUFJFVkVOVF9ERUZBVUxUO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9LFxuXG4gICAgX2dldFJvb3QgPSBmdW5jdGlvbihub2RlLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyLl9leHRyYS5yb290IHx8IChub2RlLmdldChOT0RFX1RZUEUpID09PSA5KSA/IG5vZGUgOiBub2RlLmdldChPV05FUl9ET0NVTUVOVCk7XG4gICAgfSxcblxuICAgIC8vQ2hlY2tzIHRvIHNlZSBpZiB0aGUgbm9kZSBpcyB0aGUgZG9jdW1lbnQsIGFuZCBpZiBpdCBpcywgcmV0dXJucyB0aGUgZG9jdW1lbnRFbGVtZW50LlxuICAgIF9jaGVja0RvY3VtZW50RWxlbSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGVsZW0gPSBub2RlLmdldERPTU5vZGUoKTtcbiAgICAgICAgaWYgKG5vZGUuY29tcGFyZVRvKFkuY29uZmlnLmRvYykgJiYgZWxlbS5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfbm9ybVRvdWNoRmFjYWRlID0gZnVuY3Rpb24odG91Y2hGYWNhZGUsIHRvdWNoLCBwYXJhbXMpIHtcbiAgICAgICAgdG91Y2hGYWNhZGUucGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgICAgICAgdG91Y2hGYWNhZGUucGFnZVkgPSB0b3VjaC5wYWdlWTtcbiAgICAgICAgdG91Y2hGYWNhZGUuc2NyZWVuWCA9IHRvdWNoLnNjcmVlblg7XG4gICAgICAgIHRvdWNoRmFjYWRlLnNjcmVlblkgPSB0b3VjaC5zY3JlZW5ZO1xuICAgICAgICB0b3VjaEZhY2FkZS5jbGllbnRYID0gdG91Y2guY2xpZW50WDtcbiAgICAgICAgdG91Y2hGYWNhZGUuY2xpZW50WSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICAgIHRvdWNoRmFjYWRlW1RBUkdFVF0gPSB0b3VjaEZhY2FkZVtUQVJHRVRdIHx8IHRvdWNoW1RBUkdFVF07XG4gICAgICAgIHRvdWNoRmFjYWRlW0NVUlJFTlRfVEFSR0VUXSA9IHRvdWNoRmFjYWRlW0NVUlJFTlRfVEFSR0VUXSB8fCB0b3VjaFtDVVJSRU5UX1RBUkdFVF07XG5cbiAgICAgICAgdG91Y2hGYWNhZGVbQlVUVE9OXSA9IChwYXJhbXMgJiYgcGFyYW1zW0JVVFRPTl0pIHx8IDE7IC8vIGRlZmF1bHQgdG8gbGVmdCAobGVmdCBhcyBwZXIgdmVuZG9ycywgbm90IFczQyB3aGljaCBpcyAwKVxuICAgIH0sXG5cbiAgICAvKlxuICAgIEluIElFMTAgdG91Y2ggbW9kZSwgZ2VzdHVyZXMgd2lsbCBub3Qgd29yayBwcm9wZXJseSB1bmxlc3MgdGhlIC1tcy10b3VjaC1hY3Rpb24gQ1NTIHByb3BlcnR5IGlzIHNldCB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiAnYXV0bycuIFJlYWQgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvYXBwcy9oaDc2NzMxMy5hc3B4IGZvciBtb3JlIGluZm8uIFRvIGdldCBhcm91bmQgdGhpcywgd2Ugc2V0IC1tcy10b3VjaC1hY3Rpb246IG5vbmUgd2hpY2ggaXMgdGhlIHNhbWUgYXMgZS5wcmV2ZW50RGVmYXVsdCgpIG9uIHRvdWNoIGVudmlyb25tZW50cy4gVGhpcyB0ZWxscyB0aGUgYnJvd3NlciB0byBmaXJlIERPTSBldmVudHMgZm9yIGFsbCB0b3VjaCBldmVudHMsIGFuZCBub3QgcGVyZm9ybSBhbnkgZGVmYXVsdCBiZWhhdmlvci5cblxuICAgIFRoZSB1c2VyIGNhbiBvdmVyLXJpZGUgdGhpcyBieSBzZXR0aW5nIGEgbW9yZSBsZW5pZW50IC1tcy10b3VjaC1hY3Rpb24gcHJvcGVydHkgb24gYSBub2RlIChzdWNoIGFzIHBhbi14LCBwYW4teSwgZXRjLikgdmlhIENTUyB3aGVuIHN1YnNjcmliaW5nIHRvIHRoZSAnZ2VzdHVyZW1vdmVzdGFydCcgZXZlbnQuXG4gICAgKi9cbiAgICBfc2V0VG91Y2hBY3Rpb25zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGVsZW0gPSBfY2hlY2tEb2N1bWVudEVsZW0obm9kZSkgfHwgbm9kZS5nZXRET01Ob2RlKCksXG4gICAgICAgICAgICBudW0gPSBub2RlLmdldERhdGEoTVNfVE9VQ0hfQUNUSU9OX0NPVU5UKTtcblxuICAgICAgICAvL0NoZWNrcyB0byBzZWUgaWYgbXNUb3VjaEFjdGlvbiBpcyBzdXBwb3J0ZWQuXG4gICAgICAgIGlmIChTVVBQT1JUU19QT0lOVEVSKSB7XG4gICAgICAgICAgICBpZiAoIW51bSkge1xuICAgICAgICAgICAgICAgIG51bSA9IDA7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXREYXRhKE1TX0lOSVRfVE9VQ0hfQUNUSU9OLCBlbGVtLnN0eWxlLm1zVG91Y2hBY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbS5zdHlsZS5tc1RvdWNoQWN0aW9uID0gWS5FdmVudC5fREVGQVVMVF9UT1VDSF9BQ1RJT047XG4gICAgICAgICAgICBudW0rKztcbiAgICAgICAgICAgIG5vZGUuc2V0RGF0YShNU19UT1VDSF9BQ1RJT05fQ09VTlQsIG51bSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLypcbiAgICBSZXNldHMgdGhlIGVsZW1lbnQncyAtbXMtdG91Y2gtYWN0aW9uIHByb3BlcnR5IGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlLCBUaGlzIGlzIGNhbGxlZCBvbiBkZXRhY2goKSBhbmQgZGV0YWNoRGVsZWdhdGUoKS5cbiAgICAqL1xuICAgIF91bnNldFRvdWNoQWN0aW9ucyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBlbGVtID0gX2NoZWNrRG9jdW1lbnRFbGVtKG5vZGUpIHx8IG5vZGUuZ2V0RE9NTm9kZSgpLFxuICAgICAgICAgICAgbnVtID0gbm9kZS5nZXREYXRhKE1TX1RPVUNIX0FDVElPTl9DT1VOVCksXG4gICAgICAgICAgICBpbml0VG91Y2hBY3Rpb24gPSBub2RlLmdldERhdGEoTVNfSU5JVF9UT1VDSF9BQ1RJT04pO1xuXG4gICAgICAgIGlmIChTVVBQT1JUU19QT0lOVEVSKSB7XG4gICAgICAgICAgICBudW0tLTtcbiAgICAgICAgICAgIG5vZGUuc2V0RGF0YShNU19UT1VDSF9BQ1RJT05fQ09VTlQsIG51bSk7XG4gICAgICAgICAgICBpZiAobnVtID09PSAwICYmIGVsZW0uc3R5bGUubXNUb3VjaEFjdGlvbiAhPT0gaW5pdFRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5tc1RvdWNoQWN0aW9uID0gaW5pdFRvdWNoQWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wcmV2ZW50ID0gZnVuY3Rpb24oZSwgcHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAvLyBwcmV2ZW50RGVmYXVsdCBpcyBhIGJvb2xlYW4gb3IgYSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFwcmV2ZW50RGVmYXVsdC5jYWxsIHx8IHByZXZlbnREZWZhdWx0KGUpKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRlZmluZSA9IFkuRXZlbnQuZGVmaW5lO1xuICAgIFkuRXZlbnQuX0RFRkFVTFRfVE9VQ0hfQUNUSU9OID0gJ25vbmUnO1xuXG4vKipcbiAqIFNldHMgdXAgYSBcImdlc3R1cmVtb3Zlc3RhcnRcIiBldmVudCwgdGhhdCBpcyBmaXJlZCBvbiB0b3VjaCBkZXZpY2VzIGluIHJlc3BvbnNlIHRvIGEgc2luZ2xlIGZpbmdlciBcInRvdWNoc3RhcnRcIixcbiAqIGFuZCBvbiBtb3VzZSBiYXNlZCBkZXZpY2VzIGluIHJlc3BvbnNlIHRvIGEgXCJtb3VzZWRvd25cIi4gVGhlIHN1YnNjcmliZXIgY2FuIHNwZWNpZnkgdGhlIG1pbmltdW0gdGltZVxuICogYW5kIGRpc3RhbmNlIHRocmVzaG9sZHMgd2hpY2ggc2hvdWxkIGJlIGNyb3NzZWQgYmVmb3JlIHRoZSBcImdlc3R1cmVtb3Zlc3RhcnRcIiBpcyBmaXJlZCBhbmQgZm9yIHRoZSBtb3VzZSxcbiAqIHdoaWNoIGJ1dHRvbiBzaG91bGQgaW5pdGlhdGUgYSBcImdlc3R1cmVtb3Zlc3RhcnRcIi4gVGhpcyBldmVudCBjYW4gYWxzbyBiZSBsaXN0ZW5lZCBmb3IgdXNpbmcgbm9kZS5kZWxlZ2F0ZSgpLlxuICpcbiAqIDxwPkl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSBZLmJpbmQgdG8gc2V0IHVwIGNvbnRleHQgYW5kIGFkZGl0aW9uYWwgYXJndW1lbnRzIGZvciB5b3VyIGV2ZW50IGhhbmRsZXIsXG4gKiBob3dldmVyIGlmIHlvdSB3YW50IHRvIHBhc3MgdGhlIGNvbnRleHQgYW5kIGFyZ3VtZW50cyBhcyBhZGRpdGlvbmFsIHNpZ25hdHVyZSBhcmd1bWVudHMgdG8gb24vZGVsZWdhdGUsXG4gKiB5b3UgbmVlZCB0byBwcm92aWRlIGEgbnVsbCB2YWx1ZSBmb3IgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBlLmc6IDxjb2RlPm5vZGUub24oXCJnZXN0dXJlbW92ZXN0YXJ0XCIsIGZuLCBudWxsLCBjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczKTwvY29kZT48L3A+XG4gKlxuICogQGV2ZW50IGdlc3R1cmVtb3Zlc3RhcnRcbiAqIEBmb3IgWVVJXG4gKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSBcImdlc3R1cmVtb3Zlc3RhcnRcIlxuICogQHBhcmFtIGZuIHtmdW5jdGlvbn0gVGhlIG1ldGhvZCB0aGUgZXZlbnQgaW52b2tlcy4gSXQgcmVjZWl2ZXMgdGhlIGV2ZW50IGZhY2FkZSBvZiB0aGUgdW5kZXJseWluZyBET00gZXZlbnQgKG1vdXNlZG93biBvciB0b3VjaHN0YXJ0LnRvdWNoZXNbMF0pIHdoaWNoIGNvbnRhaW5zIHBvc2l0aW9uIGNvLW9yZGluYXRlcy5cbiAqIEBwYXJhbSBjZmcge09iamVjdH0gT3B0aW9uYWwuIEFuIG9iamVjdCB3aGljaCBzcGVjaWZpZXM6XG4gKlxuICogPGRsPlxuICogPGR0Pm1pbkRpc3RhbmNlIChkZWZhdWx0cyB0byAwKTwvZHQ+XG4gKiA8ZGQ+VGhlIG1pbmltdW0gZGlzdGFuY2UgdGhyZXNob2xkIHdoaWNoIHNob3VsZCBiZSBjcm9zc2VkIGJlZm9yZSB0aGUgZ2VzdHVyZW1vdmVzdGFydCBpcyBmaXJlZDwvZGQ+XG4gKiA8ZHQ+bWluVGltZSAoZGVmYXVsdHMgdG8gMCk8L2R0PlxuICogPGRkPlRoZSBtaW5pbXVtIHRpbWUgdGhyZXNob2xkIGZvciB3aGljaCB0aGUgZmluZ2VyL21vdXNlIHNob3VsZCBiZSBoZWxwIGRvd24gYmVmb3JlIHRoZSBnZXN0dXJlbW92ZXN0YXJ0IGlzIGZpcmVkPC9kZD5cbiAqIDxkdD5idXR0b24gKG5vIGRlZmF1bHQpPC9kdD5cbiAqIDxkZD5JbiB0aGUgY2FzZSBvZiBhIG1vdXNlIGlucHV0IGRldmljZSwgaWYgdGhlIGV2ZW50IHNob3VsZCBvbmx5IGJlIGZpcmVkIGZvciBhIHNwZWNpZmljIG1vdXNlIGJ1dHRvbi48L2RkPlxuICogPGR0PnByZXZlbnREZWZhdWx0IChkZWZhdWx0cyB0byBmYWxzZSk8L2R0PlxuICogPGRkPkNhbiBiZSBzZXQgdG8gdHJ1ZS9mYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3IgYXMgc29vbiBhcyB0aGUgdG91Y2hzdGFydCBvciBtb3VzZWRvd24gaXMgcmVjZWl2ZWQgKHRoYXQgaXMgYmVmb3JlIG1pblRpbWUgb3IgbWluRGlzdGFuY2UgdGhyZXNob2xkcyBhcmUgY3Jvc3NlZCwgYW5kIHNvIGJlZm9yZSB0aGUgZ2VzdHVyZW1vdmVzdGFydCBsaXN0ZW5lciBpcyBub3RpZmllZCkgc28gdGhhdCB0aGluZ3MgbGlrZSB0ZXh0IHNlbGVjdGlvbiBhbmQgY29udGV4dCBwb3B1cHMgKG9uIHRvdWNoIGRldmljZXMpIGNhbiBiZVxuICogcHJldmVudGVkLiBUaGlzIHByb3BlcnR5IGNhbiBhbHNvIGJlIHNldCB0byBhIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIHRydWUgb3IgZmFsc2UsIGJhc2VkIG9uIHRoZSBldmVudCBmYWNhZGUgcGFzc2VkIHRvIGl0IChmb3IgZXhhbXBsZSwgRHJhZ0Ryb3AgY2FuIGRldGVybWluZSBpZiB0aGUgdGFyZ2V0IGlzIGEgdmFsaWQgaGFuZGxlIG9yIG5vdCBiZWZvcmUgcHJldmVudGluZyBkZWZhdWx0KS48L2RkPlxuICogPC9kbD5cbiAqXG4gKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gdGhlIGRldGFjaCBoYW5kbGVcbiAqL1xuXG5kZWZpbmUoR0VTVFVSRV9NT1ZFX1NUQVJULCB7XG5cbiAgICBvbjogZnVuY3Rpb24gKG5vZGUsIHN1YnNjcmliZXIsIGNlKSB7XG5cbiAgICAgICAgLy9TZXQgLW1zLXRvdWNoLWFjdGlvbiBvbiBJRTEwIGFuZCBzZXQgcHJldmVudERlZmF1bHQgdG8gdHJ1ZVxuICAgICAgICBfc2V0VG91Y2hBY3Rpb25zKG5vZGUpO1xuXG4gICAgICAgIHN1YnNjcmliZXJbX01PVkVfU1RBUlRfSEFORExFXSA9IG5vZGUub24oRVZFTlRbU1RBUlRdLFxuICAgICAgICAgICAgdGhpcy5fb25TdGFydCxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgICAgIGNlKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGUgOiBmdW5jdGlvbihub2RlLCBzdWJzY3JpYmVyLCBjZSwgZmlsdGVyKSB7XG5cbiAgICAgICAgdmFyIHNlID0gdGhpcztcblxuICAgICAgICBzdWJzY3JpYmVyW19ERUxfTU9WRV9TVEFSVF9IQU5ETEVdID0gbm9kZS5kZWxlZ2F0ZShFVkVOVFtTVEFSVF0sXG4gICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc2UuX29uU3RhcnQoZSwgbm9kZSwgc3Vic2NyaWJlciwgY2UsIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlcik7XG4gICAgfSxcblxuICAgIGRldGFjaERlbGVnYXRlIDogZnVuY3Rpb24obm9kZSwgc3Vic2NyaWJlciwgY2UsIGZpbHRlcikge1xuICAgICAgICB2YXIgaGFuZGxlID0gc3Vic2NyaWJlcltfREVMX01PVkVfU1RBUlRfSEFORExFXTtcblxuICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICBoYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgICAgICBzdWJzY3JpYmVyW19ERUxfTU9WRV9TVEFSVF9IQU5ETEVdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIF91bnNldFRvdWNoQWN0aW9ucyhub2RlKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoOiBmdW5jdGlvbiAobm9kZSwgc3Vic2NyaWJlciwgY2UpIHtcbiAgICAgICAgdmFyIHN0YXJ0SGFuZGxlID0gc3Vic2NyaWJlcltfTU9WRV9TVEFSVF9IQU5ETEVdO1xuXG4gICAgICAgIGlmIChzdGFydEhhbmRsZSkge1xuICAgICAgICAgICAgc3RhcnRIYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgICAgICBzdWJzY3JpYmVyW19NT1ZFX1NUQVJUX0hBTkRMRV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Vuc2V0VG91Y2hBY3Rpb25zKG5vZGUpO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzQXJncyA6IGZ1bmN0aW9uKGFyZ3MsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBfZGVmQXJnc1Byb2Nlc3Nvcih0aGlzLCBhcmdzLCBkZWxlZ2F0ZSk7XG5cbiAgICAgICAgaWYgKCEoTUlOX1RJTUUgaW4gcGFyYW1zKSkge1xuICAgICAgICAgICAgcGFyYW1zW01JTl9USU1FXSA9IHRoaXMuTUlOX1RJTUU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShNSU5fRElTVEFOQ0UgaW4gcGFyYW1zKSkge1xuICAgICAgICAgICAgcGFyYW1zW01JTl9ESVNUQU5DRV0gPSB0aGlzLk1JTl9ESVNUQU5DRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIF9vblN0YXJ0IDogZnVuY3Rpb24oZSwgbm9kZSwgc3Vic2NyaWJlciwgY2UsIGRlbGVnYXRlKSB7XG5cbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICBub2RlID0gZVtDVVJSRU5UX1RBUkdFVF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1zID0gc3Vic2NyaWJlci5fZXh0cmEsXG4gICAgICAgICAgICBmaXJlU3RhcnQgPSB0cnVlLFxuICAgICAgICAgICAgbWluVGltZSA9IHBhcmFtc1tNSU5fVElNRV0sXG4gICAgICAgICAgICBtaW5EaXN0YW5jZSA9IHBhcmFtc1tNSU5fRElTVEFOQ0VdLFxuICAgICAgICAgICAgYnV0dG9uID0gcGFyYW1zLmJ1dHRvbixcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gcGFyYW1zW1BSRVZFTlRfREVGQVVMVF0sXG4gICAgICAgICAgICByb290ID0gX2dldFJvb3Qobm9kZSwgc3Vic2NyaWJlciksXG4gICAgICAgICAgICBzdGFydFhZO1xuXG4gICAgICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgX25vcm1Ub3VjaEZhY2FkZShlLCBlLnRvdWNoZXNbMF0sIHBhcmFtcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpcmVTdGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlyZVN0YXJ0ID0gKGJ1dHRvbiA9PT0gdW5kZWZpbmVkKSB8fCAoYnV0dG9uID09PSBlLmJ1dHRvbik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChmaXJlU3RhcnQpIHtcblxuICAgICAgICAgICAgX3ByZXZlbnQoZSwgcHJldmVudERlZmF1bHQpO1xuXG4gICAgICAgICAgICBpZiAobWluVGltZSA9PT0gMCB8fCBtaW5EaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KGUsIG5vZGUsIGNlLCBwYXJhbXMpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc3RhcnRYWSA9IFtlLnBhZ2VYLCBlLnBhZ2VZXTtcblxuICAgICAgICAgICAgICAgIGlmIChtaW5UaW1lID4gMCkge1xuXG5cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLl9odCA9IFkubGF0ZXIobWluVGltZSwgdGhpcywgdGhpcy5fc3RhcnQsIFtlLCBub2RlLCBjZSwgcGFyYW1zXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLl9obWUgPSByb290Lm9uKEVWRU5UW0VORF0sIFkuYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbChwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1pbkRpc3RhbmNlID4gMCkge1xuXG5cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLl9obSA9IHJvb3Qub24oRVZFTlRbTU9WRV0sIFkuYmluZChmdW5jdGlvbihlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGVtLnBhZ2VYIC0gc3RhcnRYWVswXSkgPiBtaW5EaXN0YW5jZSB8fCBNYXRoLmFicyhlbS5wYWdlWSAtIHN0YXJ0WFlbMV0pID4gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydChlLCBub2RlLCBjZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2FuY2VsIDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuX2h0KSB7XG4gICAgICAgICAgICBwYXJhbXMuX2h0LmNhbmNlbCgpO1xuICAgICAgICAgICAgcGFyYW1zLl9odCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5faG1lKSB7XG4gICAgICAgICAgICBwYXJhbXMuX2htZS5kZXRhY2goKTtcbiAgICAgICAgICAgIHBhcmFtcy5faG1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLl9obSkge1xuICAgICAgICAgICAgcGFyYW1zLl9obS5kZXRhY2goKTtcbiAgICAgICAgICAgIHBhcmFtcy5faG0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zdGFydCA6IGZ1bmN0aW9uKGUsIG5vZGUsIGNlLCBwYXJhbXMpIHtcblxuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWwocGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUudHlwZSA9IEdFU1RVUkVfTU9WRV9TVEFSVDtcblxuXG4gICAgICAgIG5vZGUuc2V0RGF0YShfTU9WRV9TVEFSVCwgZSk7XG4gICAgICAgIGNlLmZpcmUoZSk7XG4gICAgfSxcblxuICAgIE1JTl9USU1FIDogMCxcbiAgICBNSU5fRElTVEFOQ0UgOiAwLFxuICAgIFBSRVZFTlRfREVGQVVMVCA6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBTZXRzIHVwIGEgXCJnZXN0dXJlbW92ZVwiIGV2ZW50LCB0aGF0IGlzIGZpcmVkIG9uIHRvdWNoIGRldmljZXMgaW4gcmVzcG9uc2UgdG8gYSBzaW5nbGUgZmluZ2VyIFwidG91Y2htb3ZlXCIsXG4gKiBhbmQgb24gbW91c2UgYmFzZWQgZGV2aWNlcyBpbiByZXNwb25zZSB0byBhIFwibW91c2Vtb3ZlXCIuXG4gKlxuICogPHA+QnkgZGVmYXVsdCB0aGlzIGV2ZW50IGlzIG9ubHkgZmlyZWQgd2hlbiB0aGUgc2FtZSBub2RlXG4gKiBoYXMgcmVjZWl2ZWQgYSBcImdlc3R1cmVtb3Zlc3RhcnRcIiBldmVudC4gVGhlIHN1YnNjcmliZXIgY2FuIHNldCBzdGFuZEFsb25lIHRvIHRydWUsIGluIHRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMsXG4gKiBpZiB0aGV5IHdhbnQgdG8gbGlzdGVuIGZvciB0aGlzIGV2ZW50IHdpdGhvdXQgYW4gaW5pdGlhbCBcImdlc3R1cmVtb3Zlc3RhcnRcIi48L3A+XG4gKlxuICogPHA+QnkgZGVmYXVsdCB0aGlzIGV2ZW50IHNldHMgdXAgaXQncyBpbnRlcm5hbCBcInRvdWNobW92ZVwiIGFuZCBcIm1vdXNlbW92ZVwiIERPTSBsaXN0ZW5lcnMgb24gdGhlIGRvY3VtZW50IGVsZW1lbnQuIFRoZSBzdWJzY3JpYmVyXG4gKiBjYW4gc2V0IHRoZSByb290IGNvbmZpZ3VyYXRpb24gcHJvcGVydHksIHRvIHNwZWNpZnkgd2hpY2ggbm9kZSB0byBhdHRhY2ggRE9NIGxpc3RlbmVycyB0bywgaWYgZGlmZmVyZW50IGZyb20gdGhlIGRvY3VtZW50LjwvcD5cbiAqXG4gKiA8cD5UaGlzIGV2ZW50IGNhbiBhbHNvIGJlIGxpc3RlbmVkIGZvciB1c2luZyBub2RlLmRlbGVnYXRlKCkuPC9wPlxuICpcbiAqIDxwPkl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSBZLmJpbmQgdG8gc2V0IHVwIGNvbnRleHQgYW5kIGFkZGl0aW9uYWwgYXJndW1lbnRzIGZvciB5b3VyIGV2ZW50IGhhbmRsZXIsXG4gKiBob3dldmVyIGlmIHlvdSB3YW50IHRvIHBhc3MgdGhlIGNvbnRleHQgYW5kIGFyZ3VtZW50cyBhcyBhZGRpdGlvbmFsIHNpZ25hdHVyZSBhcmd1bWVudHMgdG8gb24vZGVsZWdhdGUsXG4gKiB5b3UgbmVlZCB0byBwcm92aWRlIGEgbnVsbCB2YWx1ZSBmb3IgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBlLmc6IDxjb2RlPm5vZGUub24oXCJnZXN0dXJlbW92ZVwiLCBmbiwgbnVsbCwgY29udGV4dCwgYXJnMSwgYXJnMiwgYXJnMyk8L2NvZGU+PC9wPlxuICpcbiAqIEBldmVudCBnZXN0dXJlbW92ZVxuICogQGZvciBZVUlcbiAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9IFwiZ2VzdHVyZW1vdmVcIlxuICogQHBhcmFtIGZuIHtmdW5jdGlvbn0gVGhlIG1ldGhvZCB0aGUgZXZlbnQgaW52b2tlcy4gSXQgcmVjZWl2ZXMgdGhlIGV2ZW50IGZhY2FkZSBvZiB0aGUgdW5kZXJseWluZyBET00gZXZlbnQgKG1vdXNlbW92ZSBvciB0b3VjaG1vdmUudG91Y2hlc1swXSkgd2hpY2ggY29udGFpbnMgcG9zaXRpb24gY28tb3JkaW5hdGVzLlxuICogQHBhcmFtIGNmZyB7T2JqZWN0fSBPcHRpb25hbC4gQW4gb2JqZWN0IHdoaWNoIHNwZWNpZmllczpcbiAqIDxkbD5cbiAqIDxkdD5zdGFuZEFsb25lIChkZWZhdWx0cyB0byBmYWxzZSk8L2R0PlxuICogPGRkPnRydWUsIGlmIHRoZSBzdWJzY3JpYmVyIHNob3VsZCBiZSBub3RpZmllZCBldmVuIGlmIGEgXCJnZXN0dXJlbW92ZXN0YXJ0XCIgaGFzIG5vdCBvY2N1cmVkIG9uIHRoZSBzYW1lIG5vZGUuPC9kZD5cbiAqIDxkdD5yb290IChkZWZhdWx0cyB0byBkb2N1bWVudCk8L2R0PlxuICogPGRkPlRoZSBub2RlIHRvIHdoaWNoIHRoZSBpbnRlcm5hbCBET00gbGlzdGVuZXJzIHNob3VsZCBiZSBhdHRhY2hlZC48L2RkPlxuICogPGR0PnByZXZlbnREZWZhdWx0IChkZWZhdWx0cyB0byBmYWxzZSk8L2R0PlxuICogPGRkPkNhbiBiZSBzZXQgdG8gdHJ1ZS9mYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3IgYXMgc29vbiBhcyB0aGUgdG91Y2htb3ZlIG9yIG1vdXNlbW92ZSBpcyByZWNlaXZlZC4gQXMgd2l0aCBnZXN0dXJlbW92ZXN0YXJ0LCBjYW4gYWxzbyBiZSBzZXQgdG8gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0cnVlL2ZhbHNlIGJhc2VkIG9uIHRoZSBldmVudCBmYWNhZGUgcGFzc2VkIHRvIGl0LjwvZGQ+XG4gKiA8L2RsPlxuICpcbiAqIEByZXR1cm4ge0V2ZW50SGFuZGxlfSB0aGUgZGV0YWNoIGhhbmRsZVxuICovXG5kZWZpbmUoR0VTVFVSRV9NT1ZFLCB7XG5cbiAgICBvbiA6IGZ1bmN0aW9uIChub2RlLCBzdWJzY3JpYmVyLCBjZSkge1xuXG4gICAgICAgIF9zZXRUb3VjaEFjdGlvbnMobm9kZSk7XG4gICAgICAgIHZhciByb290ID0gX2dldFJvb3Qobm9kZSwgc3Vic2NyaWJlciwgRVZFTlRbTU9WRV0pLFxuXG4gICAgICAgICAgICBtb3ZlSGFuZGxlID0gcm9vdC5vbihFVkVOVFtNT1ZFXSxcbiAgICAgICAgICAgICAgICB0aGlzLl9vbk1vdmUsXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIsXG4gICAgICAgICAgICAgICAgY2UpO1xuXG4gICAgICAgIHN1YnNjcmliZXJbX01PVkVfSEFORExFXSA9IG1vdmVIYW5kbGU7XG5cbiAgICB9LFxuXG4gICAgZGVsZWdhdGUgOiBmdW5jdGlvbihub2RlLCBzdWJzY3JpYmVyLCBjZSwgZmlsdGVyKSB7XG5cbiAgICAgICAgdmFyIHNlID0gdGhpcztcblxuICAgICAgICBzdWJzY3JpYmVyW19ERUxfTU9WRV9IQU5ETEVdID0gbm9kZS5kZWxlZ2F0ZShFVkVOVFtNT1ZFXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBzZS5fb25Nb3ZlKGUsIG5vZGUsIHN1YnNjcmliZXIsIGNlLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWx0ZXIpO1xuICAgIH0sXG5cbiAgICBkZXRhY2ggOiBmdW5jdGlvbiAobm9kZSwgc3Vic2NyaWJlciwgY2UpIHtcbiAgICAgICAgdmFyIG1vdmVIYW5kbGUgPSBzdWJzY3JpYmVyW19NT1ZFX0hBTkRMRV07XG5cbiAgICAgICAgaWYgKG1vdmVIYW5kbGUpIHtcbiAgICAgICAgICAgIG1vdmVIYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgICAgICBzdWJzY3JpYmVyW19NT1ZFX0hBTkRMRV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Vuc2V0VG91Y2hBY3Rpb25zKG5vZGUpO1xuICAgIH0sXG5cbiAgICBkZXRhY2hEZWxlZ2F0ZSA6IGZ1bmN0aW9uKG5vZGUsIHN1YnNjcmliZXIsIGNlLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIGhhbmRsZSA9IHN1YnNjcmliZXJbX0RFTF9NT1ZFX0hBTkRMRV07XG5cbiAgICAgICAgaWYgKGhhbmRsZSkge1xuICAgICAgICAgICAgaGFuZGxlLmRldGFjaCgpO1xuICAgICAgICAgICAgc3Vic2NyaWJlcltfREVMX01PVkVfSEFORExFXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBfdW5zZXRUb3VjaEFjdGlvbnMobm9kZSk7XG5cbiAgICB9LFxuXG4gICAgcHJvY2Vzc0FyZ3MgOiBmdW5jdGlvbihhcmdzLCBkZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gX2RlZkFyZ3NQcm9jZXNzb3IodGhpcywgYXJncywgZGVsZWdhdGUpO1xuICAgIH0sXG5cbiAgICBfb25Nb3ZlIDogZnVuY3Rpb24oZSwgbm9kZSwgc3Vic2NyaWJlciwgY2UsIGRlbGVnYXRlKSB7XG5cbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICBub2RlID0gZVtDVVJSRU5UX1RBUkdFVF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlyZU1vdmUgPSBzdWJzY3JpYmVyLl9leHRyYS5zdGFuZEFsb25lIHx8IG5vZGUuZ2V0RGF0YShfTU9WRV9TVEFSVCksXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHN1YnNjcmliZXIuX2V4dHJhLnByZXZlbnREZWZhdWx0O1xuXG5cbiAgICAgICAgaWYgKGZpcmVNb3ZlKSB7XG5cbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBfbm9ybVRvdWNoRmFjYWRlKGUsIGUudG91Y2hlc1swXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZU1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJlTW92ZSkge1xuXG4gICAgICAgICAgICAgICAgX3ByZXZlbnQoZSwgcHJldmVudERlZmF1bHQpO1xuXG5cbiAgICAgICAgICAgICAgICBlLnR5cGUgPSBHRVNUVVJFX01PVkU7XG4gICAgICAgICAgICAgICAgY2UuZmlyZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBQUkVWRU5UX0RFRkFVTFQgOiBmYWxzZVxufSk7XG5cbi8qKlxuICogU2V0cyB1cCBhIFwiZ2VzdHVyZW1vdmVlbmRcIiBldmVudCwgdGhhdCBpcyBmaXJlZCBvbiB0b3VjaCBkZXZpY2VzIGluIHJlc3BvbnNlIHRvIGEgc2luZ2xlIGZpbmdlciBcInRvdWNoZW5kXCIsXG4gKiBhbmQgb24gbW91c2UgYmFzZWQgZGV2aWNlcyBpbiByZXNwb25zZSB0byBhIFwibW91c2V1cFwiLlxuICpcbiAqIDxwPkJ5IGRlZmF1bHQgdGhpcyBldmVudCBpcyBvbmx5IGZpcmVkIHdoZW4gdGhlIHNhbWUgbm9kZVxuICogaGFzIHJlY2VpdmVkIGEgXCJnZXN0dXJlbW92ZVwiIG9yIFwiZ2VzdHVyZW1vdmVzdGFydFwiIGV2ZW50LiBUaGUgc3Vic2NyaWJlciBjYW4gc2V0IHN0YW5kQWxvbmUgdG8gdHJ1ZSwgaW4gdGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyxcbiAqIGlmIHRoZXkgd2FudCB0byBsaXN0ZW4gZm9yIHRoaXMgZXZlbnQgd2l0aG91dCBhIHByZWNlZGluZyBcImdlc3R1cmVtb3Zlc3RhcnRcIiBvciBcImdlc3R1cmVtb3ZlXCIuPC9wPlxuICpcbiAqIDxwPkJ5IGRlZmF1bHQgdGhpcyBldmVudCBzZXRzIHVwIGl0J3MgaW50ZXJuYWwgXCJ0b3VjaGVuZFwiIGFuZCBcIm1vdXNldXBcIiBET00gbGlzdGVuZXJzIG9uIHRoZSBkb2N1bWVudCBlbGVtZW50LiBUaGUgc3Vic2NyaWJlclxuICogY2FuIHNldCB0aGUgcm9vdCBjb25maWd1cmF0aW9uIHByb3BlcnR5LCB0byBzcGVjaWZ5IHdoaWNoIG5vZGUgdG8gYXR0YWNoIERPTSBsaXN0ZW5lcnMgdG8sIGlmIGRpZmZlcmVudCBmcm9tIHRoZSBkb2N1bWVudC48L3A+XG4gKlxuICogPHA+VGhpcyBldmVudCBjYW4gYWxzbyBiZSBsaXN0ZW5lZCBmb3IgdXNpbmcgbm9kZS5kZWxlZ2F0ZSgpLjwvcD5cbiAqXG4gKiA8cD5JdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2UgWS5iaW5kIHRvIHNldCB1cCBjb250ZXh0IGFuZCBhZGRpdGlvbmFsIGFyZ3VtZW50cyBmb3IgeW91ciBldmVudCBoYW5kbGVyLFxuICogaG93ZXZlciBpZiB5b3Ugd2FudCB0byBwYXNzIHRoZSBjb250ZXh0IGFuZCBhcmd1bWVudHMgYXMgYWRkaXRpb25hbCBzaWduYXR1cmUgYXJndW1lbnRzIHRvIG9uL2RlbGVnYXRlLFxuICogeW91IG5lZWQgdG8gcHJvdmlkZSBhIG51bGwgdmFsdWUgZm9yIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCwgZS5nOiA8Y29kZT5ub2RlLm9uKFwiZ2VzdHVyZW1vdmVlbmRcIiwgZm4sIG51bGwsIGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMpPC9jb2RlPjwvcD5cbiAqXG4gKlxuICogQGV2ZW50IGdlc3R1cmVtb3ZlZW5kXG4gKiBAZm9yIFlVSVxuICogQHBhcmFtIHR5cGUge3N0cmluZ30gXCJnZXN0dXJlbW92ZWVuZFwiXG4gKiBAcGFyYW0gZm4ge2Z1bmN0aW9ufSBUaGUgbWV0aG9kIHRoZSBldmVudCBpbnZva2VzLiBJdCByZWNlaXZlcyB0aGUgZXZlbnQgZmFjYWRlIG9mIHRoZSB1bmRlcmx5aW5nIERPTSBldmVudCAobW91c2V1cCBvciB0b3VjaGVuZC5jaGFuZ2VkVG91Y2hlc1swXSkuXG4gKiBAcGFyYW0gY2ZnIHtPYmplY3R9IE9wdGlvbmFsLiBBbiBvYmplY3Qgd2hpY2ggc3BlY2lmaWVzOlxuICogPGRsPlxuICogPGR0PnN0YW5kQWxvbmUgKGRlZmF1bHRzIHRvIGZhbHNlKTwvZHQ+XG4gKiA8ZGQ+dHJ1ZSwgaWYgdGhlIHN1YnNjcmliZXIgc2hvdWxkIGJlIG5vdGlmaWVkIGV2ZW4gaWYgYSBcImdlc3R1cmVtb3Zlc3RhcnRcIiBvciBcImdlc3R1cmVtb3ZlXCIgaGFzIG5vdCBvY2N1cmVkIG9uIHRoZSBzYW1lIG5vZGUuPC9kZD5cbiAqIDxkdD5yb290IChkZWZhdWx0cyB0byBkb2N1bWVudCk8L2R0PlxuICogPGRkPlRoZSBub2RlIHRvIHdoaWNoIHRoZSBpbnRlcm5hbCBET00gbGlzdGVuZXJzIHNob3VsZCBiZSBhdHRhY2hlZC48L2RkPlxuICogPGR0PnByZXZlbnREZWZhdWx0IChkZWZhdWx0cyB0byBmYWxzZSk8L2R0PlxuICogPGRkPkNhbiBiZSBzZXQgdG8gdHJ1ZS9mYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3IgYXMgc29vbiBhcyB0aGUgdG91Y2hlbmQgb3IgbW91c2V1cCBpcyByZWNlaXZlZC4gQXMgd2l0aCBnZXN0dXJlbW92ZXN0YXJ0LCBjYW4gYWxzbyBiZSBzZXQgdG8gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0cnVlL2ZhbHNlIGJhc2VkIG9uIHRoZSBldmVudCBmYWNhZGUgcGFzc2VkIHRvIGl0LjwvZGQ+XG4gKiA8L2RsPlxuICpcbiAqIEByZXR1cm4ge0V2ZW50SGFuZGxlfSB0aGUgZGV0YWNoIGhhbmRsZVxuICovXG5kZWZpbmUoR0VTVFVSRV9NT1ZFX0VORCwge1xuXG4gICAgb24gOiBmdW5jdGlvbiAobm9kZSwgc3Vic2NyaWJlciwgY2UpIHtcbiAgICAgICAgX3NldFRvdWNoQWN0aW9ucyhub2RlKTtcbiAgICAgICAgdmFyIHJvb3QgPSBfZ2V0Um9vdChub2RlLCBzdWJzY3JpYmVyKSxcblxuICAgICAgICAgICAgZW5kSGFuZGxlID0gcm9vdC5vbihFVkVOVFtFTkRdLFxuICAgICAgICAgICAgICAgIHRoaXMuX29uRW5kLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLFxuICAgICAgICAgICAgICAgIGNlKTtcblxuICAgICAgICBzdWJzY3JpYmVyW19NT1ZFX0VORF9IQU5ETEVdID0gZW5kSGFuZGxlO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZSA6IGZ1bmN0aW9uKG5vZGUsIHN1YnNjcmliZXIsIGNlLCBmaWx0ZXIpIHtcblxuICAgICAgICB2YXIgc2UgPSB0aGlzO1xuXG4gICAgICAgIHN1YnNjcmliZXJbX0RFTF9NT1ZFX0VORF9IQU5ETEVdID0gbm9kZS5kZWxlZ2F0ZShFVkVOVFtFTkRdLFxuICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHNlLl9vbkVuZChlLCBub2RlLCBzdWJzY3JpYmVyLCBjZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsdGVyKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoRGVsZWdhdGUgOiBmdW5jdGlvbihub2RlLCBzdWJzY3JpYmVyLCBjZSwgZmlsdGVyKSB7XG4gICAgICAgIHZhciBoYW5kbGUgPSBzdWJzY3JpYmVyW19ERUxfTU9WRV9FTkRfSEFORExFXTtcblxuICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICBoYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgICAgICBzdWJzY3JpYmVyW19ERUxfTU9WRV9FTkRfSEFORExFXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBfdW5zZXRUb3VjaEFjdGlvbnMobm9kZSk7XG5cbiAgICB9LFxuXG4gICAgZGV0YWNoIDogZnVuY3Rpb24gKG5vZGUsIHN1YnNjcmliZXIsIGNlKSB7XG4gICAgICAgIHZhciBlbmRIYW5kbGUgPSBzdWJzY3JpYmVyW19NT1ZFX0VORF9IQU5ETEVdO1xuXG4gICAgICAgIGlmIChlbmRIYW5kbGUpIHtcbiAgICAgICAgICAgIGVuZEhhbmRsZS5kZXRhY2goKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXJbX01PVkVfRU5EX0hBTkRMRV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Vuc2V0VG91Y2hBY3Rpb25zKG5vZGUpO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzQXJncyA6IGZ1bmN0aW9uKGFyZ3MsIGRlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBfZGVmQXJnc1Byb2Nlc3Nvcih0aGlzLCBhcmdzLCBkZWxlZ2F0ZSk7XG4gICAgfSxcblxuICAgIF9vbkVuZCA6IGZ1bmN0aW9uKGUsIG5vZGUsIHN1YnNjcmliZXIsIGNlLCBkZWxlZ2F0ZSkge1xuXG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgbm9kZSA9IGVbQ1VSUkVOVF9UQVJHRVRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcmVNb3ZlRW5kID0gc3Vic2NyaWJlci5fZXh0cmEuc3RhbmRBbG9uZSB8fCBub2RlLmdldERhdGEoX01PVkUpIHx8IG5vZGUuZ2V0RGF0YShfTU9WRV9TVEFSVCksXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHN1YnNjcmliZXIuX2V4dHJhLnByZXZlbnREZWZhdWx0O1xuXG4gICAgICAgIGlmIChmaXJlTW92ZUVuZCkge1xuXG4gICAgICAgICAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICAgICAgICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBfbm9ybVRvdWNoRmFjYWRlKGUsIGUuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVNb3ZlRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyZU1vdmVFbmQpIHtcblxuICAgICAgICAgICAgICAgIF9wcmV2ZW50KGUsIHByZXZlbnREZWZhdWx0KTtcblxuICAgICAgICAgICAgICAgIGUudHlwZSA9IEdFU1RVUkVfTU9WRV9FTkQ7XG4gICAgICAgICAgICAgICAgY2UuZmlyZShlKTtcblxuICAgICAgICAgICAgICAgIG5vZGUuY2xlYXJEYXRhKF9NT1ZFX1NUQVJUKTtcbiAgICAgICAgICAgICAgICBub2RlLmNsZWFyRGF0YShfTU9WRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgUFJFVkVOVF9ERUZBVUxUIDogZmFsc2Vcbn0pO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJub2RlLWJhc2VcIiwgXCJldmVudC10b3VjaFwiLCBcImV2ZW50LXN5bnRoZXRpY1wiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdldmVudC1vdXRzaWRlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBPdXRzaWRlIGV2ZW50cyBhcmUgc3ludGhldGljIERPTSBldmVudHMgdGhhdCBmaXJlIHdoZW4gYSBjb3JyZXNwb25kaW5nIG5hdGl2ZVxuICogb3Igc3ludGhldGljIERPTSBldmVudCBvY2N1cnMgb3V0c2lkZSBhIGJvdW5kIGVsZW1lbnQuXG4gKlxuICogVGhlIGZvbGxvd2luZyBvdXRzaWRlIGV2ZW50cyBhcmUgcHJlLWRlZmluZWQgYnkgdGhpcyBtb2R1bGU6XG4gKiA8dWw+XG4gKiAgIDxsaT5ibHVyPC9saT5cbiAqICAgPGxpPmNoYW5nZTwvbGk+XG4gKiAgIDxsaT5jbGljazwvbGk+XG4gKiAgIDxsaT5kYmxjbGljazwvbGk+XG4gKiAgIDxsaT5mb2N1czwvbGk+XG4gKiAgIDxsaT5rZXlkb3duPC9saT5cbiAqICAgPGxpPmtleXByZXNzPC9saT5cbiAqICAgPGxpPmtleXVwPC9saT5cbiAqICAgPGxpPm1vdXNlZG93bjwvbGk+XG4gKiAgIDxsaT5tb3VzZW1vdmU8L2xpPlxuICogICA8bGk+bW91c2VvdXQ8L2xpPlxuICogICA8bGk+bW91c2VvdmVyPC9saT5cbiAqICAgPGxpPm1vdXNldXA8L2xpPlxuICogICA8bGk+c2VsZWN0PC9saT5cbiAqICAgPGxpPnN1Ym1pdDwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIERlZmluZSBuZXcgb3V0c2lkZSBldmVudHMgd2l0aFxuICogPGNvZGU+WS5FdmVudC5kZWZpbmVPdXRzaWRlKGV2ZW50VHlwZSk7PC9jb2RlPi5cbiAqIEJ5IGRlZmF1bHQsIHRoZSBjcmVhdGVkIHN5bnRoZXRpYyBldmVudCBuYW1lIHdpbGwgYmUgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gKiB3aXRoIFwib3V0c2lkZVwiIGFwcGVuZGVkIChlLmcuIFwiY2xpY2tcIiBiZWNvbWVzIFwiY2xpY2tvdXRzaWRlXCIpLiBJZiB5b3Ugd2FudFxuICogYSBkaWZmZXJlbnQgbmFtZSBmb3IgdGhlIGNyZWF0ZWQgRXZlbnQsIHBhc3MgaXQgYXMgYSBzZWNvbmQgYXJndW1lbnQgbGlrZSBzbzpcbiAqIDxjb2RlPlkuRXZlbnQuZGVmaW5lT3V0c2lkZShldmVudFR5cGUsIFwieW9uZGVyY2xpY2tcIik8L2NvZGU+LlxuICpcbiAqIFRoaXMgbW9kdWxlIHdhcyBjb250cmlidXRlZCBieSBCcmV0dCBTdGltbWVybWFuLCBwcm9tb3RlZCBmcm9tIGhpc1xuICogZ2FsbGVyeS1vdXRzaWRlLWV2ZW50cyBtb2R1bGUgYXRcbiAqIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9nYWxsZXJ5L3Nob3cvb3V0c2lkZS1ldmVudHNcbiAqXG4gKiBAbW9kdWxlIGV2ZW50XG4gKiBAc3VibW9kdWxlIGV2ZW50LW91dHNpZGVcbiAqIEBhdXRob3IgYnJldHRzdGltbWVybWFuXG4gKiBAc2luY2UgMy40LjBcbiAqL1xuXG4vLyBPdXRzaWRlIGV2ZW50cyBhcmUgcHJlLWRlZmluZWQgZm9yIGVhY2ggb2YgdGhlc2UgbmF0aXZlIERPTSBldmVudHNcbnZhciBuYXRpdmVFdmVudHMgPSBbXG4gICAgICAgICdibHVyJywgJ2NoYW5nZScsICdjbGljaycsICdkYmxjbGljaycsICdmb2N1cycsICdrZXlkb3duJywgJ2tleXByZXNzJyxcbiAgICAgICAgJ2tleXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2VvdXQnLCAnbW91c2VvdmVyJywgJ21vdXNldXAnLFxuICAgICAgICAnc2VsZWN0JywgJ3N1Ym1pdCdcbiAgICBdO1xuXG4vKipcbiAqIERlZmluZXMgYSBuZXcgb3V0c2lkZSBldmVudCB0byBjb3JyZXNwb25kIHdpdGggdGhlIGdpdmVuIERPTSBldmVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgY3JlYXRlZCBzeW50aGV0aWMgZXZlbnQgbmFtZSB3aWxsIGJlIHRoZSBuYW1lIG9mIHRoZSBldmVudFxuICogd2l0aCBcIm91dHNpZGVcIiBhcHBlbmRlZCAoZS5nLiBcImNsaWNrXCIgYmVjb21lcyBcImNsaWNrb3V0c2lkZVwiKS4gSWYgeW91IHdhbnRcbiAqIGEgZGlmZmVyZW50IG5hbWUgZm9yIHRoZSBjcmVhdGVkIEV2ZW50LCBwYXNzIGl0IGFzIGEgc2Vjb25kIGFyZ3VtZW50IGxpa2Ugc286XG4gKiA8Y29kZT5ZLkV2ZW50LmRlZmluZU91dHNpZGUoZXZlbnRUeXBlLCBcInlvbmRlcmNsaWNrXCIpPC9jb2RlPi5cbiAqXG4gKiBAbWV0aG9kIGRlZmluZU91dHNpZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBET00gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIChvcHRpb25hbCkgY3VzdG9tIG91dHNpZGUgZXZlbnQgbmFtZVxuICogQHN0YXRpY1xuICogQGZvciBFdmVudFxuICovXG5ZLkV2ZW50LmRlZmluZU91dHNpZGUgPSBmdW5jdGlvbiAoZXZlbnQsIG5hbWUpIHtcbiAgICBuYW1lID0gbmFtZSB8fCAoZXZlbnQgKyAnb3V0c2lkZScpO1xuXG4gICAgdmFyIGNvbmZpZyA9IHtcblxuICAgICAgICBvbjogZnVuY3Rpb24gKG5vZGUsIHN1Yiwgbm90aWZpZXIpIHtcbiAgICAgICAgICAgIHN1Yi5oYW5kbGUgPSBZLm9uZSgnZG9jJykub24oZXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc091dHNpZGUobm9kZSwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWVyLmZpcmUoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoOiBmdW5jdGlvbiAobm9kZSwgc3ViLCBub3RpZmllcikge1xuICAgICAgICAgICAgc3ViLmhhbmRsZS5kZXRhY2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxlZ2F0ZTogZnVuY3Rpb24gKG5vZGUsIHN1Yiwgbm90aWZpZXIsIGZpbHRlcikge1xuICAgICAgICAgICAgc3ViLmhhbmRsZSA9IFkub25lKCdkb2MnKS5kZWxlZ2F0ZShldmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc091dHNpZGUobm9kZSwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWVyLmZpcmUoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmlsdGVyLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc091dHNpZGU6IGZ1bmN0aW9uIChub2RlLCB0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgIT09IG5vZGUgJiYgIXRhcmdldC5hbmNlc3RvcihmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcCA9PT0gbm9kZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uZmlnLmRldGFjaERlbGVnYXRlID0gY29uZmlnLmRldGFjaDtcblxuICAgIFkuRXZlbnQuZGVmaW5lKG5hbWUsIGNvbmZpZyk7XG59O1xuXG4vLyBEZWZpbmUgb3V0c2lkZSBldmVudHMgZm9yIHNvbWUgY29tbW9uIG5hdGl2ZSBET00gZXZlbnRzXG5ZLkFycmF5LmVhY2gobmF0aXZlRXZlbnRzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBZLkV2ZW50LmRlZmluZU91dHNpZGUoZXZlbnQpO1xufSk7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImV2ZW50LXN5bnRoZXRpY1wiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdldmVudC1yZXNpemUnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIEFkZHMgYSB3aW5kb3cgcmVzaXplIGV2ZW50IHRoYXQgaGFzIGl0cyBiZWhhdmlvciBub3JtYWxpemVkIHRvIGZpcmUgYXQgdGhlXG4gKiBlbmQgb2YgdGhlIHJlc2l6ZSByYXRoZXIgdGhhbiBjb25zdGFudGx5IGR1cmluZyB0aGUgcmVzaXplLlxuICogQG1vZHVsZSBldmVudFxuICogQHN1Ym1vZHVsZSBldmVudC1yZXNpemVcbiAqL1xuXG5cbi8qKlxuICogT2xkIGZpcmVmb3ggZmlyZXMgdGhlIHdpbmRvdyByZXNpemUgZXZlbnQgb25jZSB3aGVuIHRoZSByZXNpemUgYWN0aW9uXG4gKiBmaW5pc2hlcywgb3RoZXIgYnJvd3NlcnMgZmlyZSB0aGUgZXZlbnQgcGVyaW9kaWNhbGx5IGR1cmluZyB0aGVcbiAqIHJlc2l6ZS4gIFRoaXMgY29kZSB1c2VzIHRpbWVvdXQgbG9naWMgdG8gc2ltdWxhdGUgdGhlIEZpcmVmb3hcbiAqIGJlaGF2aW9yIGluIG90aGVyIGJyb3dzZXJzLlxuICogQGV2ZW50IHdpbmRvd3Jlc2l6ZVxuICogQGZvciBZVUlcbiAqL1xuWS5FdmVudC5kZWZpbmUoJ3dpbmRvd3Jlc2l6ZScsIHtcblxuICAgIG9uOiAoWS5VQS5nZWNrbyAmJiBZLlVBLmdlY2tvIDwgMS45MSkgP1xuICAgICAgICBmdW5jdGlvbiAobm9kZSwgc3ViLCBub3RpZmllcikge1xuICAgICAgICAgICAgc3ViLl9oYW5kbGUgPSBZLkV2ZW50LmF0dGFjaCgncmVzaXplJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBub3RpZmllci5maXJlKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbiAobm9kZSwgc3ViLCBub3RpZmllcikge1xuICAgICAgICAgICAgLy8gaW50ZXJ2YWwgYnVtcGVkIGZyb20gNDAgdG8gMTAwbXMgYXMgb2YgMy40LjFcbiAgICAgICAgICAgIHZhciBkZWxheSA9IFkuY29uZmlnLndpbmRvd1Jlc2l6ZURlbGF5IHx8IDEwMDtcblxuICAgICAgICAgICAgc3ViLl9oYW5kbGUgPSBZLkV2ZW50LmF0dGFjaCgncmVzaXplJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViLl90aW1lcikge1xuICAgICAgICAgICAgICAgICAgICBzdWIuX3RpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN1Yi5fdGltZXIgPSBZLmxhdGVyKGRlbGF5LCBZLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWVyLmZpcmUoZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgIGRldGFjaDogZnVuY3Rpb24gKG5vZGUsIHN1Yikge1xuICAgICAgICBpZiAoc3ViLl90aW1lcikge1xuICAgICAgICAgICAgc3ViLl90aW1lci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBzdWIuX2hhbmRsZS5kZXRhY2goKTtcbiAgICB9XG4gICAgLy8gZGVsZWdhdGUgbWV0aG9kcyBub3QgZGVmaW5lZCBiZWNhdXNlIHRoaXMgb25seSB3b3JrcyBmb3Igd2luZG93XG4gICAgLy8gc3Vic2NyaXB0aW9ucywgc28uLi55ZWFoLlxufSk7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcIm5vZGUtYmFzZVwiLCBcImV2ZW50LXN5bnRoZXRpY1wiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdldmVudC1zaW11bGF0ZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbihmdW5jdGlvbigpIHtcbi8qKlxuICogU2ltdWxhdGUgdXNlciBpbnRlcmFjdGlvbiBieSBnZW5lcmF0aW5nIG5hdGl2ZSBET00gZXZlbnRzLlxuICpcbiAqIEBtb2R1bGUgZXZlbnQtc2ltdWxhdGVcbiAqIEByZXF1aXJlcyBldmVudFxuICovXG5cbi8vc2hvcnRjdXRzXG52YXIgTCAgID0gWS5MYW5nLFxuICAgIHdpbiA9IFkuY29uZmlnLndpbixcbiAgICBpc0Z1bmN0aW9uICA9IEwuaXNGdW5jdGlvbixcbiAgICBpc1N0cmluZyAgICA9IEwuaXNTdHJpbmcsXG4gICAgaXNCb29sZWFuICAgPSBMLmlzQm9vbGVhbixcbiAgICBpc09iamVjdCAgICA9IEwuaXNPYmplY3QsXG4gICAgaXNOdW1iZXIgICAgPSBMLmlzTnVtYmVyLFxuXG4gICAgLy9tb3VzZSBldmVudHMgc3VwcG9ydGVkXG4gICAgbW91c2VFdmVudHMgPSB7XG4gICAgICAgIGNsaWNrOiAgICAgIDEsXG4gICAgICAgIGRibGNsaWNrOiAgIDEsXG4gICAgICAgIG1vdXNlb3ZlcjogIDEsXG4gICAgICAgIG1vdXNlb3V0OiAgIDEsXG4gICAgICAgIG1vdXNlZG93bjogIDEsXG4gICAgICAgIG1vdXNldXA6ICAgIDEsXG4gICAgICAgIG1vdXNlbW92ZTogIDEsXG4gICAgICAgIGNvbnRleHRtZW51OjFcbiAgICB9LFxuXG4gICAgcG9pbnRlckV2ZW50cyA9ICh3aW4gJiYgd2luLlBvaW50ZXJFdmVudCkgPyB7XG4gICAgICAgIHBvaW50ZXJvdmVyOiAgMSxcbiAgICAgICAgcG9pbnRlcm91dDogICAxLFxuICAgICAgICBwb2ludGVyZG93bjogIDEsXG4gICAgICAgIHBvaW50ZXJ1cDogICAgMSxcbiAgICAgICAgcG9pbnRlcm1vdmU6ICAxXG4gICAgfSA6IHtcbiAgICAgICAgTVNQb2ludGVyT3ZlcjogIDEsXG4gICAgICAgIE1TUG9pbnRlck91dDogICAxLFxuICAgICAgICBNU1BvaW50ZXJEb3duOiAgMSxcbiAgICAgICAgTVNQb2ludGVyVXA6ICAgIDEsXG4gICAgICAgIE1TUG9pbnRlck1vdmU6ICAxXG4gICAgfSxcblxuICAgIC8va2V5IGV2ZW50cyBzdXBwb3J0ZWRcbiAgICBrZXlFdmVudHMgICA9IHtcbiAgICAgICAga2V5ZG93bjogICAgMSxcbiAgICAgICAga2V5dXA6ICAgICAgMSxcbiAgICAgICAga2V5cHJlc3M6ICAgMVxuICAgIH0sXG5cbiAgICAvL0hUTUwgZXZlbnRzIHN1cHBvcnRlZFxuICAgIHVpRXZlbnRzICA9IHtcbiAgICAgICAgc3VibWl0OiAgICAgMSxcbiAgICAgICAgYmx1cjogICAgICAgMSxcbiAgICAgICAgY2hhbmdlOiAgICAgMSxcbiAgICAgICAgZm9jdXM6ICAgICAgMSxcbiAgICAgICAgcmVzaXplOiAgICAgMSxcbiAgICAgICAgc2Nyb2xsOiAgICAgMSxcbiAgICAgICAgc2VsZWN0OiAgICAgMVxuICAgIH0sXG5cbiAgICAvL2V2ZW50cyB0aGF0IGJ1YmJsZSBieSBkZWZhdWx0XG4gICAgYnViYmxlRXZlbnRzID0ge1xuICAgICAgICBzY3JvbGw6ICAgICAxLFxuICAgICAgICByZXNpemU6ICAgICAxLFxuICAgICAgICByZXNldDogICAgICAxLFxuICAgICAgICBzdWJtaXQ6ICAgICAxLFxuICAgICAgICBjaGFuZ2U6ICAgICAxLFxuICAgICAgICBzZWxlY3Q6ICAgICAxLFxuICAgICAgICBlcnJvcjogICAgICAxLFxuICAgICAgICBhYm9ydDogICAgICAxXG4gICAgfSxcblxuICAgIC8vdG91Y2ggZXZlbnRzIHN1cHBvcnRlZFxuICAgIHRvdWNoRXZlbnRzID0ge1xuICAgICAgICB0b3VjaHN0YXJ0OiAxLFxuICAgICAgICB0b3VjaG1vdmU6IDEsXG4gICAgICAgIHRvdWNoZW5kOiAxLFxuICAgICAgICB0b3VjaGNhbmNlbDogMVxuICAgIH0sXG5cbiAgICBnZXN0dXJlRXZlbnRzID0ge1xuICAgICAgICBnZXN0dXJlc3RhcnQ6IDEsXG4gICAgICAgIGdlc3R1cmVjaGFuZ2U6IDEsXG4gICAgICAgIGdlc3R1cmVlbmQ6IDFcbiAgICB9O1xuXG4vL2FsbCBrZXksIG1vdXNlIGFuZCB0b3VjaCBldmVudHMgYnViYmxlXG5ZLm1peChidWJibGVFdmVudHMsIG1vdXNlRXZlbnRzKTtcblkubWl4KGJ1YmJsZUV2ZW50cywga2V5RXZlbnRzKTtcblkubWl4KGJ1YmJsZUV2ZW50cywgdG91Y2hFdmVudHMpO1xuXG4vKlxuICogTm90ZTogSW50ZW50aW9uYWxseSBub3QgZm9yIFlVSURvYyBnZW5lcmF0aW9uLlxuICogU2ltdWxhdGVzIGEga2V5IGV2ZW50IHVzaW5nIHRoZSBnaXZlbiBldmVudCBpbmZvcm1hdGlvbiB0byBwb3B1bGF0ZVxuICogdGhlIGdlbmVyYXRlZCBldmVudCBvYmplY3QuIFRoaXMgbWV0aG9kIGRvZXMgYnJvd3Nlci1lcXVhbGl6aW5nXG4gKiBjYWxjdWxhdGlvbnMgdG8gYWNjb3VudCBmb3IgZGlmZmVyZW5jZXMgaW4gdGhlIERPTSBhbmQgSUUgZXZlbnQgbW9kZWxzXG4gKiBhcyB3ZWxsIGFzIGRpZmZlcmVudCBicm93c2VyIHF1aXJrcy4gTm90ZToga2V5ZG93biBjYXVzZXMgU2FmYXJpIDIueCB0b1xuICogY3Jhc2guXG4gKiBAbWV0aG9kIHNpbXVsYXRlS2V5RXZlbnRcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBmaXJlLiBUaGlzIGNhbiBiZSBhbnkgb25lIG9mXG4gKiAgICAgIHRoZSBmb2xsb3dpbmc6IGtleXVwLCBrZXlkb3duLCBhbmQga2V5cHJlc3MuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPXRydWVdIEluZGljYXRlcyBpZiB0aGUgZXZlbnQgY2FuIGJlXG4gKiAgICAgIGJ1YmJsZWQgdXAuIERPTSBMZXZlbCAzIHNwZWNpZmllcyB0aGF0IGFsbCBrZXkgZXZlbnRzIGJ1YmJsZSBieVxuICogICAgICBkZWZhdWx0LlxuICogQHBhcmFtIHtCb29sZWFufSBbY2FuY2VsYWJsZT10cnVlXSBJbmRpY2F0ZXMgaWYgdGhlIGV2ZW50IGNhbiBiZVxuICogICAgICBjYW5jZWxlZCB1c2luZyBwcmV2ZW50RGVmYXVsdCgpLiBET00gTGV2ZWwgMyBzcGVjaWZpZXMgdGhhdCBhbGxcbiAqICAgICAga2V5IGV2ZW50cyBjYW4gYmUgY2FuY2VsbGVkLlxuICogQHBhcmFtIHtXaW5kb3d9IFt2aWV3PXdpbmRvd10gVGhlIHZpZXcgY29udGFpbmluZyB0aGUgdGFyZ2V0LiBUaGlzIGlzXG4gKiAgICAgIHR5cGljYWxseSB0aGUgd2luZG93IG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N0cmxLZXk9ZmFsc2VdIEluZGljYXRlcyBpZiBvbmUgb2YgdGhlIENUUkwga2V5c1xuICogICAgICBpcyBwcmVzc2VkIHdoaWxlIHRoZSBldmVudCBpcyBmaXJpbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbHRLZXk9ZmFsc2VdIEluZGljYXRlcyBpZiBvbmUgb2YgdGhlIEFMVCBrZXlzXG4gKiAgICAgIGlzIHByZXNzZWQgd2hpbGUgdGhlIGV2ZW50IGlzIGZpcmluZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NoaWZ0S2V5PWZhbHNlXSBJbmRpY2F0ZXMgaWYgb25lIG9mIHRoZSBTSElGVCBrZXlzXG4gKiAgICAgIGlzIHByZXNzZWQgd2hpbGUgdGhlIGV2ZW50IGlzIGZpcmluZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21ldGFLZXk9ZmFsc2VdIEluZGljYXRlcyBpZiBvbmUgb2YgdGhlIE1FVEEga2V5c1xuICogICAgICBpcyBwcmVzc2VkIHdoaWxlIHRoZSBldmVudCBpcyBmaXJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2tleUNvZGU9MF0gVGhlIGNvZGUgZm9yIHRoZSBrZXkgdGhhdCBpcyBpbiB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NoYXJDb2RlPTBdIFRoZSBVbmljb2RlIGNvZGUgZm9yIHRoZSBjaGFyYWN0ZXJcbiAqICAgICAgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkgYmVpbmcgdXNlZC5cbiAqL1xuZnVuY3Rpb24gc2ltdWxhdGVLZXlFdmVudCh0YXJnZXQgLyo6SFRNTEVsZW1lbnQqLywgdHlwZSAvKjpTdHJpbmcqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlcyAvKjpCb29sZWFuKi8sICBjYW5jZWxhYmxlIC8qOkJvb2xlYW4qLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldyAvKjpXaW5kb3cqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybEtleSAvKjpCb29sZWFuKi8sICAgIGFsdEtleSAvKjpCb29sZWFuKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0S2V5IC8qOkJvb2xlYW4qLywgICBtZXRhS2V5IC8qOkJvb2xlYW4qLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5Q29kZSAvKjppbnQqLywgICAgICAgIGNoYXJDb2RlIC8qOmludCovKSAvKjpWb2lkKi9cbntcbiAgICAvL2NoZWNrIHRhcmdldFxuICAgIGlmICghdGFyZ2V0KXtcbiAgICAgICAgWS5lcnJvcihcInNpbXVsYXRlS2V5RXZlbnQoKTogSW52YWxpZCB0YXJnZXQuXCIpO1xuICAgIH1cblxuICAgIC8vY2hlY2sgZXZlbnQgdHlwZVxuICAgIGlmIChpc1N0cmluZyh0eXBlKSl7XG4gICAgICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0ZXZlbnRcIjogLy9ET00gTGV2ZWwgM1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcImtleXByZXNzXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia2V5dXBcIjpcbiAgICAgICAgICAgIGNhc2UgXCJrZXlkb3duXCI6XG4gICAgICAgICAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgWS5lcnJvcihcInNpbXVsYXRlS2V5RXZlbnQoKTogRXZlbnQgdHlwZSAnXCIgKyB0eXBlICsgXCInIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgWS5lcnJvcihcInNpbXVsYXRlS2V5RXZlbnQoKTogRXZlbnQgdHlwZSBtdXN0IGJlIGEgc3RyaW5nLlwiKTtcbiAgICB9XG5cbiAgICAvL3NldHVwIGRlZmF1bHQgdmFsdWVzXG4gICAgaWYgKCFpc0Jvb2xlYW4oYnViYmxlcykpe1xuICAgICAgICBidWJibGVzID0gdHJ1ZTsgLy9hbGwga2V5IGV2ZW50cyBidWJibGVcbiAgICB9XG4gICAgaWYgKCFpc0Jvb2xlYW4oY2FuY2VsYWJsZSkpe1xuICAgICAgICBjYW5jZWxhYmxlID0gdHJ1ZTsgLy9hbGwga2V5IGV2ZW50cyBjYW4gYmUgY2FuY2VsbGVkXG4gICAgfVxuICAgIGlmICghaXNPYmplY3Qodmlldykpe1xuICAgICAgICB2aWV3ID0gWS5jb25maWcud2luOyAvL3ZpZXcgaXMgdHlwaWNhbGx5IHdpbmRvd1xuICAgIH1cbiAgICBpZiAoIWlzQm9vbGVhbihjdHJsS2V5KSl7XG4gICAgICAgIGN0cmxLZXkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0Jvb2xlYW4oYWx0S2V5KSl7XG4gICAgICAgIGFsdEtleSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzQm9vbGVhbihzaGlmdEtleSkpe1xuICAgICAgICBzaGlmdEtleSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzQm9vbGVhbihtZXRhS2V5KSl7XG4gICAgICAgIG1ldGFLZXkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc051bWJlcihrZXlDb2RlKSl7XG4gICAgICAgIGtleUNvZGUgPSAwO1xuICAgIH1cbiAgICBpZiAoIWlzTnVtYmVyKGNoYXJDb2RlKSl7XG4gICAgICAgIGNoYXJDb2RlID0gMDtcbiAgICB9XG5cbiAgICAvL3RyeSB0byBjcmVhdGUgYSBtb3VzZSBldmVudFxuICAgIHZhciBjdXN0b21FdmVudCAvKjpNb3VzZUV2ZW50Ki8gPSBudWxsO1xuXG4gICAgLy9jaGVjayBmb3IgRE9NLWNvbXBsaWFudCBicm93c2VycyBmaXJzdFxuICAgIGlmIChpc0Z1bmN0aW9uKFkuY29uZmlnLmRvYy5jcmVhdGVFdmVudCkpe1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIC8vdHJ5IHRvIGNyZWF0ZSBrZXkgZXZlbnRcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50ID0gWS5jb25maWcuZG9jLmNyZWF0ZUV2ZW50KFwiS2V5RXZlbnRzXCIpO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSW50ZXJlc3RpbmcgcHJvYmxlbTogRmlyZWZveCBpbXBsZW1lbnRlZCBhIG5vbi1zdGFuZGFyZFxuICAgICAgICAgICAgICogdmVyc2lvbiBvZiBpbml0S2V5RXZlbnQoKSBiYXNlZCBvbiBET00gTGV2ZWwgMiBzcGVjcy5cbiAgICAgICAgICAgICAqIEtleSBldmVudCB3YXMgcmVtb3ZlZCBmcm9tIERPTSBMZXZlbCAyIGFuZCByZS1pbnRyb2R1Y2VkXG4gICAgICAgICAgICAgKiBpbiBET00gTGV2ZWwgMyB3aXRoIGEgZGlmZmVyZW50IGludGVyZmFjZS4gRmlyZWZveCBpcyB0aGVcbiAgICAgICAgICAgICAqIG9ubHkgYnJvd3NlciB3aXRoIGFueSBpbXBsZW1lbnRhdGlvbiBvZiBLZXkgRXZlbnRzLCBzbyBmb3JcbiAgICAgICAgICAgICAqIG5vdywgYXNzdW1lIGl0J3MgRmlyZWZveCBpZiB0aGUgYWJvdmUgbGluZSBkb2Vzbid0IGVycm9yLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBAVE9ETzogRGVjaXBoZXIgYmV0d2VlbiBGaXJlZm94J3MgaW1wbGVtZW50YXRpb24gYW5kIGEgY29ycmVjdCBvbmUuXG4gICAgICAgICAgICBjdXN0b21FdmVudC5pbml0S2V5RXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgdmlldywgY3RybEtleSxcbiAgICAgICAgICAgICAgICBhbHRLZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBrZXlDb2RlLCBjaGFyQ29kZSk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXggLyo6RXJyb3IqLyl7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJZiBpdCBnb3QgaGVyZSwgdGhhdCBtZWFucyBrZXkgZXZlbnRzIGFyZW4ndCBvZmZpY2lhbGx5IHN1cHBvcnRlZC5cbiAgICAgICAgICAgICAqIFNhZmFyaS9XZWJLaXQgaXMgYSByZWFsIHByb2JsZW0gbm93LiBXZWJLaXQgNTIyIHdvbid0IGxldCB5b3VcbiAgICAgICAgICAgICAqIHNldCBrZXlDb2RlLCBjaGFyQ29kZSwgb3Igb3RoZXIgcHJvcGVydGllcyBpZiB5b3UgdXNlIGFcbiAgICAgICAgICAgICAqIFVJRXZlbnQsIHNvIHdlIGZpcnN0IG11c3QgdHJ5IHRvIGNyZWF0ZSBhIGdlbmVyaWMgZXZlbnQuIFRoZVxuICAgICAgICAgICAgICogZnVuIHBhcnQgaXMgdGhhdCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3Igb24gU2FmYXJpIDIueC4gVGhlXG4gICAgICAgICAgICAgKiBlbmQgcmVzdWx0IGlzIHRoYXQgd2UgbmVlZCBhbm90aGVyIHRyeS4uLmNhdGNoIHN0YXRlbWVudCBqdXN0IHRvXG4gICAgICAgICAgICAgKiBkZWFsIHdpdGggdGhpcyBtZXNzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgLy90cnkgdG8gY3JlYXRlIGdlbmVyaWMgZXZlbnQgLSB3aWxsIGZhaWwgaW4gU2FmYXJpIDIueFxuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50ID0gWS5jb25maWcuZG9jLmNyZWF0ZUV2ZW50KFwiRXZlbnRzXCIpO1xuXG4gICAgICAgICAgICB9IGNhdGNoICh1aWVycm9yIC8qOkVycm9yKi8pe1xuXG4gICAgICAgICAgICAgICAgLy90aGUgYWJvdmUgZmFpbGVkLCBzbyBjcmVhdGUgYSBVSUV2ZW50IGZvciBTYWZhcmkgMi54XG4gICAgICAgICAgICAgICAgY3VzdG9tRXZlbnQgPSBZLmNvbmZpZy5kb2MuY3JlYXRlRXZlbnQoXCJVSUV2ZW50c1wiKTtcblxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcblxuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LmluaXRFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcblxuICAgICAgICAgICAgICAgIC8vaW5pdGlhbGl6ZVxuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LmFsdEtleSA9IGFsdEtleTtcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudC5jdHJsS2V5ID0gY3RybEtleTtcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudC5zaGlmdEtleSA9IHNoaWZ0S2V5O1xuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50Lm1ldGFLZXkgPSBtZXRhS2V5O1xuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LmtleUNvZGUgPSBrZXlDb2RlO1xuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LmNoYXJDb2RlID0gY2hhckNvZGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy9maXJlIHRoZSBldmVudFxuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7XG5cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KFkuY29uZmlnLmRvYy5jcmVhdGVFdmVudE9iamVjdCkpeyAvL0lFXG5cbiAgICAgICAgLy9jcmVhdGUgYW4gSUUgZXZlbnQgb2JqZWN0XG4gICAgICAgIGN1c3RvbUV2ZW50ID0gWS5jb25maWcuZG9jLmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG5cbiAgICAgICAgLy9hc3NpZ24gYXZhaWxhYmxlIHByb3BlcnRpZXNcbiAgICAgICAgY3VzdG9tRXZlbnQuYnViYmxlcyA9IGJ1YmJsZXM7XG4gICAgICAgIGN1c3RvbUV2ZW50LmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICAgICAgICBjdXN0b21FdmVudC52aWV3ID0gdmlldztcbiAgICAgICAgY3VzdG9tRXZlbnQuY3RybEtleSA9IGN0cmxLZXk7XG4gICAgICAgIGN1c3RvbUV2ZW50LmFsdEtleSA9IGFsdEtleTtcbiAgICAgICAgY3VzdG9tRXZlbnQuc2hpZnRLZXkgPSBzaGlmdEtleTtcbiAgICAgICAgY3VzdG9tRXZlbnQubWV0YUtleSA9IG1ldGFLZXk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogSUUgZG9lc24ndCBzdXBwb3J0IGNoYXJDb2RlIGV4cGxpY2l0bHkuIENoYXJDb2RlIHNob3VsZFxuICAgICAgICAgKiB0YWtlIHByZWNlZGVuY2Ugb3ZlciBhbnkga2V5Q29kZSB2YWx1ZSBmb3IgYWNjdXJhdGVcbiAgICAgICAgICogcmVwcmVzZW50YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBjdXN0b21FdmVudC5rZXlDb2RlID0gKGNoYXJDb2RlID4gMCkgPyBjaGFyQ29kZSA6IGtleUNvZGU7XG5cbiAgICAgICAgLy9maXJlIHRoZSBldmVudFxuICAgICAgICB0YXJnZXQuZmlyZUV2ZW50KFwib25cIiArIHR5cGUsIGN1c3RvbUV2ZW50KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIFkuZXJyb3IoXCJzaW11bGF0ZUtleUV2ZW50KCk6IE5vIGV2ZW50IHNpbXVsYXRpb24gZnJhbWV3b3JrIHByZXNlbnQuXCIpO1xuICAgIH1cbn1cblxuLypcbiAqIE5vdGU6IEludGVudGlvbmFsbHkgbm90IGZvciBZVUlEb2MgZ2VuZXJhdGlvbi5cbiAqIFNpbXVsYXRlcyBhIG1vdXNlIGV2ZW50IHVzaW5nIHRoZSBnaXZlbiBldmVudCBpbmZvcm1hdGlvbiB0byBwb3B1bGF0ZVxuICogdGhlIGdlbmVyYXRlZCBldmVudCBvYmplY3QuIFRoaXMgbWV0aG9kIGRvZXMgYnJvd3Nlci1lcXVhbGl6aW5nXG4gKiBjYWxjdWxhdGlvbnMgdG8gYWNjb3VudCBmb3IgZGlmZmVyZW5jZXMgaW4gdGhlIERPTSBhbmQgSUUgZXZlbnQgbW9kZWxzXG4gKiBhcyB3ZWxsIGFzIGRpZmZlcmVudCBicm93c2VyIHF1aXJrcy5cbiAqIEBtZXRob2Qgc2ltdWxhdGVNb3VzZUV2ZW50XG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2YgdGhlIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gZmlyZS4gVGhpcyBjYW4gYmUgYW55IG9uZSBvZlxuICogICAgICB0aGUgZm9sbG93aW5nOiBjbGljaywgZGJsY2xpY2ssIG1vdXNlZG93biwgbW91c2V1cCwgbW91c2VvdXQsXG4gKiAgICAgIG1vdXNlb3ZlciwgYW5kIG1vdXNlbW92ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiB0aGUgZXZlbnQgY2FuIGJlXG4gKiAgICAgIGJ1YmJsZWQgdXAuIERPTSBMZXZlbCAyIHNwZWNpZmllcyB0aGF0IGFsbCBtb3VzZSBldmVudHMgYnViYmxlIGJ5XG4gKiAgICAgIGRlZmF1bHQuIFRoZSBkZWZhdWx0IGlzIHRydWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgKE9wdGlvbmFsKSBJbmRpY2F0ZXMgaWYgdGhlIGV2ZW50IGNhbiBiZVxuICogICAgICBjYW5jZWxlZCB1c2luZyBwcmV2ZW50RGVmYXVsdCgpLiBET00gTGV2ZWwgMiBzcGVjaWZpZXMgdGhhdCBhbGxcbiAqICAgICAgbW91c2UgZXZlbnRzIGV4Y2VwdCBtb3VzZW1vdmUgY2FuIGJlIGNhbmNlbGxlZC4gVGhlIGRlZmF1bHRcbiAqICAgICAgaXMgdHJ1ZSBmb3IgYWxsIGV2ZW50cyBleGNlcHQgbW91c2Vtb3ZlLCBmb3Igd2hpY2ggdGhlIGRlZmF1bHRcbiAqICAgICAgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge1dpbmRvd30gdmlldyAoT3B0aW9uYWwpIFRoZSB2aWV3IGNvbnRhaW5pbmcgdGhlIHRhcmdldC4gVGhpcyBpc1xuICogICAgICB0eXBpY2FsbHkgdGhlIHdpbmRvdyBvYmplY3QuIFRoZSBkZWZhdWx0IGlzIHdpbmRvdy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXRhaWwgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBtb3VzZSBidXR0b24gaGFzXG4gKiAgICAgIGJlZW4gdXNlZC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzY3JlZW5YIChPcHRpb25hbCkgVGhlIHgtY29vcmRpbmF0ZSBvbiB0aGUgc2NyZWVuIGF0IHdoaWNoXG4gKiAgICAgIHBvaW50IHRoZSBldmVudCBvY2N1cmVkLiBUaGUgZGVmYXVsdCBpcyAwLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNjcmVlblkgKE9wdGlvbmFsKSBUaGUgeS1jb29yZGluYXRlIG9uIHRoZSBzY3JlZW4gYXQgd2hpY2hcbiAqICAgICAgcG9pbnQgdGhlIGV2ZW50IG9jY3VyZWQuIFRoZSBkZWZhdWx0IGlzIDAuXG4gKiBAcGFyYW0ge051bWJlcn0gY2xpZW50WCAoT3B0aW9uYWwpIFRoZSB4LWNvb3JkaW5hdGUgb24gdGhlIGNsaWVudCBhdCB3aGljaFxuICogICAgICBwb2ludCB0aGUgZXZlbnQgb2NjdXJlZC4gVGhlIGRlZmF1bHQgaXMgMC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjbGllbnRZIChPcHRpb25hbCkgVGhlIHktY29vcmRpbmF0ZSBvbiB0aGUgY2xpZW50IGF0IHdoaWNoXG4gKiAgICAgIHBvaW50IHRoZSBldmVudCBvY2N1cmVkLiBUaGUgZGVmYXVsdCBpcyAwLlxuICogQHBhcmFtIHtCb29sZWFufSBjdHJsS2V5IChPcHRpb25hbCkgSW5kaWNhdGVzIGlmIG9uZSBvZiB0aGUgQ1RSTCBrZXlzXG4gKiAgICAgIGlzIHByZXNzZWQgd2hpbGUgdGhlIGV2ZW50IGlzIGZpcmluZy4gVGhlIGRlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsdEtleSAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiBvbmUgb2YgdGhlIEFMVCBrZXlzXG4gKiAgICAgIGlzIHByZXNzZWQgd2hpbGUgdGhlIGV2ZW50IGlzIGZpcmluZy4gVGhlIGRlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNoaWZ0S2V5IChPcHRpb25hbCkgSW5kaWNhdGVzIGlmIG9uZSBvZiB0aGUgU0hJRlQga2V5c1xuICogICAgICBpcyBwcmVzc2VkIHdoaWxlIHRoZSBldmVudCBpcyBmaXJpbmcuIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICogQHBhcmFtIHtCb29sZWFufSBtZXRhS2V5IChPcHRpb25hbCkgSW5kaWNhdGVzIGlmIG9uZSBvZiB0aGUgTUVUQSBrZXlzXG4gKiAgICAgIGlzIHByZXNzZWQgd2hpbGUgdGhlIGV2ZW50IGlzIGZpcmluZy4gVGhlIGRlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge051bWJlcn0gYnV0dG9uIChPcHRpb25hbCkgVGhlIGJ1dHRvbiBiZWluZyBwcmVzc2VkIHdoaWxlIHRoZSBldmVudFxuICogICAgICBpcyBleGVjdXRpbmcuIFRoZSB2YWx1ZSBzaG91bGQgYmUgMCBmb3IgdGhlIHByaW1hcnkgbW91c2UgYnV0dG9uXG4gKiAgICAgICh0eXBpY2FsbHkgdGhlIGxlZnQgYnV0dG9uKSwgMSBmb3IgdGhlIHRlcmNpYXJ5IG1vdXNlIGJ1dHRvblxuICogICAgICAodHlwaWNhbGx5IHRoZSBtaWRkbGUgYnV0dG9uKSwgYW5kIDIgZm9yIHRoZSBzZWNvbmRhcnkgbW91c2UgYnV0dG9uXG4gKiAgICAgICh0eXBpY2FsbHkgdGhlIHJpZ2h0IGJ1dHRvbikuIFRoZSBkZWZhdWx0IGlzIDAuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWxhdGVkVGFyZ2V0IChPcHRpb25hbCkgRm9yIG1vdXNlb3V0IGV2ZW50cyxcbiAqICAgICAgdGhpcyBpcyB0aGUgZWxlbWVudCB0aGF0IHRoZSBtb3VzZSBoYXMgbW92ZWQgdG8uIEZvciBtb3VzZW92ZXJcbiAqICAgICAgZXZlbnRzLCB0aGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgdGhlIG1vdXNlIGhhcyBtb3ZlZCBmcm9tLiBUaGlzXG4gKiAgICAgIGFyZ3VtZW50IGlzIGlnbm9yZWQgZm9yIGFsbCBvdGhlciBldmVudHMuIFRoZSBkZWZhdWx0IGlzIG51bGwuXG4gKi9cbmZ1bmN0aW9uIHNpbXVsYXRlTW91c2VFdmVudCh0YXJnZXQgLyo6SFRNTEVsZW1lbnQqLywgdHlwZSAvKjpTdHJpbmcqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzIC8qOkJvb2xlYW4qLywgIGNhbmNlbGFibGUgLyo6Qm9vbGVhbiovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcgLyo6V2luZG93Ki8sICAgICAgICBkZXRhaWwgLyo6aW50Ki8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuWCAvKjppbnQqLywgICAgICAgIHNjcmVlblkgLyo6aW50Ki8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WCAvKjppbnQqLywgICAgICAgIGNsaWVudFkgLyo6aW50Ki8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybEtleSAvKjpCb29sZWFuKi8sICAgIGFsdEtleSAvKjpCb29sZWFuKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRLZXkgLyo6Qm9vbGVhbiovLCAgIG1ldGFLZXkgLyo6Qm9vbGVhbiovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbiAvKjppbnQqLywgICAgICAgICByZWxhdGVkVGFyZ2V0IC8qOkhUTUxFbGVtZW50Ki8pIC8qOlZvaWQqL1xue1xuICAgIC8vY2hlY2sgdGFyZ2V0XG4gICAgaWYgKCF0YXJnZXQpe1xuICAgICAgICBZLmVycm9yKFwic2ltdWxhdGVNb3VzZUV2ZW50KCk6IEludmFsaWQgdGFyZ2V0LlwiKTtcbiAgICB9XG5cblxuICAgIGlmIChpc1N0cmluZyh0eXBlKSl7XG5cbiAgICAgICAgLy9tYWtlIHN1cmUgaXQncyBhIHN1cHBvcnRlZCBtb3VzZSBldmVudCBvciBhbiBtc1BvaW50ZXJFdmVudC5cbiAgICAgICAgaWYgKCFtb3VzZUV2ZW50c1t0eXBlLnRvTG93ZXJDYXNlKCldICYmICFwb2ludGVyRXZlbnRzW3R5cGVdKXtcbiAgICAgICAgICAgIFkuZXJyb3IoXCJzaW11bGF0ZU1vdXNlRXZlbnQoKTogRXZlbnQgdHlwZSAnXCIgKyB0eXBlICsgXCInIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBZLmVycm9yKFwic2ltdWxhdGVNb3VzZUV2ZW50KCk6IEV2ZW50IHR5cGUgbXVzdCBiZSBhIHN0cmluZy5cIik7XG4gICAgfVxuXG4gICAgLy9zZXR1cCBkZWZhdWx0IHZhbHVlc1xuICAgIGlmICghaXNCb29sZWFuKGJ1YmJsZXMpKXtcbiAgICAgICAgYnViYmxlcyA9IHRydWU7IC8vYWxsIG1vdXNlIGV2ZW50cyBidWJibGVcbiAgICB9XG4gICAgaWYgKCFpc0Jvb2xlYW4oY2FuY2VsYWJsZSkpe1xuICAgICAgICBjYW5jZWxhYmxlID0gKHR5cGUgIT09IFwibW91c2Vtb3ZlXCIpOyAvL21vdXNlbW92ZSBpcyB0aGUgb25seSBvbmUgdGhhdCBjYW4ndCBiZSBjYW5jZWxsZWRcbiAgICB9XG4gICAgaWYgKCFpc09iamVjdCh2aWV3KSl7XG4gICAgICAgIHZpZXcgPSBZLmNvbmZpZy53aW47IC8vdmlldyBpcyB0eXBpY2FsbHkgd2luZG93XG4gICAgfVxuICAgIGlmICghaXNOdW1iZXIoZGV0YWlsKSl7XG4gICAgICAgIGRldGFpbCA9IDE7ICAvL251bWJlciBvZiBtb3VzZSBjbGlja3MgbXVzdCBiZSBhdCBsZWFzdCBvbmVcbiAgICB9XG4gICAgaWYgKCFpc051bWJlcihzY3JlZW5YKSl7XG4gICAgICAgIHNjcmVlblggPSAwO1xuICAgIH1cbiAgICBpZiAoIWlzTnVtYmVyKHNjcmVlblkpKXtcbiAgICAgICAgc2NyZWVuWSA9IDA7XG4gICAgfVxuICAgIGlmICghaXNOdW1iZXIoY2xpZW50WCkpe1xuICAgICAgICBjbGllbnRYID0gMDtcbiAgICB9XG4gICAgaWYgKCFpc051bWJlcihjbGllbnRZKSl7XG4gICAgICAgIGNsaWVudFkgPSAwO1xuICAgIH1cbiAgICBpZiAoIWlzQm9vbGVhbihjdHJsS2V5KSl7XG4gICAgICAgIGN0cmxLZXkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0Jvb2xlYW4oYWx0S2V5KSl7XG4gICAgICAgIGFsdEtleSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzQm9vbGVhbihzaGlmdEtleSkpe1xuICAgICAgICBzaGlmdEtleSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzQm9vbGVhbihtZXRhS2V5KSl7XG4gICAgICAgIG1ldGFLZXkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc051bWJlcihidXR0b24pKXtcbiAgICAgICAgYnV0dG9uID0gMDtcbiAgICB9XG5cbiAgICByZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZFRhcmdldCB8fCBudWxsO1xuXG4gICAgLy90cnkgdG8gY3JlYXRlIGEgbW91c2UgZXZlbnRcbiAgICB2YXIgY3VzdG9tRXZlbnQgLyo6TW91c2VFdmVudCovID0gbnVsbDtcblxuICAgIC8vY2hlY2sgZm9yIERPTS1jb21wbGlhbnQgYnJvd3NlcnMgZmlyc3RcbiAgICBpZiAoaXNGdW5jdGlvbihZLmNvbmZpZy5kb2MuY3JlYXRlRXZlbnQpKXtcblxuICAgICAgICBjdXN0b21FdmVudCA9IFkuY29uZmlnLmRvYy5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuXG4gICAgICAgIC8vU2FmYXJpIDIueCAoV2ViS2l0IDQxOCkgc3RpbGwgZG9lc24ndCBpbXBsZW1lbnQgaW5pdE1vdXNlRXZlbnQoKVxuICAgICAgICBpZiAoY3VzdG9tRXZlbnQuaW5pdE1vdXNlRXZlbnQpe1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQuaW5pdE1vdXNlRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgdmlldywgZGV0YWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuWCwgc2NyZWVuWSwgY2xpZW50WCwgY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmxLZXksIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24sIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9IGVsc2UgeyAvL1NhZmFyaVxuXG4gICAgICAgICAgICAvL3RoZSBjbG9zZXN0IHRoaW5nIGF2YWlsYWJsZSBpbiBTYWZhcmkgMi54IGlzIFVJRXZlbnRzXG4gICAgICAgICAgICBjdXN0b21FdmVudCA9IFkuY29uZmlnLmRvYy5jcmVhdGVFdmVudChcIlVJRXZlbnRzXCIpO1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQuaW5pdEV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQudmlldyA9IHZpZXc7XG4gICAgICAgICAgICBjdXN0b21FdmVudC5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgICAgICBjdXN0b21FdmVudC5zY3JlZW5YID0gc2NyZWVuWDtcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50LnNjcmVlblkgPSBzY3JlZW5ZO1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQuY2xpZW50WCA9IGNsaWVudFg7XG4gICAgICAgICAgICBjdXN0b21FdmVudC5jbGllbnRZID0gY2xpZW50WTtcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50LmN0cmxLZXkgPSBjdHJsS2V5O1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQuYWx0S2V5ID0gYWx0S2V5O1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQubWV0YUtleSA9IG1ldGFLZXk7XG4gICAgICAgICAgICBjdXN0b21FdmVudC5zaGlmdEtleSA9IHNoaWZ0S2V5O1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQuYnV0dG9uID0gYnV0dG9uO1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBDaGVjayB0byBzZWUgaWYgcmVsYXRlZFRhcmdldCBoYXMgYmVlbiBhc3NpZ25lZC4gRmlyZWZveFxuICAgICAgICAgKiB2ZXJzaW9ucyBsZXNzIHRoYW4gMi4wIGRvbid0IGFsbG93IGl0IHRvIGJlIGFzc2lnbmVkIHZpYVxuICAgICAgICAgKiBpbml0TW91c2VFdmVudCgpIGFuZCB0aGUgcHJvcGVydHkgaXMgcmVhZG9ubHkgYWZ0ZXIgZXZlbnRcbiAgICAgICAgICogY3JlYXRpb24sIHNvIGluIG9yZGVyIHRvIGtlZXAgWUFIT08udXRpbC5nZXRSZWxhdGVkVGFyZ2V0KClcbiAgICAgICAgICogd29ya2luZywgYXNzaWduIHRvIHRoZSBJRSBwcm9wcmlldGFyeSB0b0VsZW1lbnQgcHJvcGVydHlcbiAgICAgICAgICogZm9yIG1vdXNlb3V0IGV2ZW50IGFuZCBmcm9tRWxlbWVudCBwcm9wZXJ0eSBmb3IgbW91c2VvdmVyXG4gICAgICAgICAqIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgJiYgIWN1c3RvbUV2ZW50LnJlbGF0ZWRUYXJnZXQpe1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwibW91c2VvdXRcIil7XG4gICAgICAgICAgICAgICAgY3VzdG9tRXZlbnQudG9FbGVtZW50ID0gcmVsYXRlZFRhcmdldDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJtb3VzZW92ZXJcIil7XG4gICAgICAgICAgICAgICAgY3VzdG9tRXZlbnQuZnJvbUVsZW1lbnQgPSByZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9maXJlIHRoZSBldmVudFxuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7XG5cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KFkuY29uZmlnLmRvYy5jcmVhdGVFdmVudE9iamVjdCkpeyAvL0lFXG5cbiAgICAgICAgLy9jcmVhdGUgYW4gSUUgZXZlbnQgb2JqZWN0XG4gICAgICAgIGN1c3RvbUV2ZW50ID0gWS5jb25maWcuZG9jLmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG5cbiAgICAgICAgLy9hc3NpZ24gYXZhaWxhYmxlIHByb3BlcnRpZXNcbiAgICAgICAgY3VzdG9tRXZlbnQuYnViYmxlcyA9IGJ1YmJsZXM7XG4gICAgICAgIGN1c3RvbUV2ZW50LmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICAgICAgICBjdXN0b21FdmVudC52aWV3ID0gdmlldztcbiAgICAgICAgY3VzdG9tRXZlbnQuZGV0YWlsID0gZGV0YWlsO1xuICAgICAgICBjdXN0b21FdmVudC5zY3JlZW5YID0gc2NyZWVuWDtcbiAgICAgICAgY3VzdG9tRXZlbnQuc2NyZWVuWSA9IHNjcmVlblk7XG4gICAgICAgIGN1c3RvbUV2ZW50LmNsaWVudFggPSBjbGllbnRYO1xuICAgICAgICBjdXN0b21FdmVudC5jbGllbnRZID0gY2xpZW50WTtcbiAgICAgICAgY3VzdG9tRXZlbnQuY3RybEtleSA9IGN0cmxLZXk7XG4gICAgICAgIGN1c3RvbUV2ZW50LmFsdEtleSA9IGFsdEtleTtcbiAgICAgICAgY3VzdG9tRXZlbnQubWV0YUtleSA9IG1ldGFLZXk7XG4gICAgICAgIGN1c3RvbUV2ZW50LnNoaWZ0S2V5ID0gc2hpZnRLZXk7XG5cbiAgICAgICAgLy9maXggYnV0dG9uIHByb3BlcnR5IGZvciBJRSdzIHdhY2t5IGltcGxlbWVudGF0aW9uXG4gICAgICAgIHN3aXRjaChidXR0b24pe1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LmJ1dHRvbiA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY3VzdG9tRXZlbnQuYnV0dG9uID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAvL2xlYXZlIGFzIGlzXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LmJ1dHRvbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBIYXZlIHRvIHVzZSByZWxhdGVkVGFyZ2V0IGJlY2F1c2UgSUUgd29uJ3QgYWxsb3cgYXNzaWdubWVudFxuICAgICAgICAgKiB0byB0b0VsZW1lbnQgb3IgZnJvbUVsZW1lbnQgb24gZ2VuZXJpYyBldmVudHMuIFRoaXMga2VlcHNcbiAgICAgICAgICogWUFIT08udXRpbC5jdXN0b21FdmVudC5nZXRSZWxhdGVkVGFyZ2V0KCkgZnVuY3Rpb25hbC5cbiAgICAgICAgICovXG4gICAgICAgIGN1c3RvbUV2ZW50LnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkVGFyZ2V0O1xuXG4gICAgICAgIC8vZmlyZSB0aGUgZXZlbnRcbiAgICAgICAgdGFyZ2V0LmZpcmVFdmVudChcIm9uXCIgKyB0eXBlLCBjdXN0b21FdmVudCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBZLmVycm9yKFwic2ltdWxhdGVNb3VzZUV2ZW50KCk6IE5vIGV2ZW50IHNpbXVsYXRpb24gZnJhbWV3b3JrIHByZXNlbnQuXCIpO1xuICAgIH1cbn1cblxuLypcbiAqIE5vdGU6IEludGVudGlvbmFsbHkgbm90IGZvciBZVUlEb2MgZ2VuZXJhdGlvbi5cbiAqIFNpbXVsYXRlcyBhIFVJIGV2ZW50IHVzaW5nIHRoZSBnaXZlbiBldmVudCBpbmZvcm1hdGlvbiB0byBwb3B1bGF0ZVxuICogdGhlIGdlbmVyYXRlZCBldmVudCBvYmplY3QuIFRoaXMgbWV0aG9kIGRvZXMgYnJvd3Nlci1lcXVhbGl6aW5nXG4gKiBjYWxjdWxhdGlvbnMgdG8gYWNjb3VudCBmb3IgZGlmZmVyZW5jZXMgaW4gdGhlIERPTSBhbmQgSUUgZXZlbnQgbW9kZWxzXG4gKiBhcyB3ZWxsIGFzIGRpZmZlcmVudCBicm93c2VyIHF1aXJrcy5cbiAqIEBtZXRob2Qgc2ltdWxhdGVIVE1MRXZlbnRcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBmaXJlLiBUaGlzIGNhbiBiZSBhbnkgb25lIG9mXG4gKiAgICAgIHRoZSBmb2xsb3dpbmc6IGNsaWNrLCBkYmxjbGljaywgbW91c2Vkb3duLCBtb3VzZXVwLCBtb3VzZW91dCxcbiAqICAgICAgbW91c2VvdmVyLCBhbmQgbW91c2Vtb3ZlLlxuICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIChPcHRpb25hbCkgSW5kaWNhdGVzIGlmIHRoZSBldmVudCBjYW4gYmVcbiAqICAgICAgYnViYmxlZCB1cC4gRE9NIExldmVsIDIgc3BlY2lmaWVzIHRoYXQgYWxsIG1vdXNlIGV2ZW50cyBidWJibGUgYnlcbiAqICAgICAgZGVmYXVsdC4gVGhlIGRlZmF1bHQgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiB0aGUgZXZlbnQgY2FuIGJlXG4gKiAgICAgIGNhbmNlbGVkIHVzaW5nIHByZXZlbnREZWZhdWx0KCkuIERPTSBMZXZlbCAyIHNwZWNpZmllcyB0aGF0IGFsbFxuICogICAgICBtb3VzZSBldmVudHMgZXhjZXB0IG1vdXNlbW92ZSBjYW4gYmUgY2FuY2VsbGVkLiBUaGUgZGVmYXVsdFxuICogICAgICBpcyB0cnVlIGZvciBhbGwgZXZlbnRzIGV4Y2VwdCBtb3VzZW1vdmUsIGZvciB3aGljaCB0aGUgZGVmYXVsdFxuICogICAgICBpcyBmYWxzZS5cbiAqIEBwYXJhbSB7V2luZG93fSB2aWV3IChPcHRpb25hbCkgVGhlIHZpZXcgY29udGFpbmluZyB0aGUgdGFyZ2V0LiBUaGlzIGlzXG4gKiAgICAgIHR5cGljYWxseSB0aGUgd2luZG93IG9iamVjdC4gVGhlIGRlZmF1bHQgaXMgd2luZG93LlxuICogQHBhcmFtIHtOdW1iZXJ9IGRldGFpbCAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIG1vdXNlIGJ1dHRvbiBoYXNcbiAqICAgICAgYmVlbiB1c2VkLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxLlxuICovXG5mdW5jdGlvbiBzaW11bGF0ZVVJRXZlbnQodGFyZ2V0IC8qOkhUTUxFbGVtZW50Ki8sIHR5cGUgLyo6U3RyaW5nKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlcyAvKjpCb29sZWFuKi8sICBjYW5jZWxhYmxlIC8qOkJvb2xlYW4qLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3IC8qOldpbmRvdyovLCAgICAgICAgZGV0YWlsIC8qOmludCovKSAvKjpWb2lkKi9cbntcblxuICAgIC8vY2hlY2sgdGFyZ2V0XG4gICAgaWYgKCF0YXJnZXQpe1xuICAgICAgICBZLmVycm9yKFwic2ltdWxhdGVVSUV2ZW50KCk6IEludmFsaWQgdGFyZ2V0LlwiKTtcbiAgICB9XG5cbiAgICAvL2NoZWNrIGV2ZW50IHR5cGVcbiAgICBpZiAoaXNTdHJpbmcodHlwZSkpe1xuICAgICAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vbWFrZSBzdXJlIGl0J3MgYSBzdXBwb3J0ZWQgbW91c2UgZXZlbnRcbiAgICAgICAgaWYgKCF1aUV2ZW50c1t0eXBlXSl7XG4gICAgICAgICAgICBZLmVycm9yKFwic2ltdWxhdGVVSUV2ZW50KCk6IEV2ZW50IHR5cGUgJ1wiICsgdHlwZSArIFwiJyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIFkuZXJyb3IoXCJzaW11bGF0ZVVJRXZlbnQoKTogRXZlbnQgdHlwZSBtdXN0IGJlIGEgc3RyaW5nLlwiKTtcbiAgICB9XG5cbiAgICAvL3RyeSB0byBjcmVhdGUgYSBtb3VzZSBldmVudFxuICAgIHZhciBjdXN0b21FdmVudCA9IG51bGw7XG5cblxuICAgIC8vc2V0dXAgZGVmYXVsdCB2YWx1ZXNcbiAgICBpZiAoIWlzQm9vbGVhbihidWJibGVzKSl7XG4gICAgICAgIGJ1YmJsZXMgPSAodHlwZSBpbiBidWJibGVFdmVudHMpOyAgLy9ub3QgYWxsIGV2ZW50cyBidWJibGVcbiAgICB9XG4gICAgaWYgKCFpc0Jvb2xlYW4oY2FuY2VsYWJsZSkpe1xuICAgICAgICBjYW5jZWxhYmxlID0gKHR5cGUgPT09IFwic3VibWl0XCIpOyAvL3N1Ym1pdCBpcyB0aGUgb25seSBvbmUgdGhhdCBjYW4gYmUgY2FuY2VsbGVkXG4gICAgfVxuICAgIGlmICghaXNPYmplY3Qodmlldykpe1xuICAgICAgICB2aWV3ID0gWS5jb25maWcud2luOyAvL3ZpZXcgaXMgdHlwaWNhbGx5IHdpbmRvd1xuICAgIH1cbiAgICBpZiAoIWlzTnVtYmVyKGRldGFpbCkpe1xuICAgICAgICBkZXRhaWwgPSAxOyAgLy91c3VhbGx5IG5vdCB1c2VkIGJ1dCBkZWZhdWx0ZWQgdG8gdGhpc1xuICAgIH1cblxuICAgIC8vY2hlY2sgZm9yIERPTS1jb21wbGlhbnQgYnJvd3NlcnMgZmlyc3RcbiAgICBpZiAoaXNGdW5jdGlvbihZLmNvbmZpZy5kb2MuY3JlYXRlRXZlbnQpKXtcblxuICAgICAgICAvL2p1c3QgYSBnZW5lcmljIFVJIEV2ZW50IG9iamVjdCBpcyBuZWVkZWRcbiAgICAgICAgY3VzdG9tRXZlbnQgPSBZLmNvbmZpZy5kb2MuY3JlYXRlRXZlbnQoXCJVSUV2ZW50c1wiKTtcbiAgICAgICAgY3VzdG9tRXZlbnQuaW5pdFVJRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgdmlldywgZGV0YWlsKTtcblxuICAgICAgICAvL2ZpcmUgdGhlIGV2ZW50XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTtcblxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoWS5jb25maWcuZG9jLmNyZWF0ZUV2ZW50T2JqZWN0KSl7IC8vSUVcblxuICAgICAgICAvL2NyZWF0ZSBhbiBJRSBldmVudCBvYmplY3RcbiAgICAgICAgY3VzdG9tRXZlbnQgPSBZLmNvbmZpZy5kb2MuY3JlYXRlRXZlbnRPYmplY3QoKTtcblxuICAgICAgICAvL2Fzc2lnbiBhdmFpbGFibGUgcHJvcGVydGllc1xuICAgICAgICBjdXN0b21FdmVudC5idWJibGVzID0gYnViYmxlcztcbiAgICAgICAgY3VzdG9tRXZlbnQuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7XG4gICAgICAgIGN1c3RvbUV2ZW50LnZpZXcgPSB2aWV3O1xuICAgICAgICBjdXN0b21FdmVudC5kZXRhaWwgPSBkZXRhaWw7XG5cbiAgICAgICAgLy9maXJlIHRoZSBldmVudFxuICAgICAgICB0YXJnZXQuZmlyZUV2ZW50KFwib25cIiArIHR5cGUsIGN1c3RvbUV2ZW50KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIFkuZXJyb3IoXCJzaW11bGF0ZVVJRXZlbnQoKTogTm8gZXZlbnQgc2ltdWxhdGlvbiBmcmFtZXdvcmsgcHJlc2VudC5cIik7XG4gICAgfVxufVxuXG4vKlxuICogKGlPUyBvbmx5KSBUaGlzIGlzIGZvciBjcmVhdGluZyBuYXRpdmUgRE9NIGdlc3R1cmUgZXZlbnRzIHdoaWNoIG9ubHkgaU9TXG4gKiB2Mi4wKyBpcyBzdXBwb3J0aW5nLlxuICpcbiAqIEBtZXRob2Qgc2ltdWxhdGVHZXN0dXJlRXZlbnRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBmaXJlLiBUaGlzIGNhbiBiZSBhbnkgb25lIG9mXG4gKiAgICAgIHRoZSBmb2xsb3dpbmc6IHRvdWNoc3RhcnQsIHRvdWNobW92ZSwgdG91Y2hlbmQsIHRvdWNoY2FuY2VsLlxuICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIChPcHRpb25hbCkgSW5kaWNhdGVzIGlmIHRoZSBldmVudCBjYW4gYmVcbiAqICAgICAgYnViYmxlZCB1cC4gRE9NIExldmVsIDIgc3BlY2lmaWVzIHRoYXQgYWxsIG1vdXNlIGV2ZW50cyBidWJibGUgYnlcbiAqICAgICAgZGVmYXVsdC4gVGhlIGRlZmF1bHQgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiB0aGUgZXZlbnQgY2FuIGJlXG4gKiAgICAgIGNhbmNlbGVkIHVzaW5nIHByZXZlbnREZWZhdWx0KCkuIERPTSBMZXZlbCAyIHNwZWNpZmllcyB0aGF0IGFsbFxuICogICAgICB0b3VjaCBldmVudHMgZXhjZXB0IHRvdWNoY2FuY2VsIGNhbiBiZSBjYW5jZWxsZWQuIFRoZSBkZWZhdWx0XG4gKiAgICAgIGlzIHRydWUgZm9yIGFsbCBldmVudHMgZXhjZXB0IHRvdWNoY2FuY2VsLCBmb3Igd2hpY2ggdGhlIGRlZmF1bHRcbiAqICAgICAgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge1dpbmRvd30gdmlldyAoT3B0aW9uYWwpIFRoZSB2aWV3IGNvbnRhaW5pbmcgdGhlIHRhcmdldC4gVGhpcyBpc1xuICogICAgICB0eXBpY2FsbHkgdGhlIHdpbmRvdyBvYmplY3QuIFRoZSBkZWZhdWx0IGlzIHdpbmRvdy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXRhaWwgKE9wdGlvbmFsKSBTcGVjaWZpZXMgc29tZSBkZXRhaWwgaW5mb3JtYXRpb24gYWJvdXRcbiAqICAgICAgdGhlIGV2ZW50IGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBldmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzY3JlZW5YIChPcHRpb25hbCkgVGhlIHgtY29vcmRpbmF0ZSBvbiB0aGUgc2NyZWVuIGF0IHdoaWNoXG4gKiAgICAgIHBvaW50IHRoZSBldmVudCBvY2N1cmVkLiBUaGUgZGVmYXVsdCBpcyAwLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNjcmVlblkgKE9wdGlvbmFsKSBUaGUgeS1jb29yZGluYXRlIG9uIHRoZSBzY3JlZW4gYXQgd2hpY2hcbiAqICAgICAgcG9pbnQgdGhlIGV2ZW50IG9jY3VyZWQuIFRoZSBkZWZhdWx0IGlzIDAuXG4gKiBAcGFyYW0ge051bWJlcn0gY2xpZW50WCAoT3B0aW9uYWwpIFRoZSB4LWNvb3JkaW5hdGUgb24gdGhlIGNsaWVudCBhdCB3aGljaFxuICogICAgICBwb2ludCB0aGUgZXZlbnQgb2NjdXJlZC4gVGhlIGRlZmF1bHQgaXMgMC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjbGllbnRZIChPcHRpb25hbCkgVGhlIHktY29vcmRpbmF0ZSBvbiB0aGUgY2xpZW50IGF0IHdoaWNoXG4gKiAgICAgIHBvaW50IHRoZSBldmVudCBvY2N1cmVkLiBUaGUgZGVmYXVsdCBpcyAwLlxuICogQHBhcmFtIHtCb29sZWFufSBjdHJsS2V5IChPcHRpb25hbCkgSW5kaWNhdGVzIGlmIG9uZSBvZiB0aGUgQ1RSTCBrZXlzXG4gKiAgICAgIGlzIHByZXNzZWQgd2hpbGUgdGhlIGV2ZW50IGlzIGZpcmluZy4gVGhlIGRlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsdEtleSAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiBvbmUgb2YgdGhlIEFMVCBrZXlzXG4gKiAgICAgIGlzIHByZXNzZWQgd2hpbGUgdGhlIGV2ZW50IGlzIGZpcmluZy4gVGhlIGRlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNoaWZ0S2V5IChPcHRpb25hbCkgSW5kaWNhdGVzIGlmIG9uZSBvZiB0aGUgU0hJRlQga2V5c1xuICogICAgICBpcyBwcmVzc2VkIHdoaWxlIHRoZSBldmVudCBpcyBmaXJpbmcuIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICogQHBhcmFtIHtCb29sZWFufSBtZXRhS2V5IChPcHRpb25hbCkgSW5kaWNhdGVzIGlmIG9uZSBvZiB0aGUgTUVUQSBrZXlzXG4gKiAgICAgIGlzIHByZXNzZWQgd2hpbGUgdGhlIGV2ZW50IGlzIGZpcmluZy4gVGhlIGRlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgKGlPUyB2Misgb25seSkgVGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGZpbmdlcnNcbiAqICAgICAgc2luY2UgdGhlIHN0YXJ0IG9mIGFuIGV2ZW50IGFzIGEgbXVsdGlwbGllciBvZiB0aGUgaW5pdGlhbCBkaXN0YW5jZS5cbiAqICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgMS4wLlxuICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uIChpT1MgdjIrIG9ubHkpIFRoZSBkZWx0YSByb3RhdGlvbiBzaW5jZSB0aGUgc3RhcnRcbiAqICAgICAgb2YgYW4gZXZlbnQsIGluIGRlZ3JlZXMsIHdoZXJlIGNsb2Nrd2lzZSBpcyBwb3NpdGl2ZSBhbmRcbiAqICAgICAgY291bnRlci1jbG9ja3dpc2UgaXMgbmVnYXRpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDAuMC5cbiAqL1xuZnVuY3Rpb24gc2ltdWxhdGVHZXN0dXJlRXZlbnQodGFyZ2V0LCB0eXBlLFxuICAgIGJ1YmJsZXMsICAgICAgICAgICAgLy8gYm9vbGVhblxuICAgIGNhbmNlbGFibGUsICAgICAgICAgLy8gYm9vbGVhblxuICAgIHZpZXcsICAgICAgICAgICAgICAgLy8gRE9NV2luZG93XG4gICAgZGV0YWlsLCAgICAgICAgICAgICAvLyBsb25nXG4gICAgc2NyZWVuWCwgc2NyZWVuWSwgICAvLyBsb25nXG4gICAgY2xpZW50WCwgY2xpZW50WSwgICAvLyBsb25nXG4gICAgY3RybEtleSwgYWx0S2V5LCBzaGlmdEtleSwgbWV0YUtleSwgLy8gYm9vbGVhblxuICAgIHNjYWxlLCAgICAgICAgICAgICAgLy8gZmxvYXRcbiAgICByb3RhdGlvbiAgICAgICAgICAgIC8vIGZsb2F0XG4pIHtcbiAgICB2YXIgY3VzdG9tRXZlbnQ7XG5cbiAgICBpZighWS5VQS5pb3MgfHwgWS5VQS5pb3M8Mi4wKSB7XG4gICAgICAgIFkuZXJyb3IoXCJzaW11bGF0ZUdlc3R1cmVFdmVudCgpOiBOYXRpdmUgZ2VzdHVyZSBET00gZXZlbnRmcmFtZSBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgcGxhdGZvcm0uXCIpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHRhZ2V0XG4gICAgaWYgKCF0YXJnZXQpe1xuICAgICAgICBZLmVycm9yKFwic2ltdWxhdGVHZXN0dXJlRXZlbnQoKTogSW52YWxpZCB0YXJnZXQuXCIpO1xuICAgIH1cblxuICAgIC8vY2hlY2sgZXZlbnQgdHlwZVxuICAgIGlmIChZLkxhbmcuaXNTdHJpbmcodHlwZSkpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvL21ha2Ugc3VyZSBpdCdzIGEgc3VwcG9ydGVkIHRvdWNoIGV2ZW50XG4gICAgICAgIGlmICghZ2VzdHVyZUV2ZW50c1t0eXBlXSl7XG4gICAgICAgICAgICBZLmVycm9yKFwic2ltdWxhdGVUb3VjaEV2ZW50KCk6IEV2ZW50IHR5cGUgJ1wiICsgdHlwZSArIFwiJyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIFkuZXJyb3IoXCJzaW11bGF0ZUdlc3R1cmVFdmVudCgpOiBFdmVudCB0eXBlIG11c3QgYmUgYSBzdHJpbmcuXCIpO1xuICAgIH1cblxuICAgIC8vIHNldHVwIGRlZmF1bHQgdmFsdWVzXG4gICAgaWYgKCFZLkxhbmcuaXNCb29sZWFuKGJ1YmJsZXMpKSB7IGJ1YmJsZXMgPSB0cnVlOyB9IC8vIGJ1YmJsZSBieSBkZWZhdWx0XG4gICAgaWYgKCFZLkxhbmcuaXNCb29sZWFuKGNhbmNlbGFibGUpKSB7IGNhbmNlbGFibGUgPSB0cnVlOyB9XG4gICAgaWYgKCFZLkxhbmcuaXNPYmplY3QodmlldykpICAgICB7IHZpZXcgPSBZLmNvbmZpZy53aW47IH1cbiAgICBpZiAoIVkuTGFuZy5pc051bWJlcihkZXRhaWwpKSAgIHsgZGV0YWlsID0gMjsgfSAgICAgLy8gdXN1YWxseSBub3QgdXNlZC5cbiAgICBpZiAoIVkuTGFuZy5pc051bWJlcihzY3JlZW5YKSkgIHsgc2NyZWVuWCA9IDA7IH1cbiAgICBpZiAoIVkuTGFuZy5pc051bWJlcihzY3JlZW5ZKSkgIHsgc2NyZWVuWSA9IDA7IH1cbiAgICBpZiAoIVkuTGFuZy5pc051bWJlcihjbGllbnRYKSkgIHsgY2xpZW50WCA9IDA7IH1cbiAgICBpZiAoIVkuTGFuZy5pc051bWJlcihjbGllbnRZKSkgIHsgY2xpZW50WSA9IDA7IH1cbiAgICBpZiAoIVkuTGFuZy5pc0Jvb2xlYW4oY3RybEtleSkpIHsgY3RybEtleSA9IGZhbHNlOyB9XG4gICAgaWYgKCFZLkxhbmcuaXNCb29sZWFuKGFsdEtleSkpICB7IGFsdEtleSA9IGZhbHNlOyB9XG4gICAgaWYgKCFZLkxhbmcuaXNCb29sZWFuKHNoaWZ0S2V5KSl7IHNoaWZ0S2V5ID0gZmFsc2U7IH1cbiAgICBpZiAoIVkuTGFuZy5pc0Jvb2xlYW4obWV0YUtleSkpIHsgbWV0YUtleSA9IGZhbHNlOyB9XG5cbiAgICBpZiAoIVkuTGFuZy5pc051bWJlcihzY2FsZSkpeyBzY2FsZSA9IDEuMDsgfVxuICAgIGlmICghWS5MYW5nLmlzTnVtYmVyKHJvdGF0aW9uKSl7IHJvdGF0aW9uID0gMC4wOyB9XG5cbiAgICBjdXN0b21FdmVudCA9IFkuY29uZmlnLmRvYy5jcmVhdGVFdmVudChcIkdlc3R1cmVFdmVudFwiKTtcblxuICAgIGN1c3RvbUV2ZW50LmluaXRHZXN0dXJlRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgdmlldywgZGV0YWlsLFxuICAgICAgICBzY3JlZW5YLCBzY3JlZW5ZLCBjbGllbnRYLCBjbGllbnRZLFxuICAgICAgICBjdHJsS2V5LCBhbHRLZXksIHNoaWZ0S2V5LCBtZXRhS2V5LFxuICAgICAgICB0YXJnZXQsIHNjYWxlLCByb3RhdGlvbik7XG5cbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7XG59XG5cblxuLypcbiAqIEBtZXRob2Qgc2ltdWxhdGVUb3VjaEV2ZW50XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2YgdGhlIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gZmlyZS4gVGhpcyBjYW4gYmUgYW55IG9uZSBvZlxuICogICAgICB0aGUgZm9sbG93aW5nOiB0b3VjaHN0YXJ0LCB0b3VjaG1vdmUsIHRvdWNoZW5kLCB0b3VjaGNhbmNlbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiB0aGUgZXZlbnQgY2FuIGJlXG4gKiAgICAgIGJ1YmJsZWQgdXAuIERPTSBMZXZlbCAyIHNwZWNpZmllcyB0aGF0IGFsbCBtb3VzZSBldmVudHMgYnViYmxlIGJ5XG4gKiAgICAgIGRlZmF1bHQuIFRoZSBkZWZhdWx0IGlzIHRydWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgKE9wdGlvbmFsKSBJbmRpY2F0ZXMgaWYgdGhlIGV2ZW50IGNhbiBiZVxuICogICAgICBjYW5jZWxlZCB1c2luZyBwcmV2ZW50RGVmYXVsdCgpLiBET00gTGV2ZWwgMiBzcGVjaWZpZXMgdGhhdCBhbGxcbiAqICAgICAgdG91Y2ggZXZlbnRzIGV4Y2VwdCB0b3VjaGNhbmNlbCBjYW4gYmUgY2FuY2VsbGVkLiBUaGUgZGVmYXVsdFxuICogICAgICBpcyB0cnVlIGZvciBhbGwgZXZlbnRzIGV4Y2VwdCB0b3VjaGNhbmNlbCwgZm9yIHdoaWNoIHRoZSBkZWZhdWx0XG4gKiAgICAgIGlzIGZhbHNlLlxuICogQHBhcmFtIHtXaW5kb3d9IHZpZXcgKE9wdGlvbmFsKSBUaGUgdmlldyBjb250YWluaW5nIHRoZSB0YXJnZXQuIFRoaXMgaXNcbiAqICAgICAgdHlwaWNhbGx5IHRoZSB3aW5kb3cgb2JqZWN0LiBUaGUgZGVmYXVsdCBpcyB3aW5kb3cuXG4gKiBAcGFyYW0ge051bWJlcn0gZGV0YWlsIChPcHRpb25hbCkgU3BlY2lmaWVzIHNvbWUgZGV0YWlsIGluZm9ybWF0aW9uIGFib3V0XG4gKiAgICAgIHRoZSBldmVudCBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgZXZlbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gc2NyZWVuWCAoT3B0aW9uYWwpIFRoZSB4LWNvb3JkaW5hdGUgb24gdGhlIHNjcmVlbiBhdCB3aGljaFxuICogICAgICBwb2ludCB0aGUgZXZlbnQgb2NjdXJlZC4gVGhlIGRlZmF1bHQgaXMgMC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzY3JlZW5ZIChPcHRpb25hbCkgVGhlIHktY29vcmRpbmF0ZSBvbiB0aGUgc2NyZWVuIGF0IHdoaWNoXG4gKiAgICAgIHBvaW50IHRoZSBldmVudCBvY2N1cmVkLiBUaGUgZGVmYXVsdCBpcyAwLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNsaWVudFggKE9wdGlvbmFsKSBUaGUgeC1jb29yZGluYXRlIG9uIHRoZSBjbGllbnQgYXQgd2hpY2hcbiAqICAgICAgcG9pbnQgdGhlIGV2ZW50IG9jY3VyZWQuIFRoZSBkZWZhdWx0IGlzIDAuXG4gKiBAcGFyYW0ge051bWJlcn0gY2xpZW50WSAoT3B0aW9uYWwpIFRoZSB5LWNvb3JkaW5hdGUgb24gdGhlIGNsaWVudCBhdCB3aGljaFxuICogICAgICBwb2ludCB0aGUgZXZlbnQgb2NjdXJlZC4gVGhlIGRlZmF1bHQgaXMgMC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY3RybEtleSAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiBvbmUgb2YgdGhlIENUUkwga2V5c1xuICogICAgICBpcyBwcmVzc2VkIHdoaWxlIHRoZSBldmVudCBpcyBmaXJpbmcuIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICogQHBhcmFtIHtCb29sZWFufSBhbHRLZXkgKE9wdGlvbmFsKSBJbmRpY2F0ZXMgaWYgb25lIG9mIHRoZSBBTFQga2V5c1xuICogICAgICBpcyBwcmVzc2VkIHdoaWxlIHRoZSBldmVudCBpcyBmaXJpbmcuIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICogQHBhcmFtIHtCb29sZWFufSBzaGlmdEtleSAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiBvbmUgb2YgdGhlIFNISUZUIGtleXNcbiAqICAgICAgaXMgcHJlc3NlZCB3aGlsZSB0aGUgZXZlbnQgaXMgZmlyaW5nLiBUaGUgZGVmYXVsdCBpcyBmYWxzZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbWV0YUtleSAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiBvbmUgb2YgdGhlIE1FVEEga2V5c1xuICogICAgICBpcyBwcmVzc2VkIHdoaWxlIHRoZSBldmVudCBpcyBmaXJpbmcuIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICogQHBhcmFtIHtUb3VjaExpc3R9IHRvdWNoZXMgQSBjb2xsZWN0aW9uIG9mIFRvdWNoIG9iamVjdHMgcmVwcmVzZW50aW5nXG4gKiAgICAgIGFsbCB0b3VjaGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtUb3VjaExpc3R9IHRhcmdldFRvdWNoZXMgQSBjb2xsZWN0aW9uIG9mIFRvdWNoIG9iamVjdHNcbiAqICAgICAgcmVwcmVzZW50aW5nIGFsbCB0b3VjaGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRhcmdldC5cbiAqIEBwYXJhbSB7VG91Y2hMaXN0fSBjaGFuZ2VkVG91Y2hlcyBBIGNvbGxlY3Rpb24gb2YgVG91Y2ggb2JqZWN0c1xuICogICAgICByZXByZXNlbnRpbmcgYWxsIHRvdWNoZXMgdGhhdCBjaGFuZ2VkIGluIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgKGlPUyB2Misgb25seSkgVGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGZpbmdlcnNcbiAqICAgICAgc2luY2UgdGhlIHN0YXJ0IG9mIGFuIGV2ZW50IGFzIGEgbXVsdGlwbGllciBvZiB0aGUgaW5pdGlhbCBkaXN0YW5jZS5cbiAqICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgMS4wLlxuICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uIChpT1MgdjIrIG9ubHkpIFRoZSBkZWx0YSByb3RhdGlvbiBzaW5jZSB0aGUgc3RhcnRcbiAqICAgICAgb2YgYW4gZXZlbnQsIGluIGRlZ3JlZXMsIHdoZXJlIGNsb2Nrd2lzZSBpcyBwb3NpdGl2ZSBhbmRcbiAqICAgICAgY291bnRlci1jbG9ja3dpc2UgaXMgbmVnYXRpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDAuMC5cbiAqL1xuZnVuY3Rpb24gc2ltdWxhdGVUb3VjaEV2ZW50KHRhcmdldCwgdHlwZSxcbiAgICBidWJibGVzLCAgICAgICAgICAgIC8vIGJvb2xlYW5cbiAgICBjYW5jZWxhYmxlLCAgICAgICAgIC8vIGJvb2xlYW5cbiAgICB2aWV3LCAgICAgICAgICAgICAgIC8vIERPTVdpbmRvd1xuICAgIGRldGFpbCwgICAgICAgICAgICAgLy8gbG9uZ1xuICAgIHNjcmVlblgsIHNjcmVlblksICAgLy8gbG9uZ1xuICAgIGNsaWVudFgsIGNsaWVudFksICAgLy8gbG9uZ1xuICAgIGN0cmxLZXksIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXksIC8vIGJvb2xlYW5cbiAgICB0b3VjaGVzLCAgICAgICAgICAgIC8vIFRvdWNoTGlzdFxuICAgIHRhcmdldFRvdWNoZXMsICAgICAgLy8gVG91Y2hMaXN0XG4gICAgY2hhbmdlZFRvdWNoZXMsICAgICAvLyBUb3VjaExpc3RcbiAgICBzY2FsZSwgICAgICAgICAgICAgIC8vIGZsb2F0XG4gICAgcm90YXRpb24gICAgICAgICAgICAvLyBmbG9hdFxuKSB7XG5cbiAgICB2YXIgY3VzdG9tRXZlbnQ7XG5cbiAgICAvLyBjaGVjayB0YWdldFxuICAgIGlmICghdGFyZ2V0KXtcbiAgICAgICAgWS5lcnJvcihcInNpbXVsYXRlVG91Y2hFdmVudCgpOiBJbnZhbGlkIHRhcmdldC5cIik7XG4gICAgfVxuXG4gICAgLy9jaGVjayBldmVudCB0eXBlXG4gICAgaWYgKFkuTGFuZy5pc1N0cmluZyh0eXBlKSkge1xuICAgICAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vbWFrZSBzdXJlIGl0J3MgYSBzdXBwb3J0ZWQgdG91Y2ggZXZlbnRcbiAgICAgICAgaWYgKCF0b3VjaEV2ZW50c1t0eXBlXSl7XG4gICAgICAgICAgICBZLmVycm9yKFwic2ltdWxhdGVUb3VjaEV2ZW50KCk6IEV2ZW50IHR5cGUgJ1wiICsgdHlwZSArIFwiJyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIFkuZXJyb3IoXCJzaW11bGF0ZVRvdWNoRXZlbnQoKTogRXZlbnQgdHlwZSBtdXN0IGJlIGEgc3RyaW5nLlwiKTtcbiAgICB9XG5cbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSB0byBwYXNzIGFwcHJvcHJpYXRlIHRvdWNoIG9iamVjdHMuXG4gICAgLy8gY2hlY2sgdG91Y2ggb2JqZWN0c1xuICAgIC8vIEFuZHJvaWQoZXZlbiA0LjApIGRvZXNuJ3QgZGVmaW5lIFRvdWNoTGlzdCB5ZXRcbiAgICAvKmlmKHR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCB0eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICBpZighdG91Y2hlcyBpbnN0YW5jZW9mIFRvdWNoTGlzdCkge1xuICAgICAgICAgICAgWS5lcnJvcignc2ltdWxhdGVUb3VjaEV2ZW50KCk6IEludmFsaWQgdG91Y2hlcy4gSXQgbXVzdCBiZSBhIFRvdWNoTGlzdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYodG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBZLmVycm9yKCdzaW11bGF0ZVRvdWNoRXZlbnQoKTogTm8gdG91Y2ggb2JqZWN0IGZvdW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgaWYoIWNoYW5nZWRUb3VjaGVzIGluc3RhbmNlb2YgVG91Y2hMaXN0KSB7XG4gICAgICAgICAgICBZLmVycm9yKCdzaW11bGF0ZVRvdWNoRXZlbnQoKTogSW52YWxpZCB0b3VjaGVzLiBJdCBtdXN0IGJlIGEgVG91Y2hMaXN0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihjaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBZLmVycm9yKCdzaW11bGF0ZVRvdWNoRXZlbnQoKTogTm8gdG91Y2ggb2JqZWN0IGZvdW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSovXG5cbiAgICBpZih0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgaWYodG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIFkuZXJyb3IoJ3NpbXVsYXRlVG91Y2hFdmVudCgpOiBObyB0b3VjaCBvYmplY3QgaW4gdG91Y2hlcycpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgaWYoY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBZLmVycm9yKCdzaW11bGF0ZVRvdWNoRXZlbnQoKTogTm8gdG91Y2ggb2JqZWN0IGluIGNoYW5nZWRUb3VjaGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXR1cCBkZWZhdWx0IHZhbHVlc1xuICAgIGlmICghWS5MYW5nLmlzQm9vbGVhbihidWJibGVzKSkgeyBidWJibGVzID0gdHJ1ZTsgfSAvLyBidWJibGUgYnkgZGVmYXVsdC5cbiAgICBpZiAoIVkuTGFuZy5pc0Jvb2xlYW4oY2FuY2VsYWJsZSkpIHtcbiAgICAgICAgY2FuY2VsYWJsZSA9ICh0eXBlICE9PSBcInRvdWNoY2FuY2VsXCIpOyAvLyB0b3VjaGNhbmNlbCBpcyBub3QgY2FuY2VsbGVkXG4gICAgfVxuICAgIGlmICghWS5MYW5nLmlzT2JqZWN0KHZpZXcpKSAgICAgeyB2aWV3ID0gWS5jb25maWcud2luOyB9XG4gICAgaWYgKCFZLkxhbmcuaXNOdW1iZXIoZGV0YWlsKSkgICB7IGRldGFpbCA9IDE7IH0gLy8gdXN1YWxseSBub3QgdXNlZC4gZGVmYXVsdGVkIHRvICMgb2YgdG91Y2ggb2JqZWN0cy5cbiAgICBpZiAoIVkuTGFuZy5pc051bWJlcihzY3JlZW5YKSkgIHsgc2NyZWVuWCA9IDA7IH1cbiAgICBpZiAoIVkuTGFuZy5pc051bWJlcihzY3JlZW5ZKSkgIHsgc2NyZWVuWSA9IDA7IH1cbiAgICBpZiAoIVkuTGFuZy5pc051bWJlcihjbGllbnRYKSkgIHsgY2xpZW50WCA9IDA7IH1cbiAgICBpZiAoIVkuTGFuZy5pc051bWJlcihjbGllbnRZKSkgIHsgY2xpZW50WSA9IDA7IH1cbiAgICBpZiAoIVkuTGFuZy5pc0Jvb2xlYW4oY3RybEtleSkpIHsgY3RybEtleSA9IGZhbHNlOyB9XG4gICAgaWYgKCFZLkxhbmcuaXNCb29sZWFuKGFsdEtleSkpICB7IGFsdEtleSA9IGZhbHNlOyB9XG4gICAgaWYgKCFZLkxhbmcuaXNCb29sZWFuKHNoaWZ0S2V5KSl7IHNoaWZ0S2V5ID0gZmFsc2U7IH1cbiAgICBpZiAoIVkuTGFuZy5pc0Jvb2xlYW4obWV0YUtleSkpIHsgbWV0YUtleSA9IGZhbHNlOyB9XG4gICAgaWYgKCFZLkxhbmcuaXNOdW1iZXIoc2NhbGUpKSAgICB7IHNjYWxlID0gMS4wOyB9XG4gICAgaWYgKCFZLkxhbmcuaXNOdW1iZXIocm90YXRpb24pKSB7IHJvdGF0aW9uID0gMC4wOyB9XG5cblxuICAgIC8vY2hlY2sgZm9yIERPTS1jb21wbGlhbnQgYnJvd3NlcnMgZmlyc3RcbiAgICBpZiAoWS5MYW5nLmlzRnVuY3Rpb24oWS5jb25maWcuZG9jLmNyZWF0ZUV2ZW50KSkge1xuICAgICAgICBpZiAoWS5VQS5hbmRyb2lkKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICogQ291bGRuJ3QgZmluZCBhbmRyb2lkIHN0YXJ0IHZlcnNpb24gdGhhdCBzdXBwb3J0cyB0b3VjaCBldmVudC5cbiAgICAgICAgICAgICAgICAqIEFzc3VtZWQgc3VwcG9ydGVkKGJ0dyBBUElzIGJyb2tlbiB0aWxsIGljZWNyZWFtIHNhbmR3aXRjaClcbiAgICAgICAgICAgICAgICAqIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZihZLlVBLmFuZHJvaWQgPCA0LjApIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAqIFRvdWNoIEFQSXMgYXJlIGJyb2tlbiBpbiBhbmRyb2lkcyBvbGRlciB0aGFuIDQuMC4gV2Ugd2lsbCB1c2VcbiAgICAgICAgICAgICAgICAgICAgKiBzaW11bGF0ZWQgdG91Y2ggYXBpcyBmb3IgdGhlc2UgdmVyc2lvbnMuXG4gICAgICAgICAgICAgICAgICAgICogQXBwIGRldmVsb3BlciBzdGlsbCBjYW4gbGlzdGVuIGZvciB0b3VjaCBldmVudHMuIFRoaXMgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICogd2lsbCBiZSBkaXNwYXRjaGVkIHdpdGggdG91Y2ggZXZlbnQgdHlwZXMuXG4gICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgKiAoTm90ZSkgVXNlZCB0YXJnZXQgZm9yIHRoZSByZWxhdGVkVGFyZ2V0LiBOZWVkIHRvIHZlcmlmeSBpZlxuICAgICAgICAgICAgICAgICAgICAqIGl0IGhhcyBhIHNpZGUgZWZmZWN0LlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY3VzdG9tRXZlbnQgPSBZLmNvbmZpZy5kb2MuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudC5pbml0TW91c2VFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCB2aWV3LCBkZXRhaWwsXG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblgsIHNjcmVlblksIGNsaWVudFgsIGNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgIGN0cmxLZXksIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXksXG4gICAgICAgICAgICAgICAgICAgIDAsIHRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudC50b3VjaGVzID0gdG91Y2hlcztcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudC50YXJnZXRUb3VjaGVzID0gdGFyZ2V0VG91Y2hlcztcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudC5jaGFuZ2VkVG91Y2hlcyA9IGNoYW5nZWRUb3VjaGVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudCA9IFkuY29uZmlnLmRvYy5jcmVhdGVFdmVudChcIlRvdWNoRXZlbnRcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBBbmRvcm9pZCBpc24ndCBjb21wbGlhbnQgVzNDIGluaXRUb3VjaEV2ZW50IG1ldGhvZCBzaWduYXR1cmUuXG4gICAgICAgICAgICAgICAgY3VzdG9tRXZlbnQuaW5pdFRvdWNoRXZlbnQodG91Y2hlcywgdGFyZ2V0VG91Y2hlcywgY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsIHZpZXcsXG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblgsIHNjcmVlblksIGNsaWVudFgsIGNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgIGN0cmxLZXksIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFkuVUEuaW9zKSB7XG4gICAgICAgICAgICBpZihZLlVBLmlvcyA+PSAyLjApIHtcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudCA9IFkuY29uZmlnLmRvYy5jcmVhdGVFdmVudChcIlRvdWNoRXZlbnRcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBBdmFpbGFibGUgaU9TIDIuMCBhbmQgbGF0ZXJcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudC5pbml0VG91Y2hFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCB2aWV3LCBkZXRhaWwsXG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblgsIHNjcmVlblksIGNsaWVudFgsIGNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgIGN0cmxLZXksIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXksXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoZXMsIHRhcmdldFRvdWNoZXMsIGNoYW5nZWRUb3VjaGVzLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZSwgcm90YXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBZLmVycm9yKCdzaW11bGF0ZVRvdWNoRXZlbnQoKTogTm8gdG91Y2ggZXZlbnQgc2ltdWxhdGlvbiBmcmFtZXdvcmsgcHJlc2VudCBmb3IgaU9TLCAnK1kuVUEuaW9zKycuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBZLmVycm9yKCdzaW11bGF0ZVRvdWNoRXZlbnQoKTogTm90IHN1cHBvcnRlZCBhZ2VudCB5ZXQsICcrWS5VQS51c2VyQWdlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9maXJlIHRoZSBldmVudFxuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7XG4gICAgLy99IGVsc2UgaWYgKFkuTGFuZy5pc09iamVjdChkb2MuY3JlYXRlRXZlbnRPYmplY3QpKXsgLy8gV2luZG93cyBNb2JpbGUvSUUsIHN1cHBvcnQgbGF0ZXJcbiAgICB9IGVsc2Uge1xuICAgICAgICBZLmVycm9yKCdzaW11bGF0ZVRvdWNoRXZlbnQoKTogTm8gZXZlbnQgc2ltdWxhdGlvbiBmcmFtZXdvcmsgcHJlc2VudC4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSBldmVudCBvciBnZXN0dXJlIHdpdGggdGhlIGdpdmVuIG5hbWUgb24gYSB0YXJnZXQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGhlIERPTSBlbGVtZW50IHRoYXQncyB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IG9yIG5hbWUgb2YgdGhlIHN1cHBvcnRlZCBnZXN0dXJlIHRvIHNpbXVsYXRlXG4gKiAgICAgIChpLmUuLCBcImNsaWNrXCIsIFwiZG91YmxldGFwXCIsIFwiZmxpY2tcIikuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAoT3B0aW9uYWwpIEV4dHJhIG9wdGlvbnMgdG8gY29weSBvbnRvIHRoZSBldmVudCBvYmplY3QuXG4gKiAgICAgIEZvciBnZXN0dXJlcywgb3B0aW9ucyBhcmUgdXNlZCB0byByZWZpbmUgdGhlIGdlc3R1cmUgYmVoYXZpb3IuXG4gKiBAZm9yIEV2ZW50XG4gKiBAbWV0aG9kIHNpbXVsYXRlXG4gKiBAc3RhdGljXG4gKi9cblkuRXZlbnQuc2ltdWxhdGUgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIG9wdGlvbnMpe1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAobW91c2VFdmVudHNbdHlwZV0gfHwgcG9pbnRlckV2ZW50c1t0eXBlXSl7XG4gICAgICAgIHNpbXVsYXRlTW91c2VFdmVudCh0YXJnZXQsIHR5cGUsIG9wdGlvbnMuYnViYmxlcyxcbiAgICAgICAgICAgIG9wdGlvbnMuY2FuY2VsYWJsZSwgb3B0aW9ucy52aWV3LCBvcHRpb25zLmRldGFpbCwgb3B0aW9ucy5zY3JlZW5YLFxuICAgICAgICAgICAgb3B0aW9ucy5zY3JlZW5ZLCBvcHRpb25zLmNsaWVudFgsIG9wdGlvbnMuY2xpZW50WSwgb3B0aW9ucy5jdHJsS2V5LFxuICAgICAgICAgICAgb3B0aW9ucy5hbHRLZXksIG9wdGlvbnMuc2hpZnRLZXksIG9wdGlvbnMubWV0YUtleSwgb3B0aW9ucy5idXR0b24sXG4gICAgICAgICAgICBvcHRpb25zLnJlbGF0ZWRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoa2V5RXZlbnRzW3R5cGVdKXtcbiAgICAgICAgc2ltdWxhdGVLZXlFdmVudCh0YXJnZXQsIHR5cGUsIG9wdGlvbnMuYnViYmxlcyxcbiAgICAgICAgICAgIG9wdGlvbnMuY2FuY2VsYWJsZSwgb3B0aW9ucy52aWV3LCBvcHRpb25zLmN0cmxLZXksXG4gICAgICAgICAgICBvcHRpb25zLmFsdEtleSwgb3B0aW9ucy5zaGlmdEtleSwgb3B0aW9ucy5tZXRhS2V5LFxuICAgICAgICAgICAgb3B0aW9ucy5rZXlDb2RlLCBvcHRpb25zLmNoYXJDb2RlKTtcbiAgICB9IGVsc2UgaWYgKHVpRXZlbnRzW3R5cGVdKXtcbiAgICAgICAgc2ltdWxhdGVVSUV2ZW50KHRhcmdldCwgdHlwZSwgb3B0aW9ucy5idWJibGVzLFxuICAgICAgICAgICAgb3B0aW9ucy5jYW5jZWxhYmxlLCBvcHRpb25zLnZpZXcsIG9wdGlvbnMuZGV0YWlsKTtcblxuICAgIC8vIHRvdWNoIGxvdy1sZXZlbCBldmVudCBzaW11bGF0aW9uXG4gICAgfSBlbHNlIGlmICh0b3VjaEV2ZW50c1t0eXBlXSkge1xuICAgICAgICBpZigoWS5jb25maWcud2luICYmIChcIm9udG91Y2hzdGFydFwiIGluIFkuY29uZmlnLndpbikpICYmICEoWS5VQS5waGFudG9tanMpICYmICEoWS5VQS5jaHJvbWUgJiYgWS5VQS5jaHJvbWUgPCA2KSkge1xuICAgICAgICAgICAgc2ltdWxhdGVUb3VjaEV2ZW50KHRhcmdldCwgdHlwZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJ1YmJsZXMsIG9wdGlvbnMuY2FuY2VsYWJsZSwgb3B0aW9ucy52aWV3LCBvcHRpb25zLmRldGFpbCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNjcmVlblgsIG9wdGlvbnMuc2NyZWVuWSwgb3B0aW9ucy5jbGllbnRYLCBvcHRpb25zLmNsaWVudFksXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jdHJsS2V5LCBvcHRpb25zLmFsdEtleSwgb3B0aW9ucy5zaGlmdEtleSwgb3B0aW9ucy5tZXRhS2V5LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMudG91Y2hlcywgb3B0aW9ucy50YXJnZXRUb3VjaGVzLCBvcHRpb25zLmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2NhbGUsIG9wdGlvbnMucm90YXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgWS5lcnJvcihcInNpbXVsYXRlKCk6IEV2ZW50ICdcIiArIHR5cGUgKyBcIicgY2FuJ3QgYmUgc2ltdWxhdGVkLiBVc2UgZ2VzdHVyZS1zaW11bGF0ZSBtb2R1bGUgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cblxuICAgIC8vIGlvcyBnZXN0dXJlIGxvdy1sZXZlbCBldmVudCBzaW11bGF0aW9uIChpT1MgdjIrIG9ubHkpXG4gICAgfSBlbHNlIGlmKFkuVUEuaW9zICYmIFkuVUEuaW9zID49IDIuMCAmJiBnZXN0dXJlRXZlbnRzW3R5cGVdKSB7XG4gICAgICAgIHNpbXVsYXRlR2VzdHVyZUV2ZW50KHRhcmdldCwgdHlwZSxcbiAgICAgICAgICAgIG9wdGlvbnMuYnViYmxlcywgb3B0aW9ucy5jYW5jZWxhYmxlLCBvcHRpb25zLnZpZXcsIG9wdGlvbnMuZGV0YWlsLFxuICAgICAgICAgICAgb3B0aW9ucy5zY3JlZW5YLCBvcHRpb25zLnNjcmVlblksIG9wdGlvbnMuY2xpZW50WCwgb3B0aW9ucy5jbGllbnRZLFxuICAgICAgICAgICAgb3B0aW9ucy5jdHJsS2V5LCBvcHRpb25zLmFsdEtleSwgb3B0aW9ucy5zaGlmdEtleSwgb3B0aW9ucy5tZXRhS2V5LFxuICAgICAgICAgICAgb3B0aW9ucy5zY2FsZSwgb3B0aW9ucy5yb3RhdGlvbik7XG5cbiAgICAvLyBhbnl0aGluZyBlbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgICAgWS5lcnJvcihcInNpbXVsYXRlKCk6IEV2ZW50ICdcIiArIHR5cGUgKyBcIicgY2FuJ3QgYmUgc2ltdWxhdGVkLlwiKTtcbiAgICB9XG59O1xuXG5cbn0pKCk7XG5cblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiZXZlbnQtYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdldmVudC1zeW50aGV0aWMnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIERlZmluZSBuZXcgRE9NIGV2ZW50cyB0aGF0IGNhbiBiZSBzdWJzY3JpYmVkIHRvIGZyb20gTm9kZXMuXG4gKlxuICogQG1vZHVsZSBldmVudFxuICogQHN1Ym1vZHVsZSBldmVudC1zeW50aGV0aWNcbiAqL1xudmFyIEN1c3RvbUV2ZW50ID0gWS5DdXN0b21FdmVudCxcbiAgICBET01NYXAgICA9IFkuRW52LmV2dC5kb21fbWFwLFxuICAgIHRvQXJyYXkgID0gWS5BcnJheSxcbiAgICBZTGFuZyAgICA9IFkuTGFuZyxcbiAgICBpc09iamVjdCA9IFlMYW5nLmlzT2JqZWN0LFxuICAgIGlzU3RyaW5nID0gWUxhbmcuaXNTdHJpbmcsXG4gICAgaXNBcnJheSAgPSBZTGFuZy5pc0FycmF5LFxuICAgIHF1ZXJ5ICAgID0gWS5TZWxlY3Rvci5xdWVyeSxcbiAgICBub29wICAgICA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vKipcbiAqIDxwPlRoZSB0cmlnZ2VyaW5nIG1lY2hhbmlzbSB1c2VkIGJ5IFN5bnRoZXRpY0V2ZW50cy48L3A+XG4gKlxuICogPHA+SW1wbGVtZW50ZXJzIHNob3VsZCBub3QgaW5zdGFudGlhdGUgdGhlc2UgZGlyZWN0bHkuICBVc2UgdGhlIE5vdGlmaWVyXG4gKiBwcm92aWRlZCB0byB0aGUgZXZlbnQncyBpbXBsZW1lbnRlZCA8Y29kZT5vbihub2RlLCBzdWIsIG5vdGlmaWVyKTwvY29kZT4gb3JcbiAqIDxjb2RlPmRlbGVnYXRlKG5vZGUsIHN1Yiwgbm90aWZpZXIsIGZpbHRlcik8L2NvZGU+IG1ldGhvZHMuPC9wPlxuICpcbiAqIEBjbGFzcyBTeW50aGV0aWNFdmVudC5Ob3RpZmllclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gaGFuZGxlIHtFdmVudEhhbmRsZX0gdGhlIGRldGFjaCBoYW5kbGUgZm9yIHRoZSBzdWJzY3JpcHRpb24gdG8gYW5cbiAqICAgICAgICAgICAgICBpbnRlcm5hbCBjdXN0b20gZXZlbnQgdXNlZCB0byBleGVjdXRlIHRoZSBjYWxsYmFjayBwYXNzZWQgdG9cbiAqICAgICAgICAgICAgICBvbiguLikgb3IgZGVsZWdhdGUoLi4pXG4gKiBAcGFyYW0gZW1pdEZhY2FkZSB7Qm9vbGVhbn0gdGFrZSBzdGVwcyB0byBlbnN1cmUgdGhlIGZpcnN0IGFyZyByZWNlaXZlZCBieVxuICogICAgICAgICAgICAgIHRoZSBzdWJzY3JpcHRpb24gY2FsbGJhY2sgaXMgYW4gZXZlbnQgZmFjYWRlXG4gKiBAcHJpdmF0ZVxuICogQHNpbmNlIDMuMi4wXG4gKi9cbmZ1bmN0aW9uIE5vdGlmaWVyKGhhbmRsZSwgZW1pdEZhY2FkZSkge1xuICAgIHRoaXMuaGFuZGxlICAgICA9IGhhbmRsZTtcbiAgICB0aGlzLmVtaXRGYWNhZGUgPSBlbWl0RmFjYWRlO1xufVxuXG4vKipcbiAqIDxwPkV4ZWN1dGVzIHRoZSBzdWJzY3JpcHRpb24gY2FsbGJhY2ssIHBhc3NpbmcgdGhlIGZpcmluZyBhcmd1bWVudHMgYXMgdGhlXG4gKiBmaXJzdCBwYXJhbWV0ZXJzIHRvIHRoYXQgY2FsbGJhY2suIEZvciBldmVudHMgdGhhdCBhcmUgY29uZmlndXJlZCB3aXRoXG4gKiBlbWl0RmFjYWRlPXRydWUsIGl0IGlzIGNvbW1vbiBwcmFjdGljZSB0byBwYXNzIHRoZSB0cmlnZ2VyaW5nIERPTUV2ZW50RmFjYWRlXG4gKiBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLiAgQmFycmluZyBhIHByb3BlciBET01FdmVudEZhY2FkZSBvciBFdmVudEZhY2FkZVxuICogKGZyb20gYSBDdXN0b21FdmVudCksIGEgbmV3IEV2ZW50RmFjYWRlIHdpbGwgYmUgZ2VuZXJhdGVkLiAgSW4gdGhhdCBjYXNlLCBpZlxuICogZmlyZSgpIGlzIGNhbGxlZCB3aXRoIGEgc2ltcGxlIG9iamVjdCwgaXQgd2lsbCBiZSBtaXhlZCBpbnRvIHRoZSBmYWNhZGUuXG4gKiBPdGhlcndpc2UsIHRoZSBmYWNhZGUgd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhlIGNhbGxiYWNrIHBhcmFtZXRlcnMuPC9wPlxuICpcbiAqIDxwPkZvciBub3RpZmllcnMgcHJvdmlkZWQgdG8gZGVsZWdhdGUgbG9naWMsIHRoZSBmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW5cbiAqIG9iamVjdCB3aXRoIGEgJnF1b3Q7Y3VycmVudFRhcmdldCZxdW90OyBwcm9wZXJ0eSB0byBpZGVudGlmeSB3aGF0IG9iamVjdCB0b1xuICogZGVmYXVsdCBhcyAndGhpcycgaW4gdGhlIGNhbGxiYWNrLiAgVHlwaWNhbGx5IHRoaXMgaXMgZ2xlYW5lZCBmcm9tIHRoZVxuICogRE9NRXZlbnRGYWNhZGUgb3IgRXZlbnRGYWNhZGUsIGJ1dCBpZiBjb25maWd1cmVkIHdpdGggZW1pdEZhY2FkZT1mYWxzZSwgYW5cbiAqIG9iamVjdCBtdXN0IGJlIHByb3ZpZGVkLiAgSW4gdGhhdCBjYXNlLCB0aGUgb2JqZWN0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZVxuICogY2FsbGJhY2sgcGFyYW1ldGVycy48L3A+XG4gKlxuICogPHA+QWRkaXRpb25hbCBhcmd1bWVudHMgcGFzc2VkIGR1cmluZyBldmVudCBzdWJzY3JpcHRpb24gd2lsbCBiZVxuICogYXV0b21hdGljYWxseSBhZGRlZCBhZnRlciB0aG9zZSBwYXNzZWQgdG8gZmlyZSgpLjwvcD5cbiAqXG4gKiBAbWV0aG9kIGZpcmVcbiAqIEBwYXJhbSB7RXZlbnRGYWNhZGV8RE9NRXZlbnRGYWNhZGV8YW55fSBlIChzZWUgZGVzY3JpcHRpb24pXG4gKiBAcGFyYW0ge2FueVtdfSBbYXJnKl0gYWRkaXRpb25hbCBhcmd1bWVudHMgcmVjZWl2ZWQgYnkgYWxsIHN1YnNjcmlwdGlvbnNcbiAqIEBwcml2YXRlXG4gKi9cbk5vdGlmaWVyLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAvLyBmaXJzdCBhcmcgdG8gZGVsZWdhdGUgbm90aWZpZXIgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGN1cnJlbnRUYXJnZXRcbiAgICB2YXIgYXJncyAgICAgPSB0b0FycmF5KGFyZ3VtZW50cywgMCwgdHJ1ZSksXG4gICAgICAgIGhhbmRsZSAgID0gdGhpcy5oYW5kbGUsXG4gICAgICAgIGNlICAgICAgID0gaGFuZGxlLmV2dCxcbiAgICAgICAgc3ViICAgICAgPSBoYW5kbGUuc3ViLFxuICAgICAgICB0aGlzT2JqICA9IHN1Yi5jb250ZXh0LFxuICAgICAgICBkZWxlZ2F0ZSA9IHN1Yi5maWx0ZXIsXG4gICAgICAgIGV2ZW50ICAgID0gZSB8fCB7fSxcbiAgICAgICAgcmV0O1xuXG4gICAgaWYgKHRoaXMuZW1pdEZhY2FkZSkge1xuICAgICAgICBpZiAoIWUgfHwgIWUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gY2UuX2dldEZhY2FkZSgpO1xuXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoZSkgJiYgIWUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBZLm1peChldmVudCwgZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYXJnc1swXSA9IGV2ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQudHlwZSAgICA9IGNlLnR5cGU7XG4gICAgICAgIGV2ZW50LmRldGFpbHMgPSBhcmdzLnNsaWNlKCk7XG5cbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICBldmVudC5jb250YWluZXIgPSBjZS5ob3N0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChkZWxlZ2F0ZSAmJiBpc09iamVjdChlKSAmJiBlLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgYXJncy5zaGlmdCgpO1xuICAgIH1cblxuICAgIHN1Yi5jb250ZXh0ID0gdGhpc09iaiB8fCBldmVudC5jdXJyZW50VGFyZ2V0IHx8IGNlLmhvc3Q7XG4gICAgcmV0ID0gY2UuZmlyZS5hcHBseShjZSwgYXJncyk7XG5cbiAgICAvLyBoYXZlIHRvIGhhbmRsZSBwcmV2ZW50ZWRGbiBhbmQgc3RvcHBlZEZuIG1hbnVhbGx5IGJlY2F1c2VcbiAgICAvLyBOb3RpZmllciBDdXN0b21FdmVudHMgYXJlIGZvcmNlZCB0byBlbWl0RmFjYWRlPWZhbHNlXG4gICAgaWYgKGUucHJldmVudGVkICYmIGNlLnByZXZlbnRlZEZuKSB7XG4gICAgICAgIGNlLnByZXZlbnRlZEZuLmFwcGx5KGNlLCBhcmdzKTtcbiAgICB9XG5cbiAgICBpZiAoZS5zdG9wcGVkICYmIGNlLnN0b3BwZWRGbikge1xuICAgICAgICBjZS5zdG9wcGVkRm4uYXBwbHkoY2UsIGFyZ3MpO1xuICAgIH1cblxuICAgIHN1Yi5jb250ZXh0ID0gdGhpc09iajsgLy8gcmVzZXQgZm9yIGZ1dHVyZSBmaXJpbmdcblxuICAgIC8vIHRvIGNhcHR1cmUgY2FsbGJhY2tzIHRoYXQgcmV0dXJuIGZhbHNlIHRvIHN0b3BQcm9wYWdhdGlvbi5cbiAgICAvLyBVc2VmdWwgZm9yIGRlbGVnYXRlIGltcGxlbWVudGF0aW9uc1xuICAgIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIE1hbmFnZXIgb2JqZWN0IGZvciBzeW50aGV0aWMgZXZlbnQgc3Vic2NyaXB0aW9ucyB0byBhZ2dyZWdhdGUgbXVsdGlwbGUgc3ludGhzIG9uIHRoZVxuICogc2FtZSBub2RlIHdpdGhvdXQgY29sbGlkaW5nIHdpdGggYWN0dWFsIERPTSBzdWJzY3JpcHRpb24gZW50cmllcyBpbiB0aGUgZ2xvYmFsIG1hcCBvZlxuICogRE9NIHN1YnNjcmlwdGlvbnMuICBBbHNvIGZhY2lsaXRhdGVzIHByb3BlciBjbGVhbnVwIG9uIHBhZ2UgdW5sb2FkLlxuICpcbiAqIEBjbGFzcyBTeW50aFJlZ2lzdHJ5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBlbCB7SFRNTEVsZW1lbnR9IHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHl1aWQge1N0cmluZ30gdGhlIHl1aWQgc3RhbXAgZm9yIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ga2V5IHtTdHJpbmd9IHRoZSBnZW5lcmF0ZWQgaWQgdG9rZW4gdXNlZCB0byBpZGVudGlmeSBhbiBldmVudCB0eXBlICtcbiAqICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCBpbiB0aGUgZ2xvYmFsIERPTSBzdWJzY3JpcHRpb24gbWFwLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU3ludGhSZWdpc3RyeShlbCwgeXVpZCwga2V5KSB7XG4gICAgdGhpcy5oYW5kbGVzID0gW107XG4gICAgdGhpcy5lbCAgICAgID0gZWw7XG4gICAgdGhpcy5rZXkgICAgID0ga2V5O1xuICAgIHRoaXMuZG9ta2V5ICA9IHl1aWQ7XG59XG5cblN5bnRoUmVnaXN0cnkucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBTeW50aFJlZ2lzdHJ5LFxuXG4gICAgLy8gQSBmZXcgb2JqZWN0IHByb3BlcnRpZXMgdG8gZmFrZSB0aGUgQ3VzdG9tRXZlbnQgaW50ZXJmYWNlIGZvciBwYWdlXG4gICAgLy8gdW5sb2FkIGNsZWFudXAuICBET04nVCBUT1VDSCFcbiAgICB0eXBlICAgICAgOiAnX3N5bnRoJyxcbiAgICBmbiAgICAgICAgOiBub29wLFxuICAgIGNhcHR1cmUgICA6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN1YnNjcmlwdGlvbiBmcm9tIHRoZSBOb3RpZmllciByZWdpc3RyeS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcbiAgICAgKiBAcGFyYW0gaGFuZGxlIHtFdmVudEhhbmRsZX0gdGhlIHN1YnNjcmlwdGlvblxuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICAgIGhhbmRsZS5ldnQucmVnaXN0cnkgPSB0aGlzO1xuICAgICAgICB0aGlzLmhhbmRsZXMucHVzaChoYW5kbGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzdWJzY3JpcHRpb24gZnJvbSB0aGUgTm90aWZpZXIgcmVnaXN0cnkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF91bnJlZ2lzdGVyU3ViXG4gICAgICogQHBhcmFtIHN1YiB7U3Vic2NyaXB0aW9ufSB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICovXG4gICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICB2YXIgaGFuZGxlcyA9IHRoaXMuaGFuZGxlcyxcbiAgICAgICAgICAgIGV2ZW50cyA9IERPTU1hcFt0aGlzLmRvbWtleV0sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IGhhbmRsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVzW2ldLnN1YiA9PT0gc3ViKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhbiB1cCBsZWZ0IG92ZXIgb2JqZWN0cyB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIHN1YnNjcmliZXJzLlxuICAgICAgICBpZiAoIWhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3RoaXMua2V5XTtcbiAgICAgICAgICAgIGlmICghWS5PYmplY3Quc2l6ZShldmVudHMpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIERPTU1hcFt0aGlzLmRvbWtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSB0aGUgZXZlbnQgc3lzdGVtJ3MgdW5sb2FkIGNsZWFudXAgcHJvY2Vzcy4gIFdoZW4gbmF2aWdhdGluZ1xuICAgICAqIGF3YXkgZnJvbSB0aGUgcGFnZSwgdGhlIGV2ZW50IHN5c3RlbSBpdGVyYXRlcyB0aGUgZ2xvYmFsIG1hcCBvZiBlbGVtZW50XG4gICAgICogc3Vic2NyaXB0aW9ucyBhbmQgZGV0YWNoZXMgZXZlcnl0aGluZyB1c2luZyBkZXRhY2hBbGwoKS4gIE5vcm1hbGx5LFxuICAgICAqIHRoZSBtYXAgaXMgcG9wdWxhdGVkIHdpdGggY3VzdG9tIGV2ZW50cywgc28gdGhpcyBvYmplY3QgbmVlZHMgdG9cbiAgICAgKiBhdCBsZWFzdCBzdXBwb3J0IHRoZSBkZXRhY2hBbGwgbWV0aG9kIHRvIGR1Y2sgdHlwZSBpdHMgd2F5IHRvXG4gICAgICogY2xlYW5saW5lc3MuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRldGFjaEFsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICovXG4gICAgZGV0YWNoQWxsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFuZGxlcyA9IHRoaXMuaGFuZGxlcyxcbiAgICAgICAgICAgIGkgPSBoYW5kbGVzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGhhbmRsZXNbaV0uZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIDxwPldyYXBwZXIgY2xhc3MgZm9yIHRoZSBpbnRlZ3JhdGlvbiBvZiBuZXcgZXZlbnRzIGludG8gdGhlIFlVSSBldmVudFxuICogaW5mcmFzdHJ1Y3R1cmUuICBEb24ndCBpbnN0YW50aWF0ZSB0aGlzIG9iamVjdCBkaXJlY3RseSwgdXNlXG4gKiA8Y29kZT5ZLkV2ZW50LmRlZmluZSh0eXBlLCBjb25maWcpPC9jb2RlPi4gIFNlZSB0aGF0IG1ldGhvZCBmb3IgZGV0YWlscy48L3A+XG4gKlxuICogPHA+UHJvcGVydGllcyB0aGF0IE1BWSBvciBTSE9VTEQgYmUgc3BlY2lmaWVkIGluIHRoZSBjb25maWd1cmF0aW9uIGFyZSBub3RlZFxuICogYmVsb3cgYW5kIGluIHRoZSBkZXNjcmlwdGlvbiBvZiA8Y29kZT5ZLkV2ZW50LmRlZmluZTwvY29kZT4uPC9wPlxuICpcbiAqIEBjbGFzcyBTeW50aGV0aWNFdmVudFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gY2ZnIHtPYmplY3R9IEltcGxlbWVudGF0aW9uIHBpZWNlcyBhbmQgY29uZmlndXJhdGlvblxuICogQHNpbmNlIDMuMS4wXG4gKiBAaW4gZXZlbnQtc3ludGhldGljXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KCkge1xuICAgIHRoaXMuX2luaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuWS5taXgoU3ludGhldGljRXZlbnQsIHtcbiAgICBOb3RpZmllcjogTm90aWZpZXIsXG4gICAgU3ludGhSZWdpc3RyeTogU3ludGhSZWdpc3RyeSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFycmF5IG9mIHN1YnNjcmlwdGlvbiBoYW5kbGVzIGZvciBhIG5vZGUgZm9yIHRoZSBnaXZlbiBldmVudFxuICAgICAqIHR5cGUuICBQYXNzaW5nIHRydWUgYXMgdGhlIHRoaXJkIGFyZ3VtZW50IHdpbGwgY3JlYXRlIGEgcmVnaXN0cnkgZW50cnlcbiAgICAgKiBpbiB0aGUgZXZlbnQgc3lzdGVtJ3MgRE9NIG1hcCB0byBob3N0IHRoZSBhcnJheSBpZiBvbmUgZG9lc24ndCB5ZXQgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIG5vZGUge05vZGV9IHRoZSBub2RlXG4gICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIGNyZWF0ZSB7Qm9vbGVhbn0gY3JlYXRlIGEgcmVnaXN0cmF0aW9uIGVudHJ5IHRvIGhvc3QgYSBuZXcgYXJyYXlcbiAgICAgKiAgICAgICAgICAgICAgICAgIGlmIG9uZSBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICovXG4gICAgZ2V0UmVnaXN0cnk6IGZ1bmN0aW9uIChub2RlLCB0eXBlLCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIGVsICAgICA9IG5vZGUuX25vZGUsXG4gICAgICAgICAgICB5dWlkICAgPSBZLnN0YW1wKGVsKSxcbiAgICAgICAgICAgIGtleSAgICA9ICdldmVudDonICsgeXVpZCArIHR5cGUgKyAnX3N5bnRoJyxcbiAgICAgICAgICAgIGV2ZW50cyA9IERPTU1hcFt5dWlkXTtcblxuICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50cykge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IERPTU1hcFt5dWlkXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFldmVudHNba2V5XSkge1xuICAgICAgICAgICAgICAgIGV2ZW50c1trZXldID0gbmV3IFN5bnRoUmVnaXN0cnkoZWwsIHl1aWQsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGV2ZW50cyAmJiBldmVudHNba2V5XSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWx0ZXJuYXRlIDxjb2RlPl9kZWxldGUoKTwvY29kZT4gbWV0aG9kIGZvciB0aGUgQ3VzdG9tRXZlbnQgb2JqZWN0XG4gICAgICogY3JlYXRlZCB0byBtYW5hZ2UgU3ludGhldGljRXZlbnQgc3Vic2NyaXB0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2RlbGV0ZVN1YlxuICAgICAqIEBwYXJhbSBzdWIge1N1YnNjcmlwdGlvbn0gdGhlIHN1YnNjcmlwdGlvbiB0byBjbGVhbiB1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICovXG4gICAgX2RlbGV0ZVN1YjogZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICBpZiAoc3ViICYmIHN1Yi5mbikge1xuICAgICAgICAgICAgdmFyIHN5bnRoID0gdGhpcy5ldmVudERlZixcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAoc3ViLmZpbHRlcikgPyAnZGV0YWNoRGVsZWdhdGUnIDogJ2RldGFjaCc7XG5cbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICAgICAgICAgIGlmIChDdXN0b21FdmVudC5rZWVwRGVwcmVjYXRlZFN1YnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN5bnRoW21ldGhvZF0oc3ViLm5vZGUsIHN1YiwgdGhpcy5ub3RpZmllciwgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5LnVucmVnaXN0ZXIoc3ViKTtcblxuICAgICAgICAgICAgZGVsZXRlIHN1Yi5mbjtcbiAgICAgICAgICAgIGRlbGV0ZSBzdWIubm9kZTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdWIuY29udGV4dDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgY29uc3RydWN0b3I6IFN5bnRoZXRpY0V2ZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3Rpb24gbG9naWMgZm9yIHRoZSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfaW5pdFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBfaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMucHVibGlzaENvbmZpZyB8fCAodGhpcy5wdWJsaXNoQ29uZmlnID0ge30pO1xuXG4gICAgICAgICAgICAvLyBUaGUgbm90aWZpY2F0aW9uIG1lY2hhbmlzbSBoYW5kbGVzIGZhY2FkZSBjcmVhdGlvblxuICAgICAgICAgICAgdGhpcy5lbWl0RmFjYWRlID0gKCdlbWl0RmFjYWRlJyBpbiBjb25maWcpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVtaXRGYWNhZGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLmVtaXRGYWNhZGUgID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkltcGxlbWVudGVycyBNQVkgcHJvdmlkZSB0aGlzIG1ldGhvZCBkZWZpbml0aW9uLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+SW1wbGVtZW50IHRoaXMgZnVuY3Rpb24gaWYgdGhlIGV2ZW50IHN1cHBvcnRzIGEgZGlmZmVyZW50XG4gICAgICAgICAqIHN1YnNjcmlwdGlvbiBzaWduYXR1cmUuICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgYm90aFxuICAgICAgICAgKiA8Y29kZT5vbigpPC9jb2RlPiBhbmQgPGNvZGU+ZGVsZWdhdGUoKTwvY29kZT4uICBUaGUgc2Vjb25kIHBhcmFtZXRlclxuICAgICAgICAgKiBpbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaXMgYmVpbmcgc3Vic2NyaWJlZCB2aWFcbiAgICAgICAgICogPGNvZGU+ZGVsZWdhdGUoKTwvY29kZT4uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5JbXBsZW1lbnRhdGlvbnMgbXVzdCByZW1vdmUgZXh0cmEgYXJndW1lbnRzIGZyb20gdGhlIGFyZ3MgbGlzdFxuICAgICAgICAgKiBiZWZvcmUgcmV0dXJuaW5nLiAgVGhlIHJlcXVpcmVkIGFyZ3MgZm9yIDxjb2RlPm9uKCk8L2NvZGU+XG4gICAgICAgICAqIHN1YnNjcmlwdGlvbnMgYXJlPC9wPlxuICAgICAgICAgKiA8cHJlPjxjb2RlPlt0eXBlLCBjYWxsYmFjaywgdGFyZ2V0LCBjb250ZXh0LCBhcmdOLi4uXTwvY29kZT48L3ByZT5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+VGhlIHJlcXVpcmVkIGFyZ3MgZm9yIDxjb2RlPmRlbGVnYXRlKCk8L2NvZGU+XG4gICAgICAgICAqIHN1YnNjcmlwdGlvbnMgYXJlPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cHJlPjxjb2RlPlt0eXBlLCBjYWxsYmFjaywgdGFyZ2V0LCBmaWx0ZXIsIGNvbnRleHQsIGFyZ04uLi5dPC9jb2RlPjwvcHJlPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5UaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhpcyBmdW5jdGlvbiB3aWxsIGJlIHN0b3JlZCBvbiB0aGVcbiAgICAgICAgICogc3Vic2NyaXB0aW9uIGluIHRoZSAnX2V4dHJhJyBwcm9wZXJ0eSBmb3IgcmVmZXJlbmNlIGVsc2V3aGVyZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvY2Vzc0FyZ3NcbiAgICAgICAgICogQHBhcmFtIGFyZ3Mge0FycmF5fSBwYXJtZXRlcnMgcGFzc2VkIHRvIFkub24oLi4pIG9yIFkuZGVsZWdhdGUoLi4pXG4gICAgICAgICAqIEBwYXJhbSBkZWxlZ2F0ZSB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3Vic2NyaXB0aW9uIGlzIGZyb20gWS5kZWxlZ2F0ZVxuICAgICAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzQXJnczogbm9vcCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+SW1wbGVtZW50ZXJzIE1BWSBvdmVycmlkZSB0aGlzIHByb3BlcnR5LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+V2hldGhlciB0byBwcmV2ZW50IG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhpcyBldmVudCB0aGF0IGFyZVxuICAgICAgICAgKiBjbGFzc2lmaWVkIGFzIGJlaW5nIHRoZSBzYW1lLiAgQnkgZGVmYXVsdCwgdGhpcyBtZWFucyB0aGUgc3Vic2NyaWJlZFxuICAgICAgICAgKiBjYWxsYmFjayBpcyB0aGUgc2FtZSBmdW5jdGlvbi4gIFNlZSB0aGUgPGNvZGU+c3ViTWF0Y2g8L2NvZGU+XG4gICAgICAgICAqIG1ldGhvZC4gIFNldHRpbmcgdGhpcyB0byB0cnVlIHdpbGwgaW1wYWN0IHBlcmZvcm1hbmNlIGZvciBoaWdoIHZvbHVtZVxuICAgICAgICAgKiBldmVudHMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgcHJldmVudER1cHNcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICAvL3ByZXZlbnREdXBzICA6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5JbXBsZW1lbnRlcnMgU0hPVUxEIHByb3ZpZGUgdGhpcyBtZXRob2QgZGVmaW5pdGlvbi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEltcGxlbWVudGF0aW9uIGxvZ2ljIGZvciBzdWJzY3JpcHRpb25zIGRvbmUgdmlhIDxjb2RlPm5vZGUub24odHlwZSxcbiAgICAgICAgICogZm4pPC9jb2RlPiBvciA8Y29kZT5ZLm9uKHR5cGUsIGZuLCB0YXJnZXQpPC9jb2RlPi4gIFRoaXNcbiAgICAgICAgICogZnVuY3Rpb24gc2hvdWxkIHNldCB1cCB0aGUgbW9uaXRvcihzKSB0aGF0IHdpbGwgZXZlbnR1YWxseSBmaXJlIHRoZVxuICAgICAgICAgKiBldmVudC4gIFR5cGljYWxseSB0aGlzIGludm9sdmVzIHN1YnNjcmliaW5nIHRvIGF0IGxlYXN0IG9uZSBET01cbiAgICAgICAgICogZXZlbnQuICBJdCBpcyByZWNvbW1lbmRlZCB0byBzdG9yZSBkZXRhY2ggaGFuZGxlcyBmcm9tIGFueSBET01cbiAgICAgICAgICogc3Vic2NyaXB0aW9ucyB0byBtYWtlIGZvciBlYXN5IGNsZWFudXAgaW4gdGhlIDxjb2RlPmRldGFjaDwvY29kZT5cbiAgICAgICAgICogbWV0aG9kLiAgVHlwaWNhbGx5IHRoZXNlIGhhbmRsZXMgYXJlIGFkZGVkIHRvIHRoZSA8Y29kZT5zdWI8L2NvZGU+XG4gICAgICAgICAqIG9iamVjdC4gIEFsc28gZm9yIFN5bnRoZXRpY0V2ZW50cyB0aGF0IGxldmVyYWdlIGEgc2luZ2xlIERPTVxuICAgICAgICAgKiBzdWJzY3JpcHRpb24gdW5kZXIgdGhlIGhvb2QsIGl0IGlzIHJlY29tbWVuZGVkIHRvIHBhc3MgdGhlIERPTSBldmVudFxuICAgICAgICAgKiBvYmplY3QgdG8gPGNvZGU+bm90aWZpZXIuZmlyZShlKTwvY29kZT4uICAoVGhlIGV2ZW50IG5hbWUgb24gdGhlXG4gICAgICAgICAqIG9iamVjdCB3aWxsIGJlIHVwZGF0ZWQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIG9uXG4gICAgICAgICAqIEBwYXJhbSBub2RlIHtOb2RlfSB0aGUgbm9kZSB0aGUgc3Vic2NyaXB0aW9uIGlzIGJlaW5nIGFwcGxpZWQgdG9cbiAgICAgICAgICogQHBhcmFtIHN1YiB7U3Vic2NyaXB0aW9ufSB0aGUgb2JqZWN0IHRvIHRyYWNrIHRoaXMgc3Vic2NyaXB0aW9uXG4gICAgICAgICAqIEBwYXJhbSBub3RpZmllciB7U3ludGhldGljRXZlbnQuTm90aWZpZXJ9IGNhbGwgbm90aWZpZXIuZmlyZSguLikgdG9cbiAgICAgICAgICogICAgICAgICAgICAgIHRyaWdnZXIgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgc3Vic2NyaWJlcnNcbiAgICAgICAgICovXG4gICAgICAgIG9uOiBub29wLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5JbXBsZW1lbnRlcnMgU0hPVUxEIHByb3ZpZGUgdGhpcyBtZXRob2QgZGVmaW5pdGlvbi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPkltcGxlbWVudGF0aW9uIGxvZ2ljIGZvciBkZXRhY2hpbmcgc3Vic2NyaXB0aW9ucyBkb25lIHZpYVxuICAgICAgICAgKiA8Y29kZT5ub2RlLm9uKHR5cGUsIGZuKTwvY29kZT4uICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBjbGVhbiB1cCBhbnlcbiAgICAgICAgICogc3Vic2NyaXB0aW9ucyBtYWRlIGluIHRoZSA8Y29kZT5vbigpPC9jb2RlPiBwaGFzZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgZGV0YWNoXG4gICAgICAgICAqIEBwYXJhbSBub2RlIHtOb2RlfSB0aGUgbm9kZSB0aGUgc3Vic2NyaXB0aW9uIHdhcyBhcHBsaWVkIHRvXG4gICAgICAgICAqIEBwYXJhbSBzdWIge1N1YnNjcmlwdGlvbn0gdGhlIG9iamVjdCB0cmFja2luZyB0aGlzIHN1YnNjcmlwdGlvblxuICAgICAgICAgKiBAcGFyYW0gbm90aWZpZXIge1N5bnRoZXRpY0V2ZW50Lk5vdGlmaWVyfSB0aGUgTm90aWZpZXIgdXNlZCB0b1xuICAgICAgICAgKiAgICAgICAgICAgICAgdHJpZ2dlciB0aGUgZXhlY3V0aW9uIG9mIHRoZSBzdWJzY3JpYmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZGV0YWNoOiBub29wLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5JbXBsZW1lbnRlcnMgU0hPVUxEIHByb3ZpZGUgdGhpcyBtZXRob2QgZGVmaW5pdGlvbi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPkltcGxlbWVudGF0aW9uIGxvZ2ljIGZvciBzdWJzY3JpcHRpb25zIGRvbmUgdmlhXG4gICAgICAgICAqIDxjb2RlPm5vZGUuZGVsZWdhdGUodHlwZSwgZm4sIGZpbHRlcik8L2NvZGU+IG9yXG4gICAgICAgICAqIDxjb2RlPlkuZGVsZWdhdGUodHlwZSwgZm4sIGNvbnRhaW5lciwgZmlsdGVyKTwvY29kZT4uICBMaWtlIHdpdGhcbiAgICAgICAgICogPGNvZGU+b24oKTwvY29kZT4gYWJvdmUsIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG1vbml0b3IgdGhlIGVudmlyb25tZW50XG4gICAgICAgICAqIGZvciB0aGUgZXZlbnQgYmVpbmcgZmlyZWQsIGFuZCB0cmlnZ2VyIHN1YnNjcmlwdGlvbiBleGVjdXRpb24gYnlcbiAgICAgICAgICogY2FsbGluZyA8Y29kZT5ub3RpZmllci5maXJlKGUpPC9jb2RlPi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlRoaXMgZnVuY3Rpb24gcmVjZWl2ZXMgYSBmb3VydGggYXJndW1lbnQsIHdoaWNoIGlzIHRoZSBmaWx0ZXJcbiAgICAgICAgICogdXNlZCB0byBpZGVudGlmeSB3aGljaCBOb2RlJ3MgYXJlIG9mIGludGVyZXN0IHRvIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICAgICAqIFRoZSBmaWx0ZXIgd2lsbCBiZSBlaXRoZXIgYSBib29sZWFuIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHRhcmdldFxuICAgICAgICAgKiBOb2RlIGZvciBlYWNoIGhpZXJhcmNoeSBsZXZlbCBhcyB0aGUgZXZlbnQgYnViYmxlcywgb3IgYSBzZWxlY3RvclxuICAgICAgICAgKiBzdHJpbmcuICBUbyB0cmFuc2xhdGUgc2VsZWN0b3Igc3RyaW5ncyBpbnRvIGZpbHRlciBmdW5jdGlvbnMsIHVzZVxuICAgICAgICAgKiA8Y29kZT5ZLmRlbGVnYXRlLmNvbXBpbGVGaWx0ZXIoZmlsdGVyKTwvY29kZT4uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGRlbGVnYXRlXG4gICAgICAgICAqIEBwYXJhbSBub2RlIHtOb2RlfSB0aGUgbm9kZSB0aGUgc3Vic2NyaXB0aW9uIGlzIGJlaW5nIGFwcGxpZWQgdG9cbiAgICAgICAgICogQHBhcmFtIHN1YiB7U3Vic2NyaXB0aW9ufSB0aGUgb2JqZWN0IHRvIHRyYWNrIHRoaXMgc3Vic2NyaXB0aW9uXG4gICAgICAgICAqIEBwYXJhbSBub3RpZmllciB7U3ludGhldGljRXZlbnQuTm90aWZpZXJ9IGNhbGwgbm90aWZpZXIuZmlyZSguLikgdG9cbiAgICAgICAgICogICAgICAgICAgICAgIHRyaWdnZXIgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgc3Vic2NyaWJlcnNcbiAgICAgICAgICogQHBhcmFtIGZpbHRlciB7U3RyaW5nfEZ1bmN0aW9ufSBTZWxlY3RvciBzdHJpbmcgb3IgZnVuY3Rpb24gdGhhdFxuICAgICAgICAgKiAgICAgICAgICAgICAgYWNjZXB0cyBhbiBldmVudCBvYmplY3QgYW5kIHJldHVybnMgbnVsbCwgYSBOb2RlLCBvciBhblxuICAgICAgICAgKiAgICAgICAgICAgICAgYXJyYXkgb2YgTm9kZXMgbWF0Y2hpbmcgdGhlIGNyaXRlcmlhIGZvciBwcm9jZXNzaW5nLlxuICAgICAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgICAgICovXG4gICAgICAgIGRlbGVnYXRlICAgICAgIDogbm9vcCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+SW1wbGVtZW50ZXJzIFNIT1VMRCBwcm92aWRlIHRoaXMgbWV0aG9kIGRlZmluaXRpb24uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5JbXBsZW1lbnRhdGlvbiBsb2dpYyBmb3IgZGV0YWNoaW5nIHN1YnNjcmlwdGlvbnMgZG9uZSB2aWFcbiAgICAgICAgICogPGNvZGU+bm9kZS5kZWxlZ2F0ZSh0eXBlLCBmbiwgZmlsdGVyKTwvY29kZT4gb3JcbiAgICAgICAgICogPGNvZGU+WS5kZWxlZ2F0ZSh0eXBlLCBmbiwgY29udGFpbmVyLCBmaWx0ZXIpPC9jb2RlPi4gIFRoaXMgZnVuY3Rpb25cbiAgICAgICAgICogc2hvdWxkIGNsZWFuIHVwIGFueSBzdWJzY3JpcHRpb25zIG1hZGUgaW4gdGhlXG4gICAgICAgICAqIDxjb2RlPmRlbGVnYXRlKCk8L2NvZGU+IHBoYXNlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBkZXRhY2hEZWxlZ2F0ZVxuICAgICAgICAgKiBAcGFyYW0gbm9kZSB7Tm9kZX0gdGhlIG5vZGUgdGhlIHN1YnNjcmlwdGlvbiB3YXMgYXBwbGllZCB0b1xuICAgICAgICAgKiBAcGFyYW0gc3ViIHtTdWJzY3JpcHRpb259IHRoZSBvYmplY3QgdHJhY2tpbmcgdGhpcyBzdWJzY3JpcHRpb25cbiAgICAgICAgICogQHBhcmFtIG5vdGlmaWVyIHtTeW50aGV0aWNFdmVudC5Ob3RpZmllcn0gdGhlIE5vdGlmaWVyIHVzZWQgdG9cbiAgICAgICAgICogICAgICAgICAgICAgIHRyaWdnZXIgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgc3Vic2NyaWJlcnNcbiAgICAgICAgICogQHBhcmFtIGZpbHRlciB7U3RyaW5nfEZ1bmN0aW9ufSBTZWxlY3RvciBzdHJpbmcgb3IgZnVuY3Rpb24gdGhhdFxuICAgICAgICAgKiAgICAgICAgICAgICAgYWNjZXB0cyBhbiBldmVudCBvYmplY3QgYW5kIHJldHVybnMgbnVsbCwgYSBOb2RlLCBvciBhblxuICAgICAgICAgKiAgICAgICAgICAgICAgYXJyYXkgb2YgTm9kZXMgbWF0Y2hpbmcgdGhlIGNyaXRlcmlhIGZvciBwcm9jZXNzaW5nLlxuICAgICAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgICAgICovXG4gICAgICAgIGRldGFjaERlbGVnYXRlIDogbm9vcCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB1cCB0aGUgYm9pbGVycGxhdGUgZm9yIGRldGFjaGluZyB0aGUgZXZlbnQgYW5kIGZhY2lsaXRhdGluZyB0aGVcbiAgICAgICAgICogZXhlY3V0aW9uIG9mIHN1YnNjcmliZXIgY2FsbGJhY2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIF9vblxuICAgICAgICAgKiBAcGFyYW0gYXJncyB7QXJyYXl9IGFycmF5IG9mIGFyZ3VtZW50cyBwYXNzZWQgdG9cbiAgICAgICAgICogICAgICAgICAgICAgIDxjb2RlPlkub24oLi4uKTwvY29kZT4gb3IgPGNvZGU+WS5kZWxlZ2F0ZSguLi4pPC9jb2RlPlxuICAgICAgICAgKiBAcGFyYW0gZGVsZWdhdGUge0Jvb2xlYW59IHRydWUgaWYgY2FsbGVkIGZyb21cbiAgICAgICAgICogPGNvZGU+WS5kZWxlZ2F0ZSguLi4pPC9jb2RlPlxuICAgICAgICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gdGhlIGRldGFjaCBoYW5kbGUgZm9yIHRoaXMgc3Vic2NyaXB0aW9uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIHNpbmNlIDMuMi4wXG4gICAgICAgICAqL1xuICAgICAgICBfb246IGZ1bmN0aW9uIChhcmdzLCBkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXMgID0gW10sXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxBcmdzID0gYXJncy5zbGljZSgpLFxuICAgICAgICAgICAgICAgIGV4dHJhICAgID0gdGhpcy5wcm9jZXNzQXJncyhhcmdzLCBkZWxlZ2F0ZSksXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBhcmdzWzJdLFxuICAgICAgICAgICAgICAgIG1ldGhvZCAgID0gZGVsZWdhdGUgPyAnZGVsZWdhdGUnIDogJ29uJyxcbiAgICAgICAgICAgICAgICBub2RlcywgaGFuZGxlO1xuXG4gICAgICAgICAgICAvLyBDYW4ndCBqdXN0IHVzZSBZLmFsbCBiZWNhdXNlIGl0IGRvZXNuJ3Qgc3VwcG9ydCB3aW5kb3cgKHlldD8pXG4gICAgICAgICAgICBub2RlcyA9IChpc1N0cmluZyhzZWxlY3RvcikpID9cbiAgICAgICAgICAgICAgICBxdWVyeShzZWxlY3RvcikgOlxuICAgICAgICAgICAgICAgIHRvQXJyYXkoc2VsZWN0b3IgfHwgWS5vbmUoWS5jb25maWcud2luKSk7XG5cbiAgICAgICAgICAgIGlmICghbm9kZXMubGVuZ3RoICYmIGlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZSA9IFkub24oJ2F2YWlsYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgWS5taXgoaGFuZGxlLCBZW21ldGhvZF0uYXBwbHkoWSwgb3JpZ2luYWxBcmdzKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSwgc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgWS5BcnJheS5lYWNoKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJBcmdzID0gYXJncy5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI7XG5cbiAgICAgICAgICAgICAgICBub2RlID0gWS5vbmUobm9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IHN1YkFyZ3Muc3BsaWNlKDMsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gKHR5cGUsIGZuLCBlbCwgdGhpc09iaiwgLi4uKSA9PiAoZm4sIHRoaXNPYmosIC4uLilcbiAgICAgICAgICAgICAgICAgICAgc3ViQXJncy5zcGxpY2UoMCwgNCwgc3ViQXJnc1sxXSwgc3ViQXJnc1szXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZXZlbnREdXBzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5nZXRTdWJzKG5vZGUsIGFyZ3MsIG51bGwsIHRydWUpKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVzLnB1c2godGhpcy5fc3Vic2NyaWJlKG5vZGUsIG1ldGhvZCwgc3ViQXJncywgZXh0cmEsIGZpbHRlcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiAoaGFuZGxlcy5sZW5ndGggPT09IDEpID9cbiAgICAgICAgICAgICAgICBoYW5kbGVzWzBdIDpcbiAgICAgICAgICAgICAgICBuZXcgWS5FdmVudEhhbmRsZShoYW5kbGVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBOb3RpZmllciBvYmplY3QgZm9yIHVzZSBieSB0aGlzIGV2ZW50J3NcbiAgICAgICAgICogPGNvZGU+b24oLi4uKTwvY29kZT4gb3IgPGNvZGU+ZGVsZWdhdGUoLi4uKTwvY29kZT4gaW1wbGVtZW50YXRpb25cbiAgICAgICAgICogYW5kIHJlZ2lzdGVyIHRoZSBjdXN0b20gZXZlbnQgcHJveHkgaW4gdGhlIERPTSBzeXN0ZW0gZm9yIGNsZWFudXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX3N1YnNjcmliZVxuICAgICAgICAgKiBAcGFyYW0gbm9kZSB7Tm9kZX0gdGhlIE5vZGUgaG9zdGluZyB0aGUgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIG1ldGhvZCB7U3RyaW5nfSBcIm9uXCIgb3IgXCJkZWxlZ2F0ZVwiXG4gICAgICAgICAqIEBwYXJhbSBhcmdzIHtBcnJheX0gdGhlIHN1YnNjcmlwdGlvbiBhcmd1bWVudHMgcGFzc2VkIHRvIGVpdGhlclxuICAgICAgICAgKiAgICAgICAgICAgICAgPGNvZGU+WS5vbiguLi4pPC9jb2RlPiBvciA8Y29kZT5ZLmRlbGVnYXRlKC4uLik8L2NvZGU+XG4gICAgICAgICAqICAgICAgICAgICAgICBhZnRlciBydW5uaW5nIHRocm91Z2ggPGNvZGU+cHJvY2Vzc0FyZ3MoYXJncyk8L2NvZGU+IHRvXG4gICAgICAgICAqICAgICAgICAgICAgICBub3JtYWxpemUgdGhlIGFyZ3VtZW50IHNpZ25hdHVyZVxuICAgICAgICAgKiBAcGFyYW0gZXh0cmEge2FueX0gRXh0cmEgZGF0YSBwYXJzZWQgZnJvbVxuICAgICAgICAgKiAgICAgICAgICAgICAgPGNvZGU+cHJvY2Vzc0FyZ3MoYXJncyk8L2NvZGU+XG4gICAgICAgICAqIEBwYXJhbSBmaWx0ZXIge1N0cmluZ3xGdW5jdGlvbn0gdGhlIHNlbGVjdG9yIHN0cmluZyBvciBmdW5jdGlvblxuICAgICAgICAgKiAgICAgICAgICAgICAgZmlsdGVyIHBhc3NlZCB0byA8Y29kZT5ZLmRlbGVnYXRlKC4uLik8L2NvZGU+IChub3RcbiAgICAgICAgICogICAgICAgICAgICAgIHByZXNlbnQgd2hlbiBjYWxsZWQgZnJvbSA8Y29kZT5ZLm9uKC4uLik8L2NvZGU+KVxuICAgICAgICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHNpbmNlIDMuMi4wXG4gICAgICAgICAqL1xuICAgICAgICBfc3Vic2NyaWJlOiBmdW5jdGlvbiAobm9kZSwgbWV0aG9kLCBhcmdzLCBleHRyYSwgZmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IG5ldyBZLkN1c3RvbUV2ZW50KHRoaXMudHlwZSwgdGhpcy5wdWJsaXNoQ29uZmlnKSxcbiAgICAgICAgICAgICAgICBoYW5kbGUgICAgID0gZGlzcGF0Y2hlci5vbi5hcHBseShkaXNwYXRjaGVyLCBhcmdzKSxcbiAgICAgICAgICAgICAgICBub3RpZmllciAgID0gbmV3IE5vdGlmaWVyKGhhbmRsZSwgdGhpcy5lbWl0RmFjYWRlKSxcbiAgICAgICAgICAgICAgICByZWdpc3RyeSAgID0gU3ludGhldGljRXZlbnQuZ2V0UmVnaXN0cnkobm9kZSwgdGhpcy50eXBlLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBzdWIgICAgICAgID0gaGFuZGxlLnN1YjtcblxuICAgICAgICAgICAgc3ViLm5vZGUgICA9IG5vZGU7XG4gICAgICAgICAgICBzdWIuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUFyZ0V4dHJhcyhleHRyYSwgc3ViKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgWS5taXgoZGlzcGF0Y2hlciwge1xuICAgICAgICAgICAgICAgIGV2ZW50RGVmICAgICA6IHRoaXMsXG4gICAgICAgICAgICAgICAgbm90aWZpZXIgICAgIDogbm90aWZpZXIsXG4gICAgICAgICAgICAgICAgaG9zdCAgICAgICAgIDogbm9kZSwgICAgICAgLy8gSSBmb3JnZXQgd2hhdCB0aGlzIGlzIGZvclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IG5vZGUsICAgICAgIC8vIGZvciBnZW5lcmF0aW5nIGZhY2FkZXNcbiAgICAgICAgICAgICAgICB0YXJnZXQgICAgICAgOiBub2RlLCAgICAgICAvLyBmb3IgZ2VuZXJhdGluZyBmYWNhZGVzXG4gICAgICAgICAgICAgICAgZWwgICAgICAgICAgIDogbm9kZS5fbm9kZSwgLy8gRm9yIGNhdGVnb3J5IGRldGFjaFxuXG4gICAgICAgICAgICAgICAgX2RlbGV0ZSAgICAgIDogU3ludGhldGljRXZlbnQuX2RlbGV0ZVN1YlxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGhhbmRsZS5ub3RpZmllciA9IG5vdGlmaWVyO1xuXG4gICAgICAgICAgICByZWdpc3RyeS5yZWdpc3RlcihoYW5kbGUpO1xuXG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBpbXBsZW1lbnRhdGlvbidzIFwib25cIiBvciBcImRlbGVnYXRlXCIgbWV0aG9kXG4gICAgICAgICAgICB0aGlzW21ldGhvZF0obm9kZSwgc3ViLCBub3RpZmllciwgZmlsdGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+SW1wbGVtZW50ZXJzIE1BWSBwcm92aWRlIHRoaXMgbWV0aG9kIGRlZmluaXRpb24uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5JbXBsZW1lbnQgdGhpcyBmdW5jdGlvbiBpZiB5b3Ugd2FudCBleHRyYSBkYXRhIGV4dHJhY3RlZCBkdXJpbmdcbiAgICAgICAgICogcHJvY2Vzc0FyZ3MgdG8gYmUgcHJvcGFnYXRlZCB0byBzdWJzY3JpcHRpb25zIG9uIGEgcGVyLW5vZGUgYmFzaXMuXG4gICAgICAgICAqIFRoYXQgaXMgdG8gc2F5LCBpZiB5b3UgY2FsbCA8Y29kZT5ZLm9uKCd4eXonLCBmbiwgeHRyYSwgJ2RpdicpPC9jb2RlPlxuICAgICAgICAgKiB0aGUgZGF0YSByZXR1cm5lZCBmcm9tIHByb2Nlc3NBcmdzIHdpbGwgYmUgc2hhcmVkXG4gICAgICAgICAqIGFjcm9zcyB0aGUgc3Vic2NyaXB0aW9uIG9iamVjdHMgZm9yIGFsbCB0aGUgZGl2cy4gIElmIHlvdSB3YW50IGVhY2hcbiAgICAgICAgICogc3Vic2NyaXB0aW9uIHRvIHJlY2VpdmUgdW5pcXVlIGluZm9ybWF0aW9uLCBkbyB0aGF0IHByb2Nlc3NpbmdcbiAgICAgICAgICogaGVyZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGFkZHMgdGhlIGRhdGEgZXh0cmFjdGVkIGJ5IHByb2Nlc3NBcmdzXG4gICAgICAgICAqIHRvIHRoZSBzdWJzY3JpcHRpb24gb2JqZWN0IGFzIDxjb2RlPnN1Yi5fZXh0cmE8L2NvZGU+LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhcHBseUFyZ0V4dHJhc1xuICAgICAgICAgKiBAcGFyYW0gZXh0cmEge2FueX0gQW55IGV4dHJhIGRhdGEgZXh0cmFjdGVkIGZyb20gcHJvY2Vzc0FyZ3NcbiAgICAgICAgICogQHBhcmFtIHN1YiB7U3Vic2NyaXB0aW9ufSB0aGUgaW5kaXZpZHVhbCBzdWJzY3JpcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5QXJnRXh0cmFzOiBmdW5jdGlvbiAoZXh0cmEsIHN1Yikge1xuICAgICAgICAgICAgc3ViLl9leHRyYSA9IGV4dHJhO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBzdWJzY3JpcHRpb24ocykgZnJvbSB0aGUgaW50ZXJuYWwgc3Vic2NyaXB0aW9uIGRpc3BhdGNoXG4gICAgICAgICAqIG1lY2hhbmlzbS4gIFNlZSA8Y29kZT5TeW50aGV0aWNFdmVudC5fZGVsZXRlU3ViPC9jb2RlPi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBfZGV0YWNoXG4gICAgICAgICAqIEBwYXJhbSBhcmdzIHtBcnJheX0gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG9cbiAgICAgICAgICogICAgICAgICAgICAgICAgICA8Y29kZT5ub2RlLmRldGFjaCguLi4pPC9jb2RlPlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgICAgICovXG4gICAgICAgIF9kZXRhY2g6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAvLyBDYW4ndCB1c2UgWS5hbGwgYmVjYXVzZSBpdCBkb2Vzbid0IHN1cHBvcnQgd2luZG93ICh5ZXQ/KVxuICAgICAgICAgICAgLy8gVE9ETzogRG9lcyBZLmFsbCBzdXBwb3J0IHdpbmRvdyBub3c/XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gYXJnc1syXSxcbiAgICAgICAgICAgICAgICBlbHMgICAgPSAoaXNTdHJpbmcodGFyZ2V0KSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5KHRhcmdldCkgOiB0b0FycmF5KHRhcmdldCksXG4gICAgICAgICAgICAgICAgbm9kZSwgaSwgbGVuLCBoYW5kbGVzLCBqO1xuXG4gICAgICAgICAgICAvLyAodHlwZSwgZm4sIGVsLCBjb250ZXh0LCBmaWx0ZXI/KSA9PiAodHlwZSwgZm4sIGNvbnRleHQsIGZpbHRlcj8pXG4gICAgICAgICAgICBhcmdzLnNwbGljZSgyLCAxKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZWxzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IFkub25lKGVsc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVzID0gdGhpcy5nZXRTdWJzKG5vZGUsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBoYW5kbGVzLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlc1tqXS5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGV0YWNoIGhhbmRsZXMgb2Ygc3Vic2NyaXB0aW9ucyBvbiBhIG5vZGUgdGhhdCBzYXRpc2Z5IGFcbiAgICAgICAgICogc2VhcmNoL2ZpbHRlciBmdW5jdGlvbi4gIEJ5IGRlZmF1bHQsIHRoZSBmaWx0ZXIgdXNlZCBpcyB0aGVcbiAgICAgICAgICogPGNvZGU+c3ViTWF0Y2g8L2NvZGU+IG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBnZXRTdWJzXG4gICAgICAgICAqIEBwYXJhbSBub2RlIHtOb2RlfSB0aGUgbm9kZSBob3N0aW5nIHRoZSBldmVudFxuICAgICAgICAgKiBAcGFyYW0gYXJncyB7QXJyYXl9IHRoZSBhcnJheSBvZiBvcmlnaW5hbCBzdWJzY3JpcHRpb24gYXJncyBwYXNzZWRcbiAgICAgICAgICogICAgICAgICAgICAgIHRvIDxjb2RlPlkub24oLi4uKTwvY29kZT4gKGJlZm9yZVxuICAgICAgICAgKiAgICAgICAgICAgICAgPGNvZGU+cHJvY2Vzc0FyZ3M8L2NvZGU+XG4gICAgICAgICAqIEBwYXJhbSBmaWx0ZXIge0Z1bmN0aW9ufSBmdW5jdGlvbiB1c2VkIHRvIGlkZW50aWZ5IGEgc3Vic2NyaXB0aW9uXG4gICAgICAgICAqICAgICAgICAgICAgICBmb3IgaW5jbHVzaW9uIGluIHRoZSByZXR1cm5lZCBhcnJheVxuICAgICAgICAgKiBAcGFyYW0gZmlyc3Qge0Jvb2xlYW59IHN0b3AgYWZ0ZXIgdGhlIGZpcnN0IG1hdGNoICh1c2VkIHRvIGNoZWNrIGZvclxuICAgICAgICAgKiAgICAgICAgICAgICAgZHVwbGljYXRlIHN1YnNjcmlwdGlvbnMpXG4gICAgICAgICAqIEByZXR1cm4ge0V2ZW50SGFuZGxlW119IGRldGFjaCBoYW5kbGVzIGZvciB0aGUgbWF0Y2hpbmcgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3ViczogZnVuY3Rpb24gKG5vZGUsIGFyZ3MsIGZpbHRlciwgZmlyc3QpIHtcbiAgICAgICAgICAgIHZhciByZWdpc3RyeSA9IFN5bnRoZXRpY0V2ZW50LmdldFJlZ2lzdHJ5KG5vZGUsIHRoaXMudHlwZSksXG4gICAgICAgICAgICAgICAgaGFuZGxlcyAgPSBbXSxcbiAgICAgICAgICAgICAgICBhbGxIYW5kbGVzLCBpLCBsZW4sIGhhbmRsZTtcblxuICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5KSB7XG4gICAgICAgICAgICAgICAgYWxsSGFuZGxlcyA9IHJlZ2lzdHJ5LmhhbmRsZXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSB0aGlzLnN1Yk1hdGNoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGFsbEhhbmRsZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gYWxsSGFuZGxlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5jYWxsKHRoaXMsIGhhbmRsZS5zdWIsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVzLnB1c2goYWxsSGFuZGxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVzLmxlbmd0aCAmJiBoYW5kbGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5JbXBsZW1lbnRlcnMgTUFZIG92ZXJyaWRlIHRoaXMgdG8gZGVmaW5lIHdoYXQgY29uc3RpdHV0ZXMgYVxuICAgICAgICAgKiAmcXVvdDtzYW1lJnF1b3Q7IHN1YnNjcmlwdGlvbi4gIE92ZXJyaWRlIGltcGxlbWVudGF0aW9ucyBzaG91bGRcbiAgICAgICAgICogY29uc2lkZXIgdGhlIGxhY2sgb2YgYSBjb21wYXJhdG9yIGFzIGEgbWF0Y2gsIHNvIGNhbGxpbmdcbiAgICAgICAgICogPGNvZGU+Z2V0U3VicygpPC9jb2RlPiB3aXRoIG5vIGFyZ3VtZW50cyB3aWxsIHJldHVybiBhbGwgc3Vicy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPkNvbXBhcmVzIGEgc2V0IG9mIHN1YnNjcmlwdGlvbiBhcmd1bWVudHMgYWdhaW5zdCBhIFN1YnNjcmlwdGlvblxuICAgICAgICAgKiBvYmplY3QgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgbWF0Y2guICBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgKiBjb21wYXJlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gYWdhaW5zdCB0aGUgc2Vjb25kIGFyZ3VtZW50IHBhc3NlZCB0b1xuICAgICAgICAgKiA8Y29kZT5ZLm9uKC4uLik8L2NvZGU+IG9yIDxjb2RlPm5vZGUuZGV0YWNoKC4uLik8L2NvZGU+IGV0Yy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgc3ViTWF0Y2hcbiAgICAgICAgICogQHBhcmFtIHN1YiB7U3Vic2NyaXB0aW9ufSB0aGUgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uXG4gICAgICAgICAqIEBwYXJhbSBhcmdzIHtBcnJheX0gdGhlIGNhbGxpbmcgYXJndW1lbnRzIHBhc3NlZCB0b1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIDxjb2RlPlkub24oLi4uKTwvY29kZT4gZXRjLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzdWIgY2FuIGJlIGRlc2NyaWJlZCBieSB0aGUgYXJnc1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIHByZXNlbnRcbiAgICAgICAgICogQHNpbmNlIDMuMi4wXG4gICAgICAgICAqL1xuICAgICAgICBzdWJNYXRjaDogZnVuY3Rpb24gKHN1YiwgYXJncykge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBkZXRhY2ggY2FyZXMgb25seSBhYm91dCB0aGUgY2FsbGJhY2sgbWF0Y2hpbmdcbiAgICAgICAgICAgIHJldHVybiAhYXJnc1sxXSB8fCBzdWIuZm4gPT09IGFyZ3NbMV07XG4gICAgICAgIH1cbiAgICB9XG59LCB0cnVlKTtcblxuWS5TeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAqIDxwPkRlZmluZXMgYSBuZXcgZXZlbnQgaW4gdGhlIERPTSBldmVudCBzeXN0ZW0uICBJbXBsZW1lbnRlcnMgYXJlXG4gKiByZXNwb25zaWJsZSBmb3IgbW9uaXRvcmluZyBmb3IgYSBzY2VuYXJpbyB3aGVyZWJ5IHRoZSBldmVudCBpcyBmaXJlZC4gIEFcbiAqIG5vdGlmaWVyIG9iamVjdCBpcyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb25zIGlkZW50aWZpZWQgYmVsb3cuICBXaGVuIHRoZVxuICogY3JpdGVyaWEgZGVmaW5pbmcgdGhlIGV2ZW50IGFyZSBtZXQsIGNhbGwgbm90aWZpZXIuZmlyZSggW2FyZ3NdICk7IHRvXG4gKiBleGVjdXRlIGV2ZW50IHN1YnNjcmliZXJzLjwvcD5cbiAqXG4gKiA8cD5UaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSBuYW1lIG9mIHRoZSBldmVudC4gIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIGFcbiAqIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdoaWNoIGRlZmluZSB0aGUgYmVoYXZpb3Igb2YgdGhlIGV2ZW50IHN5c3RlbSB3aGVuIHRoZVxuICogbmV3IGV2ZW50IGlzIHN1YnNjcmliZWQgdG8gb3IgZGV0YWNoZWQgZnJvbS4gIFRoZSBtZXRob2RzIHRoYXQgc2hvdWxkIGJlXG4gKiBkZWZpbmVkIGluIHRoaXMgY29uZmlndXJhdGlvbiBvYmplY3QgYXJlIDxjb2RlPm9uPC9jb2RlPixcbiAqIDxjb2RlPmRldGFjaDwvY29kZT4sIDxjb2RlPmRlbGVnYXRlPC9jb2RlPiwgYW5kIDxjb2RlPmRldGFjaERlbGVnYXRlPC9jb2RlPi5cbiAqIFlvdSBhcmUgZnJlZSB0byBkZWZpbmUgYW55IG90aGVyIG1ldGhvZHMgb3IgcHJvcGVydGllcyBuZWVkZWQgdG8gZGVmaW5lIHlvdXJcbiAqIGV2ZW50LiAgQmUgYXdhcmUsIGhvd2V2ZXIsIHRoYXQgc2luY2UgdGhlIG9iamVjdCBpcyB1c2VkIHRvIHN1YmNsYXNzXG4gKiBTeW50aGV0aWNFdmVudCwgeW91IHNob3VsZCBhdm9pZCBtZXRob2QgbmFtZXMgdXNlZCBieSBTeW50aGV0aWNFdmVudCB1bmxlc3NcbiAqIHlvdXIgaW50ZW50aW9uIGlzIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yLjwvcD5cbiAqXG4gKiA8cD5UaGlzIGlzIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgeW91IGNhbiBvciBzaG91bGQgc3BlY2lmeVxuICogaW4gdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0OjwvcD5cbiAqXG4gKiA8ZGw+XG4gKiAgIDxkdD48Y29kZT5vbjwvY29kZT48L2R0PlxuICogICAgICAgPGRkPjxjb2RlPmZ1bmN0aW9uIChub2RlLCBzdWJzY3JpcHRpb24sIG5vdGlmaWVyKTwvY29kZT4gVGhlXG4gKiAgICAgICBpbXBsZW1lbnRhdGlvbiBsb2dpYyBmb3Igc3Vic2NyaXB0aW9uLiAgQW55IHNwZWNpYWwgc2V0dXAgeW91IG5lZWQgdG9cbiAqICAgICAgIGRvIHRvIGNyZWF0ZSB0aGUgZW52aXJvbm1lbnQgZm9yIHRoZSBldmVudCBiZWluZyBmaXJlZC0tRS5nLiBuYXRpdmVcbiAqICAgICAgIERPTSBldmVudCBzdWJzY3JpcHRpb25zLiAgU3RvcmUgc3Vic2NyaXB0aW9uIHJlbGF0ZWQgb2JqZWN0cyBhbmRcbiAqICAgICAgIHN0YXRlIG9uIHRoZSA8Y29kZT5zdWJzY3JpcHRpb248L2NvZGU+IG9iamVjdC4gIFdoZW4gdGhlXG4gKiAgICAgICBjcml0ZXJpYSBoYXZlIGJlZW4gbWV0IHRvIGZpcmUgdGhlIHN5bnRoZXRpYyBldmVudCwgY2FsbFxuICogICAgICAgPGNvZGU+bm90aWZpZXIuZmlyZShlKTwvY29kZT4uICBTZWUgTm90aWZpZXIncyA8Y29kZT5maXJlKCk8L2NvZGU+XG4gKiAgICAgICBtZXRob2QgZm9yIGRldGFpbHMgYWJvdXQgd2hhdCB0byBwYXNzIGFzIHBhcmFtZXRlcnMuPC9kZD5cbiAqXG4gKiAgIDxkdD48Y29kZT5kZXRhY2g8L2NvZGU+PC9kdD5cbiAqICAgICAgIDxkZD48Y29kZT5mdW5jdGlvbiAobm9kZSwgc3Vic2NyaXB0aW9uLCBub3RpZmllcik8L2NvZGU+IFRoZVxuICogICAgICAgaW1wbGVtZW50YXRpb24gbG9naWMgZm9yIGNsZWFuaW5nIHVwIGEgZGV0YWNoZWQgc3Vic2NyaXB0aW9uLiBFLmcuXG4gKiAgICAgICBkZXRhY2ggYW55IERPTSBzdWJzY3JpcHRpb25zIGFkZGVkIGluIDxjb2RlPm9uPC9jb2RlPi48L2RkPlxuICpcbiAqICAgPGR0Pjxjb2RlPmRlbGVnYXRlPC9jb2RlPjwvZHQ+XG4gKiAgICAgICA8ZGQ+PGNvZGU+ZnVuY3Rpb24gKG5vZGUsIHN1YnNjcmlwdGlvbiwgbm90aWZpZXIsIGZpbHRlcik8L2NvZGU+IFRoZVxuICogICAgICAgaW1wbGVtZW50YXRpb24gbG9naWMgZm9yIHN1YnNjcmlwdGlvbiB2aWEgPGNvZGU+WS5kZWxlZ2F0ZTwvY29kZT4gb3JcbiAqICAgICAgIDxjb2RlPm5vZGUuZGVsZWdhdGU8L2NvZGU+LiAgVGhlIGZpbHRlciBpcyB0eXBpY2FsbHkgZWl0aGVyIGEgc2VsZWN0b3JcbiAqICAgICAgIHN0cmluZyBvciBhIGZ1bmN0aW9uLiAgWW91IGNhbiB1c2VcbiAqICAgICAgIDxjb2RlPlkuZGVsZWdhdGUuY29tcGlsZUZpbHRlcihzZWxlY3RvclN0cmluZyk8L2NvZGU+IHRvIGNyZWF0ZSBhXG4gKiAgICAgICBmaWx0ZXIgZnVuY3Rpb24gZnJvbSBhIHNlbGVjdG9yIHN0cmluZyBpZiBuZWVkZWQuICBUaGUgZmlsdGVyIGZ1bmN0aW9uXG4gKiAgICAgICBleHBlY3RzIGFuIGV2ZW50IG9iamVjdCBhcyBpbnB1dCBhbmQgc2hvdWxkIG91dHB1dCBlaXRoZXIgbnVsbCwgYVxuICogICAgICAgbWF0Y2hpbmcgTm9kZSwgb3IgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgTm9kZXMuICBPdGhlcndpc2UsIHRoaXMgYWN0c1xuICogICAgICAgbGlrZSA8Y29kZT5vbjwvY29kZT4gRE9NIGV2ZW50IHN1YnNjcmlwdGlvbnMuICBTdG9yZSBzdWJzY3JpcHRpb25cbiAqICAgICAgIHJlbGF0ZWQgb2JqZWN0cyBhbmQgaW5mb3JtYXRpb24gb24gdGhlIDxjb2RlPnN1YnNjcmlwdGlvbjwvY29kZT5cbiAqICAgICAgIG9iamVjdC4gIFdoZW4gdGhlIGNyaXRlcmlhIGhhdmUgYmVlbiBtZXQgdG8gZmlyZSB0aGUgc3ludGhldGljIGV2ZW50LFxuICogICAgICAgY2FsbCA8Y29kZT5ub3RpZmllci5maXJlKGUpPC9jb2RlPiBhcyBub3RlZCBhYm92ZS48L2RkPlxuICpcbiAqICAgPGR0Pjxjb2RlPmRldGFjaERlbGVnYXRlPC9jb2RlPjwvZHQ+XG4gKiAgICAgICA8ZGQ+PGNvZGU+ZnVuY3Rpb24gKG5vZGUsIHN1YnNjcmlwdGlvbiwgbm90aWZpZXIpPC9jb2RlPiBUaGVcbiAqICAgICAgIGltcGxlbWVudGF0aW9uIGxvZ2ljIGZvciBjbGVhbmluZyB1cCBhIGRldGFjaGVkIGRlbGVnYXRlIHN1YnNjcmlwdGlvbi5cbiAqICAgICAgIEUuZy4gZGV0YWNoIGFueSBET00gZGVsZWdhdGUgc3Vic2NyaXB0aW9ucyBhZGRlZCBpblxuICogICAgICAgPGNvZGU+ZGVsZWdhdGU8L2NvZGU+LjwvZGQ+XG4gKlxuICogICA8ZHQ+PGNvZGU+cHVibGlzaENvbmZpZzwvY29kZT48L2R0PlxuICogICAgICAgPGRkPihPYmplY3QpIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IHdpbGwgYmUgdXNlZCB0byBpbnN0YW50aWF0ZVxuICogICAgICAgdGhlIHVuZGVybHlpbmcgQ3VzdG9tRXZlbnQuIFNlZSBOb3RpZmllcidzIDxjb2RlPmZpcmU8L2NvZGU+IG1ldGhvZFxuICogICAgICAgZm9yIGRldGFpbHMuPC9kZD5cbiAqXG4gKiAgIDxkdD48Y29kZT5wcm9jZXNzQXJnczwvY29kZT48L2R0XG4gKiAgICAgICA8ZGQ+XG4gKiAgICAgICAgICA8cD48Y29kZT5mdW5jdGlvbiAoYXJnQXJyYXksIGZyb21EZWxlZ2F0ZSk8L2NvZGU+IE9wdGlvbmFsIG1ldGhvZFxuICogICAgICAgICAgdG8gZXh0cmFjdCBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgZnJvbSB0aGUgc3Vic2NyaXB0aW9uXG4gKiAgICAgICAgICBzaWduYXR1cmUuICBVc2luZyB0aGlzIGFsbG93cyA8Y29kZT5vbjwvY29kZT4gb3JcbiAqICAgICAgICAgIDxjb2RlPmRlbGVnYXRlPC9jb2RlPiBzaWduYXR1cmVzIGxpa2VcbiAqICAgICAgICAgIDxjb2RlPm5vZGUub24oJnF1b3Q7aG92ZXImcXVvdDssIG92ZXJDYWxsYmFjayxcbiAqICAgICAgICAgIG91dENhbGxiYWNrKTwvY29kZT4uPC9wPlxuICogICAgICAgICAgPHA+V2hlbiBwcm9jZXNzaW5nIGFuIGF0eXBpY2FsIGFyZ3VtZW50IHNpZ25hdHVyZSwgbWFrZSBzdXJlIHRoZVxuICogICAgICAgICAgYXJncyBhcnJheSBpcyByZXR1cm5lZCB0byB0aGUgbm9ybWFsIHNpZ25hdHVyZSBiZWZvcmUgcmV0dXJuaW5nXG4gKiAgICAgICAgICBmcm9tIHRoZSBmdW5jdGlvbi4gIEZvciBleGFtcGxlLCBpbiB0aGUgJnF1b3Q7aG92ZXImcXVvdDsgZXhhbXBsZVxuICogICAgICAgICAgYWJvdmUsIHRoZSA8Y29kZT5vdXRDYWxsYmFjazwvY29kZT4gbmVlZHMgdG8gYmUgPGNvZGU+c3BsaWNlPC9jb2RlPmRcbiAqICAgICAgICAgIG91dCBvZiB0aGUgYXJyYXkuICBUaGUgZXhwZWN0ZWQgc2lnbmF0dXJlIG9mIHRoZSBhcmdzIGFycmF5IGZvclxuICogICAgICAgICAgPGNvZGU+b24oKTwvY29kZT4gc3Vic2NyaXB0aW9ucyBpczo8L3A+XG4gKiAgICAgICAgICA8cHJlPlxuICogICAgICAgICAgICAgIDxjb2RlPlt0eXBlLCBjYWxsYmFjaywgdGFyZ2V0LCBjb250ZXh0T3ZlcnJpZGUsIGFyZ04uLi5dPC9jb2RlPlxuICogICAgICAgICAgPC9wcmU+XG4gKiAgICAgICAgICA8cD5BbmQgZm9yIDxjb2RlPmRlbGVnYXRlKCk8L2NvZGU+OjwvcD5cbiAqICAgICAgICAgIDxwcmU+XG4gKiAgICAgICAgICAgICAgPGNvZGU+W3R5cGUsIGNhbGxiYWNrLCB0YXJnZXQsIGZpbHRlciwgY29udGV4dE92ZXJyaWRlLCBhcmdOLi4uXTwvY29kZT5cbiAqICAgICAgICAgIDwvcHJlPlxuICogICAgICAgICAgPHA+d2hlcmUgPGNvZGU+dGFyZ2V0PC9jb2RlPiBpcyB0aGUgbm9kZSB0aGUgZXZlbnQgaXMgYmVpbmdcbiAqICAgICAgICAgIHN1YnNjcmliZWQgZm9yLiAgWW91IGNhbiBzZWUgdGhlc2Ugc2lnbmF0dXJlcyBkb2N1bWVudGVkIGZvclxuICogICAgICAgICAgPGNvZGU+WS5vbigpPC9jb2RlPiBhbmQgPGNvZGU+WS5kZWxlZ2F0ZSgpPC9jb2RlPiByZXNwZWN0aXZlbHkuPC9wPlxuICogICAgICAgICAgPHA+V2hhdGV2ZXIgZ2V0cyByZXR1cm5lZCBmcm9tIHRoZSBmdW5jdGlvbiB3aWxsIGJlIHN0b3JlZCBvbiB0aGVcbiAqICAgICAgICAgIDxjb2RlPnN1YnNjcmlwdGlvbjwvY29kZT4gb2JqZWN0IHVuZGVyXG4gKiAgICAgICAgICA8Y29kZT5zdWJzY3JpcHRpb24uX2V4dHJhPC9jb2RlPi48L3A+PC9kZD5cbiAqICAgPGR0Pjxjb2RlPnN1Yk1hdGNoPC9jb2RlPjwvZHQ+XG4gKiAgICAgICA8ZGQ+XG4gKiAgICAgICAgICAgPHA+PGNvZGU+ZnVuY3Rpb24gKHN1YiwgYXJncyk8L2NvZGU+ICBDb21wYXJlcyBhIHNldCBvZlxuICogICAgICAgICAgIHN1YnNjcmlwdGlvbiBhcmd1bWVudHMgYWdhaW5zdCBhIFN1YnNjcmlwdGlvbiBvYmplY3QgdG8gZGV0ZXJtaW5lXG4gKiAgICAgICAgICAgaWYgdGhleSBtYXRjaC4gIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGNvbXBhcmVzIHRoZSBjYWxsYmFja1xuICogICAgICAgICAgIGZ1bmN0aW9uIGFnYWluc3QgdGhlIHNlY29uZCBhcmd1bWVudCBwYXNzZWQgdG9cbiAqICAgICAgICAgICA8Y29kZT5ZLm9uKC4uLik8L2NvZGU+IG9yIDxjb2RlPm5vZGUuZGV0YWNoKC4uLik8L2NvZGU+IGV0Yy48L3A+XG4gKiAgICAgICA8L2RkPlxuICogPC9kbD5cbiAqXG4gKiBAbWV0aG9kIGRlZmluZVxuICogQHBhcmFtIHR5cGUge1N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gKiBAcGFyYW0gY29uZmlnIHtPYmplY3R9IHRoZSBwcm90b3R5cGUgZGVmaW5pdGlvbiBmb3IgdGhlIG5ldyBldmVudCAoc2VlIGFib3ZlKVxuICogQHBhcmFtIGZvcmNlIHtCb29sZWFufSBvdmVycmlkZSBhbiBleGlzdGluZyBldmVudCAodXNlIHdpdGggY2F1dGlvbilcbiAqIEByZXR1cm4ge1N5bnRoZXRpY0V2ZW50fSB0aGUgc3ViY2xhc3MgaW1wbGVtZW50YXRpb24gaW5zdGFuY2UgY3JlYXRlZCB0b1xuICogICAgICAgICAgICAgIGhhbmRsZSBldmVudCBzdWJzY3JpcHRpb25zIG9mIHRoaXMgdHlwZVxuICogQHN0YXRpY1xuICogQGZvciBFdmVudFxuICogQHNpbmNlIDMuMS4wXG4gKiBAaW4gZXZlbnQtc3ludGhldGljXG4gKi9cblkuRXZlbnQuZGVmaW5lID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgZm9yY2UpIHtcbiAgICB2YXIgZXZlbnREZWYsIEltcGwsIHN5bnRoO1xuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS50eXBlKSB7XG4gICAgICAgIGV2ZW50RGVmID0gdHlwZTtcbiAgICAgICAgZm9yY2UgPSBjb25maWc7XG4gICAgfSBlbHNlIGlmIChjb25maWcpIHtcbiAgICAgICAgZXZlbnREZWYgPSBZLm1lcmdlKHsgdHlwZTogdHlwZSB9LCBjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChldmVudERlZikge1xuICAgICAgICBpZiAoZm9yY2UgfHwgIVkuTm9kZS5ET01fRVZFTlRTW2V2ZW50RGVmLnR5cGVdKSB7XG4gICAgICAgICAgICBJbXBsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgWS5leHRlbmQoSW1wbCwgU3ludGhldGljRXZlbnQsIGV2ZW50RGVmKTtcbiAgICAgICAgICAgIHN5bnRoID0gbmV3IEltcGwoKTtcblxuICAgICAgICAgICAgdHlwZSA9IHN5bnRoLnR5cGU7XG5cbiAgICAgICAgICAgIFkuTm9kZS5ET01fRVZFTlRTW3R5cGVdID0gWS5FbnYuZXZ0LnBsdWdpbnNbdHlwZV0gPSB7XG4gICAgICAgICAgICAgICAgZXZlbnREZWY6IHN5bnRoLFxuXG4gICAgICAgICAgICAgICAgb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bnRoLl9vbih0b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ludGguX29uKHRvQXJyYXkoYXJndW1lbnRzKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGRldGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ludGguX2RldGFjaCh0b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodHlwZSkgfHwgaXNBcnJheSh0eXBlKSkge1xuICAgICAgICBZLkFycmF5LmVhY2godG9BcnJheSh0eXBlKSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIFkuTm9kZS5ET01fRVZFTlRTW3RdID0gMTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN5bnRoO1xufTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wibm9kZS1iYXNlXCIsIFwiZXZlbnQtY3VzdG9tLWNvbXBsZXhcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnZXZlbnQtdGFwJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG5UaGUgdGFwIG1vZHVsZSBwcm92aWRlcyBhIGdlc3R1cmUgZXZlbnRzLCBcInRhcFwiLCB3aGljaCBub3JtYWxpemVzIHVzZXIgaW50ZXJhY3Rpb25zXG5hY3Jvc3MgdG91Y2ggYW5kIG1vdXNlIG9yIHBvaW50ZXIgYmFzZWQgaW5wdXQgZGV2aWNlcy4gIFRoaXMgY2FuIGJlIHVzZWQgYnkgYXBwbGljYXRpb24gZGV2ZWxvcGVyc1xudG8gYnVpbGQgaW5wdXQgZGV2aWNlIGFnbm9zdGljIGNvbXBvbmVudHMgd2hpY2ggYmVoYXZlIHRoZSBzYW1lIGluIHJlc3BvbnNlIHRvIGVpdGhlciB0b3VjaCBvciBtb3VzZSBiYXNlZFxuaW50ZXJhY3Rpb24uXG5cbid0YXAnIGlzIGxpa2UgYSB0b3VjaHNjcmVlbiAnY2xpY2snLCBvbmx5IGl0IHJlcXVpcmVzIG11Y2ggbGVzcyBmaW5nZXItZG93biB0aW1lIHNpbmNlIGl0IGxpc3RlbnMgdG8gdG91Y2ggZXZlbnRzLFxuYnV0IHJldmVydHMgdG8gbW91c2UgZXZlbnRzIGlmIHRvdWNoIGlzIG5vdCBzdXBwb3J0ZWQuXG5cbkBleGFtcGxlXG5cbiAgICBZVUkoKS51c2UoJ2V2ZW50LXRhcCcsIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgIFkub25lKCcjbXktYnV0dG9uJykub24oJ3RhcCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG5AbW9kdWxlIGV2ZW50XG5Ac3VibW9kdWxlIGV2ZW50LXRhcFxuQGF1dGhvciBBbmRyZXMgR2FyemEsIG1hdHV6YWsgYW5kIHRpbG8gbWl0cmFcbkBzaW5jZSAzLjcuMFxuXG4qL1xudmFyIGRvYyA9IFkuY29uZmlnLmRvYyxcbiAgICBHRVNUVVJFX01BUCA9IFkuRXZlbnQuX0dFU1RVUkVfTUFQLFxuICAgIEVWVF9TVEFSVCA9IEdFU1RVUkVfTUFQLnN0YXJ0LFxuICAgIEVWVF9UQVAgPSAndGFwJyxcbiAgICBQT0lOVEVSX0VWRU5UX1RFU1QgPSAvcG9pbnRlci9pLFxuXG4gICAgSEFORExFUyA9IHtcbiAgICAgICAgU1RBUlQ6ICdZX1RBUF9PTl9TVEFSVF9IQU5ETEUnLFxuICAgICAgICBFTkQ6ICdZX1RBUF9PTl9FTkRfSEFORExFJyxcbiAgICAgICAgQ0FOQ0VMOiAnWV9UQVBfT05fQ0FOQ0VMX0hBTkRMRSdcbiAgICB9O1xuXG5mdW5jdGlvbiBkZXRhY2hIYW5kbGVzKHN1YnNjcmlwdGlvbiwgaGFuZGxlcykge1xuICAgIGhhbmRsZXMgPSBoYW5kbGVzIHx8IFkuT2JqZWN0LnZhbHVlcyhIQU5ETEVTKTtcblxuICAgIFkuQXJyYXkuZWFjaChoYW5kbGVzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaGFuZGxlID0gc3Vic2NyaXB0aW9uW2l0ZW1dO1xuICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICBoYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25baXRlbV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfSk7XG5cbn1cblxuXG4vKipcblNldHMgdXAgYSBcInRhcFwiIGV2ZW50LCB0aGF0IGlzIGZpcmVkIG9uIHRvdWNoIGRldmljZXMgaW4gcmVzcG9uc2UgdG8gYSB0YXAgZXZlbnQgKGZpbmdlciBkb3duLCBmaW5kZXIgdXApLlxuVGhpcyBldmVudCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGxpc3RlbmluZyBmb3IgY2xpY2sgZXZlbnRzIHdoaWNoIGhhdmUgYSA1MDBtcyBkZWxheSBvbiBtb3N0IHRvdWNoIGRldmljZXMuXG5UaGlzIGV2ZW50IGNhbiBhbHNvIGJlIGxpc3RlbmVkIGZvciB1c2luZyBub2RlLmRlbGVnYXRlKCkuXG5cbkBldmVudCB0YXBcbkBwYXJhbSB0eXBlIHtzdHJpbmd9IFwidGFwXCJcbkBwYXJhbSBmbiB7ZnVuY3Rpb259IFRoZSBtZXRob2QgdGhlIGV2ZW50IGludm9rZXMuIEl0IHJlY2VpdmVzIHRoZSBldmVudCBmYWNhZGUgb2YgdGhlIHVuZGVybHlpbmcgRE9NIGV2ZW50LlxuQGZvciBFdmVudFxuQHJldHVybiB7RXZlbnRIYW5kbGV9IHRoZSBkZXRhY2ggaGFuZGxlXG4qL1xuWS5FdmVudC5kZWZpbmUoRVZUX1RBUCwge1xuICAgIHB1Ymxpc2hDb25maWc6IHtcbiAgICAgICAgcHJldmVudGVkRm46IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgc3ViID0gZS50YXJnZXQub25jZSgnY2xpY2snLCBmdW5jdGlvbiAoY2xpY2spIHtcbiAgICAgICAgICAgICAgICBjbGljay5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBkZXRhY2ggdGhlIHN1YnNjcmlwdGlvbiBkdXJpbmcgdGhlIG5leHQgZXZlbnQgbG9vcFxuICAgICAgICAgICAgLy8gc28gdGhpcyBkb2Vzbid0IGBwcmV2ZW50RGVmYXVsdCgpYCBvbiB0aGUgd3JvbmcgY2xpY2sgZXZlbnQuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdWIuZGV0YWNoKCk7XG4gICAgICAgICAgICAvL1NldHRpbmcgdGhpcyB0byBgMGAgY2F1c2VzIHRoZSBkZXRhY2htZW50IHRvIG9jY3VyIGJlZm9yZSB0aGUgY2xpY2tcbiAgICAgICAgICAgIC8vY29tZXMgaW4gb24gQW5kcm9pZCA0LjAuMy00LjAuNC4gMTAwbXMgc2VlbXMgdG8gYmUgYSByZWxpYWJsZSBudW1iZXIgaGVyZVxuICAgICAgICAgICAgLy90aGF0IHdvcmtzIGFjcm9zcyB0aGUgYm9hcmQuXG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHByb2Nlc3NBcmdzOiBmdW5jdGlvbiAoYXJncywgaXNEZWxlZ2F0ZSkge1xuXG4gICAgICAgIC8vaWYgd2UgcmV0dXJuIGZvciB0aGUgZGVsZWdhdGUgdXNlIGNhc2UsIHRoZW4gdGhlIGBmaWx0ZXJgIGFyZ3VtZW50XG4gICAgICAgIC8vcmV0dXJucyB1bmRlZmluZWQsIGFuZCB3ZSBoYXZlIHRvIGdldCB0aGUgZmlsdGVyIGZyb20gc3ViLl9leHRyYVswXSAodWdseSlcblxuICAgICAgICBpZiAoIWlzRGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHZhciBleHRyYSA9IGFyZ3NbM107XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGV4dHJhIGFyZ3VtZW50cyBmcm9tIHRoZSBhcnJheSBhcyBzcGVjaWZpZWQgYnlcbiAgICAgICAgICAgIC8vIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS95dWkvZG9jcy9ldmVudC9zeW50aHMuaHRtbFxuICAgICAgICAgICAgYXJncy5zcGxpY2UoMywxKTtcbiAgICAgICAgICAgIHJldHVybiBleHRyYTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgVGhpcyBmdW5jdGlvbiBzaG91bGQgc2V0IHVwIHRoZSBub2RlIHRoYXQgd2lsbCBldmVudHVhbGx5IGZpcmUgdGhlIGV2ZW50LlxuXG4gICAgVXNhZ2U6XG5cbiAgICAgICAgbm9kZS5vbigndGFwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgfSk7XG5cbiAgICBAbWV0aG9kIG9uXG4gICAgQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgQHBhcmFtIHtBcnJheX0gc3Vic2NyaXB0aW9uXG4gICAgQHBhcmFtIHtCb29sZWFufSBub3RpZmllclxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgKiovXG4gICAgb246IGZ1bmN0aW9uIChub2RlLCBzdWJzY3JpcHRpb24sIG5vdGlmaWVyKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbltIQU5ETEVTLlNUQVJUXSA9IG5vZGUub24oRVZUX1NUQVJULCB0aGlzLl9zdGFydCwgdGhpcywgbm9kZSwgc3Vic2NyaXB0aW9uLCBub3RpZmllcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIERldGFjaGVzIGFsbCBldmVudCBzdWJzY3JpcHRpb25zIHNldCB1cCBieSB0aGUgZXZlbnQtdGFwIG1vZHVsZVxuXG4gICAgQG1ldGhvZCBkZXRhY2hcbiAgICBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICBAcGFyYW0ge0FycmF5fSBzdWJzY3JpcHRpb25cbiAgICBAcGFyYW0ge0Jvb2xlYW59IG5vdGlmaWVyXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICAqKi9cbiAgICBkZXRhY2g6IGZ1bmN0aW9uIChub2RlLCBzdWJzY3JpcHRpb24sIG5vdGlmaWVyKSB7XG4gICAgICAgIGRldGFjaEhhbmRsZXMoc3Vic2NyaXB0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgRXZlbnQgZGVsZWdhdGlvbiBmb3IgdGhlICd0YXAnIGV2ZW50LiBUaGUgZGVsZWdhdGVkIGV2ZW50IHdpbGwgdXNlIGFcbiAgICBzdXBwbGllZCBzZWxlY3RvciBvciBmaWx0ZXJpbmcgZnVuY3Rpb24gdG8gdGVzdCBpZiB0aGUgZXZlbnQgcmVmZXJlbmNlcyBhdCBsZWFzdCBvbmVcbiAgICBub2RlIHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIHN1YnNjcmlwdGlvbiBjYWxsYmFjay5cblxuICAgIFVzYWdlOlxuXG4gICAgICAgIG5vZGUuZGVsZWdhdGUoJ3RhcCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIH0sICdsaSBhJyk7XG5cbiAgICBAbWV0aG9kIGRlbGVnYXRlXG4gICAgQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgQHBhcmFtIHtBcnJheX0gc3Vic2NyaXB0aW9uXG4gICAgQHBhcmFtIHtCb29sZWFufSBub3RpZmllclxuICAgIEBwYXJhbSB7U3RyaW5nIHwgRnVuY3Rpb259IGZpbHRlclxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgKiovXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uIChub2RlLCBzdWJzY3JpcHRpb24sIG5vdGlmaWVyLCBmaWx0ZXIpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uW0hBTkRMRVMuU1RBUlRdID0gWS5kZWxlZ2F0ZShFVlRfU1RBUlQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydChlLCBub2RlLCBzdWJzY3JpcHRpb24sIG5vdGlmaWVyLCB0cnVlKTtcbiAgICAgICAgfSwgbm9kZSwgZmlsdGVyLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgRGV0YWNoZXMgdGhlIGRlbGVnYXRlZCBldmVudCBzdWJzY3JpcHRpb25zIHNldCB1cCBieSB0aGUgZXZlbnQtdGFwIG1vZHVsZS5cbiAgICBPbmx5IHVzZWQgaWYgeW91IHVzZSBub2RlLmRlbGVnYXRlKC4uLikgaW5zdGVhZCBvZiBub2RlLm9uKC4uLik7XG5cbiAgICBAbWV0aG9kIGRldGFjaERlbGVnYXRlXG4gICAgQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgQHBhcmFtIHtBcnJheX0gc3Vic2NyaXB0aW9uXG4gICAgQHBhcmFtIHtCb29sZWFufSBub3RpZmllclxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgKiovXG4gICAgZGV0YWNoRGVsZWdhdGU6IGZ1bmN0aW9uIChub2RlLCBzdWJzY3JpcHRpb24sIG5vdGlmaWVyKSB7XG4gICAgICAgIGRldGFjaEhhbmRsZXMoc3Vic2NyaXB0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgQ2FsbGVkIHdoZW4gdGhlIG1vbml0b3IocykgYXJlIHRhcHBlZCBvbiwgZWl0aGVyIHRocm91Z2ggdG91Y2hzdGFydCBvciBtb3VzZWRvd24uXG5cbiAgICBAbWV0aG9kIF9zdGFydFxuICAgIEBwYXJhbSB7RE9NRXZlbnRGYWNhZGV9IGV2ZW50XG4gICAgQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgQHBhcmFtIHtBcnJheX0gc3Vic2NyaXB0aW9uXG4gICAgQHBhcmFtIHtCb29sZWFufSBub3RpZmllclxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gZGVsZWdhdGVcbiAgICBAcHJvdGVjdGVkXG4gICAgQHN0YXRpY1xuICAgICoqL1xuICAgIF9zdGFydDogZnVuY3Rpb24gKGV2ZW50LCBub2RlLCBzdWJzY3JpcHRpb24sIG5vdGlmaWVyLCBkZWxlZ2F0ZSkge1xuXG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBldmVudFR5cGU6IGV2ZW50LnR5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2ZW50TW91c2UgPSBzdWJzY3JpcHRpb24ucHJldmVudE1vdXNlIHx8IGZhbHNlO1xuXG4gICAgICAgIC8vbW92ZSB3YXlzIHRvIHF1aXQgZWFybHkgdG8gdGhlIHRvcC5cbiAgICAgICAgLy8gbm8gcmlnaHQgY2xpY2tzXG4gICAgICAgIGlmIChldmVudC5idXR0b24gJiYgZXZlbnQuYnV0dG9uID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3Igbm93IGp1c3Qgc3VwcG9ydCBhIDEgZmluZ2VyIGNvdW50IChsYXRlciBlbmhhbmNlIHZpYSBjb25maWcpXG4gICAgICAgIGlmIChldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm5vZGUgPSBkZWxlZ2F0ZSA/IGV2ZW50LmN1cnJlbnRUYXJnZXQgOiBub2RlO1xuXG4gICAgICAgIC8vVGhlcmUgaXMgYSBkb3VibGUgY2hlY2sgaW4gaGVyZSB0byBzdXBwb3J0IGV2ZW50IHNpbXVsYXRpb24gdGVzdHMsIGluIHdoaWNoXG4gICAgICAgIC8vZXZlbnQudG91Y2hlcyBjYW4gYmUgdW5kZWZpbmVkIHdoZW4gc2ltdWxhdGluZyAndG91Y2hzdGFydCcgb24gdG91Y2ggZGV2aWNlcy5cbiAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMpIHtcbiAgICAgICAgICBjb250ZXh0LnN0YXJ0WFkgPSBbIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0YXJ0WFkgPSBbIGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiBgb25Ub3VjaFN0YXJ0KClgIHdhcyBjYWxsZWQgYnkgYSB0b3VjaCBldmVudCwgc2V0IHVwIHRvdWNoIGV2ZW50IHN1YnNjcmlwdGlvbnMuXG4gICAgICAgIC8vT3RoZXJ3aXNlLCBzZXQgdXAgbW91c2UvcG9pbnRlciBldmVudCBldmVudCBzdWJzY3JpcHRpb25zLlxuICAgICAgICBpZiAoZXZlbnQudG91Y2hlcykge1xuXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25bSEFORExFUy5FTkRdID0gbm9kZS5vbmNlKCd0b3VjaGVuZCcsIHRoaXMuX2VuZCwgdGhpcywgbm9kZSwgc3Vic2NyaXB0aW9uLCBub3RpZmllciwgZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uW0hBTkRMRVMuQ0FOQ0VMXSA9IG5vZGUub25jZSgndG91Y2hjYW5jZWwnLCB0aGlzLmRldGFjaCwgdGhpcywgbm9kZSwgc3Vic2NyaXB0aW9uLCBub3RpZmllciwgZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAvL1NpbmNlIHRoaXMgaXMgYSB0b3VjaCogZXZlbnQsIHRoZXJlIHdpbGwgYmUgY29ycmVzcG9uZGluZyBtb3VzZSBldmVudHNcbiAgICAgICAgICAgIC8vdGhhdCB3aWxsIGJlIGZpcmVkLiBXZSBkb24ndCB3YW50IHRoZXNlIGV2ZW50cyB0byBnZXQgcGlja2VkIHVwIGFuZCBmaXJlXG4gICAgICAgICAgICAvL2Fub3RoZXIgYHRhcGAgZXZlbnQsIHNvIHdlJ2xsIHNldCB0aGlzIHZhcmlhYmxlIHRvIGB0cnVlYC5cbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5wcmV2ZW50TW91c2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9Pbmx5IGFkZCB0aGVzZSBsaXN0ZW5lcnMgaWYgcHJldmVudE1vdXNlIGlzIGBmYWxzZWBcbiAgICAgICAgLy9pZTogbm90IHdoZW4gdG91Y2ggZXZlbnRzIGhhdmUgYWxyZWFkeSBiZWVuIHN1YnNjcmliZWQgdG9cbiAgICAgICAgZWxzZSBpZiAoY29udGV4dC5ldmVudFR5cGUuaW5kZXhPZignbW91c2UnKSAhPT0gLTEgJiYgIXByZXZlbnRNb3VzZSkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uW0hBTkRMRVMuRU5EXSA9IG5vZGUub25jZSgnbW91c2V1cCcsIHRoaXMuX2VuZCwgdGhpcywgbm9kZSwgc3Vic2NyaXB0aW9uLCBub3RpZmllciwgZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uW0hBTkRMRVMuQ0FOQ0VMXSA9IG5vZGUub25jZSgnbW91c2VjYW5jZWwnLCB0aGlzLmRldGFjaCwgdGhpcywgbm9kZSwgc3Vic2NyaXB0aW9uLCBub3RpZmllciwgZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiBhIG1vdXNlIGV2ZW50IGNvbWVzIGluIGFmdGVyIGEgdG91Y2ggZXZlbnQsIGl0IHdpbGwgZ28gaW4gaGVyZSBhbmRcbiAgICAgICAgLy9yZXNldCBwcmV2ZW50TW91c2UgdG8gYHRydWVgLlxuICAgICAgICAvL0lmIGEgbW91c2UgZXZlbnQgY29tZXMgaW4gd2l0aG91dCBhIHByaW9yIHRvdWNoIGV2ZW50LCBwcmV2ZW50TW91c2Ugd2lsbCBiZVxuICAgICAgICAvL2ZhbHNlIGluIGFueSBjYXNlLCBzbyB0aGlzIGJsb2NrIGRvZXNuJ3QgZG8gYW55dGhpbmcuXG4gICAgICAgIGVsc2UgaWYgKGNvbnRleHQuZXZlbnRUeXBlLmluZGV4T2YoJ21vdXNlJykgIT09IC0xICYmIHByZXZlbnRNb3VzZSkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnByZXZlbnRNb3VzZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoUE9JTlRFUl9FVkVOVF9URVNULnRlc3QoY29udGV4dC5ldmVudFR5cGUpKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25bSEFORExFUy5FTkRdID0gbm9kZS5vbmNlKEdFU1RVUkVfTUFQLmVuZCwgdGhpcy5fZW5kLCB0aGlzLCBub2RlLCBzdWJzY3JpcHRpb24sIG5vdGlmaWVyLCBkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25bSEFORExFUy5DQU5DRUxdID0gbm9kZS5vbmNlKEdFU1RVUkVfTUFQLmNhbmNlbCwgdGhpcy5kZXRhY2gsIHRoaXMsIG5vZGUsIHN1YnNjcmlwdGlvbiwgbm90aWZpZXIsIGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgQ2FsbGVkIHdoZW4gdGhlIG1vbml0b3IocykgZmlyZXMgYSB0b3VjaGVuZCBldmVudCAob3IgdGhlIG1vdXNlIGVxdWl2YWxlbnQpLlxuICAgIFRoaXMgbWV0aG9kIGZpcmVzIHRoZSAndGFwJyBldmVudCBpZiBjZXJ0YWluIHJlcXVpcmVtZW50cyBhcmUgbWV0LlxuXG4gICAgQG1ldGhvZCBfZW5kXG4gICAgQHBhcmFtIHtET01FdmVudEZhY2FkZX0gZXZlbnRcbiAgICBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICBAcGFyYW0ge0FycmF5fSBzdWJzY3JpcHRpb25cbiAgICBAcGFyYW0ge0Jvb2xlYW59IG5vdGlmaWVyXG4gICAgQHBhcmFtIHtCb29sZWFufSBkZWxlZ2F0ZVxuICAgIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgQHByb3RlY3RlZFxuICAgIEBzdGF0aWNcbiAgICAqKi9cbiAgICBfZW5kOiBmdW5jdGlvbiAoZXZlbnQsIG5vZGUsIHN1YnNjcmlwdGlvbiwgbm90aWZpZXIsIGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzdGFydFhZID0gY29udGV4dC5zdGFydFhZLFxuICAgICAgICAgICAgZW5kWFksXG4gICAgICAgICAgICBjbGllbnRYWSxcbiAgICAgICAgICAgIHNlbnNpdGl2aXR5ID0gMTU7XG5cbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5fZXh0cmEgJiYgc3Vic2NyaXB0aW9uLl9leHRyYS5zZW5zaXRpdml0eSA+PSAwKSB7XG4gICAgICAgICAgICBzZW5zaXRpdml0eSA9IHN1YnNjcmlwdGlvbi5fZXh0cmEuc2Vuc2l0aXZpdHk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1RoZXJlIGlzIGEgZG91YmxlIGNoZWNrIGluIGhlcmUgdG8gc3VwcG9ydCBldmVudCBzaW11bGF0aW9uIHRlc3RzLCBpbiB3aGljaFxuICAgICAgICAvL2V2ZW50LnRvdWNoZXMgY2FuIGJlIHVuZGVmaW5lZCB3aGVuIHNpbXVsYXRpbmcgJ3RvdWNoc3RhcnQnIG9uIHRvdWNoIGRldmljZXMuXG4gICAgICAgIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICAgIGVuZFhZID0gWyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCwgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgXTtcbiAgICAgICAgICBjbGllbnRYWSA9IFtldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLCBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbmRYWSA9IFsgZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZIF07XG4gICAgICAgICAgY2xpZW50WFkgPSBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgbW91c2UgZGlkbid0IG1vdmVcbiAgICAgICAgaWYgKE1hdGguYWJzKGVuZFhZWzBdIC0gc3RhcnRYWVswXSkgPD0gc2Vuc2l0aXZpdHkgJiYgTWF0aC5hYnMoZW5kWFlbMV0gLSBzdGFydFhZWzFdKSA8PSBzZW5zaXRpdml0eSkge1xuXG4gICAgICAgICAgICBldmVudC50eXBlID0gRVZUX1RBUDtcbiAgICAgICAgICAgIGV2ZW50LnBhZ2VYID0gZW5kWFlbMF07XG4gICAgICAgICAgICBldmVudC5wYWdlWSA9IGVuZFhZWzFdO1xuICAgICAgICAgICAgZXZlbnQuY2xpZW50WCA9IGNsaWVudFhZWzBdO1xuICAgICAgICAgICAgZXZlbnQuY2xpZW50WSA9IGNsaWVudFhZWzFdO1xuICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IGNvbnRleHQubm9kZTtcblxuICAgICAgICAgICAgbm90aWZpZXIuZmlyZShldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRhY2hIYW5kbGVzKHN1YnNjcmlwdGlvbiwgW0hBTkRMRVMuRU5ELCBIQU5ETEVTLkNBTkNFTF0pO1xuICAgIH1cbn0pO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJub2RlLWJhc2VcIiwgXCJldmVudC1iYXNlXCIsIFwiZXZlbnQtdG91Y2hcIiwgXCJldmVudC1zeW50aGV0aWNcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnZXZlbnQtdG91Y2gnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbkFkZHMgdG91Y2ggZXZlbnQgZmFjYWRlIG5vcm1hbGl6YXRpb24gcHJvcGVydGllcyAodG91Y2hlcywgY2hhbmdlZFRvdWNoZXMsIHRhcmdldFRvdWNoZXMgZXRjLikgdG8gdGhlIERPTSBldmVudCBmYWNhZGUuIEFkZHNcbnRvdWNoIGV2ZW50cyB0byB0aGUgRE9NIGV2ZW50cyB3aGl0ZWxpc3QuXG5cbkBleGFtcGxlXG4gICAgWVVJKCkudXNlKCdldmVudC10b3VjaCcsIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgIFkub25lKCcjbXlEaXYnKS5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC4uLlxuICAgICAgICB9KTtcbiAgICB9KTtcbkBtb2R1bGUgZXZlbnRcbkBzdWJtb2R1bGUgZXZlbnQtdG91Y2hcbiAqL1xudmFyIFNDQUxFID0gXCJzY2FsZVwiLFxuICAgIFJPVEFUSU9OID0gXCJyb3RhdGlvblwiLFxuICAgIElERU5USUZJRVIgPSBcImlkZW50aWZpZXJcIixcbiAgICB3aW4gPSBZLmNvbmZpZy53aW4sXG4gICAgR0VTVFVSRV9NQVAgPSB7fTtcblxuLyoqXG4gKiBBZGRzIHRvdWNoIGV2ZW50IGZhY2FkZSBub3JtYWxpemF0aW9uIHByb3BlcnRpZXMgdG8gdGhlIERPTSBldmVudCBmYWNhZGVcbiAqXG4gKiBAbWV0aG9kIF90b3VjaFxuICogQGZvciBET01FdmVudEZhY2FkZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBldiB7RXZlbnR9IHRoZSBET00gZXZlbnRcbiAqIEBwYXJhbSBjdXJyZW50VGFyZ2V0IHtIVE1MRWxlbWVudH0gdGhlIGVsZW1lbnQgdGhlIGxpc3RlbmVyIHdhcyBhdHRhY2hlZCB0b1xuICogQHBhcmFtIHdyYXBwZXIge0N1c3RvbUV2ZW50fSB0aGUgY3VzdG9tIGV2ZW50IHdyYXBwZXIgZm9yIHRoaXMgRE9NIGV2ZW50XG4gKi9cblkuRE9NRXZlbnRGYWNhZGUucHJvdG90eXBlLl90b3VjaCA9IGZ1bmN0aW9uKGUsIGN1cnJlbnRUYXJnZXQsIHdyYXBwZXIpIHtcblxuICAgIHZhciBpLGwsIGV0Q2FjaGVkLCBldCx0b3VjaENhY2hlO1xuXG5cbiAgICBpZiAoZS50b3VjaGVzKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFycmF5IG9mIGluZGl2aWR1YWwgdG91Y2ggZXZlbnRzIGZvciB0b3VjaCBwb2ludHMgdGhhdCBhcmUgc3RpbGwgaW5cbiAgICAgICAgICogY29udGFjdCB3aXRoIHRoZSB0b3VjaCBzdXJmYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgdG91Y2hlc1xuICAgICAgICAgKiBAdHlwZSB7RE9NRXZlbnRGYWNhZGVbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG91Y2hlcyA9IFtdO1xuICAgICAgICB0b3VjaENhY2hlID0ge307XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGUudG91Y2hlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGV0ID0gZS50b3VjaGVzW2ldO1xuICAgICAgICAgICAgdG91Y2hDYWNoZVtZLnN0YW1wKGV0KV0gPSB0aGlzLnRvdWNoZXNbaV0gPSBuZXcgWS5ET01FdmVudEZhY2FkZShldCwgY3VycmVudFRhcmdldCwgd3JhcHBlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZS50YXJnZXRUb3VjaGVzKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFycmF5IG9mIGluZGl2aWR1YWwgdG91Y2ggZXZlbnRzIHN0aWxsIGluIGNvbnRhY3Qgd2l0aCB0aGUgdG91Y2hcbiAgICAgICAgICogc3VyZmFjZSBhbmQgd2hvc2UgYHRvdWNoc3RhcnRgIGV2ZW50IG9jY3VycmVkIGluc2lkZSB0aGUgc2FtZSB0YXJlZ3RcbiAgICAgICAgICogZWxlbWVudCBhcyB0aGUgY3VycmVudCB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHRhcmdldFRvdWNoZXNcbiAgICAgICAgICogQHR5cGUge0RPTUV2ZW50RmFjYWRlW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldFRvdWNoZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZS50YXJnZXRUb3VjaGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgZXQgPSBlLnRhcmdldFRvdWNoZXNbaV07XG4gICAgICAgICAgICBldENhY2hlZCA9IHRvdWNoQ2FjaGUgJiYgdG91Y2hDYWNoZVtZLnN0YW1wKGV0LCB0cnVlKV07XG5cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0VG91Y2hlc1tpXSA9IGV0Q2FjaGVkIHx8IG5ldyBZLkRPTUV2ZW50RmFjYWRlKGV0LCBjdXJyZW50VGFyZ2V0LCB3cmFwcGVyKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgQW4gYXJyYXkgb2YgZXZlbnQtc3BlY2lmaWMgdG91Y2ggZXZlbnRzLlxuXG4gICAgICAgIEZvciBgdG91Y2hzdGFydGAsIHRoZSB0b3VjaCBwb2ludHMgdGhhdCBiZWNhbWUgYWN0aXZlIHdpdGggdGhlIGN1cnJlbnRcbiAgICAgICAgZXZlbnQuXG5cbiAgICAgICAgRm9yIGB0b3VjaG1vdmVgLCB0aGUgdG91Y2ggcG9pbnRzIHRoYXQgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0XG4gICAgICAgIGV2ZW50LlxuXG4gICAgICAgIEZvciBgdG91Y2hlbmRgLCB0aGUgdG91Y2ggcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgdG91Y2hcbiAgICAgICAgc3VyZmFjZS5cblxuICAgICAgICBAcHJvcGVydHkgY2hhbmdlZFRvdWNoZXNcbiAgICAgICAgQHR5cGUge0RPTUV2ZW50RmFjYWRlW119XG4gICAgICAgICoqL1xuICAgICAgICB0aGlzLmNoYW5nZWRUb3VjaGVzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBldCA9IGUuY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgICAgICBldENhY2hlZCA9IHRvdWNoQ2FjaGUgJiYgdG91Y2hDYWNoZVtZLnN0YW1wKGV0LCB0cnVlKV07XG5cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZFRvdWNoZXNbaV0gPSBldENhY2hlZCB8fCBuZXcgWS5ET01FdmVudEZhY2FkZShldCwgY3VycmVudFRhcmdldCwgd3JhcHBlcik7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChTQ0FMRSBpbiBlKSB7XG4gICAgICAgIHRoaXNbU0NBTEVdID0gZVtTQ0FMRV07XG4gICAgfVxuXG4gICAgaWYgKFJPVEFUSU9OIGluIGUpIHtcbiAgICAgICAgdGhpc1tST1RBVElPTl0gPSBlW1JPVEFUSU9OXTtcbiAgICB9XG5cbiAgICBpZiAoSURFTlRJRklFUiBpbiBlKSB7XG4gICAgICAgIHRoaXNbSURFTlRJRklFUl0gPSBlW0lERU5USUZJRVJdO1xuICAgIH1cbn07XG5cbi8vQWRkaW5nIE1TUG9pbnRlciBldmVudHMgdG8gd2hpdGVsaXN0ZWQgRE9NIEV2ZW50cy4gTVNQb2ludGVyIGV2ZW50IHBheWxvYWRzXG4vL2hhdmUgdGhlIHNhbWUgcHJvcGVydGllcyBhcyBtb3VzZSBldmVudHMuXG5pZiAoWS5Ob2RlLkRPTV9FVkVOVFMpIHtcbiAgICBZLm1peChZLk5vZGUuRE9NX0VWRU5UUywge1xuICAgICAgICB0b3VjaHN0YXJ0OjEsXG4gICAgICAgIHRvdWNobW92ZToxLFxuICAgICAgICB0b3VjaGVuZDoxLFxuICAgICAgICB0b3VjaGNhbmNlbDoxLFxuICAgICAgICBnZXN0dXJlc3RhcnQ6MSxcbiAgICAgICAgZ2VzdHVyZWNoYW5nZToxLFxuICAgICAgICBnZXN0dXJlZW5kOjEsXG4gICAgICAgIE1TUG9pbnRlckRvd246MSxcbiAgICAgICAgTVNQb2ludGVyVXA6MSxcbiAgICAgICAgTVNQb2ludGVyTW92ZToxLFxuICAgICAgICBNU1BvaW50ZXJDYW5jZWw6MSxcbiAgICAgICAgcG9pbnRlcmRvd246MSxcbiAgICAgICAgcG9pbnRlcnVwOjEsXG4gICAgICAgIHBvaW50ZXJtb3ZlOjEsXG4gICAgICAgIHBvaW50ZXJjYW5jZWw6MVxuICAgIH0pO1xufVxuXG4vL0FkZCBwcm9wZXJ0aWVzIHRvIFkuRVZFTlQuR0VTVFVSRV9NQVAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG4gIC8qKlxuICAgKlxuICAgKiBUaGlzIGlzIHRvIGZpeCBhIGJ1ZzpcbiAgICogTW9zdCBtb2JpbGUgYnJvd3NlcnMgY2FsbHMgdG91Y2ggZXZlbnRzIGFuZCBtb3VzZSBldmVudHMgc2VwYXJhdGVseS5cbiAgICogKGZpcmVzIHRvdWNoIGV2ZW50cyBmaXJzdCwgYW5kIHRoZW4gbW91c2UgZXZlbnRzIGFjY29yZGluZyB0byB0aGUgdG91Y2ggYmVoYXZpb3IpXG4gICAqIEJ1dCBZVUkncyBERE0gdXNlcyBnZXN0dXJlIGV2ZW50cywgd2hpY2ggcmVzdWx0cyBpbiBERCBldmVudHMgZ2V0dGluZyBtaXhlZCB1cCxcbiAgICogd2l0aCBub24tZXhpc3RlbnQgbW91c2UgcG9zaXRpb25zIGFuZCBsaWZlLWN5Y2xlcyBnZXR0aW5nIG1lc3NlZCB1cC5cbiAgICpcbiAgICogVGhpcyB3aWxsIGVuc3VyZSBERCBpcyB3aXJlZCB0byBvbmx5IG9uZSBzZXQgb2YgZ2VzdHVyZSBldmVudHMgZm9yIHRvdWNoIGRldmljZXMuICAtYmNcbiAgICpcbiAgICogLSBVcGRhdGUgMi8xMS8xNDpcbiAgICogTm8gZG91YmxlIGV2ZW50cyBmb3IgYW55IHRvdWNoIGRldmljZS5cbiAgICogQWxzbyBhZGRpbmcgc3VwcG9ydCBmb3IgcG9pbnRlciBldmVudHMgc2luY2UgbW9iaWxlIGNocm9tZSBhbmQgZmlyZWZveCBhcmVcbiAgICogcGxhbm5pbmcgdG8gaW1wbGVtZW50IHBvaW50ZXIgZXZlbnRzIGluIG5lYXIgZnV0dXJlLiAtYmNcbiAgICpcbiAgICovXG4gIGlmICh3aW4gJiYgd2luLlBvaW50ZXJFdmVudCkge1xuICAgIEdFU1RVUkVfTUFQLnN0YXJ0ID0gXCJwb2ludGVyZG93blwiO1xuICAgIEdFU1RVUkVfTUFQLmVuZCA9IFwicG9pbnRlcnVwXCI7XG4gICAgR0VTVFVSRV9NQVAubW92ZSA9IFwicG9pbnRlcm1vdmVcIjtcbiAgICBHRVNUVVJFX01BUC5jYW5jZWwgPSBcInBvaW50ZXJjYW5jZWxcIjtcbiAgfVxuXG4gIGVsc2UgaWYgKCh3aW4gJiYgKFwib250b3VjaHN0YXJ0XCIgaW4gd2luKSkgJiYgIShZLlVBLmNocm9tZSAmJiBZLlVBLmNocm9tZSA8IDYpKSB7XG4gICAgR0VTVFVSRV9NQVAuc3RhcnQgPSBcInRvdWNoc3RhcnRcIjtcbiAgICBHRVNUVVJFX01BUC5lbmQgPSBcInRvdWNoZW5kXCI7XG4gICAgR0VTVFVSRV9NQVAubW92ZSA9IFwidG91Y2htb3ZlXCI7XG4gICAgR0VTVFVSRV9NQVAuY2FuY2VsID0gXCJ0b3VjaGNhbmNlbFwiO1xufVxuXG5lbHNlIGlmICh3aW4gJiYgKFwibXNQb2ludGVyRW5hYmxlZFwiIGluIHdpbi5uYXZpZ2F0b3IpKSB7XG4gICAgR0VTVFVSRV9NQVAuc3RhcnQgPSBcIk1TUG9pbnRlckRvd25cIjtcbiAgICBHRVNUVVJFX01BUC5lbmQgPSBcIk1TUG9pbnRlclVwXCI7XG4gICAgR0VTVFVSRV9NQVAubW92ZSA9IFwiTVNQb2ludGVyTW92ZVwiO1xuICAgIEdFU1RVUkVfTUFQLmNhbmNlbCA9IFwiTVNQb2ludGVyQ2FuY2VsXCI7XG59XG5cbmVsc2Uge1xuICAgIEdFU1RVUkVfTUFQLnN0YXJ0ID0gXCJtb3VzZWRvd25cIjtcbiAgICBHRVNUVVJFX01BUC5lbmQgPSBcIm1vdXNldXBcIjtcbiAgICBHRVNUVVJFX01BUC5tb3ZlID0gXCJtb3VzZW1vdmVcIjtcbiAgICBHRVNUVVJFX01BUC5jYW5jZWwgPSBcIm1vdXNlY2FuY2VsXCI7XG59XG5cbi8qKlxuICogQSBvYmplY3QgbGl0ZXJhbCB3aXRoIGtleXMgXCJzdGFydFwiLCBcImVuZFwiLCBhbmQgXCJtb3ZlXCIuIFRoZSB2YWx1ZSBmb3IgZWFjaCBrZXkgaXMgYVxuICogc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgZm9yIHRoYXQgZW52aXJvbm1lbnQuIEZvciB0b3VjaCBlbnZpcm9ubWVudHMsIHRoZSByZXNwZWN0aXZlXG4gKiB2YWx1ZXMgYXJlIFwidG91Y2hzdGFydFwiLCBcInRvdWNoZW5kXCIgYW5kIFwidG91Y2htb3ZlXCIuIE1vdXNlIGFuZCBNU1BvaW50ZXIgZW52aXJvbm1lbnRzIGFyZSBhbHNvXG4gKiBzdXBwb3J0ZWQgdmlhIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSBfR0VTVFVSRV9NQVBcbiAqIEB0eXBlIE9iamVjdFxuICogQHN0YXRpY1xuICovXG5ZLkV2ZW50Ll9HRVNUVVJFX01BUCA9IEdFU1RVUkVfTUFQO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJub2RlLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnZXZlbnQtdmFsdWVjaGFuZ2UnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbkFkZHMgYSBzeW50aGV0aWMgYHZhbHVlY2hhbmdlYCBldmVudCB0aGF0IGZpcmVzIHdoZW4gdGhlIGB2YWx1ZWAgcHJvcGVydHkgb2YgYW5cbmA8aW5wdXQ+YCwgYDx0ZXh0YXJlYT5gLCBgPHNlbGVjdD5gLCBvciBgW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl1gIG5vZGUgY2hhbmdlc1xuYXMgYSByZXN1bHQgb2YgYSBrZXlzdHJva2UsIG1vdXNlIG9wZXJhdGlvbiwgb3IgaW5wdXQgbWV0aG9kIGVkaXRvciAoSU1FKVxuaW5wdXQgZXZlbnQuXG5cblVzYWdlOlxuXG4gICAgWVVJKCkudXNlKCdldmVudC12YWx1ZWNoYW5nZScsIGZ1bmN0aW9uIChZKSB7XG4gICAgICAgIFkub25lKCcjbXktaW5wdXQnKS5vbigndmFsdWVjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuQG1vZHVsZSBldmVudC12YWx1ZWNoYW5nZVxuKiovXG5cbi8qKlxuUHJvdmlkZXMgdGhlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgc3ludGhldGljIGB2YWx1ZWNoYW5nZWAgZXZlbnQuIFRoaXMgY2xhc3Ncbmlzbid0IG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHksIGJ1dCBpcyBwdWJsaWMgdG8gbWFrZSBtb25rZXlwYXRjaGluZyBwb3NzaWJsZS5cblxuVXNhZ2U6XG5cbiAgICBZVUkoKS51c2UoJ2V2ZW50LXZhbHVlY2hhbmdlJywgZnVuY3Rpb24gKFkpIHtcbiAgICAgICAgWS5vbmUoJyNteS1pbnB1dCcpLm9uKCd2YWx1ZWNoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG5AY2xhc3MgVmFsdWVDaGFuZ2VcbkBzdGF0aWNcbiovXG5cbnZhciBEQVRBX0tFWSA9ICdfdmFsdWVjaGFuZ2UnLFxuICAgIFZBTFVFICAgID0gJ3ZhbHVlJyxcbiAgICBOT0RFX05BTUUgPSAnbm9kZU5hbWUnLFxuXG4gICAgY29uZmlnLCAvLyBkZWZpbmVkIGF0IHRoZSBlbmQgb2YgdGhpcyBmaWxlXG5cbi8vIEp1c3QgYSBzaW1wbGUgbmFtZXNwYWNlIHRvIG1ha2UgbWV0aG9kcyBvdmVycmlkYWJsZS5cblZDID0ge1xuICAgIC8vIC0tIFN0YXRpYyBDb25zdGFudHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgIEludGVydmFsIChpbiBtaWxsaXNlY29uZHMpIGF0IHdoaWNoIHRvIHBvbGwgZm9yIGNoYW5nZXMgdG8gdGhlIHZhbHVlIG9mIGFuXG4gICAgZWxlbWVudCB3aXRoIG9uZSBvciBtb3JlIGB2YWx1ZWNoYW5nZWAgc3Vic2NyaWJlcnMgd2hlbiB0aGUgdXNlciBpcyBsaWtlbHlcbiAgICB0byBiZSBpbnRlcmFjdGluZyB3aXRoIGl0LlxuXG4gICAgQHByb3BlcnR5IFBPTExfSU5URVJWQUxcbiAgICBAdHlwZSBOdW1iZXJcbiAgICBAZGVmYXVsdCA1MFxuICAgIEBzdGF0aWNcbiAgICAqKi9cbiAgICBQT0xMX0lOVEVSVkFMOiA1MCxcblxuICAgIC8qKlxuICAgIFRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcykgYWZ0ZXIgd2hpY2ggdG8gc3RvcCBwb2xsaW5nIHdoZW4gdGhlcmUgaGFzbid0IGJlZW5cbiAgICBhbnkgbmV3IGFjdGl2aXR5IChrZXlwcmVzc2VzLCBtb3VzZSBjbGlja3MsIGV0Yy4pIG9uIGFuIGVsZW1lbnQuXG5cbiAgICBAcHJvcGVydHkgVElNRU9VVFxuICAgIEB0eXBlIE51bWJlclxuICAgIEBkZWZhdWx0IDEwMDAwXG4gICAgQHN0YXRpY1xuICAgICoqL1xuICAgIFRJTUVPVVQ6IDEwMDAwLFxuXG4gICAgLy8gLS0gUHJvdGVjdGVkIFN0YXRpYyBNZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgQ2FsbGVkIGF0IGFuIGludGVydmFsIHRvIHBvbGwgZm9yIGNoYW5nZXMgdG8gdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWRcbiAgICBub2RlLlxuXG4gICAgQG1ldGhvZCBfcG9sbFxuICAgIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBvbGwuXG5cbiAgICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC5cbiAgICAgICAgQHBhcmFtIHtFdmVudEZhY2FkZX0gW29wdGlvbnMuZV0gRXZlbnQgZmFjYWRlIG9mIHRoZSBldmVudCB0aGF0XG4gICAgICAgICAgICBpbml0aWF0ZWQgdGhlIHBvbGxpbmcuXG5cbiAgICBAcHJvdGVjdGVkXG4gICAgQHN0YXRpY1xuICAgICoqL1xuICAgIF9wb2xsOiBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZG9tTm9kZSAgPSBub2RlLl9ub2RlLCAvLyBwZXJmb3JtYW5jZSBjaGVhdDsgZ2V0VmFsdWUoKSBpcyBhIGJpZyBoaXQgd2hlbiBwb2xsaW5nXG4gICAgICAgICAgICBldmVudCAgICA9IG9wdGlvbnMuZSxcbiAgICAgICAgICAgIHZjRGF0YSAgID0gbm9kZS5fZGF0YSAmJiBub2RlLl9kYXRhW0RBVEFfS0VZXSwgLy8gYW5vdGhlciBwZXJmIGNoZWF0XG4gICAgICAgICAgICBzdG9wcGVkICA9IDAsXG4gICAgICAgICAgICBmYWNhZGUsIHByZXZWYWwsIG5ld1ZhbCwgbm9kZU5hbWUsIHNlbGVjdGVkT3B0aW9uLCBzdG9wRWxlbWVudDtcblxuICAgICAgICBpZiAoIShkb21Ob2RlICYmIHZjRGF0YSkpIHtcbiAgICAgICAgICAgIFZDLl9zdG9wUG9sbGluZyhub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZWYWwgPSB2Y0RhdGEucHJldlZhbDtcbiAgICAgICAgbm9kZU5hbWUgID0gdmNEYXRhLm5vZGVOYW1lO1xuXG4gICAgICAgIGlmICh2Y0RhdGEuaXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgLy8gVXNlIGlubmVySFRNTCBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIG5ld1ZhbCA9IGRvbU5vZGUuaW5uZXJIVE1MO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgICAgICAvLyBVc2UgdmFsdWUgcHJvcGVydHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICBuZXdWYWwgPSBkb21Ob2RlLnZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgLy8gQmFjay1jb21wYXRpYmlsaXR5IHdpdGggSUU2IDxzZWxlY3Q+IGVsZW1lbnQgdmFsdWVzLlxuICAgICAgICAgICAgLy8gSHVnZSBwZXJmb3JtYW5jZSBjaGVhdCB0byBnZXQgcGFzdCBub2RlLmdldCgndmFsdWUnKS5cbiAgICAgICAgICAgIHNlbGVjdGVkT3B0aW9uID0gZG9tTm9kZS5vcHRpb25zW2RvbU5vZGUuc2VsZWN0ZWRJbmRleF07XG4gICAgICAgICAgICBuZXdWYWwgPSBzZWxlY3RlZE9wdGlvbi52YWx1ZSB8fCBzZWxlY3RlZE9wdGlvbi50ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld1ZhbCAhPT0gcHJldlZhbCkge1xuICAgICAgICAgICAgdmNEYXRhLnByZXZWYWwgPSBuZXdWYWw7XG5cbiAgICAgICAgICAgIGZhY2FkZSA9IHtcbiAgICAgICAgICAgICAgICBfZXZlbnQgICAgICAgOiBldmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiAoZXZlbnQgJiYgZXZlbnQuY3VycmVudFRhcmdldCkgfHwgbm9kZSxcbiAgICAgICAgICAgICAgICBuZXdWYWwgICAgICAgOiBuZXdWYWwsXG4gICAgICAgICAgICAgICAgcHJldlZhbCAgICAgIDogcHJldlZhbCxcbiAgICAgICAgICAgICAgICB0YXJnZXQgICAgICAgOiAoZXZlbnQgJiYgZXZlbnQudGFyZ2V0KSB8fCBub2RlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBZLk9iamVjdC5zb21lKHZjRGF0YS5ub3RpZmllcnMsIGZ1bmN0aW9uIChub3RpZmllcikge1xuICAgICAgICAgICAgICAgIHZhciBldnQgPSBub3RpZmllci5oYW5kbGUuZXZ0LFxuICAgICAgICAgICAgICAgICAgICBuZXdTdG9wcGVkO1xuXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BwZWQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpZXIuZmlyZShmYWNhZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LmVsID09PSBzdG9wRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBub3RpZmllci5maXJlKGZhY2FkZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV3U3RvcHBlZCA9IGV2dCAmJiBldnQuX2ZhY2FkZSA/IGV2dC5fZmFjYWRlLnN0b3BwZWQgOiAwO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjb25zaWRlciB0aGUgY29uZGl0aW9uIGluIHdoaWNoIHRoZXJlIGFyZSB0d29cbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5lcnMgb24gdGhlIHNhbWUgZWxlbWVudDpcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5lciAxIGNhbGxzIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5lciAyIGNhbGxzIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RvcHBlZCA+IHN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IG5ld1N0b3BwZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3BwZWQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BFbGVtZW50ID0gZXZ0LmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BwZWQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIFZDLl9yZWZyZXNoVGltZW91dChub2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICBSZXN0YXJ0cyB0aGUgaW5hY3Rpdml0eSB0aW1lb3V0IGZvciB0aGUgc3BlY2lmaWVkIG5vZGUuXG5cbiAgICBAbWV0aG9kIF9yZWZyZXNoVGltZW91dFxuICAgIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHJlZnJlc2guXG4gICAgQHBhcmFtIHtTeW50aGV0aWNFdmVudC5Ob3RpZmllcn0gbm90aWZpZXJcbiAgICBAcHJvdGVjdGVkXG4gICAgQHN0YXRpY1xuICAgICoqL1xuICAgIF9yZWZyZXNoVGltZW91dDogZnVuY3Rpb24gKG5vZGUsIG5vdGlmaWVyKSB7XG4gICAgICAgIC8vIFRoZSBub2RlIG1heSBoYXZlIGJlZW4gZGVzdHJveWVkLCBzbyBjaGVjayB0aGF0IGl0IHN0aWxsIGV4aXN0c1xuICAgICAgICAvLyBiZWZvcmUgdHJ5aW5nIHRvIGdldCBpdHMgZGF0YS4gT3RoZXJ3aXNlIGFuIGVycm9yIHdpbGwgb2NjdXIuXG4gICAgICAgIGlmICghbm9kZS5fbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZjRGF0YSA9IG5vZGUuZ2V0RGF0YShEQVRBX0tFWSk7XG5cbiAgICAgICAgVkMuX3N0b3BUaW1lb3V0KG5vZGUpOyAvLyBhdm9pZCBkdXBlc1xuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IHNlZSBhbnkgY2hhbmdlcyB3aXRoaW4gdGhlIHRpbWVvdXQgcGVyaW9kICgxMCBzZWNvbmRzIGJ5XG4gICAgICAgIC8vIGRlZmF1bHQpLCBzdG9wIHBvbGxpbmcuXG4gICAgICAgIHZjRGF0YS50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBWQy5fc3RvcFBvbGxpbmcobm9kZSwgbm90aWZpZXIpO1xuICAgICAgICB9LCBWQy5USU1FT1VUKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICBCZWdpbnMgcG9sbGluZyBmb3IgY2hhbmdlcyB0byB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBvZiB0aGUgc3BlY2lmaWVkIG5vZGUuIElmXG4gICAgcG9sbGluZyBpcyBhbHJlYWR5IHVuZGVyd2F5IGZvciB0aGUgc3BlY2lmaWVkIG5vZGUsIGl0IHdpbGwgbm90IGJlIHJlc3RhcnRlZFxuICAgIHVubGVzcyB0aGUgYGZvcmNlYCBvcHRpb24gaXMgYHRydWVgXG5cbiAgICBAbWV0aG9kIF9zdGFydFBvbGxpbmdcbiAgICBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byB3YXRjaC5cbiAgICBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50Lk5vdGlmaWVyfSBub3RpZmllclxuXG4gICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuXG4gICAgICAgIEBwYXJhbSB7RXZlbnRGYWNhZGV9IFtvcHRpb25zLmVdIEV2ZW50IGZhY2FkZSBvZiB0aGUgZXZlbnQgdGhhdFxuICAgICAgICAgICAgaW5pdGlhdGVkIHRoZSBwb2xsaW5nLlxuICAgICAgICBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvcmNlPWZhbHNlXSBJZiBgdHJ1ZWAsIHBvbGxpbmcgd2lsbCBiZVxuICAgICAgICAgICAgcmVzdGFydGVkIGV2ZW4gaWYgd2UncmUgYWxyZWFkeSBwb2xsaW5nIHRoaXMgbm9kZS5cblxuICAgIEBwcm90ZWN0ZWRcbiAgICBAc3RhdGljXG4gICAgKiovXG4gICAgX3N0YXJ0UG9sbGluZzogZnVuY3Rpb24gKG5vZGUsIG5vdGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB2Y0RhdGEsIGlzRWRpdGFibGU7XG5cbiAgICAgICAgaWYgKCFub2RlLnRlc3QoJ2lucHV0LHRleHRhcmVhLHNlbGVjdCcpICYmICEoaXNFZGl0YWJsZSA9IFZDLl9pc0VkaXRhYmxlKG5vZGUpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmNEYXRhID0gbm9kZS5nZXREYXRhKERBVEFfS0VZKTtcblxuICAgICAgICBpZiAoIXZjRGF0YSkge1xuICAgICAgICAgICAgdmNEYXRhID0ge1xuICAgICAgICAgICAgICAgIG5vZGVOYW1lICAgOiBub2RlLmdldChOT0RFX05BTUUpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgaXNFZGl0YWJsZSA6IGlzRWRpdGFibGUsXG4gICAgICAgICAgICAgICAgcHJldlZhbCAgICA6IGlzRWRpdGFibGUgPyBub2RlLmdldERPTU5vZGUoKS5pbm5lckhUTUwgOiBub2RlLmdldChWQUxVRSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG5vZGUuc2V0RGF0YShEQVRBX0tFWSwgdmNEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZjRGF0YS5ub3RpZmllcnMgfHwgKHZjRGF0YS5ub3RpZmllcnMgPSB7fSk7XG5cbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbnRpbnVpbmcgaWYgd2UncmUgYWxyZWFkeSBwb2xsaW5nIHRoaXMgbm9kZSwgdW5sZXNzXG4gICAgICAgIC8vIGBvcHRpb25zLmZvcmNlYCBpcyB0cnVlLlxuICAgICAgICBpZiAodmNEYXRhLmludGVydmFsKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JjZSkge1xuICAgICAgICAgICAgICAgIFZDLl9zdG9wUG9sbGluZyhub2RlLCBub3RpZmllcik7IC8vIHJlc3RhcnQgcG9sbGluZywgYnV0IGF2b2lkIGR1cGUgcG9sbHNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmNEYXRhLm5vdGlmaWVyc1tZLnN0YW1wKG5vdGlmaWVyKV0gPSBub3RpZmllcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQb2xsIGZvciBjaGFuZ2VzIHRvIHRoZSBub2RlJ3MgdmFsdWUuIFdlIGNhbid0IHJlbHkgb24ga2V5Ym9hcmRcbiAgICAgICAgLy8gZXZlbnRzIGZvciB0aGlzLCBzaW5jZSB0aGUgdmFsdWUgbWF5IGNoYW5nZSBkdWUgdG8gYSBtb3VzZS1pbml0aWF0ZWRcbiAgICAgICAgLy8gcGFzdGUgZXZlbnQsIGFuIElNRSBpbnB1dCBldmVudCwgb3IgZm9yIHNvbWUgb3RoZXIgcmVhc29uIHRoYXRcbiAgICAgICAgLy8gZG9lc24ndCB0cmlnZ2VyIGEga2V5IGV2ZW50LlxuICAgICAgICB2Y0RhdGEubm90aWZpZXJzW1kuc3RhbXAobm90aWZpZXIpXSA9IG5vdGlmaWVyO1xuXG4gICAgICAgIHZjRGF0YS5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFZDLl9wb2xsKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgICB9LCBWQy5QT0xMX0lOVEVSVkFMKTtcblxuXG4gICAgICAgIFZDLl9yZWZyZXNoVGltZW91dChub2RlLCBub3RpZmllcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIFN0b3BzIHBvbGxpbmcgZm9yIGNoYW5nZXMgdG8gdGhlIHNwZWNpZmllZCBub2RlJ3MgYHZhbHVlYCBhdHRyaWJ1dGUuXG5cbiAgICBAbWV0aG9kIF9zdG9wUG9sbGluZ1xuICAgIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHN0b3AgcG9sbGluZyBvbi5cbiAgICBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50Lk5vdGlmaWVyfSBbbm90aWZpZXJdIE5vdGlmaWVyIHRvIHJlbW92ZSBmcm9tIHRoZVxuICAgICAgICBub2RlLiBJZiBub3Qgc3BlY2lmaWVkLCBhbGwgbm90aWZpZXJzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICBAcHJvdGVjdGVkXG4gICAgQHN0YXRpY1xuICAgICoqL1xuICAgIF9zdG9wUG9sbGluZzogZnVuY3Rpb24gKG5vZGUsIG5vdGlmaWVyKSB7XG4gICAgICAgIC8vIFRoZSBub2RlIG1heSBoYXZlIGJlZW4gZGVzdHJveWVkLCBzbyBjaGVjayB0aGF0IGl0IHN0aWxsIGV4aXN0c1xuICAgICAgICAvLyBiZWZvcmUgdHJ5aW5nIHRvIGdldCBpdHMgZGF0YS4gT3RoZXJ3aXNlIGFuIGVycm9yIHdpbGwgb2NjdXIuXG4gICAgICAgIGlmICghbm9kZS5fbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZjRGF0YSA9IG5vZGUuZ2V0RGF0YShEQVRBX0tFWSkgfHwge307XG5cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh2Y0RhdGEuaW50ZXJ2YWwpO1xuICAgICAgICBkZWxldGUgdmNEYXRhLmludGVydmFsO1xuXG4gICAgICAgIFZDLl9zdG9wVGltZW91dChub2RlKTtcblxuICAgICAgICBpZiAobm90aWZpZXIpIHtcbiAgICAgICAgICAgIHZjRGF0YS5ub3RpZmllcnMgJiYgZGVsZXRlIHZjRGF0YS5ub3RpZmllcnNbWS5zdGFtcChub3RpZmllcildO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmNEYXRhLm5vdGlmaWVycyA9IHt9O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgQ2xlYXJzIHRoZSBpbmFjdGl2aXR5IHRpbWVvdXQgZm9yIHRoZSBzcGVjaWZpZWQgbm9kZSwgaWYgYW55LlxuXG4gICAgQG1ldGhvZCBfc3RvcFRpbWVvdXRcbiAgICBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICBAcHJvdGVjdGVkXG4gICAgQHN0YXRpY1xuICAgICoqL1xuICAgIF9zdG9wVGltZW91dDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHZjRGF0YSA9IG5vZGUuZ2V0RGF0YShEQVRBX0tFWSkgfHwge307XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHZjRGF0YS50aW1lb3V0KTtcbiAgICAgICAgZGVsZXRlIHZjRGF0YS50aW1lb3V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBDaGVjayB0byBzZWUgaWYgYSBub2RlIGhhcyBlZGl0YWJsZSBjb250ZW50IG9yIG5vdC5cblxuICAgIFRPRE86IEFkZCBhZGRpdGlvbmFsIGNoZWNrcyB0byBnZXQgaXQgdG8gd29yayBmb3IgY2hpbGQgbm9kZXNcbiAgICB0aGF0IGluaGVyaXQgXCJjb250ZW50ZWRpdGFibGVcIiBmcm9tIHBhcmVudCBub2Rlcy4gVGhpcyBtYXkgYmVcbiAgICB0b28gY29tcHV0YXRpb25hbGx5IGludGVuc2l2ZSB0byBiZSBwbGFjZWQgaW5zaWRlIG9mIHRoZSBgX3BvbGxgXG4gICAgbG9vcCwgaG93ZXZlci5cblxuICAgIEBtZXRob2QgX2lzRWRpdGFibGVcbiAgICBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICBAcHJvdGVjdGVkXG4gICAgQHN0YXRpY1xuICAgICoqL1xuICAgIF9pc0VkaXRhYmxlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBQZXJmb3JtYW5jZSBjaGVhdCBiZWNhdXNlIHRoaXMgaXMgdXNlZCBpbnNpZGUgYF9wb2xsYFxuICAgICAgICB2YXIgZG9tTm9kZSA9IG5vZGUuX25vZGU7XG4gICAgICAgIHJldHVybiBkb21Ob2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnIHx8XG4gICAgICAgICAgICAgICBkb21Ob2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJyc7XG4gICAgfSxcblxuXG5cbiAgICAvLyAtLSBQcm90ZWN0ZWQgU3RhdGljIEV2ZW50IEhhbmRsZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICBTdG9wcyBwb2xsaW5nIHdoZW4gYSBub2RlJ3MgYmx1ciBldmVudCBmaXJlcy5cblxuICAgIEBtZXRob2QgX29uQmx1clxuICAgIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGVcbiAgICBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50Lk5vdGlmaWVyfSBub3RpZmllclxuICAgIEBwcm90ZWN0ZWRcbiAgICBAc3RhdGljXG4gICAgKiovXG4gICAgX29uQmx1cjogZnVuY3Rpb24gKGUsIG5vdGlmaWVyKSB7XG4gICAgICAgIFZDLl9zdG9wUG9sbGluZyhlLmN1cnJlbnRUYXJnZXQsIG5vdGlmaWVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgUmVzZXRzIGEgbm9kZSdzIGhpc3RvcnkgYW5kIHN0YXJ0cyBwb2xsaW5nIHdoZW4gYSBmb2N1cyBldmVudCBvY2N1cnMuXG5cbiAgICBAbWV0aG9kIF9vbkZvY3VzXG4gICAgQHBhcmFtIHtFdmVudEZhY2FkZX0gZVxuICAgIEBwYXJhbSB7U3ludGhldGljRXZlbnQuTm90aWZpZXJ9IG5vdGlmaWVyXG4gICAgQHByb3RlY3RlZFxuICAgIEBzdGF0aWNcbiAgICAqKi9cbiAgICBfb25Gb2N1czogZnVuY3Rpb24gKGUsIG5vdGlmaWVyKSB7XG4gICAgICAgIHZhciBub2RlICAgICAgID0gZS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgdmNEYXRhICAgICA9IG5vZGUuZ2V0RGF0YShEQVRBX0tFWSk7XG5cbiAgICAgICAgaWYgKCF2Y0RhdGEpIHtcbiAgICAgICAgICAgIHZjRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpc0VkaXRhYmxlIDogVkMuX2lzRWRpdGFibGUobm9kZSksXG4gICAgICAgICAgICAgICAgbm9kZU5hbWUgICA6IG5vZGUuZ2V0KE5PREVfTkFNRSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGUuc2V0RGF0YShEQVRBX0tFWSwgdmNEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZjRGF0YS5wcmV2VmFsID0gdmNEYXRhLmlzRWRpdGFibGUgPyBub2RlLmdldERPTU5vZGUoKS5pbm5lckhUTUwgOiBub2RlLmdldChWQUxVRSk7XG5cbiAgICAgICAgVkMuX3N0YXJ0UG9sbGluZyhub2RlLCBub3RpZmllciwge2U6IGV9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgU3RhcnRzIHBvbGxpbmcgd2hlbiBhIG5vZGUgcmVjZWl2ZXMgYSBrZXlEb3duIGV2ZW50LlxuXG4gICAgQG1ldGhvZCBfb25LZXlEb3duXG4gICAgQHBhcmFtIHtFdmVudEZhY2FkZX0gZVxuICAgIEBwYXJhbSB7U3ludGhldGljRXZlbnQuTm90aWZpZXJ9IG5vdGlmaWVyXG4gICAgQHByb3RlY3RlZFxuICAgIEBzdGF0aWNcbiAgICAqKi9cbiAgICBfb25LZXlEb3duOiBmdW5jdGlvbiAoZSwgbm90aWZpZXIpIHtcbiAgICAgICAgVkMuX3N0YXJ0UG9sbGluZyhlLmN1cnJlbnRUYXJnZXQsIG5vdGlmaWVyLCB7ZTogZX0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBTdGFydHMgcG9sbGluZyB3aGVuIGFuIElNRS1yZWxhdGVkIGtleVVwIGV2ZW50IG9jY3VycyBvbiBhIG5vZGUuXG5cbiAgICBAbWV0aG9kIF9vbktleVVwXG4gICAgQHBhcmFtIHtFdmVudEZhY2FkZX0gZVxuICAgIEBwYXJhbSB7U3ludGhldGljRXZlbnQuTm90aWZpZXJ9IG5vdGlmaWVyXG4gICAgQHByb3RlY3RlZFxuICAgIEBzdGF0aWNcbiAgICAqKi9cbiAgICBfb25LZXlVcDogZnVuY3Rpb24gKGUsIG5vdGlmaWVyKSB7XG4gICAgICAgIC8vIFRoZXNlIGNoYXJDb2RlcyBpbmRpY2F0ZSB0aGF0IGFuIElNRSBoYXMgc3RhcnRlZC4gV2UnbGwgcmVzdGFydFxuICAgICAgICAvLyBwb2xsaW5nIGFuZCBnaXZlIHRoZSBJTUUgdXAgdG8gMTAgc2Vjb25kcyAoYnkgZGVmYXVsdCkgdG8gZmluaXNoLlxuICAgICAgICBpZiAoZS5jaGFyQ29kZSA9PT0gMjI5IHx8IGUuY2hhckNvZGUgPT09IDE5Nykge1xuICAgICAgICAgICAgVkMuX3N0YXJ0UG9sbGluZyhlLmN1cnJlbnRUYXJnZXQsIG5vdGlmaWVyLCB7XG4gICAgICAgICAgICAgICAgZSAgICA6IGUsXG4gICAgICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgIFN0YXJ0cyBwb2xsaW5nIHdoZW4gYSBub2RlIHJlY2VpdmVzIGEgbW91c2VEb3duIGV2ZW50LlxuXG4gICAgQG1ldGhvZCBfb25Nb3VzZURvd25cbiAgICBAcGFyYW0ge0V2ZW50RmFjYWRlfSBlXG4gICAgQHBhcmFtIHtTeW50aGV0aWNFdmVudC5Ob3RpZmllcn0gbm90aWZpZXJcbiAgICBAcHJvdGVjdGVkXG4gICAgQHN0YXRpY1xuICAgICoqL1xuICAgIF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUsIG5vdGlmaWVyKSB7XG4gICAgICAgIFZDLl9zdGFydFBvbGxpbmcoZS5jdXJyZW50VGFyZ2V0LCBub3RpZmllciwge2U6IGV9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgQ2FsbGVkIHdoZW4gdGhlIGB2YWx1ZWNoYW5nZWAgZXZlbnQgcmVjZWl2ZXMgYSBuZXcgc3Vic2NyaWJlci5cblxuICAgIENoaWxkIG5vZGVzIHRoYXQgYXJlbid0IGluaXRpYWxseSBhdmFpbGFibGUgd2hlbiB0aGlzIHN1YnNjcmlwdGlvbiBpc1xuICAgIGNhbGxlZCB3aWxsIHN0aWxsIGZpcmUgdGhlIGB2YWx1ZWNoYW5nZWAgZXZlbnQgYWZ0ZXIgdGhlaXIgZGF0YSBpc1xuICAgIGNvbGxlY3RlZCB3aGVuIHRoZSBkZWxlZ2F0ZWQgYGZvY3VzYCBldmVudCBpcyBjYXB0dXJlZC4gVGhpcyBpbmNsdWRlc1xuICAgIGVsZW1lbnRzIHRoYXQgaGF2ZW4ndCBiZWVuIGluc2VydGVkIGludG8gdGhlIERPTSB5ZXQsIGFzIHdlbGwgYXNcbiAgICBlbGVtZW50cyB0aGF0IGFyZW4ndCBpbml0aWFsbHkgYGNvbnRlbnRlZGl0YWJsZWAuXG5cbiAgICBAbWV0aG9kIF9vblN1YnNjcmliZVxuICAgIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgIEBwYXJhbSB7U3Vic2NyaXB0aW9ufSBzdWJcbiAgICBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50Lk5vdGlmaWVyfSBub3RpZmllclxuICAgIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBbZmlsdGVyXSBGaWx0ZXIgZnVuY3Rpb24gb3Igc2VsZWN0b3Igc3RyaW5nLiBPbmx5XG4gICAgICAgIHByb3ZpZGVkIGZvciBkZWxlZ2F0ZSBzdWJzY3JpcHRpb25zLlxuICAgIEBwcm90ZWN0ZWRcbiAgICBAc3RhdGljXG4gICAgKiovXG4gICAgX29uU3Vic2NyaWJlOiBmdW5jdGlvbiAobm9kZSwgc3ViLCBub3RpZmllciwgZmlsdGVyKSB7XG4gICAgICAgIHZhciBfdmFsdWVjaGFuZ2UsIGNhbGxiYWNrcywgaXNFZGl0YWJsZSwgaW5wdXROb2RlcywgZWRpdGFibGVOb2RlcztcblxuICAgICAgICBjYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBibHVyICAgICA6IFZDLl9vbkJsdXIsXG4gICAgICAgICAgICBmb2N1cyAgICA6IFZDLl9vbkZvY3VzLFxuICAgICAgICAgICAga2V5ZG93biAgOiBWQy5fb25LZXlEb3duLFxuICAgICAgICAgICAga2V5dXAgICAgOiBWQy5fb25LZXlVcCxcbiAgICAgICAgICAgIG1vdXNlZG93bjogVkMuX29uTW91c2VEb3duXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3RvcmUgYSB1dGlsaXR5IG9iamVjdCBvbiB0aGUgbm90aWZpZXIgdG8gaG9sZCBzdHVmZiB0aGF0IG5lZWRzIHRvIGJlXG4gICAgICAgIC8vIHBhc3NlZCBhcm91bmQgdG8gdHJpZ2dlciBldmVudCBoYW5kbGVycywgcG9sbGluZyBoYW5kbGVycywgZXRjLlxuICAgICAgICBfdmFsdWVjaGFuZ2UgPSBub3RpZmllci5fdmFsdWVjaGFuZ2UgPSB7fTtcblxuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGZpbHRlciBpcyBwcm92aWRlZCwgdGhlbiB0aGlzIGlzIGEgZGVsZWdhdGVkIHN1YnNjcmlwdGlvbi5cbiAgICAgICAgICAgIF92YWx1ZWNoYW5nZS5kZWxlZ2F0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBZGQgYSBmdW5jdGlvbiB0byB0aGUgbm90aWZpZXIgdGhhdCB3ZSBjYW4gdXNlIHRvIGZpbmQgYWxsXG4gICAgICAgICAgICAvLyBub2RlcyB0aGF0IHBhc3MgdGhlIGRlbGVnYXRlIGZpbHRlci5cbiAgICAgICAgICAgIF92YWx1ZWNoYW5nZS5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbnB1dE5vZGVzICAgID0gbm9kZS5hbGwoJ2lucHV0LHRleHRhcmVhLHNlbGVjdCcpLmZpbHRlcihmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIGVkaXRhYmxlTm9kZXMgPSBub2RlLmFsbCgnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0sW2NvbnRlbnRlZGl0YWJsZT1cIlwiXScpLmZpbHRlcihmaWx0ZXIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0Tm9kZXMuY29uY2F0KGVkaXRhYmxlTm9kZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGluaXRpYWwgdmFsdWVzIGZvciBlYWNoIGRlc2NlbmRhbnQgb2YgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgLy8gbm9kZSB0aGF0IHBhc3NlcyB0aGUgZGVsZWdhdGUgZmlsdGVyLlxuICAgICAgICAgICAgX3ZhbHVlY2hhbmdlLmdldE5vZGVzKCkuZWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmdldERhdGEoREFUQV9LRVkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnNldERhdGEoREFUQV9LRVksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lICAgOiBjaGlsZC5nZXQoTk9ERV9OQU1FKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFZGl0YWJsZSA6IFZDLl9pc0VkaXRhYmxlKGNoaWxkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZWYWwgICAgOiBpc0VkaXRhYmxlID8gY2hpbGQuZ2V0RE9NTm9kZSgpLmlubmVySFRNTCA6IGNoaWxkLmdldChWQUxVRSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG5vdGlmaWVyLl9oYW5kbGVzID0gWS5kZWxlZ2F0ZShjYWxsYmFja3MsIG5vZGUsIGZpbHRlciwgbnVsbCxcbiAgICAgICAgICAgICAgICBub3RpZmllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0VkaXRhYmxlID0gVkMuX2lzRWRpdGFibGUobm9kZSk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbm9ybWFsIChub24tZGVsZWdhdGVkKSBldmVudCBzdWJzY3JpcHRpb24uXG4gICAgICAgICAgICBpZiAoIW5vZGUudGVzdCgnaW5wdXQsdGV4dGFyZWEsc2VsZWN0JykgJiYgIWlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbm9kZS5nZXREYXRhKERBVEFfS0VZKSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0RGF0YShEQVRBX0tFWSwge1xuICAgICAgICAgICAgICAgICAgICBub2RlTmFtZSAgIDogbm9kZS5nZXQoTk9ERV9OQU1FKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBpc0VkaXRhYmxlIDogaXNFZGl0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbCAgICA6IGlzRWRpdGFibGUgPyBub2RlLmdldERPTU5vZGUoKS5pbm5lckhUTUwgOiBub2RlLmdldChWQUxVRSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm90aWZpZXIuX2hhbmRsZXMgPSBub2RlLm9uKGNhbGxiYWNrcywgbnVsbCwgbnVsbCwgbm90aWZpZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgIENhbGxlZCB3aGVuIHRoZSBgdmFsdWVjaGFuZ2VgIGV2ZW50IGxvc2VzIGEgc3Vic2NyaWJlci5cblxuICAgIEBtZXRob2QgX29uVW5zdWJzY3JpYmVcbiAgICBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICBAcGFyYW0ge1N1YnNjcmlwdGlvbn0gc3Vic2NyaXB0aW9uXG4gICAgQHBhcmFtIHtTeW50aGV0aWNFdmVudC5Ob3RpZmllcn0gbm90aWZpZXJcbiAgICBAcHJvdGVjdGVkXG4gICAgQHN0YXRpY1xuICAgICoqL1xuICAgIF9vblVuc3Vic2NyaWJlOiBmdW5jdGlvbiAobm9kZSwgc3Vic2NyaXB0aW9uLCBub3RpZmllcikge1xuICAgICAgICB2YXIgX3ZhbHVlY2hhbmdlID0gbm90aWZpZXIuX3ZhbHVlY2hhbmdlO1xuXG4gICAgICAgIG5vdGlmaWVyLl9oYW5kbGVzICYmIG5vdGlmaWVyLl9oYW5kbGVzLmRldGFjaCgpO1xuXG4gICAgICAgIGlmIChfdmFsdWVjaGFuZ2UuZGVsZWdhdGVkKSB7XG4gICAgICAgICAgICBfdmFsdWVjaGFuZ2UuZ2V0Tm9kZXMoKS5lYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIFZDLl9zdG9wUG9sbGluZyhjaGlsZCwgbm90aWZpZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBWQy5fc3RvcFBvbGxpbmcobm9kZSwgbm90aWZpZXIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG5TeW50aGV0aWMgZXZlbnQgdGhhdCBmaXJlcyB3aGVuIHRoZSBgdmFsdWVgIHByb3BlcnR5IG9mIGFuIGA8aW5wdXQ+YCxcbmA8dGV4dGFyZWE+YCwgYDxzZWxlY3Q+YCwgb3IgYFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdYCBub2RlIGNoYW5nZXMgYXMgYVxucmVzdWx0IG9mIGEgdXNlci1pbml0aWF0ZWQga2V5c3Ryb2tlLCBtb3VzZSBvcGVyYXRpb24sIG9yIGlucHV0IG1ldGhvZFxuZWRpdG9yIChJTUUpIGlucHV0IGV2ZW50LlxuXG5Vbmxpa2UgdGhlIGBvbmNoYW5nZWAgZXZlbnQsIHRoaXMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgdmFsdWUgYWN0dWFsbHkgY2hhbmdlc1xuYW5kIG5vdCB3aGVuIHRoZSBlbGVtZW50IGxvc2VzIGZvY3VzLiBUaGlzIGV2ZW50IGFsc28gcmVwb3J0cyBJTUUgYW5kXG5tdWx0aS1zdHJva2UgaW5wdXQgbW9yZSByZWxpYWJseSB0aGFuIGBvbmlucHV0YCBvciB0aGUgdmFyaW91cyBrZXkgZXZlbnRzIGFjcm9zc1xuYnJvd3NlcnMuXG5cbkZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBvbmx5IGZvY3VzZWQgbm9kZXMgYXJlIG1vbml0b3JlZCBmb3IgY2hhbmdlcywgc29cbnByb2dyYW1tYXRpYyB2YWx1ZSBjaGFuZ2VzIG9uIG5vZGVzIHRoYXQgZG9uJ3QgaGF2ZSBmb2N1cyB3b24ndCBiZSBkZXRlY3RlZC5cblxuQGV4YW1wbGVcblxuICAgIFlVSSgpLnVzZSgnZXZlbnQtdmFsdWVjaGFuZ2UnLCBmdW5jdGlvbiAoWSkge1xuICAgICAgICBZLm9uZSgnI215LWlucHV0Jykub24oJ3ZhbHVlY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbkBldmVudCB2YWx1ZWNoYW5nZVxuQHBhcmFtIHtTdHJpbmd9IHByZXZWYWwgUHJldmlvdXMgdmFsdWUgcHJpb3IgdG8gdGhlIGxhdGVzdCBjaGFuZ2UuXG5AcGFyYW0ge1N0cmluZ30gbmV3VmFsIE5ldyB2YWx1ZSBhZnRlciB0aGUgbGF0ZXN0IGNoYW5nZS5cbkBmb3IgWVVJXG4qKi9cblxuY29uZmlnID0ge1xuICAgIGRldGFjaDogVkMuX29uVW5zdWJzY3JpYmUsXG4gICAgb24gICAgOiBWQy5fb25TdWJzY3JpYmUsXG5cbiAgICBkZWxlZ2F0ZSAgICAgIDogVkMuX29uU3Vic2NyaWJlLFxuICAgIGRldGFjaERlbGVnYXRlOiBWQy5fb25VbnN1YnNjcmliZSxcblxuICAgIHB1Ymxpc2hDb25maWc6IHtcbiAgICAgICAgZW1pdEZhY2FkZTogdHJ1ZVxuICAgIH1cbn07XG5cblkuRXZlbnQuZGVmaW5lKCd2YWx1ZWNoYW5nZScsIGNvbmZpZyk7XG5ZLkV2ZW50LmRlZmluZSgndmFsdWVDaGFuZ2UnLCBjb25maWcpOyAvLyBkZXByZWNhdGVkLCBidXQgc3VwcG9ydGVkIGZvciBiYWNrY29tcGF0XG5cblkuVmFsdWVDaGFuZ2UgPSBWQztcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiZXZlbnQtZm9jdXNcIiwgXCJldmVudC1zeW50aGV0aWNcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnZ2VzdHVyZS1zaW11bGF0ZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogU2ltdWxhdGUgaGlnaC1sZXZlbCB1c2VyIGdlc3R1cmVzIGJ5IGdlbmVyYXRpbmcgYSBzZXQgb2YgbmF0aXZlIERPTSBldmVudHMuXG4gKlxuICogQG1vZHVsZSBnZXN0dXJlLXNpbXVsYXRlXG4gKiBAcmVxdWlyZXMgZXZlbnQtc2ltdWxhdGUsIGFzeW5jLXF1ZXVlLCBub2RlLXNjcmVlblxuICovXG5cbnZhciBOQU1FID0gXCJnZXN0dXJlLXNpbXVsYXRlXCIsXG5cbiAgICAvLyBwaGFudG9tanMgY2hlY2sgbWF5IGJlIHRlbXBvcmFyeSwgdW50aWwgd2UgZGV0ZXJtaW5lIGlmIGl0IHJlYWxseSBzdXBwb3J0IHRvdWNoIGFsbCB0aGUgd2F5IHRocm91Z2gsIGxpa2UgaXQgY2xhaW1zIHRvIChodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcGhhbnRvbWpzL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc1KVxuICAgIFNVUFBPUlRTX1RPVUNIID0gKChZLmNvbmZpZy53aW4gJiYgKFwib250b3VjaHN0YXJ0XCIgaW4gWS5jb25maWcud2luKSkgJiYgIShZLlVBLnBoYW50b21qcykgJiYgIShZLlVBLmNocm9tZSAmJiBZLlVBLmNocm9tZSA8IDYpKSxcblxuICAgIGdlc3R1cmVOYW1lcyA9IHtcbiAgICAgICAgdGFwOiAxLFxuICAgICAgICBkb3VibGV0YXA6IDEsXG4gICAgICAgIHByZXNzOiAxLFxuICAgICAgICBtb3ZlOiAxLFxuICAgICAgICBmbGljazogMSxcbiAgICAgICAgcGluY2g6IDEsXG4gICAgICAgIHJvdGF0ZTogMVxuICAgIH0sXG5cbiAgICB0b3VjaEV2ZW50cyA9IHtcbiAgICAgICAgdG91Y2hzdGFydDogMSxcbiAgICAgICAgdG91Y2htb3ZlOiAxLFxuICAgICAgICB0b3VjaGVuZDogMSxcbiAgICAgICAgdG91Y2hjYW5jZWw6IDFcbiAgICB9LFxuXG4gICAgZG9jdW1lbnQgPSBZLmNvbmZpZy5kb2MsXG4gICAgZW1wdHlUb3VjaExpc3QsXG5cbiAgICBFVkVOVF9JTlRFUlZBTCA9IDIwLCAgICAgICAgLy8gMjBtc1xuICAgIFNUQVJUX1BBR0VYLCAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGFkanVzdGVkIHRvIHRoZSBub2RlIGVsZW1lbnQgY2VudGVyXG4gICAgU1RBUlRfUEFHRVksICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgYWRqdXN0ZWQgdG8gdGhlIG5vZGUgZWxlbWVudCBjZW50ZXJcblxuICAgIC8vIGRlZmF1bHRzIHRoYXQgdXNlciBjYW4gb3ZlcnJpZGUuXG4gICAgREVGQVVMVFMgPSB7XG4gICAgICAgIC8vIHRhcCBnZXN0dXJlc1xuICAgICAgICBIT0xEX1RBUDogMTAsICAgICAgICAgICAvLyAxMG1zXG4gICAgICAgIERFTEFZX1RBUDogMTAsICAgICAgICAgIC8vIDEwbXNcblxuICAgICAgICAvLyBwcmVzcyBnZXN0dXJlXG4gICAgICAgIEhPTERfUFJFU1M6IDMwMDAsICAgICAgIC8vIDNzZWNcbiAgICAgICAgTUlOX0hPTERfUFJFU1M6IDEwMDAsICAgLy8gMXNlY1xuICAgICAgICBNQVhfSE9MRF9QUkVTUzogNjAwMDAsICAvLyAxbWluXG5cbiAgICAgICAgLy8gbW92ZSBnZXN0dXJlXG4gICAgICAgIERJU1RBTkNFX01PVkU6IDIwMCwgICAgIC8vIDIwMCBwaXhlbHNcbiAgICAgICAgRFVSQVRJT05fTU9WRTogMTAwMCwgICAgLy8gMXNlY1xuICAgICAgICBNQVhfRFVSQVRJT05fTU9WRTogNTAwMCwvLyA1c2VjXG5cbiAgICAgICAgLy8gZmxpY2sgZ2VzdHVyZVxuICAgICAgICBNSU5fVkVMT0NJVFlfRkxJQ0s6IDEuMyxcbiAgICAgICAgRElTVEFOQ0VfRkxJQ0s6IDIwMCwgICAgIC8vIDIwMCBwaXhlbHNcbiAgICAgICAgRFVSQVRJT05fRkxJQ0s6IDEwMDAsICAgIC8vIDFzZWNcbiAgICAgICAgTUFYX0RVUkFUSU9OX0ZMSUNLOiA1MDAwLC8vIDVzZWNcblxuICAgICAgICAvLyBwaW5jaC9yb3RhdGlvblxuICAgICAgICBEVVJBVElPTl9QSU5DSDogMTAwMCAgICAgLy8gMXNlY1xuICAgIH0sXG5cbiAgICBUT1VDSF9TVEFSVCA9ICd0b3VjaHN0YXJ0JyxcbiAgICBUT1VDSF9NT1ZFID0gJ3RvdWNobW92ZScsXG4gICAgVE9VQ0hfRU5EID0gJ3RvdWNoZW5kJyxcblxuICAgIEdFU1RVUkVfU1RBUlQgPSAnZ2VzdHVyZXN0YXJ0JyxcbiAgICBHRVNUVVJFX0NIQU5HRSA9ICdnZXN0dXJlY2hhbmdlJyxcbiAgICBHRVNUVVJFX0VORCA9ICdnZXN0dXJlZW5kJyxcblxuICAgIE1PVVNFX1VQICAgID0gJ21vdXNldXAnLFxuICAgIE1PVVNFX01PVkUgID0gJ21vdXNlbW92ZScsXG4gICAgTU9VU0VfRE9XTiAgPSAnbW91c2Vkb3duJyxcbiAgICBNT1VTRV9DTElDSyA9ICdjbGljaycsXG4gICAgTU9VU0VfREJMQ0xJQ0sgPSAnZGJsY2xpY2snLFxuXG4gICAgWF9BWElTID0gJ3gnLFxuICAgIFlfQVhJUyA9ICd5JztcblxuXG5mdW5jdGlvbiBTaW11bGF0aW9ucyhub2RlKSB7XG4gICAgaWYoIW5vZGUpIHtcbiAgICAgICAgWS5lcnJvcihOQU1FKyc6IGludmFsaWQgdGFyZ2V0IG5vZGUnKTtcbiAgICB9XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLnRhcmdldCA9IFkuTm9kZS5nZXRET01Ob2RlKG5vZGUpO1xuXG4gICAgdmFyIHN0YXJ0WFkgPSB0aGlzLm5vZGUuZ2V0WFkoKSxcbiAgICAgICAgZGltcyA9IHRoaXMuX2dldERpbXMoKTtcblxuICAgIFNUQVJUX1BBR0VYID0gc3RhcnRYWVswXSArIChkaW1zWzBdKS8yO1xuICAgIFNUQVJUX1BBR0VZID0gc3RhcnRYWVsxXSArIChkaW1zWzFdKS8yO1xufVxuXG5TaW11bGF0aW9ucy5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNvbnZlcnQgYSBkZWdyZWUgdG8gYSByYWRpYW4uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF90b1JhZGlhblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlZyBBIGRlZ3JlZSB0byBiZSBjb252ZXJ0ZWQgdG8gYSByYWRpYW4uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZGVncmVlIGluIHJhZGlhbi5cbiAgICAgKi9cbiAgICBfdG9SYWRpYW46IGZ1bmN0aW9uKGRlZykge1xuICAgICAgICByZXR1cm4gZGVnICogKE1hdGguUEkvMTgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBnZXQgaGVpZ2h0L3dpZHRoIHdoaWxlIGFjY291bnRpbmcgZm9yXG4gICAgICogcm90YXRpb24vc2NhbGUgdHJhbnNmb3JtcyB3aGVyZSBwb3NzaWJsZSBieSB1c2luZyB0aGVcbiAgICAgKiBib3VuZGluZyBjbGllbnQgcmVjdGFuZ2xlIGhlaWdodC93aWR0aCBpbnN0ZWFkIG9mIHRoZVxuICAgICAqIG9mZnNldFdpZHRoL0hlaWdodCB3aGljaCByZWdpb24gdXNlcy5cbiAgICAgKiBAbWV0aG9kIF9nZXREaW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgd2l0aCBbaGVpZ2h0LCB3aWR0aF1cbiAgICAgKi9cbiAgICBfZ2V0RGltcyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVnaW9uLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ7XG5cbiAgICAgICAgLy8gSWRlYWxseSwgdGhpcyBzaG91bGQgYmUgaW4gRE9NIHNvbWV3aGVyZS5cbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgICAgICAgcmVnaW9uID0gdGhpcy50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIGlmIChcImhlaWdodFwiIGluIHJlZ2lvbikge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHJlZ2lvbi5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElFNyw4IGhhcyBnZXRCQ1IsIGJ1dCBubyBoZWlnaHQuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5hYnMocmVnaW9uLmJvdHRvbSAtIHJlZ2lvbi50b3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXCJ3aWR0aFwiIGluIHJlZ2lvbikge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gcmVnaW9uLndpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJRTcsOCBoYXMgZ2V0QkNSLCBidXQgbm8gd2lkdGguXG4gICAgICAgICAgICAgICAgd2lkdGggPSBNYXRoLmFicyhyZWdpb24ucmlnaHQgLSByZWdpb24ubGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWdpb24gPSB0aGlzLm5vZGUuZ2V0KFwicmVnaW9uXCIpO1xuICAgICAgICAgICAgd2lkdGggPSByZWdpb24ud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSByZWdpb24uaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjb252ZXJ0IGEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIG5vZGUgZWxlbWVudCBpbnRvXG4gICAgICogdGhlIHBvaW50IGluIHRoZSBwYWdlIGNvb3JkaW5hdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2NhbGN1bGF0ZURlZmF1bHRQb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnQgQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgbm9kZSBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgc2FtZSBwb2ludCBpbiB0aGUgcGFnZSBjb29yZGluYXRpb24uXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZURlZmF1bHRQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgICAgICB2YXIgaGVpZ2h0O1xuXG4gICAgICAgIGlmKCFZLkxhbmcuaXNBcnJheShwb2ludCkgfHwgcG9pbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwb2ludCA9IFtTVEFSVF9QQUdFWCwgU1RBUlRfUEFHRVldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYocG9pbnQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9nZXREaW1zWzFdO1xuICAgICAgICAgICAgICAgIHBvaW50WzFdID0gaGVpZ2h0LzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIHBhZ2Uodmlld3BvcnQpIGNvb3JkaW5hdGlvblxuICAgICAgICAgICAgcG9pbnRbMF0gPSB0aGlzLm5vZGUuZ2V0WCgpICsgcG9pbnRbMF07XG4gICAgICAgICAgICBwb2ludFsxXSA9IHRoaXMubm9kZS5nZXRZKCkgKyBwb2ludFsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIFwicm90YXRlXCIgYW5kIFwicGluY2hcIiBtZXRob2RzIGFyZSBlc3NlbmNpYWxseSBzYW1lIHdpdGggdGhlIGV4YWN0IHNhbWVcbiAgICAgKiBhcmd1bWVudHMuIE9ubHkgZGlmZmVyZW5jZSBpcyB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycy4gVGhlIHJvdGF0ZSBtZXRob2RcbiAgICAgKiByZXF1aXJlcyBcInJvdGF0aW9uXCIgcGFyYW1ldGVyIHdoaWxlIHRoZSBwaW5jaCBtZXRob2QgcmVxdWlyZXMgXCJzdGFydFJhZGl1c1wiXG4gICAgICogYW5kIFwiZW5kUmFkaXVzXCIgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZ2VzdHVyZSBzaW11bGF0aW9uXG4gICAgICogICAgICBpcyBjb21wbGV0ZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2VudGVyIEEgY2VudGVyIHBvaW50IHdoZXJlIHRoZSBwaW5jaCBnZXN0dXJlIG9mIHR3byBmaW5nZXJzXG4gICAgICogICAgICBzaG91bGQgaGFwcGVuLiBJdCBpcyByZWxhdGl2ZSB0byB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0YXJnZXRcbiAgICAgKiAgICAgIG5vZGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRSYWRpdXMgQSByYWRpdXMgb2Ygc3RhcnQgY2lyY2xlIHdoZXJlIDIgZmluZ2VycyBhcmVcbiAgICAgKiAgICAgIG9uIHdoZW4gdGhlIGdlc3R1cmUgc3RhcnRzLiBUaGlzIGlzIG9wdGlvbmFsLiBUaGUgZGVmYXVsdCBpcyBhIGZvdXJ0aCBvZlxuICAgICAqICAgICAgZWl0aGVyIHRhcmdldCBub2RlIHdpZHRoIG9yIGhlaWdodCB3aGljaGV2ZXIgaXMgc21hbGxlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUmFkaXVzIEEgcmFkaXVzIG9mIGVuZCBjaXJjbGUgd2hlcmUgMiBmaW5nZXJzIHdpbGwgYmUgb24gd2hlblxuICAgICAqICAgICAgdGhlIHBpbmNoIG9yIHNwcmVhZCBnZXN0dXJlcyBhcmUgY29tcGxldGVkLiBUaGlzIGlzIG9wdGlvbmFsLlxuICAgICAqICAgICAgVGhlIGRlZmF1bHQgaXMgYSBmb3VydGggb2YgZWl0aGVyIHRhcmdldCBub2RlIHdpZHRoIG9yIGhlaWdodCB3aGljaGV2ZXIgaXMgbGVzcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gQSBkdXJhdGlvbiBvZiB0aGUgZ2VzdHVyZSBpbiBtaWxsaXNlY29uZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgQSBzdGFydCBhbmdsZSgwIGRlZ3JlZSBhdCAxMiBvJ2Nsb2NrKSB3aGVyZSB0aGVcbiAgICAgKiAgICAgIGdlc3R1cmUgc2hvdWxkIHN0YXJ0LiBEZWZhdWx0IGlzIDAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uIEEgcm90YXRpb24gaW4gZGVncmVlLiBJdCBpcyByZXF1aXJlZC5cbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uKGNiLCBjZW50ZXIsIHN0YXJ0UmFkaXVzLCBlbmRSYWRpdXMsIGR1cmF0aW9uLCBzdGFydCwgcm90YXRpb24pIHtcbiAgICAgICAgdmFyIHJhZGl1cyxcbiAgICAgICAgICAgIHIxID0gc3RhcnRSYWRpdXMsICAgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgIHIyID0gZW5kUmFkaXVzOyAgICAgLy8gb3B0aW9uYWxcblxuICAgICAgICBpZighWS5MYW5nLmlzTnVtYmVyKHIxKSB8fCAhWS5MYW5nLmlzTnVtYmVyKHIyKSB8fCByMTwwIHx8IHIyPDApIHtcbiAgICAgICAgICAgIHJhZGl1cyA9ICh0aGlzLnRhcmdldC5vZmZzZXRXaWR0aCA8IHRoaXMudGFyZ2V0Lm9mZnNldEhlaWdodCk/XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQub2Zmc2V0V2lkdGgvNCA6IHRoaXMudGFyZ2V0Lm9mZnNldEhlaWdodC80O1xuICAgICAgICAgICAgcjEgPSByYWRpdXM7XG4gICAgICAgICAgICByMiA9IHJhZGl1cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgIGlmKCFZLkxhbmcuaXNOdW1iZXIocm90YXRpb24pKSB7XG4gICAgICAgICAgICBZLmVycm9yKE5BTUUrJ0ludmFsaWQgcm90YXRpb24gZGV0ZWN0ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBpbmNoKGNiLCBjZW50ZXIsIHIxLCByMiwgZHVyYXRpb24sIHN0YXJ0LCByb3RhdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBcInJvdGF0ZVwiIGFuZCBcInBpbmNoXCIgbWV0aG9kcyBhcmUgZXNzZW5jaWFsbHkgc2FtZSB3aXRoIHRoZSBleGFjdCBzYW1lXG4gICAgICogYXJndW1lbnRzLiBPbmx5IGRpZmZlcmVuY2UgaXMgdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMuIFRoZSByb3RhdGUgbWV0aG9kXG4gICAgICogcmVxdWlyZXMgXCJyb3RhdGlvblwiIHBhcmFtZXRlciB3aGlsZSB0aGUgcGluY2ggbWV0aG9kIHJlcXVpcmVzIFwic3RhcnRSYWRpdXNcIlxuICAgICAqIGFuZCBcImVuZFJhZGl1c1wiIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBUaGUgXCJwaW5jaFwiIGdlc3R1cmUgY2FuIHNpbXVsYXRlIHZhcmlvdXMgMiBmaW5nZXIgZ2VzdHVyZXMgc3VjaCBhcyBwaW5jaCxcbiAgICAgKiBzcHJlYWQgYW5kL29yIHJvdGF0aW9uLiBUaGUgXCJzdGFydFJhZGl1c1wiIGFuZCBcImVuZFJhZGl1c1wiIGFyZSByZXF1aXJlZC5cbiAgICAgKiBJZiBlbmRSYWRpdXMgaXMgbGFyZ2VyIHRoYW4gc3RhcnRSYWRpdXMsIGl0IGJlY29tZXMgYSBzcHJlYWQgZ2VzdHVyZVxuICAgICAqIG90aGVyd2lzZSBhIHBpbmNoIGdlc3R1cmUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHBpbmNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZ2VzdHVyZSBzaW11bGF0aW9uXG4gICAgICogICAgICBpcyBjb21wbGV0ZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2VudGVyIEEgY2VudGVyIHBvaW50IHdoZXJlIHRoZSBwaW5jaCBnZXN0dXJlIG9mIHR3byBmaW5nZXJzXG4gICAgICogICAgICBzaG91bGQgaGFwcGVuLiBJdCBpcyByZWxhdGl2ZSB0byB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0YXJnZXRcbiAgICAgKiAgICAgIG5vZGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRSYWRpdXMgQSByYWRpdXMgb2Ygc3RhcnQgY2lyY2xlIHdoZXJlIDIgZmluZ2VycyBhcmVcbiAgICAgKiAgICAgIG9uIHdoZW4gdGhlIGdlc3R1cmUgc3RhcnRzLiBUaGlzIHBhcmFtZW50ZXIgaXMgcmVxdWlyZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFJhZGl1cyBBIHJhZGl1cyBvZiBlbmQgY2lyY2xlIHdoZXJlIDIgZmluZ2VycyB3aWxsIGJlIG9uIHdoZW5cbiAgICAgKiAgICAgIHRoZSBwaW5jaCBvciBzcHJlYWQgZ2VzdHVyZXMgYXJlIGNvbXBsZXRlZC4gVGhpcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEEgZHVyYXRpb24gb2YgdGhlIGdlc3R1cmUgaW4gbWlsbGlzZWNvbmQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IEEgc3RhcnQgYW5nbGUoMCBkZWdyZWUgYXQgMTIgbydjbG9jaykgd2hlcmUgdGhlXG4gICAgICogICAgICBnZXN0dXJlIHNob3VsZCBzdGFydC4gRGVmYXVsdCBpcyAwLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvbiBJZiByb3RhdGlvbiBpcyBkZXNpcmVkIGR1cmluZyB0aGUgcGluY2ggb3JcbiAgICAgKiAgICAgIHNwcmVhZCBnZXN0dXJlcywgdGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQuIERlZmF1bHQgaXMgMCBkZWdyZWUuXG4gICAgICovXG4gICAgcGluY2g6IGZ1bmN0aW9uKGNiLCBjZW50ZXIsIHN0YXJ0UmFkaXVzLCBlbmRSYWRpdXMsIGR1cmF0aW9uLCBzdGFydCwgcm90YXRpb24pIHtcbiAgICAgICAgdmFyIGV2ZW50UXVldWUsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBFVkVOVF9JTlRFUlZBTCxcbiAgICAgICAgICAgIHRvdWNoZXMsXG4gICAgICAgICAgICBpZCA9IDAsXG4gICAgICAgICAgICByMSA9IHN0YXJ0UmFkaXVzLCAgIC8vIHJlcXVpcmVkXG4gICAgICAgICAgICByMiA9IGVuZFJhZGl1cywgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgICAgICByYWRpdXNQZXJTdGVwLFxuICAgICAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgICAgIHN0YXJ0U2NhbGUsIGVuZFNjYWxlLCBzY2FsZVBlclN0ZXAsXG4gICAgICAgICAgICBzdGFydFJvdCwgZW5kUm90LCByb3RQZXJTdGVwLFxuICAgICAgICAgICAgcGF0aDEgPSB7c3RhcnQ6IFtdLCBlbmQ6IFtdfSwgLy8gcGF0aHMgZm9yIDFzdCBhbmQgMm5kIGZpbmdlcnMuXG4gICAgICAgICAgICBwYXRoMiA9IHtzdGFydDogW10sIGVuZDogW119LFxuICAgICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgICB0b3VjaE1vdmU7XG5cbiAgICAgICAgY2VudGVyID0gdGhpcy5fY2FsY3VsYXRlRGVmYXVsdFBvaW50KGNlbnRlcik7XG5cbiAgICAgICAgaWYoIVkuTGFuZy5pc051bWJlcihyMSkgfHwgIVkuTGFuZy5pc051bWJlcihyMikgfHwgcjE8MCB8fCByMjwwKSB7XG4gICAgICAgICAgICBZLmVycm9yKE5BTUUrJ0ludmFsaWQgc3RhcnRSYWRpdXMgYW5kIGVuZFJhZGl1cyBkZXRlY3RlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFZLkxhbmcuaXNOdW1iZXIoZHVyYXRpb24pIHx8IGR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gREVGQVVMVFMuRFVSQVRJT05fUElOQ0g7XG4gICAgICAgIH1cblxuICAgICAgICBpZighWS5MYW5nLmlzTnVtYmVyKHN0YXJ0KSkge1xuICAgICAgICAgICAgc3RhcnQgPSAwLjA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0JTM2MDtcbiAgICAgICAgICAgIHdoaWxlKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IDM2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFZLkxhbmcuaXNOdW1iZXIocm90YXRpb24pKSB7XG4gICAgICAgICAgICByb3RhdGlvbiA9IDAuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIFkuQXN5bmNRdWV1ZS5kZWZhdWx0cy50aW1lb3V0ID0gaW50ZXJ2YWw7XG4gICAgICAgIGV2ZW50UXVldWUgPSBuZXcgWS5Bc3luY1F1ZXVlKCk7XG5cbiAgICAgICAgLy8gcmFuZ2UgZGV0ZXJtaW5hdGlvblxuICAgICAgICBjZW50ZXJYID0gY2VudGVyWzBdO1xuICAgICAgICBjZW50ZXJZID0gY2VudGVyWzFdO1xuXG4gICAgICAgIHN0YXJ0Um90ID0gc3RhcnQ7XG4gICAgICAgIGVuZFJvdCA9IHN0YXJ0ICsgcm90YXRpb247XG5cbiAgICAgICAgLy8gMXN0IGZpbmdlciBwYXRoXG4gICAgICAgIHBhdGgxLnN0YXJ0ID0gW1xuICAgICAgICAgICAgY2VudGVyWCArIHIxKk1hdGguc2luKHRoaXMuX3RvUmFkaWFuKHN0YXJ0Um90KSksXG4gICAgICAgICAgICBjZW50ZXJZIC0gcjEqTWF0aC5jb3ModGhpcy5fdG9SYWRpYW4oc3RhcnRSb3QpKVxuICAgICAgICBdO1xuICAgICAgICBwYXRoMS5lbmQgICA9IFtcbiAgICAgICAgICAgIGNlbnRlclggKyByMipNYXRoLnNpbih0aGlzLl90b1JhZGlhbihlbmRSb3QpKSxcbiAgICAgICAgICAgIGNlbnRlclkgLSByMipNYXRoLmNvcyh0aGlzLl90b1JhZGlhbihlbmRSb3QpKVxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIDJuZCBmaW5nZXIgcGF0aFxuICAgICAgICBwYXRoMi5zdGFydCA9IFtcbiAgICAgICAgICAgIGNlbnRlclggLSByMSpNYXRoLnNpbih0aGlzLl90b1JhZGlhbihzdGFydFJvdCkpLFxuICAgICAgICAgICAgY2VudGVyWSArIHIxKk1hdGguY29zKHRoaXMuX3RvUmFkaWFuKHN0YXJ0Um90KSlcbiAgICAgICAgXTtcbiAgICAgICAgcGF0aDIuZW5kICAgPSBbXG4gICAgICAgICAgICBjZW50ZXJYIC0gcjIqTWF0aC5zaW4odGhpcy5fdG9SYWRpYW4oZW5kUm90KSksXG4gICAgICAgICAgICBjZW50ZXJZICsgcjIqTWF0aC5jb3ModGhpcy5fdG9SYWRpYW4oZW5kUm90KSlcbiAgICAgICAgXTtcblxuICAgICAgICBzdGFydFNjYWxlID0gMS4wO1xuICAgICAgICBlbmRTY2FsZSA9IGVuZFJhZGl1cy9zdGFydFJhZGl1cztcblxuICAgICAgICAvLyB0b3VjaC9nZXN0dXJlIHN0YXJ0XG4gICAgICAgIGV2ZW50UXVldWUuYWRkKHtcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmQxLCBjb29yZDIsIGNvb3JkLCB0b3VjaGVzO1xuXG4gICAgICAgICAgICAgICAgLy8gY29vcmRpbmF0ZSBmb3IgZWFjaCB0b3VjaCBvYmplY3QuXG4gICAgICAgICAgICAgICAgY29vcmQxID0ge1xuICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGF0aDEuc3RhcnRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBwYXRoMS5zdGFydFsxXSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogcGF0aDEuc3RhcnRbMF0sXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHBhdGgxLnN0YXJ0WzFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb29yZDIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBwYXRoMi5zdGFydFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6IHBhdGgyLnN0YXJ0WzFdLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBwYXRoMi5zdGFydFswXSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogcGF0aDIuc3RhcnRbMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRvdWNoZXMgPSB0aGlzLl9jcmVhdGVUb3VjaExpc3QoW1kubWVyZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiAoaWQrKylcbiAgICAgICAgICAgICAgICB9LCBjb29yZDEpLCBZLm1lcmdlKHtcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogKGlkKyspXG4gICAgICAgICAgICAgICAgfSwgY29vcmQyKV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gY29vcmRpbmF0ZSBmb3IgdG9wIGxldmVsIGV2ZW50XG4gICAgICAgICAgICAgICAgY29vcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYOiAocGF0aDEuc3RhcnRbMF0gKyBwYXRoMi5zdGFydFswXSkvMixcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6IChwYXRoMS5zdGFydFswXSArIHBhdGgyLnN0YXJ0WzFdKS8yLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiAocGF0aDEuc3RhcnRbMF0gKyBwYXRoMi5zdGFydFswXSkvMixcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogKHBhdGgxLnN0YXJ0WzBdICsgcGF0aDIuc3RhcnRbMV0pLzJcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fc2ltdWxhdGVFdmVudCh0aGlzLnRhcmdldCwgVE9VQ0hfU1RBUlQsIFkubWVyZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGVzOiB0b3VjaGVzLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRUb3VjaGVzOiB0b3VjaGVzLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkVG91Y2hlczogdG91Y2hlcyxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHN0YXJ0U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBzdGFydFJvdFxuICAgICAgICAgICAgICAgIH0sIGNvb3JkKSk7XG5cbiAgICAgICAgICAgICAgICBpZihZLlVBLmlvcyA+PSAyLjApIHtcbiAgICAgICAgICAgICAgICAgICAgLyogZ2VzdHVyZSBzdGFydHMgd2hlbiB0aGUgMm5kIGZpbmdlciB0b3VjaCBzdGFydHMuXG4gICAgICAgICAgICAgICAgICAgICogVGhlIGltcGxlbWVudGF0aW9uIHdpbGwgZmlyZSAxIHRvdWNoIHN0YXJ0IGV2ZW50IGZvciBib3RoIGZpbmdlcnMsXG4gICAgICAgICAgICAgICAgICAgICogc2ltdWxhdGluZyAyIGZpbmdlcnMgdG91Y2hlZCBvbiB0aGUgc2NyZWVuIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpbXVsYXRlRXZlbnQodGhpcy50YXJnZXQsIEdFU1RVUkVfU1RBUlQsIFkubWVyZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHN0YXJ0U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogc3RhcnRSb3RcbiAgICAgICAgICAgICAgICAgICAgfSwgY29vcmQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZW91dDogMCxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZ2VzdHVyZSBjaGFuZ2VcbiAgICAgICAgc3RlcHMgPSBNYXRoLmZsb29yKGR1cmF0aW9uL2ludGVydmFsKTtcbiAgICAgICAgcmFkaXVzUGVyU3RlcCA9IChyMiAtIHIxKS9zdGVwcztcbiAgICAgICAgc2NhbGVQZXJTdGVwID0gKGVuZFNjYWxlIC0gc3RhcnRTY2FsZSkvc3RlcHM7XG4gICAgICAgIHJvdFBlclN0ZXAgPSAoZW5kUm90IC0gc3RhcnRSb3QpL3N0ZXBzO1xuXG4gICAgICAgIHRvdWNoTW92ZSA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSByMSArIChyYWRpdXNQZXJTdGVwKSpzdGVwLFxuICAgICAgICAgICAgICAgIHB4MSA9IGNlbnRlclggKyByYWRpdXMqTWF0aC5zaW4odGhpcy5fdG9SYWRpYW4oc3RhcnRSb3QgKyByb3RQZXJTdGVwKnN0ZXApKSxcbiAgICAgICAgICAgICAgICBweTEgPSBjZW50ZXJZIC0gcmFkaXVzKk1hdGguY29zKHRoaXMuX3RvUmFkaWFuKHN0YXJ0Um90ICsgcm90UGVyU3RlcCpzdGVwKSksXG4gICAgICAgICAgICAgICAgcHgyID0gY2VudGVyWCAtIHJhZGl1cypNYXRoLnNpbih0aGlzLl90b1JhZGlhbihzdGFydFJvdCArIHJvdFBlclN0ZXAqc3RlcCkpLFxuICAgICAgICAgICAgICAgIHB5MiA9IGNlbnRlclkgKyByYWRpdXMqTWF0aC5jb3ModGhpcy5fdG9SYWRpYW4oc3RhcnRSb3QgKyByb3RQZXJTdGVwKnN0ZXApKSxcbiAgICAgICAgICAgICAgICBweCA9IChweDErcHgyKS8yLFxuICAgICAgICAgICAgICAgIHB5ID0gKHB5MStweTIpLzIsXG4gICAgICAgICAgICAgICAgY29vcmQxLCBjb29yZDIsIGNvb3JkLCB0b3VjaGVzO1xuXG4gICAgICAgICAgICAvLyBjb29yZGluYXRlIGZvciBlYWNoIHRvdWNoIG9iamVjdC5cbiAgICAgICAgICAgIGNvb3JkMSA9IHtcbiAgICAgICAgICAgICAgICBwYWdlWDogcHgxLFxuICAgICAgICAgICAgICAgIHBhZ2VZOiBweTEsXG4gICAgICAgICAgICAgICAgY2xpZW50WDogcHgxLFxuICAgICAgICAgICAgICAgIGNsaWVudFk6IHB5MVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvb3JkMiA9IHtcbiAgICAgICAgICAgICAgICBwYWdlWDogcHgyLFxuICAgICAgICAgICAgICAgIHBhZ2VZOiBweTIsXG4gICAgICAgICAgICAgICAgY2xpZW50WDogcHgyLFxuICAgICAgICAgICAgICAgIGNsaWVudFk6IHB5MlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRvdWNoZXMgPSB0aGlzLl9jcmVhdGVUb3VjaExpc3QoW1kubWVyZ2Uoe1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IChpZCsrKVxuICAgICAgICAgICAgfSwgY29vcmQxKSwgWS5tZXJnZSh7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcjogKGlkKyspXG4gICAgICAgICAgICB9LCBjb29yZDIpXSk7XG5cbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGUgZm9yIHRvcCBsZXZlbCBldmVudFxuICAgICAgICAgICAgY29vcmQgPSB7XG4gICAgICAgICAgICAgICAgcGFnZVg6IHB4LFxuICAgICAgICAgICAgICAgIHBhZ2VZOiBweSxcbiAgICAgICAgICAgICAgICBjbGllbnRYOiBweCxcbiAgICAgICAgICAgICAgICBjbGllbnRZOiBweVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fc2ltdWxhdGVFdmVudCh0aGlzLnRhcmdldCwgVE9VQ0hfTU9WRSwgWS5tZXJnZSh7XG4gICAgICAgICAgICAgICAgdG91Y2hlczogdG91Y2hlcyxcbiAgICAgICAgICAgICAgICB0YXJnZXRUb3VjaGVzOiB0b3VjaGVzLFxuICAgICAgICAgICAgICAgIGNoYW5nZWRUb3VjaGVzOiB0b3VjaGVzLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBzdGFydFNjYWxlICsgc2NhbGVQZXJTdGVwKnN0ZXAsXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHN0YXJ0Um90ICsgcm90UGVyU3RlcCpzdGVwXG4gICAgICAgICAgICB9LCBjb29yZCkpO1xuXG4gICAgICAgICAgICBpZihZLlVBLmlvcyA+PSAyLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaW11bGF0ZUV2ZW50KHRoaXMudGFyZ2V0LCBHRVNUVVJFX0NIQU5HRSwgWS5tZXJnZSh7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBzdGFydFNjYWxlICsgc2NhbGVQZXJTdGVwKnN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBzdGFydFJvdCArIHJvdFBlclN0ZXAqc3RlcFxuICAgICAgICAgICAgICAgIH0sIGNvb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChpPTA7IGkgPCBzdGVwczsgaSsrKSB7XG4gICAgICAgICAgICBldmVudFF1ZXVlLmFkZCh7XG4gICAgICAgICAgICAgICAgZm46IHRvdWNoTW92ZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbaV0sXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXN0dXJlIGVuZFxuICAgICAgICBldmVudFF1ZXVlLmFkZCh7XG4gICAgICAgICAgICBmbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVtcHR5VG91Y2hMaXN0ID0gdGhpcy5fZ2V0RW1wdHlUb3VjaExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmQxLCBjb29yZDIsIGNvb3JkLCB0b3VjaGVzO1xuXG4gICAgICAgICAgICAgICAgLy8gY29vcmRpbmF0ZSBmb3IgZWFjaCB0b3VjaCBvYmplY3QuXG4gICAgICAgICAgICAgICAgY29vcmQxID0ge1xuICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGF0aDEuZW5kWzBdLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWTogcGF0aDEuZW5kWzFdLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBwYXRoMS5lbmRbMF0sXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHBhdGgxLmVuZFsxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29vcmQyID0ge1xuICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGF0aDIuZW5kWzBdLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWTogcGF0aDIuZW5kWzFdLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBwYXRoMi5lbmRbMF0sXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHBhdGgyLmVuZFsxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdG91Y2hlcyA9IHRoaXMuX2NyZWF0ZVRvdWNoTGlzdChbWS5tZXJnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IChpZCsrKVxuICAgICAgICAgICAgICAgIH0sIGNvb3JkMSksIFkubWVyZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiAoaWQrKylcbiAgICAgICAgICAgICAgICB9LCBjb29yZDIpXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb29yZGluYXRlIGZvciB0b3AgbGV2ZWwgZXZlbnRcbiAgICAgICAgICAgICAgICBjb29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVg6IChwYXRoMS5lbmRbMF0gKyBwYXRoMi5lbmRbMF0pLzIsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VZOiAocGF0aDEuZW5kWzBdICsgcGF0aDIuZW5kWzFdKS8yLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiAocGF0aDEuZW5kWzBdICsgcGF0aDIuZW5kWzBdKS8yLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiAocGF0aDEuZW5kWzBdICsgcGF0aDIuZW5kWzFdKS8yXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmKFkuVUEuaW9zID49IDIuMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaW11bGF0ZUV2ZW50KHRoaXMudGFyZ2V0LCBHRVNUVVJFX0VORCwgWS5tZXJnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogZW5kU2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogZW5kUm90XG4gICAgICAgICAgICAgICAgICAgIH0sIGNvb3JkKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fc2ltdWxhdGVFdmVudCh0aGlzLnRhcmdldCwgVE9VQ0hfRU5ELCBZLm1lcmdlKHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hlczogZW1wdHlUb3VjaExpc3QsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFRvdWNoZXM6IGVtcHR5VG91Y2hMaXN0LFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkVG91Y2hlczogdG91Y2hlcyxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IGVuZFNjYWxlLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogZW5kUm90XG4gICAgICAgICAgICAgICAgfSwgY29vcmQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKGNiICYmIFkuTGFuZy5pc0Z1bmN0aW9uKGNiKSkge1xuICAgICAgICAgICAgZXZlbnRRdWV1ZS5hZGQoe1xuICAgICAgICAgICAgICAgIGZuOiBjYixcblxuICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQsIHRoZSBjYWxsYmFjayBydW5zIHRoZSBub2RlIGNvbnRleHQgd2hlcmVcbiAgICAgICAgICAgICAgICAvLyBzaW11bGF0ZUdlc3R1cmUgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLm5vZGVcblxuICAgICAgICAgICAgICAgIC8vVE9ETzogVXNlIGFyZ3MgdG8gcGFzcyBlcnJvciBvYmplY3QgYXMgMXN0IHBhcmFtIGlmIHRoZXJlIGlzIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgIC8vYXJnczpcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnRRdWV1ZS5ydW4oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIFwidGFwXCIgZ2VzdHVyZSBjYW4gYmUgdXNlZCBmb3IgdmFyaW91cyBzaW5nbGUgdG91Y2ggcG9pbnQgZ2VzdHVyZXNcbiAgICAgKiBzdWNoIGFzIHNpbmdsZSB0YXAsIE4gbnVtYmVyIG9mIHRhcHMsIGxvbmcgcHJlc3MuIFRoZSBkZWZhdWx0IGlzIGEgc2luZ2xlXG4gICAgICogdGFwLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0YXBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBnZXN0dXJlIHNpbXVsYXRpb25cbiAgICAgKiAgICAgIGlzIGNvbXBsZXRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBBIHBvaW50KHJlbGF0aXZlIHRvIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlXG4gICAgICogICAgICB0YXJnZXQgbm9kZSBlbGVtZW50KSB3aGVyZSB0aGUgdGFwIGdlc3R1cmUgc2hvdWxkIHN0YXJ0LiBUaGUgZGVmYXVsdFxuICAgICAqICAgICAgaXMgdGhlIGNlbnRlciBvZiB0aGUgdGFnZXQgbm9kZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZXMgVGhlIG51bWJlciBvZiB0YXBzLiBEZWZhdWx0IGlzIDEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvbGQgVGhlIGhvbGQgdGltZSBpbiBtaWxsaXNlY29uZHMgYmV0d2VlbiBcInRvdWNoc3RhcnRcIiBhbmRcbiAgICAgKiAgICAgIFwidG91Y2hlbmRcIiBldmVudCBnZW5lcmF0aW9uLiBEZWZhdWx0IGlzIDEwbXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IFRoZSB0aW1lIGdhcCBpbiBtaWxsaXNlY29uZCBiZXR3ZWVuIHRhcHMgaWYgdGhpc1xuICAgICAqICAgICAgZ2VzdHVyZSBoYXMgbW9yZSB0aGFuIDEgdGFwLiBEZWZhdWx0IGlzIDEwbXMuXG4gICAgICovXG4gICAgdGFwOiBmdW5jdGlvbihjYiwgcG9pbnQsIHRpbWVzLCBob2xkLCBkZWxheSkge1xuICAgICAgICB2YXIgZXZlbnRRdWV1ZSA9IG5ldyBZLkFzeW5jUXVldWUoKSxcbiAgICAgICAgICAgIGVtcHR5VG91Y2hMaXN0ID0gdGhpcy5fZ2V0RW1wdHlUb3VjaExpc3QoKSxcbiAgICAgICAgICAgIHRvdWNoZXMsXG4gICAgICAgICAgICBjb29yZCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICB0b3VjaFN0YXJ0LFxuICAgICAgICAgICAgdG91Y2hFbmQ7XG5cbiAgICAgICAgcG9pbnQgPSB0aGlzLl9jYWxjdWxhdGVEZWZhdWx0UG9pbnQocG9pbnQpO1xuXG4gICAgICAgIGlmKCFZLkxhbmcuaXNOdW1iZXIodGltZXMpIHx8IHRpbWVzIDwgMSkge1xuICAgICAgICAgICAgdGltZXMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIVkuTGFuZy5pc051bWJlcihob2xkKSkge1xuICAgICAgICAgICAgaG9sZCA9IERFRkFVTFRTLkhPTERfVEFQO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIVkuTGFuZy5pc051bWJlcihkZWxheSkpIHtcbiAgICAgICAgICAgIGRlbGF5ID0gREVGQVVMVFMuREVMQVlfVEFQO1xuICAgICAgICB9XG5cbiAgICAgICAgY29vcmQgPSB7XG4gICAgICAgICAgICBwYWdlWDogcG9pbnRbMF0sXG4gICAgICAgICAgICBwYWdlWTogcG9pbnRbMV0sXG4gICAgICAgICAgICBjbGllbnRYOiBwb2ludFswXSxcbiAgICAgICAgICAgIGNsaWVudFk6IHBvaW50WzFdXG4gICAgICAgIH07XG5cbiAgICAgICAgdG91Y2hlcyA9IHRoaXMuX2NyZWF0ZVRvdWNoTGlzdChbWS5tZXJnZSh7aWRlbnRpZmllcjogMH0sIGNvb3JkKV0pO1xuXG4gICAgICAgIHRvdWNoU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpbXVsYXRlRXZlbnQodGhpcy50YXJnZXQsIFRPVUNIX1NUQVJULCBZLm1lcmdlKHtcbiAgICAgICAgICAgICAgICB0b3VjaGVzOiB0b3VjaGVzLFxuICAgICAgICAgICAgICAgIHRhcmdldFRvdWNoZXM6IHRvdWNoZXMsXG4gICAgICAgICAgICAgICAgY2hhbmdlZFRvdWNoZXM6IHRvdWNoZXNcbiAgICAgICAgICAgIH0sIGNvb3JkKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdG91Y2hFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpbXVsYXRlRXZlbnQodGhpcy50YXJnZXQsIFRPVUNIX0VORCwgWS5tZXJnZSh7XG4gICAgICAgICAgICAgICAgdG91Y2hlczogZW1wdHlUb3VjaExpc3QsXG4gICAgICAgICAgICAgICAgdGFyZ2V0VG91Y2hlczogZW1wdHlUb3VjaExpc3QsXG4gICAgICAgICAgICAgICAgY2hhbmdlZFRvdWNoZXM6IHRvdWNoZXNcbiAgICAgICAgICAgIH0sIGNvb3JkKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChpPTA7IGkgPCB0aW1lczsgaSsrKSB7XG4gICAgICAgICAgICBldmVudFF1ZXVlLmFkZCh7XG4gICAgICAgICAgICAgICAgZm46IHRvdWNoU3RhcnQsXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiAoaSA9PT0gMCk/IDAgOiBkZWxheVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGV2ZW50UXVldWUuYWRkKHtcbiAgICAgICAgICAgICAgICBmbjogdG91Y2hFbmQsXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBob2xkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRpbWVzID4gMSAmJiAhU1VQUE9SVFNfVE9VQ0gpIHtcbiAgICAgICAgICAgIGV2ZW50UXVldWUuYWRkKHtcbiAgICAgICAgICAgICAgICBmbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpbXVsYXRlRXZlbnQodGhpcy50YXJnZXQsIE1PVVNFX0RCTENMSUNLLCBjb29yZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGNiICYmIFkuTGFuZy5pc0Z1bmN0aW9uKGNiKSkge1xuICAgICAgICAgICAgZXZlbnRRdWV1ZS5hZGQoe1xuICAgICAgICAgICAgICAgIGZuOiBjYixcblxuICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQsIHRoZSBjYWxsYmFjayBydW5zIHRoZSBub2RlIGNvbnRleHQgd2hlcmVcbiAgICAgICAgICAgICAgICAvLyBzaW11bGF0ZUdlc3R1cmUgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLm5vZGVcblxuICAgICAgICAgICAgICAgIC8vVE9ETzogVXNlIGFyZ3MgdG8gcGFzcyBlcnJvciBvYmplY3QgYXMgMXN0IHBhcmFtIGlmIHRoZXJlIGlzIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgIC8vYXJnczpcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnRRdWV1ZS5ydW4oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIFwiZmxpY2tcIiBnZXN0dXJlIGlzIGEgc3BlY2lhbGl6ZWQgXCJtb3ZlXCIgdGhhdCBoYXMgc29tZSB2ZWxvY2l0eVxuICAgICAqIGFuZCB0aGUgbW92ZW1lbnQgYWx3YXlzIHJ1bnMgZWl0aGVyIHggb3IgeSBheGlzLiBUaGUgdmVsb2NpdHkgaXMgY2FsY3VsYXRlZFxuICAgICAqIHdpdGggXCJkaXN0YW5jZVwiIGFuZCBcImR1cmF0aW9uXCIgYXJndW1lbnRzLiBJZiB0aGUgY2FsY3VsYXRlZCB2ZWxvY2l0eSBpc1xuICAgICAqIGJlbG93IHRoYW4gdGhlIG1pbmltdW0gdmVsb2NpdHksIHRoZSBnaXZlbiBkdXJhdGlvbiB3aWxsIGJlIGlnbm9yZWQgYW5kXG4gICAgICogbmV3IGR1cmF0aW9uIHdpbGwgYmUgY3JlYXRlZCB0byBtYWtlIGEgdmFsaWQgZmxpY2sgZ2VzdHVyZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZmxpY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBnZXN0dXJlIHNpbXVsYXRpb25cbiAgICAgKiAgICAgIGlzIGNvbXBsZXRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBBIHBvaW50KHJlbGF0aXZlIHRvIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlXG4gICAgICogICAgICB0YXJnZXQgbm9kZSBlbGVtZW50KSB3aGVyZSB0aGUgZmxpY2sgZ2VzdHVyZSBzaG91bGQgc3RhcnQuIFRoZSBkZWZhdWx0XG4gICAgICogICAgICBpcyB0aGUgY2VudGVyIG9mIHRoZSB0YWdldCBub2RlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIEVpdGhlciBcInhcIiBvciBcInlcIi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2UgQSBkaXN0YW5jZSBpbiBwaXhlbHMgdG8gZmxpY2suXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEEgZHVyYXRpb24gb2YgdGhlIGdlc3R1cmUgaW4gbWlsbGlzZWNvbmQuXG4gICAgICpcbiAgICAgKi9cbiAgICBmbGljazogZnVuY3Rpb24oY2IsIHBvaW50LCBheGlzLCBkaXN0YW5jZSwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHBhdGg7XG5cbiAgICAgICAgcG9pbnQgPSB0aGlzLl9jYWxjdWxhdGVEZWZhdWx0UG9pbnQocG9pbnQpO1xuXG4gICAgICAgIGlmKCFZLkxhbmcuaXNTdHJpbmcoYXhpcykpIHtcbiAgICAgICAgICAgIGF4aXMgPSBYX0FYSVM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBheGlzID0gYXhpcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYoYXhpcyAhPT0gWF9BWElTICYmIGF4aXMgIT09IFlfQVhJUykge1xuICAgICAgICAgICAgICAgIFkuZXJyb3IoTkFNRSsnKGZsaWNrKTogT25seSB4IG9yIHkgYXhpcyBhbGxvd2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZighWS5MYW5nLmlzTnVtYmVyKGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBERUZBVUxUUy5ESVNUQU5DRV9GTElDSztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFZLkxhbmcuaXNOdW1iZXIoZHVyYXRpb24pKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gREVGQVVMVFMuRFVSQVRJT05fRkxJQ0s7IC8vIG1zXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihkdXJhdGlvbiA+IERFRkFVTFRTLk1BWF9EVVJBVElPTl9GTElDSykge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gREVGQVVMVFMuTUFYX0RVUkFUSU9OX0ZMSUNLO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogQ2hlY2sgaWYgdG9vIHNsb3cgZm9yIGEgZmxpY2suXG4gICAgICAgICAqIEFkanVzdCBkdXJhdGlvbiBpZiB0aGUgY2FsY3VsYXRlZCB2ZWxvY2l0eSBpcyBsZXNzIHRoYW5cbiAgICAgICAgICogdGhlIG1pbmltdW0gdmVsY29jaXR5IHRvIGJlIGNsYWltZWQgYXMgYSBmbGljay5cbiAgICAgICAgICovXG4gICAgICAgIGlmKE1hdGguYWJzKGRpc3RhbmNlKS9kdXJhdGlvbiA8IERFRkFVTFRTLk1JTl9WRUxPQ0lUWV9GTElDSykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLmFicyhkaXN0YW5jZSkvREVGQVVMVFMuTUlOX1ZFTE9DSVRZX0ZMSUNLO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBZLmNsb25lKHBvaW50KSxcbiAgICAgICAgICAgIGVuZDogW1xuICAgICAgICAgICAgICAgIChheGlzID09PSBYX0FYSVMpID8gcG9pbnRbMF0rZGlzdGFuY2UgOiBwb2ludFswXSxcbiAgICAgICAgICAgICAgICAoYXhpcyA9PT0gWV9BWElTKSA/IHBvaW50WzFdK2Rpc3RhbmNlIDogcG9pbnRbMV1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9tb3ZlKGNiLCBwYXRoLCBkdXJhdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBcIm1vdmVcIiBnZXN0dXJlIHNpbXVsYXRlIHRoZSBtb3ZlbWVudCBvZiBhbnkgZGlyZWN0aW9uIGJldHdlZW5cbiAgICAgKiB0aGUgc3RyYWlnaHQgbGluZSBvZiBzdGFydCBhbmQgZW5kIHBvaW50IGZvciB0aGUgZ2l2ZW4gZHVyYXRpb24uXG4gICAgICogVGhlIHBhdGggYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggXCJwb2ludFwiLCBcInhkaXN0XCIgYW5kIFwieWRpc3RcIiBwcm9wZXJ0aWVzLlxuICAgICAqIFRoZSBcInBvaW50XCIgcHJvcGVydHkgaXMgYW4gYXJyYXkgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGlvbnMocmVsYXRpdmUgdG8gdGhlXG4gICAgICogdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0YXJnZXQgbm9kZSBlbGVtZW50KSB3aGlsZSBcInhkaXN0XCIgYW5kIFwieWRpc3RcIlxuICAgICAqIHByb3BlcnRpZXMgYXJlIHVzZWQgZm9yIHRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgeCBhbmQgeSBheGlzLiBBIG5lZ2F0aXZlXG4gICAgICogZGlzdGFuY2UgbnVtYmVyIGNhbiBiZSB1c2VkIHRvIGRyYWcgZWl0aGVyIGxlZnQgb3IgdXAgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgbm8gYXJndW1lbnRzIGFyZSBnaXZlbiwgaXQgd2lsbCBzaW11bGF0ZSB0aGUgZGVmYXVsdCBtb3ZlLCB3aGljaFxuICAgICAqIGlzIG1vdmluZyAyMDAgcGl4ZWxzIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudCB0byB0aGUgcG9zaXRpdmUgWC1heGlzXG4gICAgICogZGlyZWN0aW9uIGZvciAxIHNlYy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbW92ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGdlc3R1cmUgc2ltdWxhdGlvblxuICAgICAqICAgICAgaXMgY29tcGxldGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXRoIEFuIG9iamVjdCB3aXRoIFwicG9pbnRcIiwgXCJ4ZGlzdFwiIGFuZCBcInlkaXN0XCIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEEgZHVyYXRpb24gb2YgdGhlIGdlc3R1cmUgaW4gbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgbW92ZTogZnVuY3Rpb24oY2IsIHBhdGgsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBjb252ZXJ0ZWRQYXRoO1xuXG4gICAgICAgIGlmKCFZLkxhbmcuaXNPYmplY3QocGF0aCkpIHtcbiAgICAgICAgICAgIHBhdGggPSB7XG4gICAgICAgICAgICAgICAgcG9pbnQ6IHRoaXMuX2NhbGN1bGF0ZURlZmF1bHRQb2ludChbXSksXG4gICAgICAgICAgICAgICAgeGRpc3Q6IERFRkFVTFRTLkRJU1RBTkNFX01PVkUsXG4gICAgICAgICAgICAgICAgeWRpc3Q6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIHRoZSBwYWdlIGNvb3JkaW5hdGlvblxuICAgICAgICAgICAgaWYoIVkuTGFuZy5pc0FycmF5KHBhdGgucG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wb2ludCA9IHRoaXMuX2NhbGN1bGF0ZURlZmF1bHRQb2ludChbXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGgucG9pbnQgPSB0aGlzLl9jYWxjdWxhdGVEZWZhdWx0UG9pbnQocGF0aC5wb2ludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFZLkxhbmcuaXNOdW1iZXIocGF0aC54ZGlzdCkpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnhkaXN0ID0gREVGQVVMVFMuRElTVEFOQ0VfTU9WRTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIVkuTGFuZy5pc051bWJlcihwYXRoLnlkaXN0KSkge1xuICAgICAgICAgICAgICAgIHBhdGgueWRpc3QgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIVkuTGFuZy5pc051bWJlcihkdXJhdGlvbikpe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBERUZBVUxUUy5EVVJBVElPTl9NT1ZFOyAvLyBtc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoZHVyYXRpb24gPiBERUZBVUxUUy5NQVhfRFVSQVRJT05fTU9WRSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gREVGQVVMVFMuTUFYX0RVUkFUSU9OX01PVkU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb252ZXJ0ZWRQYXRoID0ge1xuICAgICAgICAgICAgc3RhcnQ6IFkuY2xvbmUocGF0aC5wb2ludCksXG4gICAgICAgICAgICBlbmQ6IFtwYXRoLnBvaW50WzBdK3BhdGgueGRpc3QsIHBhdGgucG9pbnRbMV0rcGF0aC55ZGlzdF1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9tb3ZlKGNiLCBjb252ZXJ0ZWRQYXRoLCBkdXJhdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgYmFzZSBtZXRob2Qgb24gdG9wIG9mIFwibW92ZVwiIGFuZCBcImZsaWNrXCIgbWV0aG9kcy4gVGhlIG1ldGhvZCB0YWtlc1xuICAgICAqIHRoZSBwYXRoIHdpdGggc3RhcnQvZW5kIHByb3BlcnRpZXMgYW5kIGR1cmF0aW9uIHRvIGdlbmVyYXRlIGEgc2V0IG9mXG4gICAgICogdG91Y2ggZXZlbnRzIGZvciB0aGUgbW92ZW1lbnQgZ2VzdHVyZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX21vdmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGdlc3R1cmUgc2ltdWxhdGlvblxuICAgICAqICAgICAgaXMgY29tcGxldGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXRoIEFuIG9iamVjdCB3aXRoIFwic3RhcnRcIiBhbmQgXCJlbmRcIiBwcm9wZXJ0aWVzLiBFYWNoXG4gICAgICogICAgICBwcm9wZXJ0eSBzaG91bGQgYmUgYW4gYXJyYXkgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGlvbiAoZS5nLiBzdGFydDogWzEwMCwgNTBdKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBBIGR1cmF0aW9uIG9mIHRoZSBnZXN0dXJlIGluIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIF9tb3ZlOiBmdW5jdGlvbihjYiwgcGF0aCwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGV2ZW50UXVldWUsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBFVkVOVF9JTlRFUlZBTCxcbiAgICAgICAgICAgIHN0ZXBzLCBzdGVwWCwgc3RlcFksXG4gICAgICAgICAgICBpZCA9IDAsXG4gICAgICAgICAgICB0b3VjaE1vdmU7XG5cbiAgICAgICAgaWYoIVkuTGFuZy5pc051bWJlcihkdXJhdGlvbikpe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBERUZBVUxUUy5EVVJBVElPTl9NT1ZFOyAvLyBtc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoZHVyYXRpb24gPiBERUZBVUxUUy5NQVhfRFVSQVRJT05fTU9WRSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gREVGQVVMVFMuTUFYX0RVUkFUSU9OX01PVkU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZighWS5MYW5nLmlzT2JqZWN0KHBhdGgpKSB7XG4gICAgICAgICAgICBwYXRoID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBbXG4gICAgICAgICAgICAgICAgICAgIFNUQVJUX1BBR0VYLFxuICAgICAgICAgICAgICAgICAgICBTVEFSVF9QQUdFWVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZW5kOiBbXG4gICAgICAgICAgICAgICAgICAgIFNUQVJUX1BBR0VYICsgREVGQVVMVFMuRElTVEFOQ0VfTU9WRSxcbiAgICAgICAgICAgICAgICAgICAgU1RBUlRfUEFHRVlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoIVkuTGFuZy5pc0FycmF5KHBhdGguc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5zdGFydCA9IFtcbiAgICAgICAgICAgICAgICAgICAgU1RBUlRfUEFHRVgsXG4gICAgICAgICAgICAgICAgICAgIFNUQVJUX1BBR0VZXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFZLkxhbmcuaXNBcnJheShwYXRoLmVuZCkpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmVuZCA9IFtcbiAgICAgICAgICAgICAgICAgICAgU1RBUlRfUEFHRVggKyBERUZBVUxUUy5ESVNUQU5DRV9NT1ZFLFxuICAgICAgICAgICAgICAgICAgICBTVEFSVF9QQUdFWVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBZLkFzeW5jUXVldWUuZGVmYXVsdHMudGltZW91dCA9IGludGVydmFsO1xuICAgICAgICBldmVudFF1ZXVlID0gbmV3IFkuQXN5bmNRdWV1ZSgpO1xuXG4gICAgICAgIC8vIHN0YXJ0XG4gICAgICAgIGV2ZW50UXVldWUuYWRkKHtcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGF0aC5zdGFydFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBwYXRoLnN0YXJ0WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogcGF0aC5zdGFydFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHBhdGguc3RhcnRbMV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hlcyA9IHRoaXMuX2NyZWF0ZVRvdWNoTGlzdChbXG4gICAgICAgICAgICAgICAgICAgICAgICBZLm1lcmdlKHtpZGVudGlmaWVyOiAoaWQrKyl9LCBjb29yZClcbiAgICAgICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zaW11bGF0ZUV2ZW50KHRoaXMudGFyZ2V0LCBUT1VDSF9TVEFSVCwgWS5tZXJnZSh7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoZXM6IHRvdWNoZXMsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFRvdWNoZXM6IHRvdWNoZXMsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRUb3VjaGVzOiB0b3VjaGVzXG4gICAgICAgICAgICAgICAgfSwgY29vcmQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lb3V0OiAwLFxuICAgICAgICAgICAgY29udGV4dDogdGhpc1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBtb3ZlXG4gICAgICAgIHN0ZXBzID0gTWF0aC5mbG9vcihkdXJhdGlvbi9pbnRlcnZhbCk7XG4gICAgICAgIHN0ZXBYID0gKHBhdGguZW5kWzBdIC0gcGF0aC5zdGFydFswXSkvc3RlcHM7XG4gICAgICAgIHN0ZXBZID0gKHBhdGguZW5kWzFdIC0gcGF0aC5zdGFydFsxXSkvc3RlcHM7XG5cbiAgICAgICAgdG91Y2hNb3ZlID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgICAgICAgdmFyIHB4ID0gcGF0aC5zdGFydFswXSsoc3RlcFggKiBzdGVwKSxcbiAgICAgICAgICAgICAgICBweSA9IHBhdGguc3RhcnRbMV0rKHN0ZXBZICogc3RlcCksXG4gICAgICAgICAgICAgICAgY29vcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBweCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6IHB5LFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBweCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogcHlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRvdWNoZXMgPSB0aGlzLl9jcmVhdGVUb3VjaExpc3QoW1xuICAgICAgICAgICAgICAgICAgICBZLm1lcmdlKHtpZGVudGlmaWVyOiAoaWQrKyl9LCBjb29yZClcbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgdGhpcy5fc2ltdWxhdGVFdmVudCh0aGlzLnRhcmdldCwgVE9VQ0hfTU9WRSwgWS5tZXJnZSh7XG4gICAgICAgICAgICAgICAgdG91Y2hlczogdG91Y2hlcyxcbiAgICAgICAgICAgICAgICB0YXJnZXRUb3VjaGVzOiB0b3VjaGVzLFxuICAgICAgICAgICAgICAgIGNoYW5nZWRUb3VjaGVzOiB0b3VjaGVzXG4gICAgICAgICAgICB9LCBjb29yZCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaT0wOyBpIDwgc3RlcHM7IGkrKykge1xuICAgICAgICAgICAgZXZlbnRRdWV1ZS5hZGQoe1xuICAgICAgICAgICAgICAgIGZuOiB0b3VjaE1vdmUsXG4gICAgICAgICAgICAgICAgYXJnczogW2ldLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGFzdCBtb3ZlXG4gICAgICAgIGV2ZW50UXVldWUuYWRkKHtcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGF0aC5lbmRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWTogcGF0aC5lbmRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBwYXRoLmVuZFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHBhdGguZW5kWzFdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoZXMgPSB0aGlzLl9jcmVhdGVUb3VjaExpc3QoW1xuICAgICAgICAgICAgICAgICAgICAgICAgWS5tZXJnZSh7aWRlbnRpZmllcjogaWR9LCBjb29yZClcbiAgICAgICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zaW11bGF0ZUV2ZW50KHRoaXMudGFyZ2V0LCBUT1VDSF9NT1ZFLCBZLm1lcmdlKHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hlczogdG91Y2hlcyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VG91Y2hlczogdG91Y2hlcyxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFRvdWNoZXM6IHRvdWNoZXNcbiAgICAgICAgICAgICAgICB9LCBjb29yZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IDAsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGVuZFxuICAgICAgICBldmVudFF1ZXVlLmFkZCh7XG4gICAgICAgICAgICBmbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkID0ge1xuICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGF0aC5lbmRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBwYXRoLmVuZFsxXSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogcGF0aC5lbmRbMF0sXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHBhdGguZW5kWzFdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbXB0eVRvdWNoTGlzdCA9IHRoaXMuX2dldEVtcHR5VG91Y2hMaXN0KCksXG4gICAgICAgICAgICAgICAgdG91Y2hlcyA9IHRoaXMuX2NyZWF0ZVRvdWNoTGlzdChbXG4gICAgICAgICAgICAgICAgICAgIFkubWVyZ2Uoe2lkZW50aWZpZXI6IGlkfSwgY29vcmQpXG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zaW11bGF0ZUV2ZW50KHRoaXMudGFyZ2V0LCBUT1VDSF9FTkQsIFkubWVyZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGVzOiBlbXB0eVRvdWNoTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VG91Y2hlczogZW1wdHlUb3VjaExpc3QsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRUb3VjaGVzOiB0b3VjaGVzXG4gICAgICAgICAgICAgICAgfSwgY29vcmQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKGNiICYmIFkuTGFuZy5pc0Z1bmN0aW9uKGNiKSkge1xuICAgICAgICAgICAgZXZlbnRRdWV1ZS5hZGQoe1xuICAgICAgICAgICAgICAgIGZuOiBjYixcblxuICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQsIHRoZSBjYWxsYmFjayBydW5zIHRoZSBub2RlIGNvbnRleHQgd2hlcmVcbiAgICAgICAgICAgICAgICAvLyBzaW11bGF0ZUdlc3R1cmUgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLm5vZGVcblxuICAgICAgICAgICAgICAgIC8vVE9ETzogVXNlIGFyZ3MgdG8gcGFzcyBlcnJvciBvYmplY3QgYXMgMXN0IHBhcmFtIGlmIHRoZXJlIGlzIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgIC8vYXJnczpcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnRRdWV1ZS5ydW4oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byByZXR1cm4gYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgZW1wdHkgdG91Y2ggbGlzdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2dldEVtcHR5VG91Y2hMaXN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtUb3VjaExpc3QgfCBBcnJheX0gQW4gZW1wdHkgdG91Y2ggbGlzdCBvYmplY3QuXG4gICAgICovXG4gICAgX2dldEVtcHR5VG91Y2hMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoIWVtcHR5VG91Y2hMaXN0KSB7XG4gICAgICAgICAgICBlbXB0eVRvdWNoTGlzdCA9IHRoaXMuX2NyZWF0ZVRvdWNoTGlzdChbXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW1wdHlUb3VjaExpc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gY29udmVydCBhbiBhcnJheSB3aXRoIHRvdWNoIHBvaW50cyB0byBUb3VjaExpc3Qgb2JqZWN0IGFzXG4gICAgICogZGVmaW5lZCBpbiBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVUb3VjaExpc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRvdWNoUG9pbnRzXG4gICAgICogQHJldHVybiB7VG91Y2hMaXN0IHwgQXJyYXl9IElmIHVuZGVybGF5aW5nIHBsYXRmb3JtIHN1cHBvcnQgY3JlYXRpbmcgdG91Y2ggbGlzdFxuICAgICAqICAgICAgYSBUb3VjaExpc3Qgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQgb3RoZXJ3aXNlIGEgZmFrZSBBcnJheSBvYmplY3RcbiAgICAgKiAgICAgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICovXG4gICAgX2NyZWF0ZVRvdWNoTGlzdDogZnVuY3Rpb24odG91Y2hQb2ludHMpIHtcbiAgICAgICAgLypcbiAgICAgICAgKiBBbmRyb2lkIDQuMC4zIGVtdWxhdG9yOlxuICAgICAgICAqIE5hdGl2ZSB0b3VjaCBhcGkgc3VwcG9ydGVkIHN0YXJ0aW5nIGluIHZlcnNpb24gNC4wIChJY2UgQ3JlYW0gU2FuZHdpY2gpLlxuICAgICAgICAqIEhvd2V2ZXIgdGhlIHN1cHBvcnQgc2VlbXMgbGltaXRlZC4gSW4gQW5kcm9pZCA0LjAuMyBlbXVsYXRvciwgSSBnb3RcbiAgICAgICAgKiBcIlRvdWNoTGlzdCBpcyBub3QgZGVmaW5lZFwiLlxuICAgICAgICAqL1xuICAgICAgICB2YXIgdG91Y2hlcyA9IFtdLFxuICAgICAgICAgICAgdG91Y2hMaXN0LFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYoISF0b3VjaFBvaW50cyAmJiBZLkxhbmcuaXNBcnJheSh0b3VjaFBvaW50cykpIHtcbiAgICAgICAgICAgIGlmKFkuVUEuYW5kcm9pZCAmJiBZLlVBLmFuZHJvaWQgPj0gNC4wIHx8IFkuVUEuaW9zICYmIFkuVUEuaW9zID49IDIuMCkge1xuICAgICAgICAgICAgICAgIFkuZWFjaCh0b3VjaFBvaW50cywgZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIXBvaW50LmlkZW50aWZpZXIpIHtwb2ludC5pZGVudGlmaWVyID0gMDt9XG4gICAgICAgICAgICAgICAgICAgIGlmKCFwb2ludC5wYWdlWCkge3BvaW50LnBhZ2VYID0gMDt9XG4gICAgICAgICAgICAgICAgICAgIGlmKCFwb2ludC5wYWdlWSkge3BvaW50LnBhZ2VZID0gMDt9XG4gICAgICAgICAgICAgICAgICAgIGlmKCFwb2ludC5zY3JlZW5YKSB7cG9pbnQuc2NyZWVuWCA9IDA7fVxuICAgICAgICAgICAgICAgICAgICBpZighcG9pbnQuc2NyZWVuWSkge3BvaW50LnNjcmVlblkgPSAwO31cblxuICAgICAgICAgICAgICAgICAgICB0b3VjaGVzLnB1c2goZG9jdW1lbnQuY3JlYXRlVG91Y2goWS5jb25maWcud2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQucGFnZVgsIHBvaW50LnBhZ2VZLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQuc2NyZWVuWCwgcG9pbnQuc2NyZWVuWSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdG91Y2hMaXN0ID0gZG9jdW1lbnQuY3JlYXRlVG91Y2hMaXN0LmFwcGx5KGRvY3VtZW50LCB0b3VjaGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihZLlVBLmlvcyAmJiBZLlVBLmlvcyA8IDIuMCkge1xuICAgICAgICAgICAgICAgIFkuZXJyb3IoTkFNRSsnOiBObyB0b3VjaCBldmVudCBzaW11bGF0aW9uIGZyYW1ld29yayBwcmVzZW50LicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgaW5jbGlkZSBhbmRyb2lkKFkuVUEuYW5kcm9pZCAmJiBZLlVBLmFuZHJvaWQgPCA0LjApXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRlc2t0b3BzIGFtb25nIGFsbCBvdGhlcnMuXG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFRvdWNoIEFQSXMgYXJlIGJyb2tlbiBpbiBhbmRyb2lkcyBvbGRlciB0aGFuIDQuMC4gV2Ugd2lsbCB1c2VcbiAgICAgICAgICAgICAgICAgKiBzaW11bGF0ZWQgdG91Y2ggYXBpcyBmb3IgdGhlc2UgdmVyc2lvbnMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdG91Y2hMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgWS5lYWNoKHRvdWNoUG9pbnRzLCBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBpZighcG9pbnQuaWRlbnRpZmllcikge3BvaW50LmlkZW50aWZpZXIgPSAwO31cbiAgICAgICAgICAgICAgICAgICAgaWYoIXBvaW50LmNsaWVudFgpICB7cG9pbnQuY2xpZW50WCA9IDA7fVxuICAgICAgICAgICAgICAgICAgICBpZighcG9pbnQuY2xpZW50WSkgIHtwb2ludC5jbGllbnRZID0gMDt9XG4gICAgICAgICAgICAgICAgICAgIGlmKCFwb2ludC5wYWdlWCkgICAge3BvaW50LnBhZ2VYID0gMDt9XG4gICAgICAgICAgICAgICAgICAgIGlmKCFwb2ludC5wYWdlWSkgICAge3BvaW50LnBhZ2VZID0gMDt9XG4gICAgICAgICAgICAgICAgICAgIGlmKCFwb2ludC5zY3JlZW5YKSAge3BvaW50LnNjcmVlblggPSAwO31cbiAgICAgICAgICAgICAgICAgICAgaWYoIXBvaW50LnNjcmVlblkpICB7cG9pbnQuc2NyZWVuWSA9IDA7fVxuXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogc2VsZi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBwb2ludC5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogcG9pbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHBvaW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogcG9pbnQucGFnZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWTogcG9pbnQucGFnZVksXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5YOiBwb2ludC5zY3JlZW5YLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuWTogcG9pbnQuc2NyZWVuWVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRvdWNoTGlzdC5pdGVtID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG91Y2hMaXN0W2ldO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBZLmVycm9yKE5BTUUrJzogSW52YWxpZCB0b3VjaFBvaW50cyBwYXNzZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b3VjaExpc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgX3NpbXVsYXRlRXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCBUaGUgRE9NIGVsZW1lbnQgdGhhdCdzIHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IG9yIG5hbWUgb2YgdGhlIHN1cHBvcnRlZCBnZXN0dXJlIHRvIHNpbXVsYXRlXG4gICAgICogICAgICAoaS5lLiwgXCJjbGlja1wiLCBcImRvdWJsZXRhcFwiLCBcImZsaWNrXCIpLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChPcHRpb25hbCkgRXh0cmEgb3B0aW9ucyB0byBjb3B5IG9udG8gdGhlIGV2ZW50IG9iamVjdC5cbiAgICAgKiAgICAgIEZvciBnZXN0dXJlcywgb3B0aW9ucyBhcmUgdXNlZCB0byByZWZpbmUgdGhlIGdlc3R1cmUgYmVoYXZpb3IuXG4gICAgICovXG4gICAgX3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdG91Y2hlcztcblxuICAgICAgICBpZiAodG91Y2hFdmVudHNbdHlwZV0pIHtcbiAgICAgICAgICAgIGlmKFNVUFBPUlRTX1RPVUNIKSB7XG4gICAgICAgICAgICAgICAgWS5FdmVudC5zaW11bGF0ZSh0YXJnZXQsIHR5cGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzaW11bGF0ZSB1c2luZyBtb3VzZSBldmVudHMgaWYgdG91Y2ggaXMgbm90IGFwcGxpY2FibGUgb24gdGhpcyBwbGF0Zm9ybS5cbiAgICAgICAgICAgICAgICAvLyBidXQgb25seSBzaW5nbGUgdG91Y2ggZXZlbnQgY2FuIGJlIHNpbXVsYXRlZC5cbiAgICAgICAgICAgICAgICBpZih0aGlzLl9pc1NpbmdsZVRvdWNoKG9wdGlvbnMudG91Y2hlcywgb3B0aW9ucy50YXJnZXRUb3VjaGVzLCBvcHRpb25zLmNoYW5nZWRUb3VjaGVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hzdGFydDogTU9VU0VfRE9XTixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNobW92ZTogTU9VU0VfTU9WRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoZW5kOiBNT1VTRV9VUFxuICAgICAgICAgICAgICAgICAgICB9W3R5cGVdO1xuXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYnV0dG9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZWxhdGVkVGFyZ2V0ID0gbnVsbDsgLy8gc2luY2Ugd2UgYXJlIG5vdCB1c2luZyBtb3VzZW92ZXIgZXZlbnQuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdG91Y2hlbmQgaGFzIG5vbmUgaW4gb3B0aW9ucy50b3VjaGVzLlxuICAgICAgICAgICAgICAgICAgICB0b3VjaGVzID0gKHR5cGUgPT09IE1PVVNFX1VQKT8gb3B0aW9ucy5jaGFuZ2VkVG91Y2hlcyA6IG9wdGlvbnMudG91Y2hlcztcblxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gWS5taXgob3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuWDogdG91Y2hlcy5pdGVtKDApLnNjcmVlblgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5ZOiB0b3VjaGVzLml0ZW0oMCkuc2NyZWVuWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IHRvdWNoZXMuaXRlbSgwKS5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogdG91Y2hlcy5pdGVtKDApLmNsaWVudFlcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgWS5FdmVudC5zaW11bGF0ZSh0YXJnZXQsIHR5cGUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGUgPT0gTU9VU0VfVVApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFkuRXZlbnQuc2ltdWxhdGUodGFyZ2V0LCBNT1VTRV9DTElDSywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBZLmVycm9yKFwiX3NpbXVsYXRlRXZlbnQoKTogRXZlbnQgJ1wiICsgdHlwZSArIFwiJyBoYXMgbXVsdGkgdG91Y2ggb2JqZWN0cyB0aGF0IGNhbid0IGJlIHNpbXVsYXRlZCBpbiB5b3VyIHBsYXRmb3JtLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIHRocnUgZm9yIGFsbCBub24gdG91Y2ggZXZlbnRzXG4gICAgICAgICAgICBZLkV2ZW50LnNpbXVsYXRlKHRhcmdldCwgdHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjaGVjayB0aGUgc2luZ2xlIHRvdWNoLlxuICAgICAqIEBtZXRob2QgX2lzU2luZ2xlVG91Y2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7VG91Y2hMaXN0fSB0b3VjaGVzXG4gICAgICogQHBhcmFtIHtUb3VjaExpc3R9IHRhcmdldFRvdWNoZXNcbiAgICAgKiBAcGFyYW0ge1RvdWNoTGlzdH0gY2hhbmdlZFRvdWNoZXNcbiAgICAgKi9cbiAgICBfaXNTaW5nbGVUb3VjaDogZnVuY3Rpb24odG91Y2hlcywgdGFyZ2V0VG91Y2hlcywgY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgcmV0dXJuICh0b3VjaGVzICYmICh0b3VjaGVzLmxlbmd0aCA8PSAxKSkgJiZcbiAgICAgICAgICAgICh0YXJnZXRUb3VjaGVzICYmICh0YXJnZXRUb3VjaGVzLmxlbmd0aCA8PSAxKSkgJiZcbiAgICAgICAgICAgIChjaGFuZ2VkVG91Y2hlcyAmJiAoY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDw9IDEpKTtcbiAgICB9XG59O1xuXG4vKlxuICogQSBnZXN0dXJlIHNpbXVsYXRpb24gY2xhc3MuXG4gKi9cblkuR2VzdHVyZVNpbXVsYXRpb24gPSBTaW11bGF0aW9ucztcblxuLypcbiAqIFZhcmlvdXMgc2ltdWxhdGlvbiBkZWZhdWx0IGJlaGF2aW9yIHByb3BlcnRpZXMuIElmIHVzZXIgb3ZlcnJpZGVcbiAqIFkuR2VzdHVyZVNpbXVsYXRpb24uZGVmYXVsdHMsIG92ZXJyaWRlbiB2YWx1ZXMgd2lsbCBiZSB1c2VkIGFuZCB0aGlzXG4gKiBzaG91bGQgYmUgZG9uZSBiZWZvcmUgdGhlIGdlc3R1cmUgc2ltdWxhdGlvbi5cbiAqL1xuWS5HZXN0dXJlU2ltdWxhdGlvbi5kZWZhdWx0cyA9IERFRkFVTFRTO1xuXG4vKlxuICogVGhlIGhpZ2ggbGV2ZWwgZ2VzdHVyZSBuYW1lcyB0aGF0IFlVSSBrbm93cyBob3cgdG8gc2ltdWxhdGUuXG4gKi9cblkuR2VzdHVyZVNpbXVsYXRpb24uR0VTVFVSRVMgPSBnZXN0dXJlTmFtZXM7XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSBoaWdoZXIgdXNlciBsZXZlbCBnZXN0dXJlIG9mIHRoZSBnaXZlbiBuYW1lIG9uIGEgdGFyZ2V0LlxuICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGEgc2V0IG9mIGxvdyBsZXZlbCB0b3VjaCBldmVudHMoQXBwbGUgc3BlY2lmaWMgZ2VzdHVyZVxuICogZXZlbnRzIGFzIHdlbGwgZm9yIHRoZSBpT1MgcGxhdGZvcm1zKSBhc3luY2hyb25vdXNseS4gTm90ZSB0aGF0IGdlc3R1cmVcbiAqIHNpbXVsYXRpb24gaXMgcmVseWluZyBvbiBgWS5FdmVudC5zaW11bGF0ZSgpYCBtZXRob2QgdG8gZ2VuZXJhdGVcbiAqIHRoZSB0b3VjaCBldmVudHMgdW5kZXIgdGhlIGhvb2QuIFRoZSBgWS5FdmVudC5zaW11bGF0ZSgpYCBtZXRob2RcbiAqIGl0c2VsZiBpcyBhIHN5bmNocm9ub3VzIG1ldGhvZC5cbiAqXG4gKiBVc2VycyBhcmUgc3VnZ2VzdGVkIHRvIHVzZSBgTm9kZS5zaW11bGF0ZUdlc3R1cmUoKWAgbWV0aG9kIHdoaWNoXG4gKiBiYXNpY2FsbHkgY2FsbHMgdGhpcyBtZXRob2QgaW50ZXJuYWxseS4gU3VwcG9ydGVkIGdlc3R1cmVzIGFyZSBgdGFwYCxcbiAqIGBkb3VibGV0YXBgLCBgcHJlc3NgLCBgbW92ZWAsIGBmbGlja2AsIGBwaW5jaGAgYW5kIGByb3RhdGVgLlxuICpcbiAqIFRoZSBgcGluY2hgIGdlc3R1cmUgaXMgdXNlZCB0byBzaW11bGF0ZSB0aGUgcGluY2hpbmcgYW5kIHNwcmVhZGluZyBvZiB0d29cbiAqIGZpbmdlcnMuIER1cmluZyBhIHBpbmNoIHNpbXVsYXRpb24sIHJvdGF0aW9uIGlzIGFsc28gcG9zc2libGUuIEVzc2VudGlhbGx5XG4gKiBgcGluY2hgIGFuZCBgcm90YXRlYCBzaW11bGF0aW9ucyBzaGFyZSB0aGUgc2FtZSBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGFsbG93XG4gKiBib3RoIHBpbmNoaW5nIGFuZCByb3RhdGlvbiBhdCB0aGUgc2FtZSB0aW1lLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIGBwaW5jaGBcbiAqIHJlcXVpcmVzIGBzdGFydGAgYW5kIGBlbmRgIG9wdGlvbiBwcm9wZXJ0aWVzIHdoaWxlIGByb3RhdGVgIHJlcXVpcmVzIGByb3RhdGlvbmBcbiAqIG9wdGlvbiBwcm9wZXJ0eS5cbiAqXG4gKiBUaGUgYHBpbmNoYCBhbmQgYHJvdGF0ZWAgZ2VzdHVyZXMgY2FuIGJlIGRlc2NyaWJlZCBhcyBwbGFjaW5nIDIgZmluZ2VycyBhbG9uZyBhXG4gKiBjaXJjbGUuIFBpbmNoaW5nIGFuZCBzcHJlYWRpbmcgY2FuIGJlIGRlc2NyaWJlZCBieSBzdGFydCBhbmQgZW5kIGNpcmNsZXMgd2hpbGVcbiAqIHJvdGF0aW9uIG9jY3VycyBvbiBhIHNpbmdsZSBjaXJjbGUuIElmIHRoZSByYWRpdXMgb2YgdGhlIHN0YXJ0IGNpcmNsZSBpcyBncmVhdGVyXG4gKiB0aGFuIHRoZSBlbmQgY2lyY2xlLCB0aGUgZ2VzdHVyZSBiZWNvbWVzIGEgcGluY2gsIG90aGVyd2lzZSBpdCBpcyBhIHNwcmVhZCBzcHJlYWQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIG5vZGUgPSBZLm9uZShcIiN0YXJnZXRcIik7XG4gKlxuICogICAgIC8vIGRvdWJsZSB0YXAgZXhhbXBsZVxuICogICAgIG5vZGUuc2ltdWxhdGVHZXN0dXJlKFwiZG91YmxldGFwXCIsIGZ1bmN0aW9uKCkge1xuICogICAgICAgICAvLyBteSBjYWxsYmFjayBmdW5jdGlvblxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBmbGljayBleGFtcGxlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgbm9kZSwgbW92ZSA1MCBwaXhlbHMgZG93biBmb3IgNTBtcylcbiAqICAgICBub2RlLnNpbXVsYXRlR2VzdHVyZShcImZsaWNrXCIsIHtcbiAqICAgICAgICAgYXhpczogeSxcbiAqICAgICAgICAgZGlzdGFuY2U6IC0xMDBcbiAqICAgICAgICAgZHVyYXRpb246IDUwXG4gKiAgICAgfSwgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIC8vIG15IGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIHNpbXVsYXRlIHJvdGF0aW5nIGEgbm9kZSA3NSBkZWdyZWVzIGNvdW50ZXItY2xvY2t3aXNlXG4gKiAgICAgbm9kZS5zaW11bGF0ZUdlc3R1cmUoXCJyb3RhdGVcIiwge1xuICogICAgICAgICByb3RhdGlvbjogLTc1XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIHNpbXVsYXRlIGEgcGluY2ggYW5kIGEgcm90YXRpb24gYXQgdGhlIHNhbWUgdGltZS5cbiAqICAgICAvLyBmaW5nZXJzIHN0YXJ0IG9uIGEgY2lyY2xlIG9mIHJhZGl1cyAxMDAgcHgsIHBsYWNlZCBhdCB0b3AvYm90dG9tXG4gKiAgICAgLy8gZmluZ2VycyBlbmQgb24gYSBjaXJjbGUgb2YgcmFkaXVzIDUwcHgsIHBsYWNlZCBhdCByaWdodC9sZWZ0XG4gKiAgICAgbm9kZS5zaW11bGF0ZUdlc3R1cmUoXCJwaW5jaFwiLCB7XG4gKiAgICAgICAgIHIxOiAxMDAsXG4gKiAgICAgICAgIHIyOiA1MCxcbiAqICAgICAgICAgc3RhcnQ6IDBcbiAqICAgICAgICAgcm90YXRpb246IDkwXG4gKiAgICAgfSk7XG4gKlxuICogQG1ldGhvZCBzaW11bGF0ZUdlc3R1cmVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8Tm9kZX0gbm9kZSBUaGUgWVVJIG5vZGUgb3IgSFRNTCBlbGVtZW50IHRoYXQncyB0aGUgdGFyZ2V0XG4gKiAgICAgIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzdXBwb3J0ZWQgZ2VzdHVyZSB0byBzaW11bGF0ZS4gVGhlXG4gKiAgICAgIHN1cHBvcnRlZCBnZXN0dXJlIG5hbWUgaXMgb25lIG9mIFwidGFwXCIsIFwiZG91YmxldGFwXCIsIFwicHJlc3NcIiwgXCJtb3ZlXCIsXG4gKiAgICAgIFwiZmxpY2tcIiwgXCJwaW5jaFwiIGFuZCBcInJvdGF0ZVwiLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBFeHRyYSBvcHRpb25zIHVzZWQgdG8gZGVmaW5lIHRoZSBnZXN0dXJlIGJlaGF2aW9yOlxuICpcbiAqICAgICAgVmFsaWQgb3B0aW9ucyBwcm9wZXJ0aWVzIGZvciB0aGUgYHRhcGAgZ2VzdHVyZTpcbiAqXG4gKiAgICAgIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBvaW50XSAoT3B0aW9uYWwpIEluZGljYXRlcyB0aGUgW3gseV0gY29vcmRpbmF0ZXNcbiAqICAgICAgICB3aGVyZSB0aGUgdGFwIHNob3VsZCBiZSBzaW11bGF0ZWQuIERlZmF1bHQgaXMgdGhlIGNlbnRlciBvZiB0aGUgbm9kZVxuICogICAgICAgIGVsZW1lbnQuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ob2xkPTEwXSAoT3B0aW9uYWwpIFRoZSBob2xkIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgIFRoaXMgaXMgdGhlIHRpbWUgYmV0d2VlbiBgdG91Y2hzdGFydGAgYW5kIGB0b3VjaGVuZGAgZXZlbnQgZ2VuZXJhdGlvbi5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbWVzPTFdIChPcHRpb25hbCkgSW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgdGFwcy5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbGF5PTEwXSAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gKiAgICAgICAgYmVmb3JlIHRoZSBuZXh0IHRhcCBzaW11bGF0aW9uIGhhcHBlbnMuIFRoaXMgaXMgdmFsaWQgb25seSB3aGVuIGB0aW1lc2BcbiAqICAgICAgICBpcyBtb3JlIHRoYW4gMS5cbiAqXG4gKiAgICAgIFZhbGlkIG9wdGlvbnMgcHJvcGVydGllcyBmb3IgdGhlIGBkb3VibGV0YXBgIGdlc3R1cmU6XG4gKlxuICogICAgICBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5wb2ludF0gKE9wdGlvbmFsKSBJbmRpY2F0ZXMgdGhlIFt4LHldIGNvb3JkaW5hdGVzXG4gKiAgICAgICAgd2hlcmUgdGhlIGRvdWJsZXRhcCBzaG91bGQgYmUgc2ltdWxhdGVkLiBEZWZhdWx0IGlzIHRoZSBjZW50ZXIgb2YgdGhlXG4gKiAgICAgICAgbm9kZSBlbGVtZW50LlxuICpcbiAqICAgICAgVmFsaWQgb3B0aW9ucyBwcm9wZXJ0aWVzIGZvciB0aGUgYHByZXNzYCBnZXN0dXJlOlxuICpcbiAqICAgICAgQHBhcmFtIHtBcnJheX0gW29wdGlvbnMucG9pbnRdIChPcHRpb25hbCkgSW5kaWNhdGVzIHRoZSBbeCx5XSBjb29yZGluYXRlc1xuICogICAgICAgIHdoZXJlIHRoZSBwcmVzcyBzaG91bGQgYmUgc2ltdWxhdGVkLiBEZWZhdWx0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIG5vZGVcbiAqICAgICAgICBlbGVtZW50LlxuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaG9sZD0zMDAwXSAoT3B0aW9uYWwpIFRoZSBob2xkIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgIFRoaXMgaXMgdGhlIHRpbWUgYmV0d2VlbiBgdG91Y2hzdGFydGAgYW5kIGB0b3VjaGVuZGAgZXZlbnQgZ2VuZXJhdGlvbi5cbiAqICAgICAgICBEZWZhdWx0IGlzIDMwMDBtcyAoMyBzZWNvbmRzKS5cbiAqXG4gKiAgICAgIFZhbGlkIG9wdGlvbnMgcHJvcGVydGllcyBmb3IgdGhlIGBtb3ZlYCBnZXN0dXJlOlxuICpcbiAqICAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBhdGhdIChPcHRpb25hbCkgSW5kaWNhdGVzIHRoZSBwYXRoIG9mIHRoZSBmaW5nZXJcbiAqICAgICAgICBtb3ZlbWVudC4gSXQncyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBvcHRpb25hbCBwcm9wZXJ0aWVzOiBgcG9pbnRgLFxuICogICAgICAgIGB4ZGlzdGAgYW5kICBgeWRpc3RgLlxuICogICAgICAgIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBhdGgucG9pbnRdIEEgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGdlc3R1cmUuXG4gKiAgICAgICAgICBEZWZhdWx0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIG5vZGUgZWxlbWVudC5cbiAqICAgICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGF0aC54ZGlzdD0yMDBdIEEgZGlzdGFuY2UgdG8gbW92ZSBpbiBwaXhlbHNcbiAqICAgICAgICAgIGFsb25nIHRoZSBYIGF4aXMuIEEgbmVnYXRpdmUgZGlzdGFuY2UgdmFsdWUgaW5kaWNhdGVzIG1vdmluZyBsZWZ0LlxuICogICAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYXRoLnlkaXN0PTBdIEEgZGlzdGFuY2UgdG8gbW92ZSBpbiBwaXhlbHNcbiAqICAgICAgICAgIGFsb25nIHRoZSBZIGF4aXMuIEEgbmVnYXRpdmUgZGlzdGFuY2UgdmFsdWUgaW5kaWNhdGVzIG1vdmluZyB1cC5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTEwMDBdIChPcHRpb25hbCkgVGhlIGR1cmF0aW9uIG9mIHRoZVxuICogICAgICAgIGdlc3R1cmUgaW4gbWlsbGlzZWNvbmRzLlxuICpcbiAqICAgICAgVmFsaWQgb3B0aW9ucyBwcm9wZXJ0aWVzIGZvciB0aGUgYGZsaWNrYCBnZXN0dXJlOlxuICpcbiAqICAgICAgQHBhcmFtIHtBcnJheX0gW29wdGlvbnMucG9pbnRdIChPcHRpb25hbCkgSW5kaWNhdGVzIHRoZSBbeCwgeV0gY29vcmRpbmF0ZXNcbiAqICAgICAgICB3aGVyZSB0aGUgZmxpY2sgc2hvdWxkIGJlIHNpbXVsYXRlZC4gRGVmYXVsdCBpcyB0aGUgY2VudGVyIG9mIHRoZVxuICogICAgICAgIG5vZGUgZWxlbWVudC5cbiAqICAgICAgQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmF4aXM9J3gnXSAoT3B0aW9uYWwpIFZhbGlkIHZhbHVlcyBhcmUgZWl0aGVyXG4gKiAgICAgICAgXCJ4XCIgb3IgXCJ5XCIuIEluZGljYXRlcyBheGlzIHRvIG1vdmUgYWxvbmcuIFRoZSBmbGljayBjYW4gbW92ZSB0byBvbmUgb2ZcbiAqICAgICAgICA0IGRpcmVjdGlvbnMobGVmdCwgcmlnaHQsIHVwIGFuZCBkb3duKS5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlPTIwMF0gKE9wdGlvbmFsKSBEaXN0YW5jZSB0byBtb3ZlIGluIHBpeGVsc1xuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb249MTAwMF0gKE9wdGlvbmFsKSBUaGUgZHVyYXRpb24gb2YgdGhlXG4gKiAgICAgICAgZ2VzdHVyZSBpbiBtaWxsaXNlY29uZHMuIFVzZXIgZ2l2ZW4gdmFsdWUgY291bGQgYmUgYXV0b21hdGljYWxseVxuICogICAgICAgIGFkanVzdGVkIGJ5IHRoZSBmcmFtZXdvcmsgaWYgaXQgaXMgYmVsb3cgdGhlIG1pbmltdW0gdmVsb2NpdHkgdG8gYmVcbiAqICAgICAgICBhIGZsaWNrIGdlc3R1cmUuXG4gKlxuICogICAgICBWYWxpZCBvcHRpb25zIHByb3BlcnRpZXMgZm9yIHRoZSBgcGluY2hgIGdlc3R1cmU6XG4gKlxuICogICAgICBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jZW50ZXJdIChPcHRpb25hbCkgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIHdoZXJlXG4gKiAgICAgICAgdHdvIGZpbmdlcnMgYXJlIHBsYWNlZC4gRGVmYXVsdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBub2RlIGVsZW1lbnQuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yMV0gKFJlcXVpcmVkKSBQaXhlbCByYWRpdXMgb2YgdGhlIHN0YXJ0IGNpcmNsZVxuICogICAgICAgIHdoZXJlIDIgZmluZ2VycyB3aWxsIGJlIG9uIHdoZW4gdGhlIGdlc3R1cmUgc3RhcnRzLiBUaGUgY2lyY2xlcyBhcmVcbiAqICAgICAgICBjZW50ZXJlZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50LlxuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucjJdIChSZXF1aXJlZCkgUGl4ZWwgcmFkaXVzIG9mIHRoZSBlbmQgY2lyY2xlXG4gKiAgICAgICAgd2hlbiB0aGlzIGdlc3R1cmUgZW5kcy5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTEwMDBdIChPcHRpb25hbCkgVGhlIGR1cmF0aW9uIG9mIHRoZVxuICogICAgICAgIGdlc3R1cmUgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhcnQ9MF0gKE9wdGlvbmFsKSBTdGFydGluZyBkZWdyZWUgb2YgdGhlIGZpcnN0XG4gKiAgICAgICAgZmluZ2VyLiBUaGUgdmFsdWUgaXMgcmVsYXRpdmUgdG8gdGhlIHBhdGggb2YgdGhlIG5vcnRoLiBEZWZhdWx0IGlzIDBcbiAqICAgICAgICAoaS5lLiwgMTI6MDAgb24gYSBjbG9jaykuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yb3RhdGlvbj0wXSAoT3B0aW9uYWwpIERlZ3JlZXMgdG8gcm90YXRlIGZyb21cbiAqICAgICAgICB0aGUgc3RhcnRpbmcgZGVncmVlLiBBIG5lZ2F0aXZlIHZhbHVlIG1lYW5zIHJvdGF0aW9uIHRvIHRoZVxuICogICAgICAgIGNvdW50ZXItY2xvY2t3aXNlIGRpcmVjdGlvbi5cbiAqXG4gKiAgICAgIFZhbGlkIG9wdGlvbnMgcHJvcGVydGllcyBmb3IgdGhlIGByb3RhdGVgIGdlc3R1cmU6XG4gKlxuICogICAgICBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jZW50ZXJdIChPcHRpb25hbCkgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIHdoZXJlXG4gKiAgICAgICAgdHdvIGZpbmdlcnMgYXJlIHBsYWNlZC4gRGVmYXVsdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBub2RlIGVsZW1lbnQuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yMV0gKE9wdGlvbmFsKSBQaXhlbCByYWRpdXMgb2YgdGhlIHN0YXJ0IGNpcmNsZVxuICogICAgICAgIHdoZXJlIDIgZmluZ2VycyB3aWxsIGJlIG9uIHdoZW4gdGhlIGdlc3R1cmUgc3RhcnRzLiBUaGUgY2lyY2xlcyBhcmVcbiAqICAgICAgICBjZW50ZXJlZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50LiBEZWZhdWx0IGlzIGEgZm91cnRoIG9mIHRoZSBub2RlXG4gKiAgICAgICAgZWxlbWVudCB3aWR0aCBvciBoZWlnaHQsIHdoaWNoZXZlciBpcyBzbWFsbGVyLlxuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucjJdIChPcHRpb25hbCkgUGl4ZWwgcmFkaXVzIG9mIHRoZSBlbmQgY2lyY2xlXG4gKiAgICAgICAgd2hlbiB0aGlzIGdlc3R1cmUgZW5kcy4gRGVmYXVsdCBpcyBhIGZvdXJ0aCBvZiB0aGUgbm9kZSBlbGVtZW50IHdpZHRoIG9yXG4gKiAgICAgICAgaGVpZ2h0LCB3aGljaGV2ZXIgaXMgc21hbGxlci5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTEwMDBdIChPcHRpb25hbCkgVGhlIGR1cmF0aW9uIG9mIHRoZVxuICogICAgICAgIGdlc3R1cmUgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhcnQ9MF0gKE9wdGlvbmFsKSBTdGFydGluZyBkZWdyZWUgb2YgdGhlIGZpcnN0XG4gKiAgICAgICAgZmluZ2VyLiBUaGUgdmFsdWUgaXMgcmVsYXRpdmUgdG8gdGhlIHBhdGggb2YgdGhlIG5vcnRoLiBEZWZhdWx0IGlzIDBcbiAqICAgICAgICAoaS5lLiwgMTI6MDAgb24gYSBjbG9jaykuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yb3RhdGlvbl0gKFJlcXVpcmVkKSBEZWdyZWVzIHRvIHJvdGF0ZSBmcm9tXG4gKiAgICAgICAgdGhlIHN0YXJ0aW5nIGRlZ3JlZS4gQSBuZWdhdGl2ZSB2YWx1ZSBtZWFucyByb3RhdGlvbiB0byB0aGVcbiAqICAgICAgICBjb3VudGVyLWNsb2Nrd2lzZSBkaXJlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBhc3luY2hyb25vdXNlIGdlc3R1cmVcbiAqICAgICAgc2ltdWxhdGlvbiBpcyBjb21wbGV0ZWQuXG4gKiAgICAgIEBwYXJhbSB7RXJyb3J9IGNiLmVyciBBbiBlcnJvciBvYmplY3QgaWYgdGhlIHNpbXVsYXRpb24gaXMgZmFpbGVkLlxuICogQGZvciBFdmVudFxuICogQHN0YXRpY1xuICovXG5ZLkV2ZW50LnNpbXVsYXRlR2VzdHVyZSA9IGZ1bmN0aW9uKG5vZGUsIG5hbWUsIG9wdGlvbnMsIGNiKSB7XG5cbiAgICBub2RlID0gWS5vbmUobm9kZSk7XG5cbiAgICB2YXIgc2ltID0gbmV3IFkuR2VzdHVyZVNpbXVsYXRpb24obm9kZSk7XG4gICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmKCFjYiAmJiBZLkxhbmcuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChnZXN0dXJlTmFtZXNbbmFtZV0pIHtcbiAgICAgICAgc3dpdGNoKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIHNpbmdsZS10b3VjaDogcG9pbnQgZ2VzdHVyZXNcbiAgICAgICAgICAgIGNhc2UgJ3RhcCc6XG4gICAgICAgICAgICAgICAgc2ltLnRhcChjYiwgb3B0aW9ucy5wb2ludCwgb3B0aW9ucy50aW1lcywgb3B0aW9ucy5ob2xkLCBvcHRpb25zLmRlbGF5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZXRhcCc6XG4gICAgICAgICAgICAgICAgc2ltLnRhcChjYiwgb3B0aW9ucy5wb2ludCwgMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwcmVzcyc6XG4gICAgICAgICAgICAgICAgaWYoIVkuTGFuZy5pc051bWJlcihvcHRpb25zLmhvbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaG9sZCA9IERFRkFVTFRTLkhPTERfUFJFU1M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKG9wdGlvbnMuaG9sZCA8IERFRkFVTFRTLk1JTl9IT0xEX1BSRVNTKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaG9sZCA9IERFRkFVTFRTLk1JTl9IT0xEX1BSRVNTO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihvcHRpb25zLmhvbGQgPiBERUZBVUxUUy5NQVhfSE9MRF9QUkVTUykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhvbGQgPSBERUZBVUxUUy5NQVhfSE9MRF9QUkVTUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2ltLnRhcChjYiwgb3B0aW9ucy5wb2ludCwgMSwgb3B0aW9ucy5ob2xkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gc2luZ2xlLXRvdWNoOiBtb3ZlIGdlc3R1cmVzXG4gICAgICAgICAgICBjYXNlICdtb3ZlJzpcbiAgICAgICAgICAgICAgICBzaW0ubW92ZShjYiwgb3B0aW9ucy5wYXRoLCBvcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZsaWNrJzpcbiAgICAgICAgICAgICAgICBzaW0uZmxpY2soY2IsIG9wdGlvbnMucG9pbnQsIG9wdGlvbnMuYXhpcywgb3B0aW9ucy5kaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIG11bHRpLXRvdWNoOiBwaW5jaC9yb3RhdGlvbiBnZXN0dXJlc1xuICAgICAgICAgICAgY2FzZSAncGluY2gnOlxuICAgICAgICAgICAgICAgIHNpbS5waW5jaChjYiwgb3B0aW9ucy5jZW50ZXIsIG9wdGlvbnMucjEsIG9wdGlvbnMucjIsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMucm90YXRpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgICAgICBzaW0ucm90YXRlKGNiLCBvcHRpb25zLmNlbnRlciwgb3B0aW9ucy5yMSwgb3B0aW9ucy5yMixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiwgb3B0aW9ucy5zdGFydCwgb3B0aW9ucy5yb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBZLmVycm9yKE5BTUUrJzogTm90IGEgc3VwcG9ydGVkIGdlc3R1cmUgc2ltdWxhdGlvbjogJytuYW1lKTtcbiAgICB9XG59O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJhc3luYy1xdWV1ZVwiLCBcImV2ZW50LXNpbXVsYXRlXCIsIFwibm9kZS1zY3JlZW5cIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnaGlzdG9yeS1iYXNlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBQcm92aWRlcyBicm93c2VyIGhpc3RvcnkgbWFuYWdlbWVudCBmdW5jdGlvbmFsaXR5IHVzaW5nIGEgc2ltcGxlXG4gKiBhZGQvcmVwbGFjZS9nZXQgcGFyYWRpZ20uIFRoaXMgY2FuIGJlIHVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGJyb3dzZXIncyBiYWNrXG4gKiBhbmQgZm9yd2FyZCBidXR0b25zIHdvcmsgYXMgdGhlIHVzZXIgZXhwZWN0cyBhbmQgdG8gcHJvdmlkZSBib29rbWFya2FibGUgVVJMc1xuICogdGhhdCByZXR1cm4gdGhlIHVzZXIgdG8gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24gc3RhdGUsIGV2ZW4gaW4gYW4gQWpheFxuICogYXBwbGljYXRpb24gdGhhdCBkb2Vzbid0IHBlcmZvcm0gZnVsbC1wYWdlIHJlZnJlc2hlcy5cbiAqXG4gKiBAbW9kdWxlIGhpc3RvcnlcbiAqIEBtYWluIGhpc3RvcnlcbiAqIEBzaW5jZSAzLjIuMFxuICovXG5cbi8qKlxuICogUHJvdmlkZXMgZ2xvYmFsIHN0YXRlIG1hbmFnZW1lbnQgYmFja2VkIGJ5IGFuIG9iamVjdCwgYnV0IHdpdGggbm8gYnJvd3NlclxuICogaGlzdG9yeSBpbnRlZ3JhdGlvbi4gRm9yIGFjdHVhbCBicm93c2VyIGhpc3RvcnkgaW50ZWdyYXRpb24gYW5kIGJhY2svZm9yd2FyZFxuICogc3VwcG9ydCwgdXNlIHRoZSBoaXN0b3J5LWh0bWw1IG9yIGhpc3RvcnktaGFzaCBtb2R1bGVzLlxuICpcbiAqIEBtb2R1bGUgaGlzdG9yeVxuICogQHN1Ym1vZHVsZSBoaXN0b3J5LWJhc2VcbiAqIEBjbGFzcyBIaXN0b3J5QmFzZVxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAob3B0aW9uYWwpIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCB3aGljaCBtYXkgY29udGFpblxuICogICB6ZXJvIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIDxkbD5cbiAqICAgPGR0PmZvcmNlIChCb29sZWFuKTwvZHQ+XG4gKiAgIDxkZD5cbiAqICAgICBJZiBgdHJ1ZWAsIGEgYGhpc3Rvcnk6Y2hhbmdlYCBldmVudCB3aWxsIGJlIGZpcmVkIHdoZW5ldmVyIHRoZSBVUkxcbiAqICAgICBjaGFuZ2VzLCBldmVuIGlmIHRoZXJlIGlzIG5vIGFzc29jaWF0ZWQgc3RhdGUgY2hhbmdlLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gKiAgIDwvZGQ+XG4gKlxuICogICA8ZHQ+aW5pdGlhbFN0YXRlIChPYmplY3QpPC9kdD5cbiAqICAgPGRkPlxuICogICAgIEluaXRpYWwgc3RhdGUgdG8gc2V0LCBhcyBhbiBvYmplY3QgaGFzaCBvZiBrZXkvdmFsdWUgcGFpcnMuIFRoaXMgd2lsbCBiZVxuICogICAgIG1lcmdlZCBpbnRvIHRoZSBjdXJyZW50IGdsb2JhbCBzdGF0ZS5cbiAqICAgPC9kZD5cbiAqIDwvZGw+XG4gKi9cblxudmFyIExhbmcgICAgICA9IFkuTGFuZyxcbiAgICBPYmogICAgICAgPSBZLk9iamVjdCxcbiAgICBHbG9iYWxFbnYgPSBZVUkubmFtZXNwYWNlKCdFbnYuSGlzdG9yeScpLFxuICAgIFlBcnJheSAgICA9IFkuQXJyYXksXG5cbiAgICBkb2MgICAgICAgPSBZLmNvbmZpZy5kb2MsXG4gICAgZG9jTW9kZSAgID0gZG9jLmRvY3VtZW50TW9kZSxcbiAgICB3aW4gICAgICAgPSBZLmNvbmZpZy53aW4sXG5cbiAgICBERUZBVUxUX09QVElPTlMgPSB7bWVyZ2U6IHRydWV9LFxuICAgIEVWVF9DSEFOR0UgICAgICA9ICdjaGFuZ2UnLFxuICAgIFNSQ19BREQgICAgICAgICA9ICdhZGQnLFxuICAgIFNSQ19SRVBMQUNFICAgICA9ICdyZXBsYWNlJztcblxuZnVuY3Rpb24gSGlzdG9yeUJhc2UoKSB7XG4gICAgdGhpcy5faW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5ZLmF1Z21lbnQoSGlzdG9yeUJhc2UsIFkuRXZlbnRUYXJnZXQsIG51bGwsIG51bGwsIHtcbiAgICBlbWl0RmFjYWRlIDogdHJ1ZSxcbiAgICBwcmVmaXggICAgIDogJ2hpc3RvcnknLFxuICAgIHByZXZlbnRhYmxlOiBmYWxzZSxcbiAgICBxdWV1ZWFibGUgIDogdHJ1ZVxufSk7XG5cbmlmICghR2xvYmFsRW52Ll9zdGF0ZSkge1xuICAgIEdsb2JhbEVudi5fc3RhdGUgPSB7fTtcbn1cblxuLy8gLS0gUHJpdmF0ZSBNZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBSZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIDxpPnZhbHVlPC9pPiBpcyBhIHNpbXBsZSBvYmplY3QgYW5kIG5vdCBhXG4gKiBmdW5jdGlvbiBvciBhbiBhcnJheS5cbiAqXG4gKiBAbWV0aG9kIF9pc1NpbXBsZU9iamVjdFxuICogQHBhcmFtIHttaXhlZH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNTaW1wbGVPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gTGFuZy50eXBlKHZhbHVlKSA9PT0gJ29iamVjdCc7XG59XG5cbi8vIC0tIFB1YmxpYyBTdGF0aWMgUHJvcGVydGllcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogTmFtZSBvZiB0aGlzIGNvbXBvbmVudC5cbiAqXG4gKiBAcHJvcGVydHkgTkFNRVxuICogQHR5cGUgU3RyaW5nXG4gKiBAc3RhdGljXG4gKi9cbkhpc3RvcnlCYXNlLk5BTUUgPSAnaGlzdG9yeUJhc2UnO1xuXG4vKipcbiAqIENvbnN0YW50IHVzZWQgdG8gaWRlbnRpZnkgc3RhdGUgY2hhbmdlcyBvcmlnaW5hdGluZyBmcm9tIHRoZVxuICogPGNvZGU+YWRkKCk8L2NvZGU+IG1ldGhvZC5cbiAqXG4gKiBAcHJvcGVydHkgU1JDX0FERFxuICogQHR5cGUgU3RyaW5nXG4gKiBAc3RhdGljXG4gKiBAZmluYWxcbiAqL1xuSGlzdG9yeUJhc2UuU1JDX0FERCA9IFNSQ19BREQ7XG5cbi8qKlxuICogQ29uc3RhbnQgdXNlZCB0byBpZGVudGlmeSBzdGF0ZSBjaGFuZ2VzIG9yaWdpbmF0aW5nIGZyb20gdGhlXG4gKiA8Y29kZT5yZXBsYWNlKCk8L2NvZGU+IG1ldGhvZC5cbiAqXG4gKiBAcHJvcGVydHkgU1JDX1JFUExBQ0VcbiAqIEB0eXBlIFN0cmluZ1xuICogQHN0YXRpY1xuICogQGZpbmFsXG4gKi9cbkhpc3RvcnlCYXNlLlNSQ19SRVBMQUNFID0gU1JDX1JFUExBQ0U7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBIVE1MNSBIaXN0b3J5IEFQSS5cbiAqXG4gKiBAcHJvcGVydHkgaHRtbDVcbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBzdGF0aWNcbiAqL1xuXG4vLyBBbGwgSFRNTDUtY2FwYWJsZSBicm93c2VycyBleGNlcHQgR2Vja28gMisgKEZpcmVmb3ggNCspIGNvcnJlY3RseSByZXR1cm5cbi8vIHRydWUgZm9yICdvbnBvcHN0YXRlJyBpbiB3aW4uIEluIG9yZGVyIHRvIHN1cHBvcnQgR2Vja28gMiwgd2UgZmFsbCBiYWNrIHRvIGFcbi8vIFVBIHNuaWZmIGZvciBub3cuIChjdXJyZW50IGFzIG9mIEZpcmVmb3ggNC4wYjIpXG5IaXN0b3J5QmFzZS5odG1sNSA9ICEhKHdpbi5oaXN0b3J5ICYmIHdpbi5oaXN0b3J5LnB1c2hTdGF0ZSAmJlxuICAgICAgICB3aW4uaGlzdG9yeS5yZXBsYWNlU3RhdGUgJiYgKCdvbnBvcHN0YXRlJyBpbiB3aW4gfHwgWS5VQS5nZWNrbyA+PSAyKSAmJlxuICAgICAgICAoIVkuVUEuYW5kcm9pZCB8fCBZLlVBLmFuZHJvaWQgPj0gMi40KSk7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSA8Y29kZT53aW5kb3cub25oYXNoY2hhbmdlPC9jb2RlPlxuICogZXZlbnQgbmF0aXZlbHkuIE5vdGUgdGhhdCBldmVuIGlmIHRoaXMgaXMgPGNvZGU+dHJ1ZTwvY29kZT4sIHlvdSBtYXlcbiAqIHN0aWxsIHdhbnQgdG8gdXNlIEhpc3RvcnlIYXNoJ3Mgc3ludGhldGljIDxjb2RlPmhhc2hjaGFuZ2U8L2NvZGU+IGV2ZW50XG4gKiBzaW5jZSBpdCBub3JtYWxpemVzIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzIGFuZCBmaXhlcyBzcGVjIHZpb2xhdGlvbnNcbiAqIGFjcm9zcyB2YXJpb3VzIGJyb3dzZXJzLlxuICpcbiAqIEBwcm9wZXJ0eSBuYXRpdmVIYXNoQ2hhbmdlXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAc3RhdGljXG4gKi9cblxuLy8gTW9zdCBicm93c2VycyB0aGF0IHN1cHBvcnQgaGFzaGNoYW5nZSBleHBvc2UgaXQgb24gdGhlIHdpbmRvdy4gT3BlcmEgMTAuNitcbi8vIGV4cG9zZXMgaXQgb24gdGhlIGRvY3VtZW50IChidXQgeW91IGNhbiBzdGlsbCBhdHRhY2ggdG8gaXQgb24gdGhlIHdpbmRvdykuXG4vL1xuLy8gSUU4IHN1cHBvcnRzIHRoZSBoYXNoY2hhbmdlIGV2ZW50LCBidXQgb25seSBpbiBJRTggU3RhbmRhcmRzXG4vLyBNb2RlLiBIb3dldmVyLCBJRTggaW4gSUU3IGNvbXBhdGliaWxpdHkgbW9kZSBzdGlsbCBkZWZpbmVzIHRoZVxuLy8gZXZlbnQgYnV0IG5ldmVyIGZpcmVzIGl0LCBzbyB3ZSBjYW4ndCBqdXN0IGRldGVjdCB0aGUgZXZlbnQuIFdlIGFsc28gY2FuJ3Rcbi8vIGp1c3QgVUEgc25pZmYgZm9yIElFOCwgc2luY2Ugb3RoZXIgYnJvd3NlcnMgc3VwcG9ydCB0aGlzIGV2ZW50IGFzIHdlbGwuXG5IaXN0b3J5QmFzZS5uYXRpdmVIYXNoQ2hhbmdlID0gKCdvbmhhc2hjaGFuZ2UnIGluIHdpbiB8fCAnb25oYXNoY2hhbmdlJyBpbiBkb2MpICYmXG4gICAgICAgICghZG9jTW9kZSB8fCBkb2NNb2RlID4gNyk7XG5cblkubWl4KEhpc3RvcnlCYXNlLnByb3RvdHlwZSwge1xuICAgIC8vIC0tIEluaXRpYWxpemF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoaXMgSGlzdG9yeUJhc2UgaW5zdGFuY2UuIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGVcbiAgICAgKiBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2luaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbml0aWFsU3RhdGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IHByb3ZpZGVkIGJ5IHRoZSB1c2VyIG9uIGluc3RhbnRpYXRpb24sIG9yIGFuXG4gICAgICAgICAqIGVtcHR5IG9iamVjdCBpZiBvbmUgd2Fzbid0IHByb3ZpZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2NvbmZpZ1xuICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICogQGRlZmF1bHQge31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAsIGEgYGhpc3Rvcnk6Y2hhbmdlYCBldmVudCB3aWxsIGJlIGZpcmVkIHdoZW5ldmVyIHRoZSBVUkxcbiAgICAgICAgICogY2hhbmdlcywgZXZlbiBpZiB0aGVyZSBpcyBubyBhc3NvY2lhdGVkIHN0YXRlIGNoYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGZvcmNlXG4gICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgICB0aGlzLmZvcmNlID0gISFjb25maWcuZm9yY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmVkIGluaXRpYWwgc3RhdGU6IGEgbWVyZ2Ugb2YgdGhlIHVzZXItc3VwcGxpZWQgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgKiAoaWYgYW55KSBhbmQgYW55IGluaXRpYWwgc3RhdGUgcHJvdmlkZWQgYnkgYSBzdWJjbGFzcy4gVGhpcyBtYXlcbiAgICAgICAgICogZGlmZmVyIGZyb20gPGNvZGU+X2NvbmZpZy5pbml0aWFsU3RhdGU8L2NvZGU+LiBJZiBuZWl0aGVyIHRoZSBjb25maWdcbiAgICAgICAgICogbm9yIGEgc3ViY2xhc3Mgc3VwcGxpZXMgYW4gaW5pdGlhbCBzdGF0ZSwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlXG4gICAgICAgICAqIDxjb2RlPm51bGw8L2NvZGU+LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2luaXRpYWxTdGF0ZVxuICAgICAgICAgKiBAdHlwZSBPYmplY3R8bnVsbFxuICAgICAgICAgKiBAZGVmYXVsdCB7fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsU3RhdGUgPSB0aGlzLl9pbml0aWFsU3RhdGUgPSB0aGlzLl9pbml0aWFsU3RhdGUgfHxcbiAgICAgICAgICAgICAgICBjb25maWcuaW5pdGlhbFN0YXRlIHx8IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhlIHN0YXRlIGNoYW5nZXMuIFRvIGJlIG5vdGlmaWVkIG9mIGFsbCBzdGF0ZSBjaGFuZ2VzXG4gICAgICAgICAqIHJlZ2FyZGxlc3Mgb2YgdGhlIEhpc3Rvcnkgb3IgWVVJIGluc3RhbmNlIHRoYXQgZ2VuZXJhdGVkIHRoZW0sXG4gICAgICAgICAqIHN1YnNjcmliZSB0byB0aGlzIGV2ZW50IG9uIDxjb2RlPlkuR2xvYmFsPC9jb2RlPi4gSWYgeW91IHdvdWxkIHJhdGhlclxuICAgICAgICAgKiBiZSBub3RpZmllZCBvbmx5IGFib3V0IGNoYW5nZXMgZ2VuZXJhdGVkIGJ5IHRoaXMgc3BlY2lmaWMgSGlzdG9yeVxuICAgICAgICAgKiBpbnN0YW5jZSwgc3Vic2NyaWJlIHRvIHRoaXMgZXZlbnQgb24gdGhlIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgaGlzdG9yeTpjaGFuZ2VcbiAgICAgICAgICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZSBFdmVudCBmYWNhZGUgd2l0aCB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWxcbiAgICAgICAgICogICBwcm9wZXJ0aWVzOlxuICAgICAgICAgKlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgPGR0PmNoYW5nZWQgKE9iamVjdCk8L2R0PlxuICAgICAgICAgKiAgIDxkZD5cbiAgICAgICAgICogICAgIE9iamVjdCBoYXNoIG9mIHN0YXRlIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIG9yIGNoYW5nZWQuIFRoZVxuICAgICAgICAgKiAgICAga2V5IGlzIHRoZSBpdGVtIGtleSwgYW5kIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgY29udGFpbmluZ1xuICAgICAgICAgKiAgICAgPGNvZGU+bmV3VmFsPC9jb2RlPiBhbmQgPGNvZGU+cHJldlZhbDwvY29kZT4gcHJvcGVydGllc1xuICAgICAgICAgKiAgICAgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZXMgb2YgdGhlIGl0ZW0gYm90aCBiZWZvcmUgYW5kIGFmdGVyIHRoZVxuICAgICAgICAgKiAgICAgY2hhbmdlLiBJZiB0aGUgaXRlbSB3YXMgbmV3bHkgYWRkZWQsIDxjb2RlPnByZXZWYWw8L2NvZGU+IHdpbGwgYmVcbiAgICAgICAgICogICAgIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4uXG4gICAgICAgICAqICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICA8ZHQ+bmV3VmFsIChPYmplY3QpPC9kdD5cbiAgICAgICAgICogICA8ZGQ+XG4gICAgICAgICAqICAgICBPYmplY3QgaGFzaCBvZiBrZXkvdmFsdWUgcGFpcnMgb2YgYWxsIHN0YXRlIGl0ZW1zIGFmdGVyIHRoZVxuICAgICAgICAgKiAgICAgY2hhbmdlLlxuICAgICAgICAgKiAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgPGR0PnByZXZWYWwgKE9iamVjdCk8L2R0PlxuICAgICAgICAgKiAgIDxkZD5cbiAgICAgICAgICogICAgIE9iamVjdCBoYXNoIG9mIGtleS92YWx1ZSBwYWlycyBvZiBhbGwgc3RhdGUgaXRlbXMgYmVmb3JlIHRoZVxuICAgICAgICAgKiAgICAgY2hhbmdlLlxuICAgICAgICAgKiAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgPGR0PnJlbW92ZWQgKE9iamVjdCk8L2R0PlxuICAgICAgICAgKiAgIDxkZD5cbiAgICAgICAgICogICAgIE9iamVjdCBoYXNoIG9mIGtleS92YWx1ZSBwYWlycyBvZiBzdGF0ZSBpdGVtcyB0aGF0IGhhdmUgYmVlblxuICAgICAgICAgKiAgICAgcmVtb3ZlZC4gVmFsdWVzIGFyZSB0aGUgb2xkIHZhbHVlcyBwcmlvciB0byByZW1vdmFsLlxuICAgICAgICAgKiAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgPGR0PnNyYyAoU3RyaW5nKTwvZHQ+XG4gICAgICAgICAqICAgPGRkPlxuICAgICAgICAgKiAgICAgVGhlIHNvdXJjZSBvZiB0aGUgZXZlbnQuIFRoaXMgY2FuIGJlIHVzZWQgdG8gc2VsZWN0aXZlbHkgaWdub3JlXG4gICAgICAgICAqICAgICBldmVudHMgZ2VuZXJhdGVkIGJ5IGNlcnRhaW4gc291cmNlcy5cbiAgICAgICAgICogICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wdWJsaXNoKEVWVF9DSEFOR0UsIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdDogMixcbiAgICAgICAgICAgIGRlZmF1bHRGbjogdGhpcy5fZGVmQ2hhbmdlRm5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgaW5pdGlhbFN0YXRlIHdhcyBwcm92aWRlZCwgbWVyZ2UgaXQgaW50byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gLS0gUHVibGljIE1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0YXRlIGVudHJ5IHdpdGggbmV3IHZhbHVlcyBmb3IgdGhlIHNwZWNpZmllZCBrZXlzLiBCeSBkZWZhdWx0LFxuICAgICAqIHRoZSBuZXcgc3RhdGUgd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgZXhpc3Rpbmcgc3RhdGUsIGFuZCBuZXcgdmFsdWVzIHdpbGxcbiAgICAgKiBvdmVycmlkZSBleGlzdGluZyB2YWx1ZXMuIFNwZWNpZnlpbmcgYSA8Y29kZT5udWxsPC9jb2RlPiBvclxuICAgICAqIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4gdmFsdWUgd2lsbCBjYXVzZSB0aGF0IGtleSB0byBiZSByZW1vdmVkIGZyb20gdGhlXG4gICAgICogbmV3IHN0YXRlIGVudHJ5LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgT2JqZWN0IGhhc2ggb2Yga2V5L3ZhbHVlIHBhaXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChvcHRpb25hbCkgWmVybyBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcbiAgICAgKiAgIDxkbD5cbiAgICAgKiAgICAgPGR0Pm1lcmdlIChCb29sZWFuKTwvZHQ+XG4gICAgICogICAgIDxkZD5cbiAgICAgKiAgICAgICA8cD5cbiAgICAgKiAgICAgICBJZiA8Y29kZT50cnVlPC9jb2RlPiAodGhlIGRlZmF1bHQpLCB0aGUgbmV3IHN0YXRlIHdpbGwgYmUgbWVyZ2VkXG4gICAgICogICAgICAgaW50byB0aGUgZXhpc3Rpbmcgc3RhdGUuIE5ldyB2YWx1ZXMgd2lsbCBvdmVycmlkZSBleGlzdGluZyB2YWx1ZXMsXG4gICAgICogICAgICAgYW5kIDxjb2RlPm51bGw8L2NvZGU+IG9yIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4gdmFsdWVzIHdpbGwgYmVcbiAgICAgKiAgICAgICByZW1vdmVkIGZyb20gdGhlIHN0YXRlLlxuICAgICAqICAgICAgIDwvcD5cbiAgICAgKlxuICAgICAqICAgICAgIDxwPlxuICAgICAqICAgICAgIElmIDxjb2RlPmZhbHNlPC9jb2RlPiwgdGhlIGV4aXN0aW5nIHN0YXRlIHdpbGwgYmUgZGlzY2FyZGVkIGFzIGFcbiAgICAgKiAgICAgICB3aG9sZSBhbmQgdGhlIG5ldyBzdGF0ZSB3aWxsIHRha2UgaXRzIHBsYWNlLlxuICAgICAqICAgICAgIDwvcD5cbiAgICAgKiAgICAgPC9kZD5cbiAgICAgKiAgIDwvZGw+XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFlBcnJheShhcmd1bWVudHMsIDAsIHRydWUpO1xuICAgICAgICBhcmdzLnVuc2hpZnQoU1JDX0FERCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdGF0ZSBlbnRyeSB3aXRoIGEgbmV3IHZhbHVlIGZvciBhIHNpbmdsZSBrZXkuIEJ5IGRlZmF1bHQsIHRoZSBuZXdcbiAgICAgKiB2YWx1ZSB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoZSBleGlzdGluZyBzdGF0ZSB2YWx1ZXMsIGFuZCB3aWxsIG92ZXJyaWRlIGFuXG4gICAgICogZXhpc3RpbmcgdmFsdWUgd2l0aCB0aGUgc2FtZSBrZXkgaWYgdGhlcmUgaXMgb25lLiBTcGVjaWZ5aW5nIGFcbiAgICAgKiA8Y29kZT5udWxsPC9jb2RlPiBvciA8Y29kZT51bmRlZmluZWQ8L2NvZGU+IHZhbHVlIHdpbGwgY2F1c2UgdGhlIGtleSB0b1xuICAgICAqIGJlIHJlbW92ZWQgZnJvbSB0aGUgbmV3IHN0YXRlIGVudHJ5LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgU3RhdGUgcGFyYW1ldGVyIGtleS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgTmV3IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChvcHRpb25hbCkgWmVybyBvciBtb3JlIG9wdGlvbnMuIFNlZVxuICAgICAqICAgPGNvZGU+YWRkKCk8L2NvZGU+IGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIG9wdGlvbnMuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZFZhbHVlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgc3RhdGUgPSB7fTtcbiAgICAgICAgc3RhdGVba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlKFNSQ19BREQsIHN0YXRlLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc3RhdGUgcGFyYW1ldGVyIHNwZWNpZmllZCBieSA8aT5rZXk8L2k+LFxuICAgICAqIG9yIGFuIG9iamVjdCBoYXNoIG9mIGtleS92YWx1ZSBwYWlycyBmb3IgYWxsIGN1cnJlbnQgc3RhdGUgcGFyYW1ldGVycyBpZlxuICAgICAqIG5vIGtleSBpcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgKG9wdGlvbmFsKSBTdGF0ZSBwYXJhbWV0ZXIga2V5LlxuICAgICAqIEByZXR1cm4ge09iamVjdHxTdHJpbmd9IFZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgc3RhdGUgcGFyYW1ldGVyLCBvciBhblxuICAgICAqICAgb2JqZWN0IGhhc2ggb2Yga2V5L3ZhbHVlIHBhaXJzIGZvciBhbGwgY3VycmVudCBzdGF0ZSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgc3RhdGUgICAgPSBHbG9iYWxFbnYuX3N0YXRlLFxuICAgICAgICAgICAgaXNPYmplY3QgPSBfaXNTaW1wbGVPYmplY3Qoc3RhdGUpO1xuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpc09iamVjdCAmJiBPYmoub3ducyhzdGF0ZSwga2V5KSA/IHN0YXRlW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QgPyBZLm1peCh7fSwgc3RhdGUsIHRydWUpIDogc3RhdGU7IC8vIG1peCBwcm92aWRlcyBhIGZhc3Qgc2hhbGxvdyBjbG9uZS5cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIDxjb2RlPmFkZCgpPC9jb2RlPiBleGNlcHQgdGhhdCBhIG5ldyBicm93c2VyIGhpc3RvcnkgZW50cnkgd2lsbFxuICAgICAqIG5vdCBiZSBjcmVhdGVkLiBJbnN0ZWFkLCB0aGUgY3VycmVudCBoaXN0b3J5IGVudHJ5IHdpbGwgYmUgcmVwbGFjZWQgd2l0aFxuICAgICAqIHRoZSBuZXcgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlcGxhY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgT2JqZWN0IGhhc2ggb2Yga2V5L3ZhbHVlIHBhaXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChvcHRpb25hbCkgWmVybyBvciBtb3JlIG9wdGlvbnMuIFNlZVxuICAgICAqICAgPGNvZGU+YWRkKCk8L2NvZGU+IGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIG9wdGlvbnMuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlcGxhY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBZQXJyYXkoYXJndW1lbnRzLCAwLCB0cnVlKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KFNSQ19SRVBMQUNFKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyA8Y29kZT5hZGRWYWx1ZSgpPC9jb2RlPiBleGNlcHQgdGhhdCBhIG5ldyBicm93c2VyIGhpc3RvcnkgZW50cnlcbiAgICAgKiB3aWxsIG5vdCBiZSBjcmVhdGVkLiBJbnN0ZWFkLCB0aGUgY3VycmVudCBoaXN0b3J5IGVudHJ5IHdpbGwgYmUgcmVwbGFjZWRcbiAgICAgKiB3aXRoIHRoZSBuZXcgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlcGxhY2VWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgU3RhdGUgcGFyYW1ldGVyIGtleS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgTmV3IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChvcHRpb25hbCkgWmVybyBvciBtb3JlIG9wdGlvbnMuIFNlZVxuICAgICAqICAgPGNvZGU+YWRkKCk8L2NvZGU+IGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIG9wdGlvbnMuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlcGxhY2VWYWx1ZTogZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge307XG4gICAgICAgIHN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZShTUkNfUkVQTEFDRSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyAtLSBQcm90ZWN0ZWQgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzdGF0ZS4gVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBjb21tb24gaW1wbGVtZW50YXRpb24gc2hhcmVkIGJ5XG4gICAgICogdGhlIHB1YmxpYyBtZXRob2RzIGZvciBjaGFuZ2luZyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2NoYW5nZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgU291cmNlIG9mIHRoZSBjaGFuZ2UsIGZvciBpbmNsdXNpb24gaW4gZXZlbnQgZmFjYWRlc1xuICAgICAqICAgdG8gZmFjaWxpdGF0ZSBmaWx0ZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIE9iamVjdCBoYXNoIG9mIGtleS92YWx1ZSBwYWlycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAob3B0aW9uYWwpIFplcm8gb3IgbW9yZSBvcHRpb25zLiBTZWVcbiAgICAgKiAgIDxjb2RlPmFkZCgpPC9jb2RlPiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCBvcHRpb25zLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX2NoYW5nZTogZnVuY3Rpb24gKHNyYywgc3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBZLm1lcmdlKERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucykgOiBERUZBVUxUX09QVElPTlM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubWVyZ2UgJiYgX2lzU2ltcGxlT2JqZWN0KHN0YXRlKSAmJlxuICAgICAgICAgICAgICAgIF9pc1NpbXBsZU9iamVjdChHbG9iYWxFbnYuX3N0YXRlKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBZLm1lcmdlKEdsb2JhbEVudi5fc3RhdGUsIHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Jlc29sdmVDaGFuZ2VzKHNyYywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IF9yZXNvbHZlQ2hhbmdlcygpIHdoZW4gdGhlIHN0YXRlIGhhcyBjaGFuZ2VkLiBUaGlzIG1ldGhvZCB0YWtlc1xuICAgICAqIGNhcmUgb2YgYWN0dWFsbHkgZmlyaW5nIHRoZSBuZWNlc3NhcnkgZXZlbnRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZmlyZUV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgU291cmNlIG9mIHRoZSBjaGFuZ2VzLCBmb3IgaW5jbHVzaW9uIGluIGV2ZW50IGZhY2FkZXNcbiAgICAgKiAgIHRvIGZhY2lsaXRhdGUgZmlsdGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VzIFJlc29sdmVkIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgWmVybyBvciBtb3JlIG9wdGlvbnMuIFNlZSA8Y29kZT5hZGQoKTwvY29kZT4gZm9yXG4gICAgICogICBhIGxpc3Qgb2Ygc3VwcG9ydGVkIG9wdGlvbnMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9maXJlRXZlbnRzOiBmdW5jdGlvbiAoc3JjLCBjaGFuZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIEZpcmUgdGhlIGdsb2JhbCBjaGFuZ2UgZXZlbnQuXG4gICAgICAgIHRoaXMuZmlyZShFVlRfQ0hBTkdFLCB7XG4gICAgICAgICAgICBfb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGNoYW5nZWQgOiBjaGFuZ2VzLmNoYW5nZWQsXG4gICAgICAgICAgICBuZXdWYWwgIDogY2hhbmdlcy5uZXdTdGF0ZSxcbiAgICAgICAgICAgIHByZXZWYWwgOiBjaGFuZ2VzLnByZXZTdGF0ZSxcbiAgICAgICAgICAgIHJlbW92ZWQgOiBjaGFuZ2VzLnJlbW92ZWQsXG4gICAgICAgICAgICBzcmMgICAgIDogc3JjXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpcmUgY2hhbmdlL3JlbW92ZSBldmVudHMgZm9yIGluZGl2aWR1YWwgaXRlbXMuXG4gICAgICAgIE9iai5lYWNoKGNoYW5nZXMuY2hhbmdlZCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudChzcmMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBPYmouZWFjaChjaGFuZ2VzLnJlbW92ZWQsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlUmVtb3ZlRXZlbnQoc3JjLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIGEgZHluYW1pYyBcIltrZXldQ2hhbmdlXCIgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9maXJlQ2hhbmdlRXZlbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIHNvdXJjZSBvZiB0aGUgY2hhbmdlLCBmb3IgaW5jbHVzaW9uIGluIGV2ZW50IGZhY2FkZXNcbiAgICAgKiAgIHRvIGZhY2lsaXRhdGUgZmlsdGVyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBrZXkgb2YgdGhlIGl0ZW0gdGhhdCB3YXMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBvYmplY3QgaGFzaCBjb250YWluaW5nIDxpPm5ld1ZhbDwvaT4gYW5kXG4gICAgICogICA8aT5wcmV2VmFsPC9pPiBwcm9wZXJ0aWVzIGZvciB0aGUgY2hhbmdlZCBpdGVtXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9maXJlQ2hhbmdlRXZlbnQ6IGZ1bmN0aW9uIChzcmMsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBEeW5hbWljIGV2ZW50IGZpcmVkIHdoZW4gYW4gaW5kaXZpZHVhbCBoaXN0b3J5IGl0ZW0gaXMgYWRkZWQgb3JcbiAgICAgICAgICogY2hhbmdlZC4gVGhlIG5hbWUgb2YgdGhpcyBldmVudCBkZXBlbmRzIG9uIHRoZSBuYW1lIG9mIHRoZSBrZXkgdGhhdFxuICAgICAgICAgKiBjaGFuZ2VkLiBUbyBsaXN0ZW4gdG8gY2hhbmdlIGV2ZW50cyBmb3IgYSBrZXkgbmFtZWQgXCJmb29cIiwgc3Vic2NyaWJlXG4gICAgICAgICAqIHRvIHRoZSA8Y29kZT5mb29DaGFuZ2U8L2NvZGU+IGV2ZW50OyBmb3IgYSBrZXkgbmFtZWQgXCJiYXJcIiwgc3Vic2NyaWJlXG4gICAgICAgICAqIHRvIDxjb2RlPmJhckNoYW5nZTwvY29kZT4sIGV0Yy5cbiAgICAgICAgICogPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogS2V5LXNwZWNpZmljIGV2ZW50cyBhcmUgb25seSBmaXJlZCBmb3IgaW5zdGFuY2UtbGV2ZWwgY2hhbmdlczsgdGhhdFxuICAgICAgICAgKiBpcywgY2hhbmdlcyB0aGF0IHdlcmUgbWFkZSB2aWEgdGhlIHNhbWUgSGlzdG9yeSBpbnN0YW5jZSBvbiB3aGljaCB0aGVcbiAgICAgICAgICogZXZlbnQgaXMgc3Vic2NyaWJlZC4gVG8gYmUgbm90aWZpZWQgb2YgY2hhbmdlcyBtYWRlIGJ5IG90aGVyIEhpc3RvcnlcbiAgICAgICAgICogaW5zdGFuY2VzLCBzdWJzY3JpYmUgdG8gdGhlIGdsb2JhbCA8Y29kZT5oaXN0b3J5OmNoYW5nZTwvY29kZT4gZXZlbnQuXG4gICAgICAgICAqIDwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFtrZXldQ2hhbmdlXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGUgRXZlbnQgZmFjYWRlIHdpdGggdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsXG4gICAgICAgICAqICAgcHJvcGVydGllczpcbiAgICAgICAgICpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgIDxkdD5uZXdWYWwgKG1peGVkKTwvZHQ+XG4gICAgICAgICAqICAgPGRkPlxuICAgICAgICAgKiAgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgaXRlbSBhZnRlciB0aGUgY2hhbmdlLlxuICAgICAgICAgKiAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgPGR0PnByZXZWYWwgKG1peGVkKTwvZHQ+XG4gICAgICAgICAqICAgPGRkPlxuICAgICAgICAgKiAgICAgVGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBpdGVtIGJlZm9yZSB0aGUgY2hhbmdlLCBvclxuICAgICAgICAgKiAgICAgPGNvZGU+dW5kZWZpbmVkPC9jb2RlPiBpZiB0aGUgaXRlbSB3YXMganVzdCBhZGRlZCBhbmQgaGFzIG5vXG4gICAgICAgICAqICAgICBwcmV2aW91cyB2YWx1ZS5cbiAgICAgICAgICogICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIDxkdD5zcmMgKFN0cmluZyk8L2R0PlxuICAgICAgICAgKiAgIDxkZD5cbiAgICAgICAgICogICAgIFRoZSBzb3VyY2Ugb2YgdGhlIGV2ZW50LiBUaGlzIGNhbiBiZSB1c2VkIHRvIHNlbGVjdGl2ZWx5IGlnbm9yZVxuICAgICAgICAgKiAgICAgZXZlbnRzIGdlbmVyYXRlZCBieSBjZXJ0YWluIHNvdXJjZXMuXG4gICAgICAgICAqICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlyZShrZXkgKyAnQ2hhbmdlJywge1xuICAgICAgICAgICAgbmV3VmFsIDogdmFsdWUubmV3VmFsLFxuICAgICAgICAgICAgcHJldlZhbDogdmFsdWUucHJldlZhbCxcbiAgICAgICAgICAgIHNyYyAgICA6IHNyY1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgYSBkeW5hbWljIFwiW2tleV1SZW1vdmVcIiBldmVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2ZpcmVSZW1vdmVFdmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgc291cmNlIG9mIHRoZSBjaGFuZ2UsIGZvciBpbmNsdXNpb24gaW4gZXZlbnQgZmFjYWRlc1xuICAgICAqICAgdG8gZmFjaWxpdGF0ZSBmaWx0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IGtleSBvZiB0aGUgaXRlbSB0aGF0IHdhcyByZW1vdmVkXG4gICAgICogQHBhcmFtIHttaXhlZH0gdmFsdWUgdmFsdWUgb2YgdGhlIGl0ZW0gcHJpb3IgdG8gaXRzIHJlbW92YWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2ZpcmVSZW1vdmVFdmVudDogZnVuY3Rpb24gKHNyYywga2V5LCB2YWx1ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIER5bmFtaWMgZXZlbnQgZmlyZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGhpc3RvcnkgaXRlbSBpcyByZW1vdmVkLiBUaGVcbiAgICAgICAgICogbmFtZSBvZiB0aGlzIGV2ZW50IGRlcGVuZHMgb24gdGhlIG5hbWUgb2YgdGhlIGtleSB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAgICAgKiBUbyBsaXN0ZW4gdG8gcmVtb3ZlIGV2ZW50cyBmb3IgYSBrZXkgbmFtZWQgXCJmb29cIiwgc3Vic2NyaWJlIHRvIHRoZVxuICAgICAgICAgKiA8Y29kZT5mb29SZW1vdmU8L2NvZGU+IGV2ZW50OyBmb3IgYSBrZXkgbmFtZWQgXCJiYXJcIiwgc3Vic2NyaWJlIHRvXG4gICAgICAgICAqIDxjb2RlPmJhclJlbW92ZTwvY29kZT4sIGV0Yy5cbiAgICAgICAgICogPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogS2V5LXNwZWNpZmljIGV2ZW50cyBhcmUgb25seSBmaXJlZCBmb3IgaW5zdGFuY2UtbGV2ZWwgY2hhbmdlczsgdGhhdFxuICAgICAgICAgKiBpcywgY2hhbmdlcyB0aGF0IHdlcmUgbWFkZSB2aWEgdGhlIHNhbWUgSGlzdG9yeSBpbnN0YW5jZSBvbiB3aGljaCB0aGVcbiAgICAgICAgICogZXZlbnQgaXMgc3Vic2NyaWJlZC4gVG8gYmUgbm90aWZpZWQgb2YgY2hhbmdlcyBtYWRlIGJ5IG90aGVyIEhpc3RvcnlcbiAgICAgICAgICogaW5zdGFuY2VzLCBzdWJzY3JpYmUgdG8gdGhlIGdsb2JhbCA8Y29kZT5oaXN0b3J5OmNoYW5nZTwvY29kZT4gZXZlbnQuXG4gICAgICAgICAqIDwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFtrZXldUmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGUgRXZlbnQgZmFjYWRlIHdpdGggdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsXG4gICAgICAgICAqICAgcHJvcGVydGllczpcbiAgICAgICAgICpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgIDxkdD5wcmV2VmFsIChtaXhlZCk8L2R0PlxuICAgICAgICAgKiAgIDxkZD5cbiAgICAgICAgICogICAgIFRoZSB2YWx1ZSBvZiB0aGUgaXRlbSBiZWZvcmUgaXQgd2FzIHJlbW92ZWQuXG4gICAgICAgICAqICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICA8ZHQ+c3JjIChTdHJpbmcpPC9kdD5cbiAgICAgICAgICogICA8ZGQ+XG4gICAgICAgICAqICAgICBUaGUgc291cmNlIG9mIHRoZSBldmVudC4gVGhpcyBjYW4gYmUgdXNlZCB0byBzZWxlY3RpdmVseSBpZ25vcmVcbiAgICAgICAgICogICAgIGV2ZW50cyBnZW5lcmF0ZWQgYnkgY2VydGFpbiBzb3VyY2VzLlxuICAgICAgICAgKiAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoa2V5ICsgJ1JlbW92ZScsIHtcbiAgICAgICAgICAgIHByZXZWYWw6IHZhbHVlLFxuICAgICAgICAgICAgc3JjICAgIDogc3JjXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgY2hhbmdlcyAoaWYgYW55KSBiZXR3ZWVuIDxpPm5ld1N0YXRlPC9pPiBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBzdGF0ZSBhbmQgZmlyZXMgYXBwcm9wcmlhdGUgZXZlbnRzIGlmIHRoaW5ncyBoYXZlIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9yZXNvbHZlQ2hhbmdlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgc291cmNlIG9mIHRoZSBjaGFuZ2VzLCBmb3IgaW5jbHVzaW9uIGluIGV2ZW50IGZhY2FkZXNcbiAgICAgKiAgIHRvIGZhY2lsaXRhdGUgZmlsdGVyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1N0YXRlIG9iamVjdCBoYXNoIG9mIGtleS92YWx1ZSBwYWlycyByZXByZXNlbnRpbmcgdGhlXG4gICAgICogICBuZXcgc3RhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBaZXJvIG9yIG1vcmUgb3B0aW9ucy4gU2VlIDxjb2RlPmFkZCgpPC9jb2RlPiBmb3JcbiAgICAgKiAgIGEgbGlzdCBvZiBzdXBwb3J0ZWQgb3B0aW9ucy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Jlc29sdmVDaGFuZ2VzOiBmdW5jdGlvbiAoc3JjLCBuZXdTdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2hhbmdlZCAgID0ge30sXG4gICAgICAgICAgICBpc0NoYW5nZWQsXG4gICAgICAgICAgICBwcmV2U3RhdGUgPSBHbG9iYWxFbnYuX3N0YXRlLFxuICAgICAgICAgICAgcmVtb3ZlZCAgID0ge307XG5cbiAgICAgICAgbmV3U3RhdGUgfHwgKG5ld1N0YXRlID0ge30pO1xuICAgICAgICBvcHRpb25zICB8fCAob3B0aW9ucyAgPSB7fSk7XG5cbiAgICAgICAgaWYgKF9pc1NpbXBsZU9iamVjdChuZXdTdGF0ZSkgJiYgX2lzU2ltcGxlT2JqZWN0KHByZXZTdGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCB3YXMgYWRkZWQgb3IgY2hhbmdlZC5cbiAgICAgICAgICAgIE9iai5lYWNoKG5ld1N0YXRlLCBmdW5jdGlvbiAobmV3VmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlZhbCA9IHByZXZTdGF0ZVtrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbCAhPT0gcHJldlZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWwgOiBuZXdWYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2VmFsOiBwcmV2VmFsXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGF0IHdhcyByZW1vdmVkLlxuICAgICAgICAgICAgT2JqLmVhY2gocHJldlN0YXRlLCBmdW5jdGlvbiAocHJldlZhbCwga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmoub3ducyhuZXdTdGF0ZSwga2V5KSB8fCBuZXdTdGF0ZVtrZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkW2tleV0gPSBwcmV2VmFsO1xuICAgICAgICAgICAgICAgICAgICBpc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNDaGFuZ2VkID0gbmV3U3RhdGUgIT09IHByZXZTdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NoYW5nZWQgfHwgdGhpcy5mb3JjZSkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50cyhzcmMsIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkICA6IGNoYW5nZWQsXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgOiBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICBwcmV2U3RhdGU6IHByZXZTdGF0ZSxcbiAgICAgICAgICAgICAgICByZW1vdmVkICA6IHJlbW92ZWRcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgc3BlY2lmaWVkIHN0YXRlLiBEb24ndCBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5OyBnbyB0aHJvdWdoXG4gICAgICogX3Jlc29sdmVDaGFuZ2VzKCkgdG8gZW5zdXJlIHRoYXQgY2hhbmdlcyBhcmUgcmVzb2x2ZWQgYW5kIGFsbCBldmVudHMgYXJlXG4gICAgICogZmlyZWQgcHJvcGVybHkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zdG9yZVN0YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBzb3VyY2Ugb2YgdGhlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3U3RhdGUgbmV3IHN0YXRlIHRvIHN0b3JlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgWmVybyBvciBtb3JlIG9wdGlvbnMuIFNlZSA8Y29kZT5hZGQoKTwvY29kZT4gZm9yXG4gICAgICogICBhIGxpc3Qgb2Ygc3VwcG9ydGVkIG9wdGlvbnMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zdG9yZVN0YXRlOiBmdW5jdGlvbiAoc3JjLCBuZXdTdGF0ZSkge1xuICAgICAgICAvLyBOb3RlOiB0aGUgc3JjIGFuZCBvcHRpb25zIHBhcmFtcyBhcmVuJ3QgdXNlZCBoZXJlLCBidXQgdGhleSBhcmUgdXNlZFxuICAgICAgICAvLyBieSBzdWJjbGFzc2VzLlxuICAgICAgICBHbG9iYWxFbnYuX3N0YXRlID0gbmV3U3RhdGUgfHwge307XG4gICAgfSxcblxuICAgIC8vIC0tIFByb3RlY3RlZCBFdmVudCBIYW5kbGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgPGNvZGU+aGlzdG9yeTpjaGFuZ2U8L2NvZGU+IGV2ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kZWZDaGFuZ2VGblxuICAgICAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGUgc3RhdGUgY2hhbmdlIGV2ZW50IGZhY2FkZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZGVmQ2hhbmdlRm46IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX3N0b3JlU3RhdGUoZS5zcmMsIGUubmV3VmFsLCBlLl9vcHRpb25zKTtcbiAgICB9XG59LCB0cnVlKTtcblxuWS5IaXN0b3J5QmFzZSA9IEhpc3RvcnlCYXNlO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJldmVudC1jdXN0b20tY29tcGxleFwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdoaXN0b3J5LWhhc2gtaWUnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIEltcHJvdmVzIElFNi83IHN1cHBvcnQgaW4gaGlzdG9yeS1oYXNoIGJ5IHVzaW5nIGEgaGlkZGVuIGlmcmFtZSB0byBjcmVhdGVcbiAqIGVudHJpZXMgaW4gSUUncyBicm93c2VyIGhpc3RvcnkuIFRoaXMgbW9kdWxlIGlzIG9ubHkgbmVlZGVkIGlmIElFNi83IHN1cHBvcnRcbiAqIGlzIG5lY2Vzc2FyeTsgaXQncyBub3QgbmVlZGVkIGZvciBhbnkgb3RoZXIgYnJvd3Nlci5cbiAqXG4gKiBAbW9kdWxlIGhpc3RvcnlcbiAqIEBzdWJtb2R1bGUgaGlzdG9yeS1oYXNoLWllXG4gKiBAc2luY2UgMy4yLjBcbiAqL1xuXG4vLyBDb21iaW5hdGlvbiBvZiBhIFVBIHNuaWZmIHRvIGVuc3VyZSB0aGlzIGlzIElFIChvciBhIGJyb3dzZXIgdGhhdCB3YW50cyB1cyB0b1xuLy8gdHJlYXQgaXQgbGlrZSBJRSkgYW5kIGZlYXR1cmUgZGV0ZWN0aW9uIGZvciBuYXRpdmUgaGFzaGNoYW5nZSBzdXBwb3J0IChmYWxzZVxuLy8gZm9yIElFIDwgOCBvciBJRTgvOSBpbiBJRTcgbW9kZSkuXG5pZiAoWS5VQS5pZSAmJiAhWS5IaXN0b3J5QmFzZS5uYXRpdmVIYXNoQ2hhbmdlKSB7XG4gICAgdmFyIERvICAgICAgICAgID0gWS5EbyxcbiAgICAgICAgR2xvYmFsRW52ICAgPSBZVUkubmFtZXNwYWNlKCdFbnYuSGlzdG9yeUhhc2gnKSxcbiAgICAgICAgSGlzdG9yeUhhc2ggPSBZLkhpc3RvcnlIYXNoLFxuXG4gICAgICAgIGlmcmFtZSA9IEdsb2JhbEVudi5faWZyYW1lLFxuICAgICAgICB3aW4gICAgPSBZLmNvbmZpZy53aW47XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByYXcgKG5vdCBkZWNvZGVkKSBjdXJyZW50IGxvY2F0aW9uIGhhc2ggZnJvbSB0aGUgSUUgaWZyYW1lLFxuICAgICAqIG1pbnVzIHRoZSBwcmVjZWRpbmcgJyMnIGNoYXJhY3RlciBhbmQgdGhlIGhhc2hQcmVmaXggKGlmIG9uZSBpcyBzZXQpLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRJZnJhbWVIYXNoXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBjdXJyZW50IGlmcmFtZSBoYXNoXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIEhpc3RvcnlIYXNoLmdldElmcmFtZUhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaWZyYW1lIHx8ICFpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWZpeCA9IEhpc3RvcnlIYXNoLmhhc2hQcmVmaXgsXG4gICAgICAgICAgICBoYXNoICAgPSBpZnJhbWUuY29udGVudFdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKTtcblxuICAgICAgICByZXR1cm4gcHJlZml4ICYmIGhhc2guaW5kZXhPZihwcmVmaXgpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgaGFzaC5yZXBsYWNlKHByZWZpeCwgJycpIDogaGFzaDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaGlzdG9yeSBpZnJhbWUgd2l0aCB0aGUgc3BlY2lmaWVkIGhhc2guXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVJZnJhbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFzaCBsb2NhdGlvbiBoYXNoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXBsYWNlIChvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIHRoZSBjdXJyZW50XG4gICAgICogICBoaXN0b3J5IHN0YXRlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aG91dCBhZGRpbmcgYSBuZXcgaGlzdG9yeSBlbnRyeVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZvciBIaXN0b3J5SGFzaFxuICAgICAqL1xuICAgIEhpc3RvcnlIYXNoLl91cGRhdGVJZnJhbWUgPSBmdW5jdGlvbiAoaGFzaCwgcmVwbGFjZSkge1xuICAgICAgICB2YXIgaWZyYW1lRG9jICAgICAgPSBpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsXG4gICAgICAgICAgICBpZnJhbWVMb2NhdGlvbiA9IGlmcmFtZURvYyAmJiBpZnJhbWVEb2MubG9jYXRpb247XG5cbiAgICAgICAgaWYgKCFpZnJhbWVEb2MgfHwgIWlmcmFtZUxvY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgICBpZnJhbWVMb2NhdGlvbi5yZXBsYWNlKGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZnJhbWVEb2Mub3BlbigpLmNsb3NlKCk7XG4gICAgICAgICAgICBpZnJhbWVMb2NhdGlvbi5oYXNoID0gaGFzaDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBEby5iZWZvcmUoSGlzdG9yeUhhc2guX3VwZGF0ZUlmcmFtZSwgSGlzdG9yeUhhc2gsICdyZXBsYWNlSGFzaCcsIEhpc3RvcnlIYXNoLCB0cnVlKTtcblxuICAgIGlmICghaWZyYW1lKSB7XG4gICAgICAgIFkub24oJ2RvbXJlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhc3RVcmxIYXNoID0gSGlzdG9yeUhhc2guZ2V0SGFzaCgpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBoaWRkZW4gaWZyYW1lIHRvIHN0b3JlIGhpc3Rvcnkgc3RhdGUsIGZvbGxvd2luZyB0aGVcbiAgICAgICAgICAgIC8vIGlmcmFtZS1oaWRpbmcgcmVjb21tZW5kYXRpb25zIGZyb21cbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cucGFjaWVsbG9ncm91cC5jb20vYmxvZy8/cD02MDQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBpZnJhbWUgd2lsbCBhbGxvdyBoaXN0b3J5IG5hdmlnYXRpb24gd2l0aGluIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgIC8vIGNvbnRleHQuIEFmdGVyIG5hdmlnYXRpbmcgdG8gYW5vdGhlciBwYWdlLCBhbGwgYnV0IHRoZSBtb3N0XG4gICAgICAgICAgICAvLyByZWNlbnQgaGlzdG9yeSBzdGF0ZSB3aWxsIGJlIGxvc3QuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRWFybGllciB2ZXJzaW9ucyBvZiB0aGUgWVVJIEhpc3RvcnkgVXRpbGl0eSBhdHRlbXB0ZWQgdG8gd29ya1xuICAgICAgICAgICAgLy8gYXJvdW5kIHRoaXMgbGltaXRhdGlvbiBieSBoYXZpbmcgdGhlIGlmcmFtZSBsb2FkIGEgc3RhdGljXG4gICAgICAgICAgICAvLyByZXNvdXJjZS4gVGhpcyB3b3JrYXJvdW5kIHdhcyBleHRyZW1lbHkgZnJhZ2lsZSBhbmQgdGVuZGVkIHRvXG4gICAgICAgICAgICAvLyBicmVhayBmcmVxdWVudGx5IChhbmQgc2lsZW50bHkpIHNpbmNlIGl0IHdhcyBlbnRpcmVseSBkZXBlbmRlbnRcbiAgICAgICAgICAgIC8vIG9uIElFJ3MgaW5jb25zaXN0ZW50IGhhbmRsaW5nIG9mIGlmcmFtZSBoaXN0b3J5LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgd29ya2Fyb3VuZCBkaWRuJ3Qgd29yayBtdWNoIG9mIHRoZSB0aW1lIGFueXdheSBhbmRcbiAgICAgICAgICAgIC8vIGFkZGVkIHNpZ25pZmljYW50IGNvbXBsZXhpdHksIGl0IGhhcyBiZWVuIHJlbW92ZWQsIGFuZCBJRTYgYW5kIDdcbiAgICAgICAgICAgIC8vIG5vdyBnZXQgc2xpZ2h0bHkgZGVncmFkZWQgaGlzdG9yeSBzdXBwb3J0LlxuXG4gICAgICAgICAgICBpZnJhbWUgPSBHbG9iYWxFbnYuX2lmcmFtZSA9IFkuTm9kZS5nZXRET01Ob2RlKFkuTm9kZS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBoZWlnaHQ9XCIwXCIgd2lkdGg9XCIwXCIgdGFiaW5kZXg9XCItMVwiIHRpdGxlPVwiZW1wdHlcIi8+J1xuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgaWZyYW1lIHRvIHRoZSBkb2N1bWVudEVsZW1lbnQgcmF0aGVyIHRoYW4gdGhlIGJvZHkuXG4gICAgICAgICAgICAvLyBLZWVwaW5nIGl0IG91dHNpZGUgdGhlIGJvZHkgcHJldmVudHMgc2Nyb2xsaW5nIG9uIHRoZSBpbml0aWFsXG4gICAgICAgICAgICAvLyBwYWdlIGxvYWQgKGhhdCB0aXAgdG8gQmVuIEFsbWFuIGFuZCBqUXVlcnkgQkJRIGZvciB0aGlzXG4gICAgICAgICAgICAvLyB0ZWNobmlxdWUpLlxuICAgICAgICAgICAgWS5jb25maWcuZG9jLmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGlmcmFtZSB3aXRoIHRoZSBpbml0aWFsIGxvY2F0aW9uIGhhc2gsIGlmIGFueS4gVGhpc1xuICAgICAgICAgICAgLy8gd2lsbCBjcmVhdGUgYW4gaW5pdGlhbCBoaXN0b3J5IGVudHJ5IHRoYXQgdGhlIHVzZXIgY2FuIHJldHVybiB0b1xuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgSGlzdG9yeUhhc2guX3VwZGF0ZUlmcmFtZShsYXN0VXJsSGFzaCB8fCAnIycpO1xuXG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGhhc2hjaGFuZ2UgZXZlbnRzIGFuZCBrZWVwIHRoZSBpZnJhbWUncyBoYXNoIGluIHN5bmNcbiAgICAgICAgICAgIC8vIHdpdGggdGhlIHBhcmVudCBmcmFtZSdzIGhhc2guXG4gICAgICAgICAgICBZLm9uKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBsYXN0VXJsSGFzaCA9IGUubmV3SGFzaDtcblxuICAgICAgICAgICAgICAgIGlmIChIaXN0b3J5SGFzaC5nZXRJZnJhbWVIYXNoKCkgIT09IGxhc3RVcmxIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIEhpc3RvcnlIYXNoLl91cGRhdGVJZnJhbWUobGFzdFVybEhhc2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHdpbik7XG5cbiAgICAgICAgICAgIC8vIFdhdGNoIHRoZSBpZnJhbWUgaGFzaCBpbiBvcmRlciB0byBkZXRlY3QgYmFjay9mb3J3YXJkIG5hdmlnYXRpb24uXG4gICAgICAgICAgICBZLmxhdGVyKDUwLCBudWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlmcmFtZUhhc2ggPSBIaXN0b3J5SGFzaC5nZXRJZnJhbWVIYXNoKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaWZyYW1lSGFzaCAhPT0gbGFzdFVybEhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgSGlzdG9yeUhhc2guc2V0SGFzaChpZnJhbWVIYXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBudWxsLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJoaXN0b3J5LWhhc2hcIiwgXCJub2RlLWJhc2VcIl19KTtcbiIsIi8vIC8qXG4vLyBZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuLy8gQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbi8vIGh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuLy8gKi9cbi8vIFxuLy8gWVVJLmFkZCgnaGlzdG9yeS1oYXNoJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcbi8vIFxuLy8gLyoqXG4vLyAgKiBQcm92aWRlcyBicm93c2VyIGhpc3RvcnkgbWFuYWdlbWVudCBiYWNrZWQgYnlcbi8vICAqIDxjb2RlPndpbmRvdy5sb2NhdGlvbi5oYXNoPC9jb2RlPiwgYXMgd2VsbCBhcyBjb252ZW5pZW5jZSBtZXRob2RzIGZvciB3b3JraW5nXG4vLyAgKiB3aXRoIHRoZSBsb2NhdGlvbiBoYXNoIGFuZCBhIHN5bnRoZXRpYyA8Y29kZT5oYXNoY2hhbmdlPC9jb2RlPiBldmVudCB0aGF0XG4vLyAgKiBub3JtYWxpemVzIGRpZmZlcmVuY2VzIGFjcm9zcyBicm93c2Vycy5cbi8vICAqXG4vLyAgKiBAbW9kdWxlIGhpc3Rvcnlcbi8vICAqIEBzdWJtb2R1bGUgaGlzdG9yeS1oYXNoXG4vLyAgKiBAc2luY2UgMy4yLjBcbi8vICAqIEBjbGFzcyBIaXN0b3J5SGFzaFxuLy8gICogQGV4dGVuZHMgSGlzdG9yeUJhc2Vcbi8vICAqIEBjb25zdHJ1Y3RvclxuLy8gICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAob3B0aW9uYWwpIENvbmZpZ3VyYXRpb24gb2JqZWN0LiBTZWUgdGhlIEhpc3RvcnlCYXNlXG4vLyAgKiAgIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG4vLyAgKi9cbi8vIFxuLy8gdmFyIEhpc3RvcnlCYXNlID0gWS5IaXN0b3J5QmFzZSxcbi8vICAgICBMYW5nICAgICAgICA9IFkuTGFuZyxcbi8vICAgICBZQXJyYXkgICAgICA9IFkuQXJyYXksXG4vLyAgICAgWU9iamVjdCAgICAgPSBZLk9iamVjdCxcbi8vICAgICBHbG9iYWxFbnYgICA9IFlVSS5uYW1lc3BhY2UoJ0Vudi5IaXN0b3J5SGFzaCcpLFxuLy8gXG4vLyAgICAgU1JDX0hBU0ggICAgPSAnaGFzaCcsXG4vLyBcbi8vICAgICBoYXNoTm90aWZpZXJzLFxuLy8gICAgIG9sZEhhc2gsXG4vLyAgICAgb2xkVXJsLFxuLy8gICAgIHdpbiAgICAgICAgICAgICA9IFkuY29uZmlnLndpbixcbi8vICAgICB1c2VIaXN0b3J5SFRNTDUgPSBZLmNvbmZpZy51c2VIaXN0b3J5SFRNTDU7XG4vLyBcbi8vIGZ1bmN0aW9uIEhpc3RvcnlIYXNoKCkge1xuLy8gICAgIEhpc3RvcnlIYXNoLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbi8vIH1cbi8vIFxuLy8gWS5leHRlbmQoSGlzdG9yeUhhc2gsIEhpc3RvcnlCYXNlLCB7XG4vLyAgICAgLy8gLS0gSW5pdGlhbGl6YXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIF9pbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG4vLyAgICAgICAgIHZhciBib29rbWFya2VkU3RhdGUgPSBIaXN0b3J5SGFzaC5wYXJzZUhhc2goKTtcbi8vIFxuLy8gICAgICAgICAvLyBJZiBhbiBpbml0aWFsU3RhdGUgd2FzIHByb3ZpZGVkLCBtZXJnZSB0aGUgYm9va21hcmtlZCBzdGF0ZSBpbnRvIGl0XG4vLyAgICAgICAgIC8vICh0aGUgYm9va21hcmtlZCBzdGF0ZSB3aW5zKS5cbi8vICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuLy8gXG4vLyAgICAgICAgIHRoaXMuX2luaXRpYWxTdGF0ZSA9IGNvbmZpZy5pbml0aWFsU3RhdGUgP1xuLy8gICAgICAgICAgICAgICAgIFkubWVyZ2UoY29uZmlnLmluaXRpYWxTdGF0ZSwgYm9va21hcmtlZFN0YXRlKSA6IGJvb2ttYXJrZWRTdGF0ZTtcbi8vIFxuLy8gICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHN5bnRoZXRpYyBoYXNoY2hhbmdlIGV2ZW50IChkZWZpbmVkIGJlbG93KSB0byBoYW5kbGVcbi8vICAgICAgICAgLy8gY2hhbmdlcy5cbi8vICAgICAgICAgWS5hZnRlcignaGFzaGNoYW5nZScsIFkuYmluZCh0aGlzLl9hZnRlckhhc2hDaGFuZ2UsIHRoaXMpLCB3aW4pO1xuLy8gXG4vLyAgICAgICAgIEhpc3RvcnlIYXNoLnN1cGVyY2xhc3MuX2luaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLy8gLS0gUHJvdGVjdGVkIE1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIF9jaGFuZ2U6IGZ1bmN0aW9uIChzcmMsIHN0YXRlLCBvcHRpb25zKSB7XG4vLyAgICAgICAgIC8vIFN0cmluZ2lmeSBhbGwgdmFsdWVzIHRvIGVuc3VyZSB0aGF0IGNvbXBhcmlzb25zIGRvbid0IGZhaWwgYWZ0ZXJcbi8vICAgICAgICAgLy8gdGhleSdyZSBjb2VyY2VkIHRvIHN0cmluZ3MgaW4gdGhlIGxvY2F0aW9uIGhhc2guXG4vLyAgICAgICAgIFlPYmplY3QuZWFjaChzdGF0ZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbi8vICAgICAgICAgICAgIGlmIChMYW5nLmlzVmFsdWUodmFsdWUpKSB7XG4vLyAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgIHJldHVybiBIaXN0b3J5SGFzaC5zdXBlcmNsYXNzLl9jaGFuZ2UuY2FsbCh0aGlzLCBzcmMsIHN0YXRlLCBvcHRpb25zKTtcbi8vICAgICB9LFxuLy8gXG4vLyAgICAgX3N0b3JlU3RhdGU6IGZ1bmN0aW9uIChzcmMsIG5ld1N0YXRlKSB7XG4vLyAgICAgICAgIHZhciBkZWNvZGUgID0gSGlzdG9yeUhhc2guZGVjb2RlLFxuLy8gICAgICAgICAgICAgbmV3SGFzaCA9IEhpc3RvcnlIYXNoLmNyZWF0ZUhhc2gobmV3U3RhdGUpO1xuLy8gXG4vLyAgICAgICAgIEhpc3RvcnlIYXNoLnN1cGVyY2xhc3MuX3N0b3JlU3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbi8vIFxuLy8gICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2F0aW9uIGhhc2ggd2l0aCB0aGUgY2hhbmdlcywgYnV0IG9ubHkgaWYgdGhlIG5ldyBoYXNoXG4vLyAgICAgICAgIC8vIGFjdHVhbGx5IGRpZmZlcnMgZnJvbSB0aGUgY3VycmVudCBoYXNoICh0aGlzIGF2b2lkcyBjcmVhdGluZyBtdWx0aXBsZVxuLy8gICAgICAgICAvLyBoaXN0b3J5IGVudHJpZXMgZm9yIGEgc2luZ2xlIHN0YXRlKS5cbi8vICAgICAgICAgLy9cbi8vICAgICAgICAgLy8gV2UgYWx3YXlzIGNvbXBhcmUgZGVjb2RlZCBoYXNoZXMsIHNpbmNlIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgaGFzaFxuLy8gICAgICAgICAvLyBjb3VsZCBiZSBzZXQgaW5jb3JyZWN0bHkgdG8gYSBub24tZW5jb2RlZCB2YWx1ZSBvdXRzaWRlIG9mXG4vLyAgICAgICAgIC8vIEhpc3RvcnlIYXNoLlxuLy8gICAgICAgICBpZiAoc3JjICE9PSBTUkNfSEFTSCAmJiBkZWNvZGUoSGlzdG9yeUhhc2guZ2V0SGFzaCgpKSAhPT0gZGVjb2RlKG5ld0hhc2gpKSB7XG4vLyAgICAgICAgICAgICBIaXN0b3J5SGFzaFtzcmMgPT09IEhpc3RvcnlCYXNlLlNSQ19SRVBMQUNFID8gJ3JlcGxhY2VIYXNoJyA6ICdzZXRIYXNoJ10obmV3SGFzaCk7XG4vLyAgICAgICAgIH1cbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLy8gLS0gUHJvdGVjdGVkIEV2ZW50IEhhbmRsZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICogSGFuZGxlciBmb3IgaGFzaGNoYW5nZSBldmVudHMuXG4vLyAgICAgICpcbi8vICAgICAgKiBAbWV0aG9kIF9hZnRlckhhc2hDaGFuZ2Vcbi8vICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4vLyAgICAgICogQHByb3RlY3RlZFxuLy8gICAgICAqL1xuLy8gICAgIF9hZnRlckhhc2hDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4vLyAgICAgICAgIHRoaXMuX3Jlc29sdmVDaGFuZ2VzKFNSQ19IQVNILCBIaXN0b3J5SGFzaC5wYXJzZUhhc2goZS5uZXdIYXNoKSwge30pO1xuLy8gICAgIH1cbi8vIH0sIHtcbi8vICAgICAvLyAtLSBQdWJsaWMgU3RhdGljIFByb3BlcnRpZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgTkFNRTogJ2hpc3RvcnlIYXNoJyxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIENvbnN0YW50IHVzZWQgdG8gaWRlbnRpZnkgc3RhdGUgY2hhbmdlcyBvcmlnaW5hdGluZyBmcm9tXG4vLyAgICAgICogPGNvZGU+aGFzaGNoYW5nZTwvY29kZT4gZXZlbnRzLlxuLy8gICAgICAqXG4vLyAgICAgICogQHByb3BlcnR5IFNSQ19IQVNIXG4vLyAgICAgICogQHR5cGUgU3RyaW5nXG4vLyAgICAgICogQHN0YXRpY1xuLy8gICAgICAqIEBmaW5hbFxuLy8gICAgICAqL1xuLy8gICAgIFNSQ19IQVNIOiBTUkNfSEFTSCxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIDxwPlxuLy8gICAgICAqIFByZWZpeCB0byBwcmVwZW5kIHdoZW4gc2V0dGluZyB0aGUgaGFzaCBmcmFnbWVudC4gRm9yIGV4YW1wbGUsIGlmIHRoZVxuLy8gICAgICAqIHByZWZpeCBpcyA8Y29kZT4hPC9jb2RlPiBhbmQgdGhlIGhhc2ggZnJhZ21lbnQgaXMgc2V0IHRvXG4vLyAgICAgICogPGNvZGU+I2Zvbz1iYXImYmF6PXF1dXg8L2NvZGU+LCB0aGUgZmluYWwgaGFzaCBmcmFnbWVudCBpbiB0aGUgVVJMIHdpbGxcbi8vICAgICAgKiBiZWNvbWUgPGNvZGU+IyFmb289YmFyJmJhej1xdXV4PC9jb2RlPi4gVGhpcyBjYW4gYmUgdXNlZCB0byBoZWxwIG1ha2UgYW5cbi8vICAgICAgKiBBamF4IGFwcGxpY2F0aW9uIGNyYXdsYWJsZSBpbiBhY2NvcmRhbmNlIHdpdGggR29vZ2xlJ3MgZ3VpZGVsaW5lcyBhdFxuLy8gICAgICAqIDxhIGhyZWY9XCJodHRwOi8vY29kZS5nb29nbGUuY29tL3dlYi9hamF4Y3Jhd2xpbmcvXCI+aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS93ZWIvYWpheGNyYXdsaW5nLzwvYT4uXG4vLyAgICAgICogPC9wPlxuLy8gICAgICAqXG4vLyAgICAgICogPHA+XG4vLyAgICAgICogTm90ZSB0aGF0IHRoaXMgcHJlZml4IGFwcGxpZXMgdG8gYWxsIEhpc3RvcnlIYXNoIGluc3RhbmNlcy4gSXQncyBub3Rcbi8vICAgICAgKiBwb3NzaWJsZSBmb3IgaW5kaXZpZHVhbCBpbnN0YW5jZXMgdG8gdXNlIHRoZWlyIG93biBwcmVmaXhlcyBzaW5jZSB0aGV5XG4vLyAgICAgICogYWxsIG9wZXJhdGUgb24gdGhlIHNhbWUgVVJMLlxuLy8gICAgICAqIDwvcD5cbi8vICAgICAgKlxuLy8gICAgICAqIEBwcm9wZXJ0eSBoYXNoUHJlZml4XG4vLyAgICAgICogQHR5cGUgU3RyaW5nXG4vLyAgICAgICogQGRlZmF1bHQgJydcbi8vICAgICAgKiBAc3RhdGljXG4vLyAgICAgICovXG4vLyAgICAgaGFzaFByZWZpeDogJycsXG4vLyBcbi8vICAgICAvLyAtLSBQcm90ZWN0ZWQgU3RhdGljIFByb3BlcnRpZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBwYXJzZSBsb2NhdGlvbiBoYXNoL3F1ZXJ5IHN0cmluZ3MuXG4vLyAgICAgICpcbi8vICAgICAgKiBAcHJvcGVydHkgX1JFR0VYX0hBU0hcbi8vICAgICAgKiBAdHlwZSBSZWdFeHBcbi8vICAgICAgKiBAcHJvdGVjdGVkXG4vLyAgICAgICogQHN0YXRpY1xuLy8gICAgICAqIEBmaW5hbFxuLy8gICAgICAqL1xuLy8gICAgIF9SRUdFWF9IQVNIOiAvKFteXFw/IyY9XSspPT8oW14mPV0qKS9nLFxuLy8gXG4vLyAgICAgLy8gLS0gUHVibGljIFN0YXRpYyBNZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICogQ3JlYXRlcyBhIGxvY2F0aW9uIGhhc2ggc3RyaW5nIGZyb20gdGhlIHNwZWNpZmllZCBvYmplY3Qgb2Yga2V5L3ZhbHVlXG4vLyAgICAgICogcGFpcnMuXG4vLyAgICAgICpcbi8vICAgICAgKiBAbWV0aG9kIGNyZWF0ZUhhc2hcbi8vICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFyYW1ldGVyIHBhaXJzXG4vLyAgICAgICogQHJldHVybiB7U3RyaW5nfSBsb2NhdGlvbiBoYXNoIHN0cmluZ1xuLy8gICAgICAqIEBzdGF0aWNcbi8vICAgICAgKi9cbi8vICAgICBjcmVhdGVIYXNoOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4vLyAgICAgICAgIHZhciBlbmNvZGUgPSBIaXN0b3J5SGFzaC5lbmNvZGUsXG4vLyAgICAgICAgICAgICBoYXNoICAgPSBbXTtcbi8vIFxuLy8gICAgICAgICBZT2JqZWN0LmVhY2gocGFyYW1zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuLy8gICAgICAgICAgICAgaWYgKExhbmcuaXNWYWx1ZSh2YWx1ZSkpIHtcbi8vICAgICAgICAgICAgICAgICBoYXNoLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsdWUpKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyBcbi8vICAgICAgICAgcmV0dXJuIGhhc2guam9pbignJicpO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiBXcmFwcGVyIGFyb3VuZCA8Y29kZT5kZWNvZGVVUklDb21wb25lbnQoKTwvY29kZT4gdGhhdCBhbHNvIGNvbnZlcnRzICtcbi8vICAgICAgKiBjaGFycyBpbnRvIHNwYWNlcy5cbi8vICAgICAgKlxuLy8gICAgICAqIEBtZXRob2QgZGVjb2RlXG4vLyAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBzdHJpbmcgdG8gZGVjb2RlXG4vLyAgICAgICogQHJldHVybiB7U3RyaW5nfSBkZWNvZGVkIHN0cmluZ1xuLy8gICAgICAqIEBzdGF0aWNcbi8vICAgICAgKi9cbi8vICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbi8vICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHJpbmcucmVwbGFjZSgvXFwrL2csICcgJykpO1xuLy8gICAgIH0sXG4vLyBcbi8vICAgICAvKipcbi8vICAgICAgKiBXcmFwcGVyIGFyb3VuZCA8Y29kZT5lbmNvZGVVUklDb21wb25lbnQoKTwvY29kZT4gdGhhdCBjb252ZXJ0cyBzcGFjZXMgdG9cbi8vICAgICAgKiArIGNoYXJzLlxuLy8gICAgICAqXG4vLyAgICAgICogQG1ldGhvZCBlbmNvZGVcbi8vICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIHN0cmluZyB0byBlbmNvZGVcbi8vICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgc3RyaW5nXG4vLyAgICAgICogQHN0YXRpY1xuLy8gICAgICAqL1xuLy8gICAgIGVuY29kZTogZnVuY3Rpb24gKHN0cmluZykge1xuLy8gICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykucmVwbGFjZSgvJTIwL2csICcrJyk7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIEdldHMgdGhlIHJhdyAobm90IGRlY29kZWQpIGN1cnJlbnQgbG9jYXRpb24gaGFzaCwgbWludXMgdGhlIHByZWNlZGluZyAnIydcbi8vICAgICAgKiBjaGFyYWN0ZXIgYW5kIHRoZSBoYXNoUHJlZml4IChpZiBvbmUgaXMgc2V0KS5cbi8vICAgICAgKlxuLy8gICAgICAqIEBtZXRob2QgZ2V0SGFzaFxuLy8gICAgICAqIEByZXR1cm4ge1N0cmluZ30gY3VycmVudCBsb2NhdGlvbiBoYXNoXG4vLyAgICAgICogQHN0YXRpY1xuLy8gICAgICAqL1xuLy8gICAgIGdldEhhc2g6IChZLlVBLmdlY2tvID8gZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAvLyBHZWNrbydzIHdpbmRvdy5sb2NhdGlvbi5oYXNoIHJldHVybnMgYSBkZWNvZGVkIHN0cmluZyBhbmQgd2Ugd2FudCBhbGxcbi8vICAgICAgICAgLy8gZW5jb2RpbmcgdW50b3VjaGVkLCBzbyB3ZSBuZWVkIHRvIGdldCB0aGUgaGFzaCB2YWx1ZSBmcm9tXG4vLyAgICAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5ocmVmIGluc3RlYWQuIFdlIGhhdmUgdG8gdXNlIFVBIHNuaWZmaW5nIHJhdGhlciB0aGFuXG4vLyAgICAgICAgIC8vIGZlYXR1cmUgZGV0ZWN0aW9uLCBzaW5jZSB0aGUgb25seSB3YXkgdG8gZGV0ZWN0IHRoaXMgd291bGQgYmUgdG9cbi8vICAgICAgICAgLy8gYWN0dWFsbHkgY2hhbmdlIHRoZSBoYXNoLlxuLy8gICAgICAgICB2YXIgbG9jYXRpb24gPSBZLmdldExvY2F0aW9uKCksXG4vLyAgICAgICAgICAgICBtYXRjaGVzICA9IC8jKC4qKSQvLmV4ZWMobG9jYXRpb24uaHJlZiksXG4vLyAgICAgICAgICAgICBoYXNoICAgICA9IG1hdGNoZXMgJiYgbWF0Y2hlc1sxXSB8fCAnJyxcbi8vICAgICAgICAgICAgIHByZWZpeCAgID0gSGlzdG9yeUhhc2guaGFzaFByZWZpeDtcbi8vIFxuLy8gICAgICAgICByZXR1cm4gcHJlZml4ICYmIGhhc2guaW5kZXhPZihwcmVmaXgpID09PSAwID9cbi8vICAgICAgICAgICAgICAgICAgICAgaGFzaC5yZXBsYWNlKHByZWZpeCwgJycpIDogaGFzaDtcbi8vICAgICB9IDogZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICB2YXIgbG9jYXRpb24gPSBZLmdldExvY2F0aW9uKCksXG4vLyAgICAgICAgICAgICBoYXNoICAgICA9IGxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpLFxuLy8gICAgICAgICAgICAgcHJlZml4ICAgPSBIaXN0b3J5SGFzaC5oYXNoUHJlZml4O1xuLy8gXG4vLyAgICAgICAgIC8vIFNsaWdodCBjb2RlIGR1cGxpY2F0aW9uIGhlcmUsIGJ1dCBleGVjdXRpb24gc3BlZWQgaXMgb2YgdGhlIGVzc2VuY2Vcbi8vICAgICAgICAgLy8gc2luY2UgZ2V0SGFzaCgpIGlzIGNhbGxlZCBldmVyeSA1MG1zIHRvIHBvbGwgZm9yIGNoYW5nZXMgaW4gYnJvd3NlcnNcbi8vICAgICAgICAgLy8gdGhhdCBkb24ndCBzdXBwb3J0IG5hdGl2ZSBvbmhhc2hjaGFuZ2UuIEFuIGFkZGl0aW9uYWwgZnVuY3Rpb24gY2FsbFxuLy8gICAgICAgICAvLyB3b3VsZCBhZGQgdW5uZWNlc3Nhcnkgb3ZlcmhlYWQuXG4vLyAgICAgICAgIHJldHVybiBwcmVmaXggJiYgaGFzaC5pbmRleE9mKHByZWZpeCkgPT09IDAgP1xuLy8gICAgICAgICAgICAgICAgICAgICBoYXNoLnJlcGxhY2UocHJlZml4LCAnJykgOiBoYXNoO1xuLy8gICAgIH0pLFxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICogR2V0cyB0aGUgY3VycmVudCBib29rbWFya2FibGUgVVJMLlxuLy8gICAgICAqXG4vLyAgICAgICogQG1ldGhvZCBnZXRVcmxcbi8vICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGN1cnJlbnQgYm9va21hcmthYmxlIFVSTFxuLy8gICAgICAqIEBzdGF0aWNcbi8vICAgICAgKi9cbi8vICAgICBnZXRVcmw6IGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhyZWY7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIFBhcnNlcyBhIGxvY2F0aW9uIGhhc2ggc3RyaW5nIGludG8gYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYXJhbWV0ZXJcbi8vICAgICAgKiBwYWlycy4gSWYgPGk+aGFzaDwvaT4gaXMgbm90IHNwZWNpZmllZCwgdGhlIGN1cnJlbnQgbG9jYXRpb24gaGFzaCB3aWxsXG4vLyAgICAgICogYmUgdXNlZC5cbi8vICAgICAgKlxuLy8gICAgICAqIEBtZXRob2QgcGFyc2VIYXNoXG4vLyAgICAgICogQHBhcmFtIHtTdHJpbmd9IGhhc2ggKG9wdGlvbmFsKSBsb2NhdGlvbiBoYXNoIHN0cmluZ1xuLy8gICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IG9mIHBhcnNlZCBrZXkvdmFsdWUgcGFyYW1ldGVyIHBhaXJzXG4vLyAgICAgICogQHN0YXRpY1xuLy8gICAgICAqL1xuLy8gICAgIHBhcnNlSGFzaDogZnVuY3Rpb24gKGhhc2gpIHtcbi8vICAgICAgICAgdmFyIGRlY29kZSA9IEhpc3RvcnlIYXNoLmRlY29kZSxcbi8vICAgICAgICAgICAgIGksXG4vLyAgICAgICAgICAgICBsZW4sXG4vLyAgICAgICAgICAgICBtYXRjaCxcbi8vICAgICAgICAgICAgIG1hdGNoZXMsXG4vLyAgICAgICAgICAgICBwYXJhbSxcbi8vICAgICAgICAgICAgIHBhcmFtcyA9IHt9LFxuLy8gICAgICAgICAgICAgcHJlZml4ID0gSGlzdG9yeUhhc2guaGFzaFByZWZpeCxcbi8vICAgICAgICAgICAgIHByZWZpeEluZGV4O1xuLy8gXG4vLyAgICAgICAgIGhhc2ggPSBMYW5nLmlzVmFsdWUoaGFzaCkgPyBoYXNoIDogSGlzdG9yeUhhc2guZ2V0SGFzaCgpO1xuLy8gXG4vLyAgICAgICAgIGlmIChwcmVmaXgpIHtcbi8vICAgICAgICAgICAgIHByZWZpeEluZGV4ID0gaGFzaC5pbmRleE9mKHByZWZpeCk7XG4vLyBcbi8vICAgICAgICAgICAgIGlmIChwcmVmaXhJbmRleCA9PT0gMCB8fCAocHJlZml4SW5kZXggPT09IDEgJiYgaGFzaC5jaGFyQXQoMCkgPT09ICcjJykpIHtcbi8vICAgICAgICAgICAgICAgICBoYXNoID0gaGFzaC5yZXBsYWNlKHByZWZpeCwgJycpO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgbWF0Y2hlcyA9IGhhc2gubWF0Y2goSGlzdG9yeUhhc2guX1JFR0VYX0hBU0gpIHx8IFtdO1xuLy8gXG4vLyAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG1hdGNoZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbi8vICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1tpXTtcbi8vIFxuLy8gICAgICAgICAgICAgcGFyYW0gPSBtYXRjaC5zcGxpdCgnPScpO1xuLy8gXG4vLyAgICAgICAgICAgICBpZiAocGFyYW0ubGVuZ3RoID4gMSkge1xuLy8gICAgICAgICAgICAgICAgIHBhcmFtc1tkZWNvZGUocGFyYW1bMF0pXSA9IGRlY29kZShwYXJhbVsxXSk7XG4vLyAgICAgICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgIHBhcmFtc1tkZWNvZGUobWF0Y2gpXSA9ICcnO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgcmV0dXJuIHBhcmFtcztcbi8vICAgICB9LFxuLy8gXG4vLyAgICAgLyoqXG4vLyAgICAgICogUmVwbGFjZXMgdGhlIGJyb3dzZXIncyBjdXJyZW50IGxvY2F0aW9uIGhhc2ggd2l0aCB0aGUgc3BlY2lmaWVkIGhhc2hcbi8vICAgICAgKiBhbmQgcmVtb3ZlcyBhbGwgZm9yd2FyZCBuYXZpZ2F0aW9uIHN0YXRlcywgd2l0aG91dCBjcmVhdGluZyBhIG5ldyBicm93c2VyXG4vLyAgICAgICogaGlzdG9yeSBlbnRyeS4gQXV0b21hdGljYWxseSBwcmVwZW5kcyB0aGUgPGNvZGU+aGFzaFByZWZpeDwvY29kZT4gaWYgb25lXG4vLyAgICAgICogaXMgc2V0LlxuLy8gICAgICAqXG4vLyAgICAgICogQG1ldGhvZCByZXBsYWNlSGFzaFxuLy8gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoIG5ldyBsb2NhdGlvbiBoYXNoXG4vLyAgICAgICogQHN0YXRpY1xuLy8gICAgICAqL1xuLy8gICAgIHJlcGxhY2VIYXNoOiBmdW5jdGlvbiAoaGFzaCkge1xuLy8gICAgICAgICB2YXIgbG9jYXRpb24gPSBZLmdldExvY2F0aW9uKCksXG4vLyAgICAgICAgICAgICBiYXNlICAgICA9IGxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIy4qJC8sICcnKTtcbi8vIFxuLy8gICAgICAgICBpZiAoaGFzaC5jaGFyQXQoMCkgPT09ICcjJykge1xuLy8gICAgICAgICAgICAgaGFzaCA9IGhhc2guc3Vic3RyaW5nKDEpO1xuLy8gICAgICAgICB9XG4vLyBcbi8vICAgICAgICAgbG9jYXRpb24ucmVwbGFjZShiYXNlICsgJyMnICsgKEhpc3RvcnlIYXNoLmhhc2hQcmVmaXggfHwgJycpICsgaGFzaCk7XG4vLyAgICAgfSxcbi8vIFxuLy8gICAgIC8qKlxuLy8gICAgICAqIFNldHMgdGhlIGJyb3dzZXIncyBsb2NhdGlvbiBoYXNoIHRvIHRoZSBzcGVjaWZpZWQgc3RyaW5nLiBBdXRvbWF0aWNhbGx5XG4vLyAgICAgICogcHJlcGVuZHMgdGhlIDxjb2RlPmhhc2hQcmVmaXg8L2NvZGU+IGlmIG9uZSBpcyBzZXQuXG4vLyAgICAgICpcbi8vICAgICAgKiBAbWV0aG9kIHNldEhhc2hcbi8vICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFzaCBuZXcgbG9jYXRpb24gaGFzaFxuLy8gICAgICAqIEBzdGF0aWNcbi8vICAgICAgKi9cbi8vICAgICBzZXRIYXNoOiBmdW5jdGlvbiAoaGFzaCkge1xuLy8gICAgICAgICB2YXIgbG9jYXRpb24gPSBZLmdldExvY2F0aW9uKCk7XG4vLyBcbi8vICAgICAgICAgaWYgKGhhc2guY2hhckF0KDApID09PSAnIycpIHtcbi8vICAgICAgICAgICAgIGhhc2ggPSBoYXNoLnN1YnN0cmluZygxKTtcbi8vICAgICAgICAgfVxuLy8gXG4vLyAgICAgICAgIGxvY2F0aW9uLmhhc2ggPSAoSGlzdG9yeUhhc2guaGFzaFByZWZpeCB8fCAnJykgKyBoYXNoO1xuLy8gICAgIH1cbi8vIH0pO1xuLy8gXG4vLyAvLyAtLSBTeW50aGV0aWMgaGFzaGNoYW5nZSBFdmVudCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gXG4vLyAvLyBUT0RPOiBZVUlEb2MgY3VycmVudGx5IGRvZXNuJ3QgcHJvdmlkZSBhIGdvb2Qgd2F5IHRvIGRvY3VtZW50IHN5bnRoZXRpYyBET01cbi8vIC8vIGV2ZW50cy4gRm9yIG5vdywgd2UncmUganVzdCBkb2N1bWVudGluZyB0aGUgaGFzaGNoYW5nZSBldmVudCBvbiB0aGUgWVVJXG4vLyAvLyBvYmplY3QsIHdoaWNoIGlzIGFib3V0IHRoZSBiZXN0IHdlIGNhbiBkbyB1bnRpbCBlbmhhbmNlbWVudHMgYXJlIG1hZGUgdG9cbi8vIC8vIFlVSURvYy5cbi8vIFxuLy8gLyoqXG4vLyBTeW50aGV0aWMgPGNvZGU+d2luZG93Lm9uaGFzaGNoYW5nZTwvY29kZT4gZXZlbnQgdGhhdCBub3JtYWxpemVzIGRpZmZlcmVuY2VzXG4vLyBhY3Jvc3MgYnJvd3NlcnMgYW5kIHByb3ZpZGVzIHN1cHBvcnQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydFxuLy8gPGNvZGU+b25oYXNoY2hhbmdlPC9jb2RlPi5cbi8vIFxuLy8gVGhpcyBldmVudCBpcyBwcm92aWRlZCBieSB0aGUgPGNvZGU+aGlzdG9yeS1oYXNoPC9jb2RlPiBtb2R1bGUuXG4vLyBcbi8vIEBleGFtcGxlXG4vLyBcbi8vICAgICBZVUkoKS51c2UoJ2hpc3RvcnktaGFzaCcsIGZ1bmN0aW9uIChZKSB7XG4vLyAgICAgICBZLm9uKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbi8vICAgICAgICAgLy8gSGFuZGxlIGhhc2hjaGFuZ2UgZXZlbnRzIG9uIHRoZSBjdXJyZW50IHdpbmRvdy5cbi8vICAgICAgIH0sIFkuY29uZmlnLndpbik7XG4vLyAgICAgfSk7XG4vLyBcbi8vIEBldmVudCBoYXNoY2hhbmdlXG4vLyBAcGFyYW0ge0V2ZW50RmFjYWRlfSBlIEV2ZW50IGZhY2FkZSB3aXRoIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbFxuLy8gICBwcm9wZXJ0aWVzOlxuLy8gXG4vLyA8ZGw+XG4vLyAgIDxkdD5vbGRIYXNoPC9kdD5cbi8vICAgPGRkPlxuLy8gICAgIFByZXZpb3VzIGhhc2ggZnJhZ21lbnQgdmFsdWUgYmVmb3JlIHRoZSBjaGFuZ2UuXG4vLyAgIDwvZGQ+XG4vLyBcbi8vICAgPGR0Pm9sZFVybDwvZHQ+XG4vLyAgIDxkZD5cbi8vICAgICBQcmV2aW91cyBVUkwgKGluY2x1ZGluZyB0aGUgaGFzaCBmcmFnbWVudCkgYmVmb3JlIHRoZSBjaGFuZ2UuXG4vLyAgIDwvZGQ+XG4vLyBcbi8vICAgPGR0Pm5ld0hhc2g8L2R0PlxuLy8gICA8ZGQ+XG4vLyAgICAgTmV3IGhhc2ggZnJhZ21lbnQgdmFsdWUgYWZ0ZXIgdGhlIGNoYW5nZS5cbi8vICAgPC9kZD5cbi8vIFxuLy8gICA8ZHQ+bmV3VXJsPC9kdD5cbi8vICAgPGRkPlxuLy8gICAgIE5ldyBVUkwgKGluY2x1ZGluZyB0aGUgaGFzaCBmcmFnbWVudCkgYWZ0ZXIgdGhlIGNoYW5nZS5cbi8vICAgPC9kZD5cbi8vIDwvZGw+XG4vLyBAZm9yIFlVSVxuLy8gQHNpbmNlIDMuMi4wXG4vLyAqKi9cbi8vIFxuLy8gaGFzaE5vdGlmaWVycyA9IEdsb2JhbEVudi5fbm90aWZpZXJzO1xuLy8gXG4vLyBpZiAoIWhhc2hOb3RpZmllcnMpIHtcbi8vICAgICBoYXNoTm90aWZpZXJzID0gR2xvYmFsRW52Ll9ub3RpZmllcnMgPSBbXTtcbi8vIH1cbi8vIFxuLy8gWS5FdmVudC5kZWZpbmUoJ2hhc2hjaGFuZ2UnLCB7XG4vLyAgICAgb246IGZ1bmN0aW9uIChub2RlLCBzdWJzY3JpYmVyLCBub3RpZmllcikge1xuLy8gICAgICAgICAvLyBJZ25vcmUgdGhpcyBzdWJzY3JpcHRpb24gaWYgdGhlIG5vZGUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiB0aGVcbi8vICAgICAgICAgLy8gd2luZG93IG9yIGRvY3VtZW50IGJvZHksIHNpbmNlIHRob3NlIGFyZSB0aGUgb25seSBlbGVtZW50cyB0aGF0XG4vLyAgICAgICAgIC8vIHNob3VsZCBzdXBwb3J0IHRoZSBoYXNoY2hhbmdlIGV2ZW50LiBOb3RlIHRoYXQgdGhlIGJvZHkgY291bGQgYWxzbyBiZVxuLy8gICAgICAgICAvLyBhIGZyYW1lc2V0LCBidXQgdGhhdCdzIG9rYXkgc2luY2UgZnJhbWVzZXRzIHN1cHBvcnQgaGFzaGNoYW5nZSB0b28uXG4vLyAgICAgICAgIGlmIChub2RlLmNvbXBhcmVUbyh3aW4pIHx8IG5vZGUuY29tcGFyZVRvKFkuY29uZmlnLmRvYy5ib2R5KSkge1xuLy8gICAgICAgICAgICAgaGFzaE5vdGlmaWVycy5wdXNoKG5vdGlmaWVyKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH0sXG4vLyBcbi8vICAgICBkZXRhY2g6IGZ1bmN0aW9uIChub2RlLCBzdWJzY3JpYmVyLCBub3RpZmllcikge1xuLy8gICAgICAgICB2YXIgaW5kZXggPSBZQXJyYXkuaW5kZXhPZihoYXNoTm90aWZpZXJzLCBub3RpZmllcik7XG4vLyBcbi8vICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuLy8gICAgICAgICAgICAgaGFzaE5vdGlmaWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gfSk7XG4vLyBcbi8vIG9sZEhhc2ggPSBIaXN0b3J5SGFzaC5nZXRIYXNoKCk7XG4vLyBvbGRVcmwgID0gSGlzdG9yeUhhc2guZ2V0VXJsKCk7XG4vLyBcbi8vIGlmIChIaXN0b3J5QmFzZS5uYXRpdmVIYXNoQ2hhbmdlKSB7XG4vLyAgICAgLy8gV3JhcCB0aGUgYnJvd3NlcidzIG5hdGl2ZSBoYXNoY2hhbmdlIGV2ZW50IGlmIHRoZXJlJ3Mgbm90IGFscmVhZHkgYVxuLy8gICAgIC8vIGdsb2JhbCBsaXN0ZW5lci5cbi8vICAgICBpZiAoIUdsb2JhbEVudi5faGFzaEhhbmRsZSkge1xuLy8gICAgICAgICBHbG9iYWxFbnYuX2hhc2hIYW5kbGUgPSBZLkV2ZW50LmF0dGFjaCgnaGFzaGNoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4vLyAgICAgICAgICAgICB2YXIgbmV3SGFzaCA9IEhpc3RvcnlIYXNoLmdldEhhc2goKSxcbi8vICAgICAgICAgICAgICAgICBuZXdVcmwgID0gSGlzdG9yeUhhc2guZ2V0VXJsKCk7XG4vLyBcbi8vICAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIGNvcHkgb2YgdGhlIGhhc2hOb3RpZmllcnMgYXJyYXkgc2luY2UgYSBzdWJzY3JpYmVyXG4vLyAgICAgICAgICAgICAvLyBjb3VsZCBkZXRhY2ggZHVyaW5nIGl0ZXJhdGlvbiBhbmQgY2F1c2UgdGhlIGFycmF5IHRvIGJlIHJlLWluZGV4ZWQuXG4vLyAgICAgICAgICAgICBZQXJyYXkuZWFjaChoYXNoTm90aWZpZXJzLmNvbmNhdCgpLCBmdW5jdGlvbiAobm90aWZpZXIpIHtcbi8vICAgICAgICAgICAgICAgICBub3RpZmllci5maXJlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgX2V2ZW50IDogZSxcbi8vICAgICAgICAgICAgICAgICAgICAgb2xkSGFzaDogb2xkSGFzaCxcbi8vICAgICAgICAgICAgICAgICAgICAgb2xkVXJsIDogb2xkVXJsLFxuLy8gICAgICAgICAgICAgICAgICAgICBuZXdIYXNoOiBuZXdIYXNoLFxuLy8gICAgICAgICAgICAgICAgICAgICBuZXdVcmwgOiBuZXdVcmxcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gXG4vLyAgICAgICAgICAgICBvbGRIYXNoID0gbmV3SGFzaDtcbi8vICAgICAgICAgICAgIG9sZFVybCAgPSBuZXdVcmw7XG4vLyAgICAgICAgIH0sIHdpbik7XG4vLyAgICAgfVxuLy8gfSBlbHNlIHtcbi8vICAgICAvLyBCZWdpbiBwb2xsaW5nIGZvciBsb2NhdGlvbiBoYXNoIGNoYW5nZXMgaWYgdGhlcmUncyBub3QgYWxyZWFkeSBhIGdsb2JhbFxuLy8gICAgIC8vIHBvbGwgcnVubmluZy5cbi8vICAgICBpZiAoIUdsb2JhbEVudi5faGFzaFBvbGwpIHtcbi8vICAgICAgICAgR2xvYmFsRW52Ll9oYXNoUG9sbCA9IFkubGF0ZXIoNTAsIG51bGwsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIHZhciBuZXdIYXNoID0gSGlzdG9yeUhhc2guZ2V0SGFzaCgpLFxuLy8gICAgICAgICAgICAgICAgIGZhY2FkZSwgbmV3VXJsO1xuLy8gXG4vLyAgICAgICAgICAgICBpZiAob2xkSGFzaCAhPT0gbmV3SGFzaCkge1xuLy8gICAgICAgICAgICAgICAgIG5ld1VybCA9IEhpc3RvcnlIYXNoLmdldFVybCgpO1xuLy8gXG4vLyAgICAgICAgICAgICAgICAgZmFjYWRlID0ge1xuLy8gICAgICAgICAgICAgICAgICAgICBvbGRIYXNoOiBvbGRIYXNoLFxuLy8gICAgICAgICAgICAgICAgICAgICBvbGRVcmwgOiBvbGRVcmwsXG4vLyAgICAgICAgICAgICAgICAgICAgIG5ld0hhc2g6IG5ld0hhc2gsXG4vLyAgICAgICAgICAgICAgICAgICAgIG5ld1VybCA6IG5ld1VybFxuLy8gICAgICAgICAgICAgICAgIH07XG4vLyBcbi8vICAgICAgICAgICAgICAgICBvbGRIYXNoID0gbmV3SGFzaDtcbi8vICAgICAgICAgICAgICAgICBvbGRVcmwgID0gbmV3VXJsO1xuLy8gXG4vLyAgICAgICAgICAgICAgICAgWUFycmF5LmVhY2goaGFzaE5vdGlmaWVycy5jb25jYXQoKSwgZnVuY3Rpb24gKG5vdGlmaWVyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWVyLmZpcmUoZmFjYWRlKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfSwgbnVsbCwgdHJ1ZSk7XG4vLyAgICAgfVxuLy8gfVxuLy8gXG4vLyBZLkhpc3RvcnlIYXNoID0gSGlzdG9yeUhhc2g7XG4vLyBcbi8vIC8vIEhpc3RvcnlIYXNoIHdpbGwgbmV2ZXIgd2luIG92ZXIgSGlzdG9yeUhUTUw1IHVubGVzcyB1c2VIaXN0b3J5SFRNTDUgaXMgZmFsc2UuXG4vLyBpZiAodXNlSGlzdG9yeUhUTUw1ID09PSBmYWxzZSB8fCAoIVkuSGlzdG9yeSAmJiB1c2VIaXN0b3J5SFRNTDUgIT09IHRydWUgJiZcbi8vICAgICAgICAgKCFIaXN0b3J5QmFzZS5odG1sNSB8fCAhWS5IaXN0b3J5SFRNTDUpKSkge1xuLy8gICAgIFkuSGlzdG9yeSA9IEhpc3RvcnlIYXNoO1xuLy8gfVxuLy8gXG4vLyBcbi8vIH0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJldmVudC1zeW50aGV0aWNcIiwgXCJoaXN0b3J5LWJhc2VcIiwgXCJ5dWktbGF0ZXJcIl19KTtcbllVSS5hZGQoJ3NxdWFyZXNwYWNlLWhpc3RvcnktaGFzaCcsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbn0sICcxLjAnLCB7XG4gIHJlcXVpcmVzOiBbXG4gICAgJ3NxdWFyZXNwYWNlLWJlZm9yZXVubG9hZCdcbiAgXVxufSk7XG5cblxuLyogIF9fICAgX18gIF9fX19fX18gIF9fXyAgICAgIF9fXyAgICAgIF9fX19fX18gIF9fXG4vLyB8ICB8IHwgIHx8ICAgICAgIHx8ICAgfCAgICB8ICAgfCAgICB8ICAgICAgIHx8ICB8XG4vLyB8ICB8X3wgIHx8ICAgIF9fX3x8ICAgfCAgICB8ICAgfCAgICB8ICAgXyAgIHx8ICB8XG4vLyB8ICAgICAgIHx8ICAgfF9fXyB8ICAgfCAgICB8ICAgfCAgICB8ICB8IHwgIHx8ICB8XG4vLyB8ICAgICAgIHx8ICAgIF9fX3x8ICAgfF9fXyB8ICAgfF9fXyB8ICB8X3wgIHx8X198XG4vLyB8ICAgXyAgIHx8ICAgfF9fXyB8ICAgICAgIHx8ICAgICAgIHx8ICAgICAgIHwgX19cbi8vIHxfX3wgfF9ffHxfX19fX19ffHxfX19fX19ffHxfX19fX19ffHxfX19fX19ffHxfX3xcbiovXG5cbi8qKlxuICogVGhpcyBmaWxlIGlzIGFuIG92ZXJyaWRlIGZvciBZVUkncyBoaXN0b3J5LWhhc2guIEJlY2F1c2Ugd2UgdXNlIG11bHRpcGxlXG4gKiBmcmFtZXMgaW4gb3VyIGVudmlyb25tZW50LCB3ZSBuZWVkIHRvIGNoYW5nZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFlVSVxuICogaGFzIGFib3V0IGVudmlyb25tZW50cy5cbiAqXG4gKiBUaGUgZ3V0cyBvZiB3aGF0IGNoYW5nZWQgY2FuIGJlIHNlZW4gYXQgdGhlIGBTeW50aGV0aWMgaGFzaGNoYW5nZSBFdmVudGAgc2VjdGlvblxuICogb2YgdGhpcyBmaWxlLlxuICpcbiAqIFdlIGF0dGFjaCBhbiBldmVudCB0byB0aGUgd2luZG93IGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSwgYW5kIHVzZSB0aGF0XG4gKiB0byBub3RpZnkgZXZlcnlvbmUgdGhhdCBsaXN0ZW5zIGZvciBhIGhhc2hjaGFuZ2UgZXZlbnQuXG4gKlxuICogV2UgYWxzbyBicmluZyBpbiB0aGUgYHNxdWFyZXNwYWNlLWJlZm9yZXVubG9hZGAgbW9kdWxlLCBzbyB0aGF0IHdlIGNhbiB1bmJpbmQgdGhlIGxpc3RlbmVyXG4gKiBvbmNlIGEgd2luZG93IGdldHMgXCJkZXN0cm95ZWRcIi5cbiAqL1xuXG4oZnVuY3Rpb24oWVVJKSB7XG5cbiAgICB2YXIgREVCVUcgPSBmYWxzZTtcblxuLy8gdGhlIHJlYXNvbiB0aGlzIGlzIGFuIGBleHBvcnRzYCBhbmQgbm90IFlVSS5hZGQoJ2hpc3RvcnktaGFzaCcpXG4vLyBpcyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgY3JlYXRlLXJvbGx1cHMgdG8gcGljayB1cCBvbiB0aGUgZmFjdFxuLy8gdGhhdCBoaXN0b3J5LWhhc2ggaXMgaW4gaGVyZS5cblxuWVVJLmFkZCgnaGlzdG9yeS1oYXNoJywgZnVuY3Rpb24oWSkge1xuXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBicm93c2VyIGhpc3RvcnkgbWFuYWdlbWVudCBiYWNrZWQgYnlcbiAgICAgKiA8Y29kZT53aW5kb3cubG9jYXRpb24uaGFzaDwvY29kZT4sIGFzIHdlbGwgYXMgY29udmVuaWVuY2UgbWV0aG9kcyBmb3Igd29ya2luZ1xuICAgICAqIHdpdGggdGhlIGxvY2F0aW9uIGhhc2ggYW5kIGEgc3ludGhldGljIDxjb2RlPmhhc2hjaGFuZ2U8L2NvZGU+IGV2ZW50IHRoYXRcbiAgICAgKiBub3JtYWxpemVzIGRpZmZlcmVuY2VzIGFjcm9zcyBicm93c2Vycy5cbiAgICAgKlxuICAgICAqIEBtb2R1bGUgaGlzdG9yeVxuICAgICAqIEBzdWJtb2R1bGUgaGlzdG9yeS1oYXNoXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNsYXNzIEhpc3RvcnlIYXNoXG4gICAgICogQGV4dGVuZHMgSGlzdG9yeUJhc2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIChvcHRpb25hbCkgQ29uZmlndXJhdGlvbiBvYmplY3QuIFNlZSB0aGUgSGlzdG9yeUJhc2VcbiAgICAgKiAgIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG4gICAgICovXG5cbiAgICB2YXIgSGlzdG9yeUJhc2UgPSBZLkhpc3RvcnlCYXNlLFxuICAgICAgICBMYW5nICAgICAgICA9IFkuTGFuZyxcbiAgICAgICAgWUFycmF5ICAgICAgPSBZLkFycmF5LFxuICAgICAgICBZT2JqZWN0ICAgICA9IFkuT2JqZWN0LFxuICAgICAgICBHbG9iYWxFbnYgICA9IFlVSS5uYW1lc3BhY2UoJ0Vudi5IaXN0b3J5SGFzaCcpLFxuXG4gICAgICAgIFNSQ19IQVNIICAgID0gJ2hhc2gnLFxuXG4gICAgICAgIGdsb2JhbEhhc2hOb3RpZmllcnNCeVdpbmRvdyxcbiAgICAgICAgaGFzaE5vdGlmaWVyc0ZvcldpbmRvdyxcbiAgICAgICAgb2xkSGFzaCxcbiAgICAgICAgb2xkVXJsLFxuICAgICAgICB3aW4gICAgICAgICAgICAgPSBZLmNvbmZpZy53aW4sXG4gICAgICAgIHVzZUhpc3RvcnlIVE1MNSA9IFkuY29uZmlnLnVzZUhpc3RvcnlIVE1MNTtcblxuICAgIGZ1bmN0aW9uIEhpc3RvcnlIYXNoKCkge1xuICAgICAgICBIaXN0b3J5SGFzaC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgWS5leHRlbmQoSGlzdG9yeUhhc2gsIEhpc3RvcnlCYXNlLCB7XG4gICAgICAgIC8vIC0tIEluaXRpYWxpemF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgX2luaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBib29rbWFya2VkU3RhdGUgPSBIaXN0b3J5SGFzaC5wYXJzZUhhc2goKTtcblxuICAgICAgICAgICAgLy8gSWYgYW4gaW5pdGlhbFN0YXRlIHdhcyBwcm92aWRlZCwgbWVyZ2UgdGhlIGJvb2ttYXJrZWQgc3RhdGUgaW50byBpdFxuICAgICAgICAgICAgLy8gKHRoZSBib29rbWFya2VkIHN0YXRlIHdpbnMpLlxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsU3RhdGUgPSBjb25maWcuaW5pdGlhbFN0YXRlID9cbiAgICAgICAgICAgICAgICAgICAgWS5tZXJnZShjb25maWcuaW5pdGlhbFN0YXRlLCBib29rbWFya2VkU3RhdGUpIDogYm9va21hcmtlZFN0YXRlO1xuXG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHN5bnRoZXRpYyBoYXNoY2hhbmdlIGV2ZW50IChkZWZpbmVkIGJlbG93KSB0byBoYW5kbGVcbiAgICAgICAgICAgIC8vIGNoYW5nZXMuXG4gICAgICAgICAgICBZLmFmdGVyKCdoYXNoY2hhbmdlJywgWS5iaW5kKHRoaXMuX2FmdGVySGFzaENoYW5nZSwgdGhpcyksIHdpbik7XG5cbiAgICAgICAgICAgIEhpc3RvcnlIYXNoLnN1cGVyY2xhc3MuX2luaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyAtLSBQcm90ZWN0ZWQgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIF9jaGFuZ2U6IGZ1bmN0aW9uIChzcmMsIHN0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdpZnkgYWxsIHZhbHVlcyB0byBlbnN1cmUgdGhhdCBjb21wYXJpc29ucyBkb24ndCBmYWlsIGFmdGVyXG4gICAgICAgICAgICAvLyB0aGV5J3JlIGNvZXJjZWQgdG8gc3RyaW5ncyBpbiB0aGUgbG9jYXRpb24gaGFzaC5cbiAgICAgICAgICAgIFlPYmplY3QuZWFjaChzdGF0ZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoTGFuZy5pc1ZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIEhpc3RvcnlIYXNoLnN1cGVyY2xhc3MuX2NoYW5nZS5jYWxsKHRoaXMsIHNyYywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zdG9yZVN0YXRlOiBmdW5jdGlvbiAoc3JjLCBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgdmFyIGRlY29kZSAgPSBIaXN0b3J5SGFzaC5kZWNvZGUsXG4gICAgICAgICAgICAgICAgbmV3SGFzaCA9IEhpc3RvcnlIYXNoLmNyZWF0ZUhhc2gobmV3U3RhdGUpO1xuXG4gICAgICAgICAgICBIaXN0b3J5SGFzaC5zdXBlcmNsYXNzLl9zdG9yZVN0YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYXRpb24gaGFzaCB3aXRoIHRoZSBjaGFuZ2VzLCBidXQgb25seSBpZiB0aGUgbmV3IGhhc2hcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGRpZmZlcnMgZnJvbSB0aGUgY3VycmVudCBoYXNoICh0aGlzIGF2b2lkcyBjcmVhdGluZyBtdWx0aXBsZVxuICAgICAgICAgICAgLy8gaGlzdG9yeSBlbnRyaWVzIGZvciBhIHNpbmdsZSBzdGF0ZSkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIGNvbXBhcmUgZGVjb2RlZCBoYXNoZXMsIHNpbmNlIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgaGFzaFxuICAgICAgICAgICAgLy8gY291bGQgYmUgc2V0IGluY29ycmVjdGx5IHRvIGEgbm9uLWVuY29kZWQgdmFsdWUgb3V0c2lkZSBvZlxuICAgICAgICAgICAgLy8gSGlzdG9yeUhhc2guXG4gICAgICAgICAgICBpZiAoc3JjICE9PSBTUkNfSEFTSCAmJiBkZWNvZGUoSGlzdG9yeUhhc2guZ2V0SGFzaCgpKSAhPT0gZGVjb2RlKG5ld0hhc2gpKSB7XG4gICAgICAgICAgICAgICAgSGlzdG9yeUhhc2hbc3JjID09PSBIaXN0b3J5QmFzZS5TUkNfUkVQTEFDRSA/ICdyZXBsYWNlSGFzaCcgOiAnc2V0SGFzaCddKG5ld0hhc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIC0tIFByb3RlY3RlZCBFdmVudCBIYW5kbGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlciBmb3IgaGFzaGNoYW5nZSBldmVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgX2FmdGVySGFzaENoYW5nZVxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIF9hZnRlckhhc2hDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlQ2hhbmdlcyhTUkNfSEFTSCwgSGlzdG9yeUhhc2gucGFyc2VIYXNoKGUubmV3SGFzaCksIHt9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgLy8gLS0gUHVibGljIFN0YXRpYyBQcm9wZXJ0aWVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBOQU1FOiAnaGlzdG9yeUhhc2gnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB1c2VkIHRvIGlkZW50aWZ5IHN0YXRlIGNoYW5nZXMgb3JpZ2luYXRpbmcgZnJvbVxuICAgICAgICAgKiA8Y29kZT5oYXNoY2hhbmdlPC9jb2RlPiBldmVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTUkNfSEFTSFxuICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIFNSQ19IQVNIOiBTUkNfSEFTSCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIFByZWZpeCB0byBwcmVwZW5kIHdoZW4gc2V0dGluZyB0aGUgaGFzaCBmcmFnbWVudC4gRm9yIGV4YW1wbGUsIGlmIHRoZVxuICAgICAgICAgKiBwcmVmaXggaXMgPGNvZGU+ITwvY29kZT4gYW5kIHRoZSBoYXNoIGZyYWdtZW50IGlzIHNldCB0b1xuICAgICAgICAgKiA8Y29kZT4jZm9vPWJhciZiYXo9cXV1eDwvY29kZT4sIHRoZSBmaW5hbCBoYXNoIGZyYWdtZW50IGluIHRoZSBVUkwgd2lsbFxuICAgICAgICAgKiBiZWNvbWUgPGNvZGU+IyFmb289YmFyJmJhej1xdXV4PC9jb2RlPi4gVGhpcyBjYW4gYmUgdXNlZCB0byBoZWxwIG1ha2UgYW5cbiAgICAgICAgICogQWpheCBhcHBsaWNhdGlvbiBjcmF3bGFibGUgaW4gYWNjb3JkYW5jZSB3aXRoIEdvb2dsZSdzIGd1aWRlbGluZXMgYXRcbiAgICAgICAgICogPGEgaHJlZj1cImh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vd2ViL2FqYXhjcmF3bGluZy9cIj5odHRwOi8vY29kZS5nb29nbGUuY29tL3dlYi9hamF4Y3Jhd2xpbmcvPC9hPi5cbiAgICAgICAgICogPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcHJlZml4IGFwcGxpZXMgdG8gYWxsIEhpc3RvcnlIYXNoIGluc3RhbmNlcy4gSXQncyBub3RcbiAgICAgICAgICogcG9zc2libGUgZm9yIGluZGl2aWR1YWwgaW5zdGFuY2VzIHRvIHVzZSB0aGVpciBvd24gcHJlZml4ZXMgc2luY2UgdGhleVxuICAgICAgICAgKiBhbGwgb3BlcmF0ZSBvbiB0aGUgc2FtZSBVUkwuXG4gICAgICAgICAqIDwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGhhc2hQcmVmaXhcbiAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGhhc2hQcmVmaXg6ICcnLFxuXG4gICAgICAgIC8vIC0tIFByb3RlY3RlZCBTdGF0aWMgUHJvcGVydGllcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gcGFyc2UgbG9jYXRpb24gaGFzaC9xdWVyeSBzdHJpbmdzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX1JFR0VYX0hBU0hcbiAgICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIF9SRUdFWF9IQVNIOiAvKFteXFw/IyY9XSspPT8oW14mPV0qKS9nLFxuXG4gICAgICAgIC8vIC0tIFB1YmxpYyBTdGF0aWMgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGxvY2F0aW9uIGhhc2ggc3RyaW5nIGZyb20gdGhlIHNwZWNpZmllZCBvYmplY3Qgb2Yga2V5L3ZhbHVlXG4gICAgICAgICAqIHBhaXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZUhhc2hcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhcmFtZXRlciBwYWlyc1xuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGxvY2F0aW9uIGhhc2ggc3RyaW5nXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUhhc2g6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBlbmNvZGUgPSBIaXN0b3J5SGFzaC5lbmNvZGUsXG4gICAgICAgICAgICAgICAgaGFzaCAgID0gW107XG5cbiAgICAgICAgICAgIFlPYmplY3QuZWFjaChwYXJhbXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKExhbmcuaXNWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaC5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBoYXNoLmpvaW4oJyYnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcHBlciBhcm91bmQgPGNvZGU+ZGVjb2RlVVJJQ29tcG9uZW50KCk8L2NvZGU+IHRoYXQgYWxzbyBjb252ZXJ0cyArXG4gICAgICAgICAqIGNoYXJzIGludG8gc3BhY2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGRlY29kZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIHN0cmluZyB0byBkZWNvZGVcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBkZWNvZGVkIHN0cmluZ1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyaW5nLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcHBlciBhcm91bmQgPGNvZGU+ZW5jb2RlVVJJQ29tcG9uZW50KCk8L2NvZGU+IHRoYXQgY29udmVydHMgc3BhY2VzIHRvXG4gICAgICAgICAqICsgY2hhcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgc3RyaW5nIHRvIGVuY29kZVxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgc3RyaW5nXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSByYXcgKG5vdCBkZWNvZGVkKSBjdXJyZW50IGxvY2F0aW9uIGhhc2gsIG1pbnVzIHRoZSBwcmVjZWRpbmcgJyMnXG4gICAgICAgICAqIGNoYXJhY3RlciBhbmQgdGhlIGhhc2hQcmVmaXggKGlmIG9uZSBpcyBzZXQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGdldEhhc2hcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBjdXJyZW50IGxvY2F0aW9uIGhhc2hcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGFzaDogKFkuVUEuZ2Vja28gPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBHZWNrbydzIHdpbmRvdy5sb2NhdGlvbi5oYXNoIHJldHVybnMgYSBkZWNvZGVkIHN0cmluZyBhbmQgd2Ugd2FudCBhbGxcbiAgICAgICAgICAgIC8vIGVuY29kaW5nIHVudG91Y2hlZCwgc28gd2UgbmVlZCB0byBnZXQgdGhlIGhhc2ggdmFsdWUgZnJvbVxuICAgICAgICAgICAgLy8gd2luZG93LmxvY2F0aW9uLmhyZWYgaW5zdGVhZC4gV2UgaGF2ZSB0byB1c2UgVUEgc25pZmZpbmcgcmF0aGVyIHRoYW5cbiAgICAgICAgICAgIC8vIGZlYXR1cmUgZGV0ZWN0aW9uLCBzaW5jZSB0aGUgb25seSB3YXkgdG8gZGV0ZWN0IHRoaXMgd291bGQgYmUgdG9cbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGNoYW5nZSB0aGUgaGFzaC5cbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IFkuZ2V0TG9jYXRpb24oKSxcbiAgICAgICAgICAgICAgICBtYXRjaGVzICA9IC8jKC4qKSQvLmV4ZWMobG9jYXRpb24uaHJlZiksXG4gICAgICAgICAgICAgICAgaGFzaCAgICAgPSBtYXRjaGVzICYmIG1hdGNoZXNbMV0gfHwgJycsXG4gICAgICAgICAgICAgICAgcHJlZml4ICAgPSBIaXN0b3J5SGFzaC5oYXNoUHJlZml4O1xuXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICYmIGhhc2guaW5kZXhPZihwcmVmaXgpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2gucmVwbGFjZShwcmVmaXgsICcnKSA6IGhhc2g7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBZLmdldExvY2F0aW9uKCksXG4gICAgICAgICAgICAgICAgaGFzaCAgICAgPSBsb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKSxcbiAgICAgICAgICAgICAgICBwcmVmaXggICA9IEhpc3RvcnlIYXNoLmhhc2hQcmVmaXg7XG5cbiAgICAgICAgICAgIC8vIFNsaWdodCBjb2RlIGR1cGxpY2F0aW9uIGhlcmUsIGJ1dCBleGVjdXRpb24gc3BlZWQgaXMgb2YgdGhlIGVzc2VuY2VcbiAgICAgICAgICAgIC8vIHNpbmNlIGdldEhhc2goKSBpcyBjYWxsZWQgZXZlcnkgNTBtcyB0byBwb2xsIGZvciBjaGFuZ2VzIGluIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyB0aGF0IGRvbid0IHN1cHBvcnQgbmF0aXZlIG9uaGFzaGNoYW5nZS4gQW4gYWRkaXRpb25hbCBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICAvLyB3b3VsZCBhZGQgdW5uZWNlc3Nhcnkgb3ZlcmhlYWQuXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICYmIGhhc2guaW5kZXhPZihwcmVmaXgpID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2gucmVwbGFjZShwcmVmaXgsICcnKSA6IGhhc2g7XG4gICAgICAgIH0pLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGJvb2ttYXJrYWJsZSBVUkwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgZ2V0VXJsXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gY3VycmVudCBib29rbWFya2FibGUgVVJMXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGdldFVybDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIGxvY2F0aW9uIGhhc2ggc3RyaW5nIGludG8gYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYXJhbWV0ZXJcbiAgICAgICAgICogcGFpcnMuIElmIDxpPmhhc2g8L2k+IGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjdXJyZW50IGxvY2F0aW9uIGhhc2ggd2lsbFxuICAgICAgICAgKiBiZSB1c2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHBhcnNlSGFzaFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFzaCAob3B0aW9uYWwpIGxvY2F0aW9uIGhhc2ggc3RyaW5nXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IG9mIHBhcnNlZCBrZXkvdmFsdWUgcGFyYW1ldGVyIHBhaXJzXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlSGFzaDogZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgICAgIHZhciBkZWNvZGUgPSBIaXN0b3J5SGFzaC5kZWNvZGUsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBsZW4sXG4gICAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBwYXJhbSxcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB7fSxcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBIaXN0b3J5SGFzaC5oYXNoUHJlZml4LFxuICAgICAgICAgICAgICAgIHByZWZpeEluZGV4O1xuXG4gICAgICAgICAgICBoYXNoID0gTGFuZy5pc1ZhbHVlKGhhc2gpID8gaGFzaCA6IEhpc3RvcnlIYXNoLmdldEhhc2goKTtcblxuICAgICAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgICAgIHByZWZpeEluZGV4ID0gaGFzaC5pbmRleE9mKHByZWZpeCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlZml4SW5kZXggPT09IDAgfHwgKHByZWZpeEluZGV4ID09PSAxICYmIGhhc2guY2hhckF0KDApID09PSAnIycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBoYXNoLnJlcGxhY2UocHJlZml4LCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRjaGVzID0gaGFzaC5tYXRjaChIaXN0b3J5SGFzaC5fUkVHRVhfSEFTSCkgfHwgW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG1hdGNoZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXNbaV07XG5cbiAgICAgICAgICAgICAgICBwYXJhbSA9IG1hdGNoLnNwbGl0KCc9Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyYW0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbZGVjb2RlKHBhcmFtWzBdKV0gPSBkZWNvZGUocGFyYW1bMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tkZWNvZGUobWF0Y2gpXSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwbGFjZXMgdGhlIGJyb3dzZXIncyBjdXJyZW50IGxvY2F0aW9uIGhhc2ggd2l0aCB0aGUgc3BlY2lmaWVkIGhhc2hcbiAgICAgICAgICogYW5kIHJlbW92ZXMgYWxsIGZvcndhcmQgbmF2aWdhdGlvbiBzdGF0ZXMsIHdpdGhvdXQgY3JlYXRpbmcgYSBuZXcgYnJvd3NlclxuICAgICAgICAgKiBoaXN0b3J5IGVudHJ5LiBBdXRvbWF0aWNhbGx5IHByZXBlbmRzIHRoZSA8Y29kZT5oYXNoUHJlZml4PC9jb2RlPiBpZiBvbmVcbiAgICAgICAgICogaXMgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlcGxhY2VIYXNoXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoIG5ldyBsb2NhdGlvbiBoYXNoXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHJlcGxhY2VIYXNoOiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gWS5nZXRMb2NhdGlvbigpLFxuICAgICAgICAgICAgICAgIGJhc2UgICAgID0gbG9jYXRpb24uaHJlZi5yZXBsYWNlKC8jLiokLywgJycpO1xuXG4gICAgICAgICAgICBpZiAoaGFzaC5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgICAgIGhhc2ggPSBoYXNoLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9jYXRpb24ucmVwbGFjZShiYXNlICsgJyMnICsgKEhpc3RvcnlIYXNoLmhhc2hQcmVmaXggfHwgJycpICsgaGFzaCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGJyb3dzZXIncyBsb2NhdGlvbiBoYXNoIHRvIHRoZSBzcGVjaWZpZWQgc3RyaW5nLiBBdXRvbWF0aWNhbGx5XG4gICAgICAgICAqIHByZXBlbmRzIHRoZSA8Y29kZT5oYXNoUHJlZml4PC9jb2RlPiBpZiBvbmUgaXMgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHNldEhhc2hcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGhhc2ggbmV3IGxvY2F0aW9uIGhhc2hcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgc2V0SGFzaDogZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IFkuZ2V0TG9jYXRpb24oKTtcblxuICAgICAgICAgICAgaWYgKGhhc2guY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICBoYXNoID0gaGFzaC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvY2F0aW9uLmhhc2ggPSAoSGlzdG9yeUhhc2guaGFzaFByZWZpeCB8fCAnJykgKyBoYXNoO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAtLSBTeW50aGV0aWMgaGFzaGNoYW5nZSBFdmVudCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gVE9ETzogWVVJRG9jIGN1cnJlbnRseSBkb2Vzbid0IHByb3ZpZGUgYSBnb29kIHdheSB0byBkb2N1bWVudCBzeW50aGV0aWMgRE9NXG4gICAgLy8gZXZlbnRzLiBGb3Igbm93LCB3ZSdyZSBqdXN0IGRvY3VtZW50aW5nIHRoZSBoYXNoY2hhbmdlIGV2ZW50IG9uIHRoZSBZVUlcbiAgICAvLyBvYmplY3QsIHdoaWNoIGlzIGFib3V0IHRoZSBiZXN0IHdlIGNhbiBkbyB1bnRpbCBlbmhhbmNlbWVudHMgYXJlIG1hZGUgdG9cbiAgICAvLyBZVUlEb2MuXG5cbiAgICAvKipcbiAgICBTeW50aGV0aWMgPGNvZGU+d2luZG93Lm9uaGFzaGNoYW5nZTwvY29kZT4gZXZlbnQgdGhhdCBub3JtYWxpemVzIGRpZmZlcmVuY2VzXG4gICAgYWNyb3NzIGJyb3dzZXJzIGFuZCBwcm92aWRlcyBzdXBwb3J0IGZvciBicm93c2VycyB0aGF0IGRvbid0IG5hdGl2ZWx5IHN1cHBvcnRcbiAgICA8Y29kZT5vbmhhc2hjaGFuZ2U8L2NvZGU+LlxuXG4gICAgVGhpcyBldmVudCBpcyBwcm92aWRlZCBieSB0aGUgPGNvZGU+aGlzdG9yeS1oYXNoPC9jb2RlPiBtb2R1bGUuXG5cbiAgICBAZXhhbXBsZVxuXG4gICAgICAgIFlVSSgpLnVzZSgnaGlzdG9yeS1oYXNoJywgZnVuY3Rpb24gKFkpIHtcbiAgICAgICAgICBZLm9uKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBoYXNoY2hhbmdlIGV2ZW50cyBvbiB0aGUgY3VycmVudCB3aW5kb3cuXG4gICAgICAgICAgfSwgWS5jb25maWcud2luKTtcbiAgICAgICAgfSk7XG5cbiAgICBAZXZlbnQgaGFzaGNoYW5nZVxuICAgIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGUgRXZlbnQgZmFjYWRlIHdpdGggdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsXG4gICAgICBwcm9wZXJ0aWVzOlxuXG4gICAgPGRsPlxuICAgICAgPGR0Pm9sZEhhc2g8L2R0PlxuICAgICAgPGRkPlxuICAgICAgICBQcmV2aW91cyBoYXNoIGZyYWdtZW50IHZhbHVlIGJlZm9yZSB0aGUgY2hhbmdlLlxuICAgICAgPC9kZD5cblxuICAgICAgPGR0Pm9sZFVybDwvZHQ+XG4gICAgICA8ZGQ+XG4gICAgICAgIFByZXZpb3VzIFVSTCAoaW5jbHVkaW5nIHRoZSBoYXNoIGZyYWdtZW50KSBiZWZvcmUgdGhlIGNoYW5nZS5cbiAgICAgIDwvZGQ+XG5cbiAgICAgIDxkdD5uZXdIYXNoPC9kdD5cbiAgICAgIDxkZD5cbiAgICAgICAgTmV3IGhhc2ggZnJhZ21lbnQgdmFsdWUgYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgICAgIDwvZGQ+XG5cbiAgICAgIDxkdD5uZXdVcmw8L2R0PlxuICAgICAgPGRkPlxuICAgICAgICBOZXcgVVJMIChpbmNsdWRpbmcgdGhlIGhhc2ggZnJhZ21lbnQpIGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgICA8L2RkPlxuICAgIDwvZGw+XG4gICAgQGZvciBZVUlcbiAgICBAc2luY2UgMy4yLjBcbiAgICAqKi9cblxuICAgIHZhciBfaGlzdG9yeUhhc2hFbnZJZCA9IFkuY29uZmlnLndpbi5fWVVJX0hJU1RPUllfSEFTSF9FTlZJUk9OTUVOVF9JRDtcbiAgICBpZiAoIV9oaXN0b3J5SGFzaEVudklkKSB7XG4gICAgICAgIF9oaXN0b3J5SGFzaEVudklkID0gWS5ndWlkKCk7XG4gICAgICAgIFkuY29uZmlnLndpbi5fWVVJX0hJU1RPUllfSEFTSF9FTlZJUk9OTUVOVF9JRCA9IF9oaXN0b3J5SGFzaEVudklkO1xuXG4gICAgICAgIGlmIChERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0ZWQgdGhlIGhhc2gnLCBfaGlzdG9yeUhhc2hFbnZJZCwgJyBmb3Igd2luZG93JywgWS5jb25maWcud2luKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdsb2JhbEhhc2hOb3RpZmllcnNCeVdpbmRvdyA9IEdsb2JhbEVudi5fbm90aWZpZXJzO1xuXG4gICAgaWYgKCFnbG9iYWxIYXNoTm90aWZpZXJzQnlXaW5kb3cpIHtcbiAgICAgICAgZ2xvYmFsSGFzaE5vdGlmaWVyc0J5V2luZG93ID0ge307XG4gICAgICAgIEdsb2JhbEVudi5fbm90aWZpZXJzID0gZ2xvYmFsSGFzaE5vdGlmaWVyc0J5V2luZG93O1xuICAgIH1cblxuICAgIGhhc2hOb3RpZmllcnNGb3JXaW5kb3cgPSBnbG9iYWxIYXNoTm90aWZpZXJzQnlXaW5kb3dbX2hpc3RvcnlIYXNoRW52SWRdO1xuXG4gICAgaWYgKCFoYXNoTm90aWZpZXJzRm9yV2luZG93KSB7XG4gICAgICAgIGhhc2hOb3RpZmllcnNGb3JXaW5kb3cgPSBbXTtcbiAgICAgICAgZ2xvYmFsSGFzaE5vdGlmaWVyc0J5V2luZG93W19oaXN0b3J5SGFzaEVudklkXSA9IGhhc2hOb3RpZmllcnNGb3JXaW5kb3c7XG4gICAgfVxuXG4gICAgWS5FdmVudC5kZWZpbmUoJ2hhc2hjaGFuZ2UnLCB7XG4gICAgICAgIG9uOiBmdW5jdGlvbiAobm9kZSwgc3Vic2NyaWJlciwgbm90aWZpZXIpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGlzIHN1YnNjcmlwdGlvbiBpZiB0aGUgbm9kZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIHRoZVxuICAgICAgICAgICAgLy8gd2luZG93IG9yIGRvY3VtZW50IGJvZHksIHNpbmNlIHRob3NlIGFyZSB0aGUgb25seSBlbGVtZW50cyB0aGF0XG4gICAgICAgICAgICAvLyBzaG91bGQgc3VwcG9ydCB0aGUgaGFzaGNoYW5nZSBldmVudC4gTm90ZSB0aGF0IHRoZSBib2R5IGNvdWxkIGFsc28gYmVcbiAgICAgICAgICAgIC8vIGEgZnJhbWVzZXQsIGJ1dCB0aGF0J3Mgb2theSBzaW5jZSBmcmFtZXNldHMgc3VwcG9ydCBoYXNoY2hhbmdlIHRvby5cbiAgICAgICAgICAgIGlmIChub2RlLmNvbXBhcmVUbyh3aW4pIHx8IG5vZGUuY29tcGFyZVRvKFkuY29uZmlnLmRvYy5ib2R5KSkge1xuICAgICAgICAgICAgICAgIGhhc2hOb3RpZmllcnNGb3JXaW5kb3cucHVzaChub3RpZmllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoOiBmdW5jdGlvbiAobm9kZSwgc3Vic2NyaWJlciwgbm90aWZpZXIpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IFlBcnJheS5pbmRleE9mKGhhc2hOb3RpZmllcnNGb3JXaW5kb3csIG5vdGlmaWVyKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGhhc2hOb3RpZmllcnNGb3JXaW5kb3cuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgb2xkSGFzaCA9IEhpc3RvcnlIYXNoLmdldEhhc2goKTtcbiAgICBvbGRVcmwgID0gSGlzdG9yeUhhc2guZ2V0VXJsKCk7XG5cbiAgICBpZiAoSGlzdG9yeUJhc2UubmF0aXZlSGFzaENoYW5nZSkge1xuICAgICAgICAvLyBXcmFwIHRoZSBicm93c2VyJ3MgbmF0aXZlIGhhc2hjaGFuZ2UgZXZlbnQgaWYgdGhlcmUncyBub3QgYWxyZWFkeSBhXG4gICAgICAgIC8vIGdsb2JhbCBsaXN0ZW5lci5cbiAgICAgICAgaWYgKCFHbG9iYWxFbnYuX2hhc2hIYW5kbGUpIHtcbiAgICAgICAgICAgIEdsb2JhbEVudi5faGFzaEhhbmRsZSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFHbG9iYWxFbnYuX2hhc2hIYW5kbGVbX2hpc3RvcnlIYXNoRW52SWRdKSB7XG4gICAgICAgICAgICBHbG9iYWxFbnYuX2hhc2hIYW5kbGVbX2hpc3RvcnlIYXNoRW52SWRdID0gWS5FdmVudC5hdHRhY2goJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdIYXNoID0gSGlzdG9yeUhhc2guZ2V0SGFzaCgpLFxuICAgICAgICAgICAgICAgICAgICBuZXdVcmwgID0gSGlzdG9yeUhhc2guZ2V0VXJsKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBjb3B5IG9mIHRoZSBoYXNoTm90aWZpZXJzRm9yV2luZG93IGFycmF5IHNpbmNlIGEgc3Vic2NyaWJlclxuICAgICAgICAgICAgICAgIC8vIGNvdWxkIGRldGFjaCBkdXJpbmcgaXRlcmF0aW9uIGFuZCBjYXVzZSB0aGUgYXJyYXkgdG8gYmUgcmUtaW5kZXhlZC5cbiAgICAgICAgICAgICAgICBZQXJyYXkuZWFjaChoYXNoTm90aWZpZXJzRm9yV2luZG93LmNvbmNhdCgpLCBmdW5jdGlvbiAobm90aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpZXIuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZXZlbnQgOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkSGFzaDogb2xkSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFVybCA6IG9sZFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0hhc2g6IG5ld0hhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdVcmwgOiBuZXdVcmxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBvbGRIYXNoID0gbmV3SGFzaDtcbiAgICAgICAgICAgICAgICBvbGRVcmwgID0gbmV3VXJsO1xuICAgICAgICAgICAgfSwgd2luKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0JpbmRlZCBoYXNoY2hhbmdlIGV2ZW50IGxpc3RlbmVyIGZvciAnLCBfaGlzdG9yeUhhc2hFbnZJZCwgJyBvbiB3aW5kb3cnLCBZLmNvbmZpZy53aW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBZLm9uKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBHbG9iYWxFbnYuX2hhc2hIYW5kbGVbX2hpc3RvcnlIYXNoRW52SWRdLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIEdsb2JhbEVudi5faGFzaEhhbmRsZVtfaGlzdG9yeUhhc2hFbnZJZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBHbG9iYWxFbnYuX2hhc2hIYW5kbGVbX2hpc3RvcnlIYXNoRW52SWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdERVRBQ0hFRCBoYXNoY2hhbmdlIGV2ZW50IGxpc3RlbmVyIGZvciAnLCBfaGlzdG9yeUhhc2hFbnZJZCwgJyBvbiB3aW5kb3cnLCBZLmNvbmZpZy53aW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFHbG9iYWxFbnYuX2hhc2hQb2xsKSB7XG4gICAgICAgICAgICBHbG9iYWxFbnYuX2hhc2hQb2xsID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZWdpbiBwb2xsaW5nIGZvciBsb2NhdGlvbiBoYXNoIGNoYW5nZXMgaWYgdGhlcmUncyBub3QgYWxyZWFkeSBhIGdsb2JhbFxuICAgICAgICAvLyBwb2xsIHJ1bm5pbmcuXG4gICAgICAgIGlmICghR2xvYmFsRW52Ll9oYXNoUG9sbFtfaGlzdG9yeUhhc2hFbnZJZF0pIHtcbiAgICAgICAgICAgIEdsb2JhbEVudi5faGFzaFBvbGxbX2hpc3RvcnlIYXNoRW52SWRdID0gWS5sYXRlcig1MCwgbnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdIYXNoID0gSGlzdG9yeUhhc2guZ2V0SGFzaCgpLFxuICAgICAgICAgICAgICAgICAgICBmYWNhZGUsIG5ld1VybDtcblxuICAgICAgICAgICAgICAgIGlmIChvbGRIYXNoICE9PSBuZXdIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VybCA9IEhpc3RvcnlIYXNoLmdldFVybCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2FkZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZEhhc2g6IG9sZEhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRVcmwgOiBvbGRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdIYXNoOiBuZXdIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VXJsIDogbmV3VXJsXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgb2xkSGFzaCA9IG5ld0hhc2g7XG4gICAgICAgICAgICAgICAgICAgIG9sZFVybCAgPSBuZXdVcmw7XG5cbiAgICAgICAgICAgICAgICAgICAgWUFycmF5LmVhY2goaGFzaE5vdGlmaWVyc0ZvcldpbmRvdy5jb25jYXQoKSwgZnVuY3Rpb24gKG5vdGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmllci5maXJlKGZhY2FkZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0JpbmRlZCBoYXNoY2hhbmdlIHBvbGxlciBmb3IgJywgX2hpc3RvcnlIYXNoRW52SWQsICcgb24gd2luZG93JywgWS5jb25maWcud2luKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgWS5vbignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgR2xvYmFsRW52Ll9oYXNoUG9sbFtfaGlzdG9yeUhhc2hFbnZJZF0uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgR2xvYmFsRW52Ll9oYXNoUG9sbFtfaGlzdG9yeUhhc2hFbnZJZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBHbG9iYWxFbnYuX2hhc2hQb2xsW19oaXN0b3J5SGFzaEVudklkXTtcblxuICAgICAgICAgICAgICAgIGlmIChERUJVRykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnREVUQUNIRUQgaGFzaGNoYW5nZSBwb2xsZXIgZm9yICcsIF9oaXN0b3J5SGFzaEVudklkLCAnIG9uIHdpbmRvdycsIFkuY29uZmlnLndpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBZLkhpc3RvcnlIYXNoID0gSGlzdG9yeUhhc2g7XG5cbiAgICAvLyBIaXN0b3J5SGFzaCB3aWxsIG5ldmVyIHdpbiBvdmVyIEhpc3RvcnlIVE1MNSB1bmxlc3MgdXNlSGlzdG9yeUhUTUw1IGlzIGZhbHNlLlxuICAgIGlmICh1c2VIaXN0b3J5SFRNTDUgPT09IGZhbHNlIHx8ICghWS5IaXN0b3J5ICYmIHVzZUhpc3RvcnlIVE1MNSAhPT0gdHJ1ZSAmJlxuICAgICAgICAgICAgKCFIaXN0b3J5QmFzZS5odG1sNSB8fCAhWS5IaXN0b3J5SFRNTDUpKSkge1xuICAgICAgICBZLkhpc3RvcnkgPSBIaXN0b3J5SGFzaDtcbiAgICB9XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImV2ZW50LXN5bnRoZXRpY1wiLCBcImhpc3RvcnktYmFzZVwiLCBcInl1aS1sYXRlclwiLCBcInNxdWFyZXNwYWNlLWJlZm9yZXVubG9hZFwiXX0pO1xuXG59KShZVUkpO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdoaXN0b3J5LWh0bWw1JywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBQcm92aWRlcyBicm93c2VyIGhpc3RvcnkgbWFuYWdlbWVudCB1c2luZyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkuXG4gKlxuICogQG1vZHVsZSBoaXN0b3J5XG4gKiBAc3VibW9kdWxlIGhpc3RvcnktaHRtbDVcbiAqIEBzaW5jZSAzLjIuMFxuICovXG5cbi8qKlxuICogPHA+XG4gKiBQcm92aWRlcyBicm93c2VyIGhpc3RvcnkgbWFuYWdlbWVudCB1c2luZyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkuXG4gKiA8L3A+XG4gKlxuICogPHA+XG4gKiBXaGVuIGNhbGxpbmcgdGhlIDxjb2RlPmFkZCgpPC9jb2RlPiwgPGNvZGU+YWRkVmFsdWUoKTwvY29kZT4sXG4gKiA8Y29kZT5yZXBsYWNlKCk8L2NvZGU+LCBvciA8Y29kZT5yZXBsYWNlVmFsdWUoKTwvY29kZT4gbWV0aG9kcyBvblxuICogPGNvZGU+SGlzdG9yeUhUTUw1PC9jb2RlPiwgdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIG9wdGlvbnMgYXJlIHN1cHBvcnRlZDpcbiAqIDwvcD5cbiAqXG4gKiA8ZGw+XG4gKiAgIDxkdD48c3Ryb25nPnRpdGxlIChTdHJpbmcpPC9zdHJvbmc+PC9kdD5cbiAqICAgPGRkPlxuICogICAgIFRpdGxlIHRvIHVzZSBmb3IgdGhlIG5ldyBoaXN0b3J5IGVudHJ5LiBCcm93c2VycyB3aWxsIHR5cGljYWxseSBkaXNwbGF5XG4gKiAgICAgdGhpcyB0aXRsZSB0byB0aGUgdXNlciBpbiB0aGUgZGV0YWlsZWQgaGlzdG9yeSB3aW5kb3cgb3IgaW4gYSBkcm9wZG93blxuICogICAgIG1lbnUgYXR0YWNoZWQgdG8gdGhlIGJhY2svZm9yd2FyZCBidXR0b25zLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGl0bGVcbiAqICAgICBvZiB0aGUgY3VycmVudCBkb2N1bWVudCB3aWxsIGJlIHVzZWQuXG4gKiAgIDwvZGQ+XG4gKlxuICogICA8ZHQ+PHN0cm9uZz51cmwgKFN0cmluZyk8L3N0cm9uZz48L2R0PlxuICogICA8ZGQ+XG4gKiAgICAgVVJMIHRvIGRpc3BsYXkgdG8gdGhlIHVzZXIgZm9yIHRoZSBuZXcgaGlzdG9yeSBlbnRyeS4gVGhpcyBVUkwgd2lsbCBiZVxuICogICAgIHZpc2libGUgaW4gdGhlIGJyb3dzZXIncyBhZGRyZXNzIGJhciBhbmQgd2lsbCBiZSB0aGUgYm9va21hcmtlZCBVUkwgaWZcbiAqICAgICB0aGUgdXNlciBib29rbWFya3MgdGhlIHBhZ2UuIEl0IG1heSBiZSBhIHJlbGF0aXZlIHBhdGggKFwiZm9vL2JhclwiKSwgYW5cbiAqICAgICBhYnNvbHV0ZSBwYXRoIChcIi9mb28vYmFyXCIpLCBvciBhIGZ1bGwgVVJMIChcImh0dHA6Ly9leGFtcGxlLmNvbS9mb28vYmFyXCIpLlxuICogICAgIElmIHlvdSBzcGVjaWZ5IGEgZnVsbCBVUkwsIHRoZSBvcmlnaW4gPGk+bXVzdDwvaT4gYmUgdGhlIHNhbWUgYXMgdGhlXG4gKiAgICAgb3JpZ2luIG9mIHRoZSBjdXJyZW50IHBhZ2UsIG9yIGFuIGVycm9yIHdpbGwgb2NjdXIuIElmIG5vIFVSTCBpc1xuICogICAgIHNwZWNpZmllZCwgdGhlIGN1cnJlbnQgVVJMIHdpbGwgbm90IGJlIGNoYW5nZWQuXG4gKiAgIDwvZGQ+XG4gKiA8L2RsPlxuICpcbiAqIEBjbGFzcyBIaXN0b3J5SFRNTDVcbiAqIEBleHRlbmRzIEhpc3RvcnlCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgKG9wdGlvbmFsKSBDb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuXG52YXIgSGlzdG9yeUJhc2UgICAgID0gWS5IaXN0b3J5QmFzZSxcbiAgICBMYW5nICAgICAgICAgICAgPSBZLkxhbmcsXG4gICAgd2luICAgICAgICAgICAgID0gWS5jb25maWcud2luLFxuICAgIHVzZUhpc3RvcnlIVE1MNSA9IFkuY29uZmlnLnVzZUhpc3RvcnlIVE1MNSxcblxuICAgIFNSQ19QT1BTVEFURSAgICA9ICdwb3BzdGF0ZScsXG4gICAgU1JDX1JFUExBQ0UgICAgID0gSGlzdG9yeUJhc2UuU1JDX1JFUExBQ0U7XG5cbmZ1bmN0aW9uIEhpc3RvcnlIVE1MNSgpIHtcbiAgICBIaXN0b3J5SFRNTDUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5ZLmV4dGVuZChIaXN0b3J5SFRNTDUsIEhpc3RvcnlCYXNlLCB7XG4gICAgLy8gLS0gSW5pdGlhbGl6YXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIF9pbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciBib29rbWFya2VkU3RhdGU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJvb2ttYXJrZWRTdGF0ZSA9IHdpbi5oaXN0b3J5LnN0YXRlO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGJvb2ttYXJrZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmVhdCBlbXB0eSBzdGF0ZSBvYmplY3RzIGFzIGBudWxsYCBzbyB0aGV5J3JlIG5vdCBwcm9jZXNzZWQgZnVydGhlci5cbiAgICAgICAgaWYgKFkuT2JqZWN0LmlzRW1wdHkoYm9va21hcmtlZFN0YXRlKSkge1xuICAgICAgICAgICAgYm9va21hcmtlZFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZyB8fCAoY29uZmlnID0ge30pO1xuXG4gICAgICAgIC8vIElmIGJvdGggdGhlIGluaXRpYWwgc3RhdGUgYW5kIHRoZSBib29rbWFya2VkIHN0YXRlIGFyZSBvYmplY3RzLCBtZXJnZVxuICAgICAgICAvLyB0aGVtIChib29rbWFya2VkIHN0YXRlIHdpbnMpLlxuICAgICAgICBpZiAoY29uZmlnLmluaXRpYWxTdGF0ZVxuICAgICAgICAgICAgICAgICYmIExhbmcudHlwZShjb25maWcuaW5pdGlhbFN0YXRlKSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAmJiBMYW5nLnR5cGUoYm9va21hcmtlZFN0YXRlKSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbFN0YXRlID0gWS5tZXJnZShjb25maWcuaW5pdGlhbFN0YXRlLCBib29rbWFya2VkU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgYm9va21hcmtlZCBzdGF0ZSBhbHdheXMgd2lucyBpZiB0aGVyZSBpcyBvbmUuIElmXG4gICAgICAgICAgICAvLyB0aGVyZSBpc24ndCBhIGJvb2ttYXJrZWQgc3RhdGUsIGhpc3RvcnktYmFzZSB3aWxsIHRha2UgY2FyZSBvZlxuICAgICAgICAgICAgLy8gZmFsbGluZyBiYWNrIHRvIGNvbmZpZy5pbml0aWFsU3RhdGUgb3IgbnVsbC5cbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxTdGF0ZSA9IGJvb2ttYXJrZWRTdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIFkub24oJ3BvcHN0YXRlJywgdGhpcy5fb25Qb3BTdGF0ZSwgd2luLCB0aGlzKTtcblxuICAgICAgICBIaXN0b3J5SFRNTDUuc3VwZXJjbGFzcy5faW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyAtLSBQcm90ZWN0ZWQgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgSGlzdG9yeUJhc2UncyA8Y29kZT5fc3RvcmVTdGF0ZSgpPC9jb2RlPiBhbmQgcHVzaGVzIG9yIHJlcGxhY2VzXG4gICAgICogYSBoaXN0b3J5IGVudHJ5IHVzaW5nIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSB3aGVuIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3N0b3JlU3RhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFNvdXJjZSBvZiB0aGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3U3RhdGUgTmV3IHN0YXRlIHRvIHN0b3JlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFplcm8gb3IgbW9yZSBvcHRpb25zLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc3RvcmVTdGF0ZTogZnVuY3Rpb24gKHNyYywgbmV3U3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHNyYyAhPT0gU1JDX1BPUFNUQVRFKSB7XG4gICAgICAgICAgICB3aW4uaGlzdG9yeVtzcmMgPT09IFNSQ19SRVBMQUNFID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJ10oXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50aXRsZSB8fCBZLmNvbmZpZy5kb2MudGl0bGUgfHwgJycsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgfHwgWS5jb25maWcuZG9jLlVSTFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEhpc3RvcnlIVE1MNS5zdXBlcmNsYXNzLl9zdG9yZVN0YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIC0tIFByb3RlY3RlZCBFdmVudCBIYW5kbGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHBvcHN0YXRlIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX29uUG9wU3RhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9vblBvcFN0YXRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlQ2hhbmdlcyhTUkNfUE9QU1RBVEUsIGUuX2V2ZW50LnN0YXRlIHx8IG51bGwpO1xuICAgIH1cbn0sIHtcbiAgICAvLyAtLSBQdWJsaWMgU3RhdGljIFByb3BlcnRpZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgTkFNRTogJ2hpc3RvcnlodG1sNScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCB1c2VkIHRvIGlkZW50aWZ5IHN0YXRlIGNoYW5nZXMgb3JpZ2luYXRpbmcgZnJvbVxuICAgICAqIDxjb2RlPnBvcHN0YXRlPC9jb2RlPiBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgU1JDX1BPUFNUQVRFXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIFNSQ19QT1BTVEFURTogU1JDX1BPUFNUQVRFXG59KTtcblxuaWYgKCFZLk5vZGUuRE9NX0VWRU5UUy5wb3BzdGF0ZSkge1xuICAgIFkuTm9kZS5ET01fRVZFTlRTLnBvcHN0YXRlID0gMTtcbn1cblxuWS5IaXN0b3J5SFRNTDUgPSBIaXN0b3J5SFRNTDU7XG5cbi8qKlxuICogPHA+XG4gKiBJZiA8Y29kZT50cnVlPC9jb2RlPiwgdGhlIDxjb2RlPlkuSGlzdG9yeTwvY29kZT4gYWxpYXMgd2lsbCBhbHdheXMgcG9pbnQgdG9cbiAqIDxjb2RlPlkuSGlzdG9yeUhUTUw1PC9jb2RlPiB3aGVuIHRoZSBoaXN0b3J5LWh0bWw1IG1vZHVsZSBpcyBsb2FkZWQsIGV2ZW4gaWZcbiAqIHRoZSBjdXJyZW50IGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IEhUTUw1IGhpc3RvcnkuXG4gKiA8L3A+XG4gKlxuICogPHA+XG4gKiBJZiA8Y29kZT5mYWxzZTwvY29kZT4sIHRoZSA8Y29kZT5ZLkhpc3Rvcnk8L2NvZGU+IGFsaWFzIHdpbGwgYWx3YXlzIHBvaW50IHRvXG4gKiA8Y29kZT5ZLkhpc3RvcnlIYXNoPC9jb2RlPiB3aGVuIHRoZSBoaXN0b3J5LWhhc2ggbW9kdWxlIGlzIGxvYWRlZCwgZXZlbiBpZlxuICogdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBIVE1MNSBoaXN0b3J5LlxuICogPC9wPlxuICpcbiAqIDxwPlxuICogSWYgbmVpdGhlciA8Y29kZT50cnVlPC9jb2RlPiBub3IgPGNvZGU+ZmFsc2U8L2NvZGU+LCB0aGVcbiAqIDxjb2RlPlkuSGlzdG9yeTwvY29kZT4gYWxpYXMgd2lsbCBwb2ludCB0byB0aGUgYmVzdCBhdmFpbGFibGUgaGlzdG9yeSBhZGFwdGVyXG4gKiB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICogPC9wPlxuICpcbiAqIEBwcm9wZXJ0eSB1c2VIaXN0b3J5SFRNTDVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqIEBmb3IgY29uZmlnXG4gKiBAc2luY2UgMy4yLjBcbiAqL1xuXG4vLyBIaXN0b3J5SFRNTDUgd2lsbCBhbHdheXMgd2luIG92ZXIgSGlzdG9yeUhhc2ggdW5sZXNzIHVzZUhpc3RvcnlIVE1MNSBpcyBmYWxzZVxuLy8gb3IgSFRNTDUgaGlzdG9yeSBpcyBub3Qgc3VwcG9ydGVkLlxuaWYgKHVzZUhpc3RvcnlIVE1MNSA9PT0gdHJ1ZSB8fCAodXNlSGlzdG9yeUhUTUw1ICE9PSBmYWxzZSAmJlxuICAgICAgICBIaXN0b3J5QmFzZS5odG1sNSkpIHtcbiAgICBZLkhpc3RvcnkgPSBIaXN0b3J5SFRNTDU7XG59XG5cblxufSwgJzMuMTcuMicsIHtcIm9wdGlvbmFsXCI6IFtcImpzb25cIl0sIFwicmVxdWlyZXNcIjogW1wiZXZlbnQtYmFzZVwiLCBcImhpc3RvcnktYmFzZVwiLCBcIm5vZGUtYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdpbnRsJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxudmFyIF9tb2RzID0ge30sXG5cbiAgICBST09UX0xBTkcgPSBcInl1aVJvb3RMYW5nXCIsXG4gICAgQUNUSVZFX0xBTkcgPSBcInl1aUFjdGl2ZUxhbmdcIixcbiAgICBOT05FID0gW107XG5cbi8qKlxuICogUHJvdmlkZXMgdXRpbGl0aWVzIHRvIHN1cHBvcnQgdGhlIG1hbmFnZW1lbnQgb2YgbG9jYWxpemVkIHJlc291cmNlcyAoc3RyaW5ncyBhbmQgZm9ybWF0dGluZyBwYXR0ZXJucykuXG4gKlxuICogQG1vZHVsZSBpbnRsXG4gKi9cblxuLyoqXG4gKiBUaGUgSW50bCB1dGlsaXR5IHByb3ZpZGVzIGEgY2VudHJhbCBsb2NhdGlvbiBmb3IgbWFuYWdpbmcgc2V0cyBvZiBsb2NhbGl6ZWQgcmVzb3VyY2VzIChzdHJpbmdzIGFuZCBmb3JtYXR0aW5nIHBhdHRlcm5zKS5cbiAqXG4gKiBAY2xhc3MgSW50bFxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqIEBzdGF0aWNcbiAqL1xuWS5taXgoWS5uYW1lc3BhY2UoXCJJbnRsXCIpLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCB0byByZXRyaWV2ZSB0aGUgbGFuZ3VhZ2UgaGFzaCBmb3IgYSBnaXZlbiBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9tb2RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZSBUaGUgbmFtZSBvZiB0aGUgbW9kdWxlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgaGFzaCBvZiBsb2NhbGl6ZWQgcmVzb3VyY2VzIGZvciB0aGUgbW9kdWxlLCBrZXllZCBieSBCQ1AgbGFuZ3VhZ2UgdGFnXG4gICAgICovXG4gICAgX21vZCA6IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICBpZiAoIV9tb2RzW21vZHVsZV0pIHtcbiAgICAgICAgICAgIF9tb2RzW21vZHVsZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX21vZHNbbW9kdWxlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGxhbmd1YWdlIGZvciB0aGUgZ2l2ZW4gbW9kdWxlLlxuICAgICAqXG4gICAgICogUmV0dXJucyBmYWxzZSBvbiBmYWlsdXJlLCB3aGljaCB3b3VsZCBoYXBwZW4gaWYgdGhlIGxhbmd1YWdlIGhhZCBub3QgYmVlbiByZWdpc3RlcmVkIHRocm91Z2ggdGhlIDxhIGhyZWY9XCIjbWV0aG9kX2FkZFwiPmFkZCgpPC9hPiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldExhbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGUgVGhlIG1vZHVsZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYW5nIFRoZSBCQ1AgNDcgbGFuZ3VhZ2UgdGFnLlxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIGlmIG5vdC5cbiAgICAgKi9cbiAgICBzZXRMYW5nIDogZnVuY3Rpb24obW9kdWxlLCBsYW5nKSB7XG4gICAgICAgIHZhciBsYW5ncyA9IHRoaXMuX21vZChtb2R1bGUpLFxuICAgICAgICAgICAgY3VyckxhbmcgPSBsYW5nc1tBQ1RJVkVfTEFOR10sXG4gICAgICAgICAgICBleGlzdHMgPSAhIWxhbmdzW2xhbmddO1xuXG4gICAgICAgIGlmIChleGlzdHMgJiYgbGFuZyAhPT0gY3VyckxhbmcpIHtcbiAgICAgICAgICAgIGxhbmdzW0FDVElWRV9MQU5HXSA9IGxhbmc7XG4gICAgICAgICAgICB0aGlzLmZpcmUoXCJpbnRsOmxhbmdDaGFuZ2VcIiwge21vZHVsZTogbW9kdWxlLCBwcmV2VmFsOiBjdXJyTGFuZywgbmV3VmFsOiAobGFuZyA9PT0gUk9PVF9MQU5HKSA/IFwiXCIgOiBsYW5nfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGFuZ3VhZ2UgZm9yIHRoZSBnaXZlbiBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldExhbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGUgVGhlIG1vZHVsZSBuYW1lLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIEJDUCA0NyBsYW5ndWFnZSB0YWcuXG4gICAgICovXG4gICAgZ2V0TGFuZyA6IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICB2YXIgbGFuZyA9IHRoaXMuX21vZChtb2R1bGUpW0FDVElWRV9MQU5HXTtcbiAgICAgICAgcmV0dXJuIChsYW5nID09PSBST09UX0xBTkcpID8gXCJcIiA6IGxhbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgaGFzaCBvZiBsb2NhbGl6ZWQgcmVzb3VyY2VzIGZvciB0aGUgZ2l2ZW4gbW9kdWxlIGFuZCBsYW5ndWFnZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGUgVGhlIG1vZHVsZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYW5nIFRoZSBCQ1AgNDcgbGFuZ3VhZ2UgdGFnLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHJpbmdzIFRoZSBoYXNoIG9mIGxvY2FsaXplZCB2YWx1ZXMsIGtleWVkIGJ5IHRoZSBzdHJpbmcgbmFtZS5cbiAgICAgKi9cbiAgICBhZGQgOiBmdW5jdGlvbihtb2R1bGUsIGxhbmcsIHN0cmluZ3MpIHtcbiAgICAgICAgbGFuZyA9IGxhbmcgfHwgUk9PVF9MQU5HO1xuICAgICAgICB0aGlzLl9tb2QobW9kdWxlKVtsYW5nXSA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMuc2V0TGFuZyhtb2R1bGUsIGxhbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtb2R1bGUncyBsb2NhbGl6ZWQgcmVzb3VyY2VzIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBsYW5ndWFnZSAoYXMgcHJvdmlkZWQgYnkgdGhlIDxhIGhyZWY9XCIjbWV0aG9kX2dldExhbmdcIj5nZXRMYW5nPC9hPiBtZXRob2QpLlxuICAgICAqIDxwPlxuICAgICAqIE9wdGlvbmFsbHksIHRoZSBsb2NhbGl6ZWQgcmVzb3VyY2VzIGZvciBhbHRlcm5hdGUgbGFuZ3VhZ2VzIHdoaWNoIGhhdmUgYmVlbiBhZGRlZCB0byBJbnRsIChzZWUgdGhlIDxhIGhyZWY9XCIjbWV0aG9kX2FkZFwiPmFkZDwvYT4gbWV0aG9kKSBjYW5cbiAgICAgKiBiZSByZXRyaWV2ZWQgYnkgcHJvdmlkaW5nIHRoZSBCQ1AgNDcgbGFuZ3VhZ2UgdGFnIGFzIHRoZSBsYW5nIHBhcmFtZXRlci5cbiAgICAgKiA8L3A+XG4gICAgICogQG1ldGhvZCBnZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGUgVGhlIG1vZHVsZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgT3B0aW9uYWwuIEEgc2luZ2xlIHJlc291cmNlIGtleS4gSWYgbm90IHByb3ZpZGVkLCByZXR1cm5zIGEgY29weSAoc2hhbGxvdyBjbG9uZSkgb2YgYWxsIHJlc291cmNlcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGFuZyBPcHRpb25hbC4gVGhlIEJDUCA0NyBsYW5ndWFnZSB0YWcuIElmIG5vdCBwcm92aWRlZCwgdGhlIG1vZHVsZSdzIGN1cnJlbnRseSBhY3RpdmUgbGFuZ3VhZ2UgaXMgdXNlZC5cbiAgICAgKiBAcmV0dXJuIFN0cmluZyB8IE9iamVjdCBBIGNvcHkgb2YgdGhlIG1vZHVsZSdzIGxvY2FsaXplZCByZXNvdXJjZXMsIG9yIGEgc2luZ2xlIHZhbHVlIGlmIGtleSBpcyBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBnZXQgOiBmdW5jdGlvbihtb2R1bGUsIGtleSwgbGFuZykge1xuICAgICAgICB2YXIgbW9kID0gdGhpcy5fbW9kKG1vZHVsZSksXG4gICAgICAgICAgICBzdHJzO1xuXG4gICAgICAgIGxhbmcgPSBsYW5nIHx8IG1vZFtBQ1RJVkVfTEFOR107XG4gICAgICAgIHN0cnMgPSBtb2RbbGFuZ10gfHwge307XG5cbiAgICAgICAgcmV0dXJuIChrZXkpID8gc3Ryc1trZXldIDogWS5tZXJnZShzdHJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiBsYW5ndWFnZXMgZm9yIHdoaWNoIGxvY2FsaXplZCByZXNvdXJjZXMgYXJlIGF2YWlsYWJsZSBmb3IgYSBnaXZlbiBtb2R1bGUsIGJhc2VkIG9uIHRoZSBtb2R1bGVcbiAgICAgKiBtZXRhLWRhdGEgKHBhcnQgb2YgbG9hZGVyKS4gSWYgbG9hZGVyIGlzIG5vdCBvbiB0aGUgcGFnZSwgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0QXZhaWxhYmxlTGFuZ3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kdWxlIFRoZSBuYW1lIG9mIHRoZSBtb2R1bGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIGxhbmd1YWdlcyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgZ2V0QXZhaWxhYmxlTGFuZ3MgOiBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IFkuRW52Ll9sb2FkZXIsXG4gICAgICAgICAgICBtb2QgPSBsb2FkZXIgJiYgbG9hZGVyLm1vZHVsZUluZm9bbW9kdWxlXSxcbiAgICAgICAgICAgIGxhbmdzID0gbW9kICYmIG1vZC5sYW5nO1xuICAgICAgICByZXR1cm4gKGxhbmdzKSA/IGxhbmdzLmNvbmNhdCgpIDogTk9ORTtcblxuICAgIH1cbn0pO1xuXG5ZLmF1Z21lbnQoWS5JbnRsLCBZLkV2ZW50VGFyZ2V0KTtcblxuLyoqXG4gKiBOb3RpZmljYXRpb24gZXZlbnQgdG8gaW5kaWNhdGUgd2hlbiB0aGUgbGFuZyBmb3IgYSBtb2R1bGUgaGFzIGNoYW5nZWQuIFRoZXJlIGlzIG5vIGRlZmF1bHQgYmVoYXZpb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnQsXG4gKiBzbyB0aGUgb24gYW5kIGFmdGVyIG1vbWVudHMgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQGV2ZW50IGludGw6bGFuZ0NoYW5nZVxuICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZSBUaGUgZXZlbnQgZmFjYWRlXG4gKiA8cD5UaGUgZXZlbnQgZmFjYWRlIGNvbnRhaW5zOjwvcD5cbiAqIDxkbD5cbiAqICAgICA8ZHQ+bW9kdWxlPC9kdD48ZGQ+VGhlIG5hbWUgb2YgdGhlIG1vZHVsZSBmb3Igd2hpY2ggdGhlIGxhbmd1YWdlIGNoYW5nZWQ8L2RkPlxuICogICAgIDxkdD5uZXdWYWw8L2R0PjxkZD5UaGUgbmV3IGxhbmd1YWdlIHRhZzwvZGQ+XG4gKiAgICAgPGR0PnByZXZWYWw8L2R0PjxkZD5UaGUgY3VycmVudCBsYW5ndWFnZSB0YWc8L2RkPlxuICogPC9kbD5cbiAqL1xuWS5JbnRsLnB1Ymxpc2goXCJpbnRsOmxhbmdDaGFuZ2VcIiwge2VtaXRGYWNhZGU6dHJ1ZX0pO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJpbnRsLWJhc2VcIiwgXCJldmVudC1jdXN0b21cIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnaW8tYmFzZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuQmFzZSBJTyBmdW5jdGlvbmFsaXR5LiBQcm92aWRlcyBiYXNpYyBYSFIgdHJhbnNwb3J0IHN1cHBvcnQuXG5cbkBtb2R1bGUgaW9cbkBzdWJtb2R1bGUgaW8tYmFzZVxuQGZvciBJT1xuKiovXG5cbnZhciAvLyBMaXN0IG9mIGV2ZW50cyB0aGF0IGNvbXByaXNlIHRoZSBJTyBldmVudCBsaWZlY3ljbGUuXG4gICAgRVZFTlRTID0gWydzdGFydCcsICdjb21wbGV0ZScsICdlbmQnLCAnc3VjY2VzcycsICdmYWlsdXJlJywgJ3Byb2dyZXNzJ10sXG5cbiAgICAvLyBXaGl0ZWxpc3Qgb2YgdXNlZCBYSFIgcmVzcG9uc2Ugb2JqZWN0IHByb3BlcnRpZXMuXG4gICAgWEhSX1BST1BTID0gWydzdGF0dXMnLCAnc3RhdHVzVGV4dCcsICdyZXNwb25zZVRleHQnLCAncmVzcG9uc2VYTUwnXSxcblxuICAgIHdpbiA9IFkuY29uZmlnLndpbixcbiAgICB1aWQgPSAwO1xuXG4vKipcblRoZSBJTyBjbGFzcyBpcyBhIHV0aWxpdHkgdGhhdCBicm9rZXJzIEhUVFAgcmVxdWVzdHMgdGhyb3VnaCBhIHNpbXBsaWZpZWRcbmludGVyZmFjZS4gIFNwZWNpZmljYWxseSwgaXQgYWxsb3dzIEphdmFTY3JpcHQgdG8gbWFrZSBIVFRQIHJlcXVlc3RzIHRvXG5hIHJlc291cmNlIHdpdGhvdXQgYSBwYWdlIHJlbG9hZC4gIFRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydCBmb3IgbWFraW5nXG5zYW1lLWRvbWFpbiByZXF1ZXN0cyBpcyB0aGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LiAgSU8gY2FuIGFsc28gdXNlXG5GbGFzaCwgaWYgc3BlY2lmaWVkIGFzIGEgdHJhbnNwb3J0LCBmb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLlxuXG5AY2xhc3MgSU9cbkBjb25zdHJ1Y3RvclxuQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBPYmplY3Qgb2YgRXZlbnRUYXJnZXQncyBwdWJsaXNoIG1ldGhvZCBjb25maWd1cmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIGNvbmZpZ3VyZSBJTydzIGV2ZW50cy5cbioqL1xuZnVuY3Rpb24gSU8gKGNvbmZpZykge1xuICAgIHZhciBpbyA9IHRoaXM7XG5cbiAgICBpby5fdWlkID0gJ2lvOicgKyB1aWQrKztcbiAgICBpby5faW5pdChjb25maWcpO1xuICAgIFkuaW8uX21hcFtpby5fdWlkXSA9IGlvO1xufVxuXG5JTy5wcm90b3R5cGUgPSB7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vICBQcm9wZXJ0aWVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAvKipcbiAgICAqIEEgY291bnRlciB0aGF0IGluY3JlbWVudHMgZm9yIGVhY2ggdHJhbnNhY3Rpb24uXG4gICAgKlxuICAgICogQHByb3BlcnR5IF9pZFxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKi9cbiAgICBfaWQ6IDAsXG5cbiAgIC8qKlxuICAgICogT2JqZWN0IG9mIElPIEhUVFAgaGVhZGVycyBzZW50IHdpdGggZWFjaCB0cmFuc2FjdGlvbi5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkgX2hlYWRlcnNcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICovXG4gICAgX2hlYWRlcnM6IHtcbiAgICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnIDogJ1hNTEh0dHBSZXF1ZXN0J1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogT2JqZWN0IHRoYXQgc3RvcmVzIHRpbWVvdXQgdmFsdWVzIGZvciBhbnkgdHJhbnNhY3Rpb24gd2l0aCBhIGRlZmluZWRcbiAgICAqIFwidGltZW91dFwiIGNvbmZpZ3VyYXRpb24gcHJvcGVydHkuXG4gICAgKlxuICAgICogQHByb3BlcnR5IF90aW1lb3V0XG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge09iamVjdH1cbiAgICAqL1xuICAgIF90aW1lb3V0OiB7fSxcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAgTWV0aG9kc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIF9pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIGlvID0gdGhpcywgaSwgbGVuO1xuXG4gICAgICAgIGlvLmNmZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgICBZLmF1Z21lbnQoaW8sIFkuRXZlbnRUYXJnZXQpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBFVkVOVFMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggSU8gZ2xvYmFsIGV2ZW50cyB3aXRoIGNvbmZpZ3VyYXRpb25zLCBpZiBhbnkuXG4gICAgICAgICAgICAvLyBJTyBnbG9iYWwgZXZlbnRzIGFyZSBzZXQgdG8gYnJvYWRjYXN0IGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICAvLyBUaGVzZSBldmVudHMgdXNlIHRoZSBcImlvOlwiIG5hbWVzcGFjZS5cbiAgICAgICAgICAgIGlvLnB1Ymxpc2goJ2lvOicgKyBFVkVOVFNbaV0sIFkubWVyZ2UoeyBicm9hZGNhc3Q6IDEgfSwgY29uZmlnKSk7XG4gICAgICAgICAgICAvLyBQdWJsaXNoIElPIHRyYW5zYWN0aW9uIGV2ZW50cyB3aXRoIGNvbmZpZ3VyYXRpb25zLCBpZlxuICAgICAgICAgICAgLy8gYW55LiAgVGhlc2UgZXZlbnRzIHVzZSB0aGUgXCJpby10cm46XCIgbmFtZXNwYWNlLlxuICAgICAgICAgICAgaW8ucHVibGlzaCgnaW8tdHJuOicgKyBFVkVOVFNbaV0sIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAvKipcbiAgICAqIE1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB1bmlxdWUgdHJhbnNhY3Rpb24gb2JqZWN0IGZvciBlYWNoIHJlcXVlc3QuXG4gICAgKlxuICAgICogQG1ldGhvZCBfY3JlYXRlXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyBDb25maWd1cmF0aW9uIG9iamVjdCBzdWJzZXQgdG8gZGV0ZXJtaW5lIGlmXG4gICAgKiAgICAgICAgICAgICAgICAgdGhlIHRyYW5zYWN0aW9uIGlzIGFuIFhEUiBvciBmaWxlIHVwbG9hZCxcbiAgICAqICAgICAgICAgICAgICAgICByZXF1aXJpbmcgYW4gYWx0ZXJuYXRlIHRyYW5zcG9ydC5cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUcmFuc2FjdGlvbiBpZFxuICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0XG4gICAgKi9cbiAgICBfY3JlYXRlOiBmdW5jdGlvbihjb25maWcsIGlkKSB7XG4gICAgICAgIHZhciBpbyA9IHRoaXMsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBpZCA6IFkuTGFuZy5pc051bWJlcihpZCkgPyBpZCA6IGlvLl9pZCsrLFxuICAgICAgICAgICAgICAgIHVpZDogaW8uX3VpZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsdCA9IGNvbmZpZy54ZHIgPyBjb25maWcueGRyLnVzZSA6IG51bGwsXG4gICAgICAgICAgICBmb3JtID0gY29uZmlnLmZvcm0gJiYgY29uZmlnLmZvcm0udXBsb2FkID8gJ2lmcmFtZScgOiBudWxsLFxuICAgICAgICAgICAgdXNlO1xuXG4gICAgICAgIGlmIChhbHQgPT09ICduYXRpdmUnKSB7XG4gICAgICAgICAgICAvLyBOb24tSUUgYW5kIElFID49IDEwICBjYW4gdXNlIFhIUiBsZXZlbCAyIGFuZCBub3QgcmVseSBvbiBhblxuICAgICAgICAgICAgLy8gZXh0ZXJuYWwgdHJhbnNwb3J0LlxuICAgICAgICAgICAgYWx0ID0gWS5VQS5pZSAmJiAhU1VQUE9SVFNfQ09SUyA/ICd4ZHInIDogbnVsbDtcblxuICAgICAgICAgICAgLy8gUHJldmVudCBcInByZS1mbGlnaHRcIiBPUFRJT05TIHJlcXVlc3QgYnkgcmVtb3ZpbmcgdGhlXG4gICAgICAgICAgICAvLyBgWC1SZXF1ZXN0ZWQtV2l0aGAgSFRUUCBoZWFkZXIgZnJvbSBDT1JTIHJlcXVlc3RzLiBUaGlzIGhlYWRlclxuICAgICAgICAgICAgLy8gY2FuIGJlIGFkZGVkIGJhY2sgb24gYSBwZXItcmVxdWVzdCBiYXNpcywgaWYgZGVzaXJlZC5cbiAgICAgICAgICAgIGlvLnNldEhlYWRlcignWC1SZXF1ZXN0ZWQtV2l0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXNlID0gYWx0IHx8IGZvcm07XG4gICAgICAgIHRyYW5zYWN0aW9uID0gdXNlID8gWS5tZXJnZShZLklPLmN1c3RvbVRyYW5zcG9ydCh1c2UpLCB0cmFuc2FjdGlvbikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFkubWVyZ2UoWS5JTy5kZWZhdWx0VHJhbnNwb3J0KCksIHRyYW5zYWN0aW9uKTtcblxuICAgICAgICBpZiAodHJhbnNhY3Rpb24ubm90aWZ5KSB7XG4gICAgICAgICAgICBjb25maWcubm90aWZ5ID0gZnVuY3Rpb24gKGUsIHQsIGMpIHsgaW8ubm90aWZ5KGUsIHQsIGMpOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1c2UpIHtcbiAgICAgICAgICAgIGlmICh3aW4gJiYgd2luLkZvcm1EYXRhICYmIGNvbmZpZy5kYXRhIGluc3RhbmNlb2Ygd2luLkZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYy51cGxvYWQub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlvLnByb2dyZXNzKHRyYW5zYWN0aW9uLCBlLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYy5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpby5sb2FkKHRyYW5zYWN0aW9uLCBlLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW8uZXJyb3IodHJhbnNhY3Rpb24sIGUsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi51cGxvYWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH0sXG5cbiAgICBfZGVzdHJveTogZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgaWYgKHdpbiAmJiAhdHJhbnNhY3Rpb24ubm90aWZ5ICYmICF0cmFuc2FjdGlvbi54ZHIpIHtcbiAgICAgICAgICAgIGlmIChYSFIgJiYgIXRyYW5zYWN0aW9uLnVwbG9hZCkge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhbnNhY3Rpb24udXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYy51cGxvYWQub25wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYy5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmMub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFkuVUEuaWUgJiYgIXRyYW5zYWN0aW9uLmUpIHtcbiAgICAgICAgICAgICAgICAvLyBJRSwgd2hlbiB1c2luZyBYTUxIdHRwUmVxdWVzdCBhcyBhbiBBY3RpdmVYIE9iamVjdCwgd2lsbCB0aHJvd1xuICAgICAgICAgICAgICAgIC8vIGEgXCJUeXBlIE1pc21hdGNoXCIgZXJyb3IgaWYgdGhlIGV2ZW50IGhhbmRsZXIgaXMgc2V0IHRvIFwibnVsbFwiLlxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmMuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uYyA9IG51bGw7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBNZXRob2QgZm9yIGNyZWF0aW5nIGFuZCBmaXJpbmcgZXZlbnRzLlxuICAgICpcbiAgICAqIEBtZXRob2QgX2V2dFxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgRXZlbnQgdG8gYmUgcHVibGlzaGVkLlxuICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBkYXRhIHN1YnNldCBmb3IgZXZlbnQgc3Vic2NyaXB0aW9uLlxuICAgICovXG4gICAgX2V2dDogZnVuY3Rpb24oZXZlbnROYW1lLCB0cmFuc2FjdGlvbiwgY29uZmlnKSB7XG4gICAgICAgIHZhciBpbyAgICAgICAgICA9IHRoaXMsIHBhcmFtcyxcbiAgICAgICAgICAgIGFyZ3MgICAgICAgID0gY29uZmlnWydhcmd1bWVudHMnXSxcbiAgICAgICAgICAgIGVtaXRGYWNhZGUgID0gaW8uY2ZnLmVtaXRGYWNhZGUsXG4gICAgICAgICAgICBnbG9iYWxFdmVudCA9IFwiaW86XCIgKyBldmVudE5hbWUsXG4gICAgICAgICAgICB0cm5FdmVudCAgICA9IFwiaW8tdHJuOlwiICsgZXZlbnROYW1lO1xuXG4gICAgICAgIC8vIFdvcmthcm91bmQgZm9yICMyNTMyMTA3XG4gICAgICAgIHRoaXMuZGV0YWNoKHRybkV2ZW50KTtcblxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZSkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYyA9IHsgc3RhdHVzOiAwLCBzdGF0dXNUZXh0OiB0cmFuc2FjdGlvbi5lIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJlIGV2ZW50IHdpdGggcGFyYW1ldGVycyBvciBhbiBFdmVudCBGYWNhZGUuXG4gICAgICAgIHBhcmFtcyA9IFsgZW1pdEZhY2FkZSA/XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IHRyYW5zYWN0aW9uLmlkLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uLmMsXG4gICAgICAgICAgICAgICAgY2ZnOiBjb25maWcsXG4gICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IGFyZ3NcbiAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uaWRcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoIWVtaXRGYWNhZGUpIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IEVWRU5UU1swXSB8fCBldmVudE5hbWUgPT09IEVWRU5UU1syXSkge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmV2dCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh0cmFuc2FjdGlvbi5ldnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRyYW5zYWN0aW9uLmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXMudW5zaGlmdChnbG9iYWxFdmVudCk7XG4gICAgICAgIC8vIEZpcmUgZ2xvYmFsIGV2ZW50cy5cbiAgICAgICAgaW8uZmlyZS5hcHBseShpbywgcGFyYW1zKTtcbiAgICAgICAgLy8gRmlyZSB0cmFuc2FjdGlvbiBldmVudHMsIGlmIHJlY2VpdmVycyBhcmUgZGVmaW5lZC5cbiAgICAgICAgaWYgKGNvbmZpZy5vbikge1xuICAgICAgICAgICAgcGFyYW1zWzBdID0gdHJuRXZlbnQ7XG4gICAgICAgICAgICBpby5vbmNlKHRybkV2ZW50LCBjb25maWcub25bZXZlbnROYW1lXSwgY29uZmlnLmNvbnRleHQgfHwgWSk7XG4gICAgICAgICAgICBpby5maXJlLmFwcGx5KGlvLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBGaXJlcyBldmVudCBcImlvOnN0YXJ0XCIgYW5kIGNyZWF0ZXMsIGZpcmVzIGEgdHJhbnNhY3Rpb24tc3BlY2lmaWNcbiAgICAqIHN0YXJ0IGV2ZW50LCBpZiBgY29uZmlnLm9uLnN0YXJ0YCBpcyBkZWZpbmVkLlxuICAgICpcbiAgICAqIEBtZXRob2Qgc3RhcnRcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24odHJhbnNhY3Rpb24sIGNvbmZpZykge1xuICAgICAgIC8qKlxuICAgICAgICAqIFNpZ25hbHMgdGhlIHN0YXJ0IG9mIGFuIElPIHJlcXVlc3QuXG4gICAgICAgICogQGV2ZW50IGlvOnN0YXJ0XG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX2V2dChFVkVOVFNbMF0sIHRyYW5zYWN0aW9uLCBjb25maWcpO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogRmlyZXMgZXZlbnQgXCJpbzpjb21wbGV0ZVwiIGFuZCBjcmVhdGVzLCBmaXJlcyBhXG4gICAgKiB0cmFuc2FjdGlvbi1zcGVjaWZpYyBcImNvbXBsZXRlXCIgZXZlbnQsIGlmIGNvbmZpZy5vbi5jb21wbGV0ZSBpc1xuICAgICogZGVmaW5lZC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIGNvbXBsZXRlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBjb25maWcpIHtcbiAgICAgICAvKipcbiAgICAgICAgKiBTaWduYWxzIHRoZSBjb21wbGV0aW9uIG9mIHRoZSByZXF1ZXN0LXJlc3BvbnNlIHBoYXNlIG9mIGFcbiAgICAgICAgKiB0cmFuc2FjdGlvbi4gUmVzcG9uc2Ugc3RhdHVzIGFuZCBkYXRhIGFyZSBhY2Nlc3NpYmxlLCBpZlxuICAgICAgICAqIGF2YWlsYWJsZSwgaW4gdGhpcyBldmVudC5cbiAgICAgICAgKiBAZXZlbnQgaW86Y29tcGxldGVcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXZ0KEVWRU5UU1sxXSwgdHJhbnNhY3Rpb24sIGNvbmZpZyk7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBGaXJlcyBldmVudCBcImlvOmVuZFwiIGFuZCBjcmVhdGVzLCBmaXJlcyBhIHRyYW5zYWN0aW9uLXNwZWNpZmljIFwiZW5kXCJcbiAgICAqIGV2ZW50LCBpZiBjb25maWcub24uZW5kIGlzIGRlZmluZWQuXG4gICAgKlxuICAgICogQG1ldGhvZCBlbmRcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBlbmQ6IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBjb25maWcpIHtcbiAgICAgICAvKipcbiAgICAgICAgKiBTaWduYWxzIHRoZSBlbmQgb2YgdGhlIHRyYW5zYWN0aW9uIGxpZmVjeWNsZS5cbiAgICAgICAgKiBAZXZlbnQgaW86ZW5kXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX2V2dChFVkVOVFNbMl0sIHRyYW5zYWN0aW9uLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kZXN0cm95KHRyYW5zYWN0aW9uKTtcbiAgICB9LFxuXG4gICAvKipcbiAgICAqIEZpcmVzIGV2ZW50IFwiaW86c3VjY2Vzc1wiIGFuZCBjcmVhdGVzLCBmaXJlcyBhIHRyYW5zYWN0aW9uLXNwZWNpZmljXG4gICAgKiBcInN1Y2Nlc3NcIiBldmVudCwgaWYgY29uZmlnLm9uLnN1Y2Nlc3MgaXMgZGVmaW5lZC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIHN1Y2Nlc3NcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBzdWNjZXNzOiBmdW5jdGlvbih0cmFuc2FjdGlvbiwgY29uZmlnKSB7XG4gICAgICAgLyoqXG4gICAgICAgICogU2lnbmFscyBhbiBIVFRQIHJlc3BvbnNlIHdpdGggc3RhdHVzIGluIHRoZSAyeHggcmFuZ2UuXG4gICAgICAgICogRmlyZXMgYWZ0ZXIgaW86Y29tcGxldGUuXG4gICAgICAgICogQGV2ZW50IGlvOnN1Y2Nlc3NcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXZ0KEVWRU5UU1szXSwgdHJhbnNhY3Rpb24sIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZW5kKHRyYW5zYWN0aW9uLCBjb25maWcpO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogRmlyZXMgZXZlbnQgXCJpbzpmYWlsdXJlXCIgYW5kIGNyZWF0ZXMsIGZpcmVzIGEgdHJhbnNhY3Rpb24tc3BlY2lmaWNcbiAgICAqIFwiZmFpbHVyZVwiIGV2ZW50LCBpZiBjb25maWcub24uZmFpbHVyZSBpcyBkZWZpbmVkLlxuICAgICpcbiAgICAqIEBtZXRob2QgZmFpbHVyZVxuICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGZhaWx1cmU6IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBjb25maWcpIHtcbiAgICAgICAvKipcbiAgICAgICAgKiBTaWduYWxzIGFuIEhUVFAgcmVzcG9uc2Ugd2l0aCBzdGF0dXMgb3V0c2lkZSBvZiB0aGUgMnh4IHJhbmdlLlxuICAgICAgICAqIEZpcmVzIGFmdGVyIGlvOmNvbXBsZXRlLlxuICAgICAgICAqIEBldmVudCBpbzpmYWlsdXJlXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX2V2dChFVkVOVFNbNF0sIHRyYW5zYWN0aW9uLCBjb25maWcpO1xuICAgICAgICB0aGlzLmVuZCh0cmFuc2FjdGlvbiwgY29uZmlnKTtcbiAgICB9LFxuXG4gICAvKipcbiAgICAqIEZpcmVzIGV2ZW50IFwiaW86cHJvZ3Jlc3NcIiBhbmQgY3JlYXRlcywgZmlyZXMgYSB0cmFuc2FjdGlvbi1zcGVjaWZpY1xuICAgICogXCJwcm9ncmVzc1wiIGV2ZW50IC0tIGZvciBYTUxIdHRwUmVxdWVzdCBmaWxlIHVwbG9hZCAtLSBpZlxuICAgICogY29uZmlnLm9uLnByb2dyZXNzIGlzIGRlZmluZWQuXG4gICAgKlxuICAgICogQG1ldGhvZCBwcm9ncmVzc1xuICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9ncmVzcyBldmVudC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHByb2dyZXNzOiBmdW5jdGlvbih0cmFuc2FjdGlvbiwgZSwgY29uZmlnKSB7XG4gICAgICAgLyoqXG4gICAgICAgICogU2lnbmFscyB0aGUgaW50ZXJhY3RpdmUgc3RhdGUgZHVyaW5nIGEgZmlsZSB1cGxvYWQgdHJhbnNhY3Rpb24uXG4gICAgICAgICogVGhpcyBldmVudCBmaXJlcyBhZnRlciBpbzpzdGFydCBhbmQgYmVmb3JlIGlvOmNvbXBsZXRlLlxuICAgICAgICAqIEBldmVudCBpbzpwcm9ncmVzc1xuICAgICAgICAqL1xuICAgICAgICB0cmFuc2FjdGlvbi5ldnQgPSBlO1xuICAgICAgICB0aGlzLl9ldnQoRVZFTlRTWzVdLCB0cmFuc2FjdGlvbiwgY29uZmlnKTtcbiAgICB9LFxuXG4gICAvKipcbiAgICAqIEZpcmVzIGV2ZW50IFwiaW86Y29tcGxldGVcIiBhbmQgY3JlYXRlcywgZmlyZXMgYSB0cmFuc2FjdGlvbi1zcGVjaWZpY1xuICAgICogXCJjb21wbGV0ZVwiIGV2ZW50IC0tIGZvciBYTUxIdHRwUmVxdWVzdCBmaWxlIHVwbG9hZCAtLSBpZlxuICAgICogY29uZmlnLm9uLmNvbXBsZXRlIGlzIGRlZmluZWQuXG4gICAgKlxuICAgICogQG1ldGhvZCBsb2FkXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICogQHBhcmFtIHtPYmplY3R9IGxvYWQgZXZlbnQuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGUsIGNvbmZpZykge1xuICAgICAgICB0cmFuc2FjdGlvbi5ldnQgPSBlLnRhcmdldDtcbiAgICAgICAgdGhpcy5fZXZ0KEVWRU5UU1sxXSwgdHJhbnNhY3Rpb24sIGNvbmZpZyk7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBGaXJlcyBldmVudCBcImlvOmZhaWx1cmVcIiBhbmQgY3JlYXRlcywgZmlyZXMgYSB0cmFuc2FjdGlvbi1zcGVjaWZpY1xuICAgICogXCJmYWlsdXJlXCIgZXZlbnQgLS0gZm9yIFhNTEh0dHBSZXF1ZXN0IGZpbGUgdXBsb2FkIC0tIGlmXG4gICAgKiBjb25maWcub24uZmFpbHVyZSBpcyBkZWZpbmVkLlxuICAgICpcbiAgICAqIEBtZXRob2QgZXJyb3JcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXJyb3IgZXZlbnQuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBlcnJvcjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBlLCBjb25maWcpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZXZ0ID0gZTtcbiAgICAgICAgdGhpcy5fZXZ0KEVWRU5UU1s0XSwgdHJhbnNhY3Rpb24sIGNvbmZpZyk7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBSZXRyeSBhbiBYRFIgdHJhbnNhY3Rpb24sIHVzaW5nIHRoZSBGbGFzaCB0cmFucG9ydCwgaWYgdGhlIG5hdGl2ZVxuICAgICogdHJhbnNwb3J0IGZhaWxzLlxuICAgICpcbiAgICAqIEBtZXRob2QgX3JldHJ5XG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgUXVhbGlmaWVkIHBhdGggdG8gdHJhbnNhY3Rpb24gcmVzb3VyY2UuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBfcmV0cnk6IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCB1cmksIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9kZXN0cm95KHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uZmlnLnhkci51c2UgPSAnZmxhc2gnO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHVyaSwgY29uZmlnLCB0cmFuc2FjdGlvbi5pZCk7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBNZXRob2QgdGhhdCBjb25jYXRlbmF0ZXMgc3RyaW5nIGRhdGEgZm9yIEhUVFAgR0VUIHRyYW5zYWN0aW9ucy5cbiAgICAqXG4gICAgKiBAbWV0aG9kIF9jb25jYXRcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJpIFVSSSBvciByb290IGRhdGEuXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBEYXRhIHRvIGJlIGNvbmNhdGVuYXRlZCBvbnRvIFVSSS5cbiAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAqL1xuICAgIF9jb25jYXQ6IGZ1bmN0aW9uKHVyaSwgZGF0YSkge1xuICAgICAgICB1cmkgKz0gKHVyaS5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIGRhdGE7XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBTdG9yZXMgZGVmYXVsdCBjbGllbnQgaGVhZGVycyBmb3IgYWxsIHRyYW5zYWN0aW9ucy4gSWYgYSBsYWJlbCBpc1xuICAgICogcGFzc2VkIHdpdGggbm8gdmFsdWUgYXJndW1lbnQsIHRoZSBoZWFkZXIgd2lsbCBiZSBkZWxldGVkLlxuICAgICpcbiAgICAqIEBtZXRob2Qgc2V0SGVhZGVyXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBIVFRQIGhlYWRlclxuICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIEhUVFAgaGVhZGVyIHZhbHVlXG4gICAgKi9cbiAgICBzZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAvKipcbiAgICAqIE1ldGhvZCB0aGF0IHNldHMgYWxsIEhUVFAgaGVhZGVycyB0byBiZSBzZW50IGluIGEgdHJhbnNhY3Rpb24uXG4gICAgKlxuICAgICogQG1ldGhvZCBfc2V0SGVhZGVyc1xuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiAtIFhIUiBpbnN0YW5jZSBmb3IgdGhlIHNwZWNpZmljIHRyYW5zYWN0aW9uLlxuICAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgLSBIVFRQIGhlYWRlcnMgZm9yIHRoZSBzcGVjaWZpYyB0cmFuc2FjdGlvbiwgYXNcbiAgICAqICAgICAgICAgICAgICAgICAgICBkZWZpbmVkIGluIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBwYXNzZWQgdG8gWVVJLmlvKCkuXG4gICAgKi9cbiAgICBfc2V0SGVhZGVyczogZnVuY3Rpb24odHJhbnNhY3Rpb24sIGhlYWRlcnMpIHtcbiAgICAgICAgaGVhZGVycyA9IFkubWVyZ2UodGhpcy5faGVhZGVycywgaGVhZGVycyk7XG4gICAgICAgIFkuT2JqZWN0LmVhY2goaGVhZGVycywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJ2Rpc2FibGUnKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBTdGFydHMgdGltZW91dCBjb3VudCBpZiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgaGFzIGEgZGVmaW5lZFxuICAgICogdGltZW91dCBwcm9wZXJ0eS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIF9zdGFydFRpbWVvdXRcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gb2JqZWN0IGdlbmVyYXRlZCBieSBfY3JlYXRlKCkuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdGltZW91dCBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAgICAqL1xuICAgIF9zdGFydFRpbWVvdXQ6IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCB0aW1lb3V0KSB7XG4gICAgICAgIHZhciBpbyA9IHRoaXM7XG5cbiAgICAgICAgaW8uX3RpbWVvdXRbdHJhbnNhY3Rpb24uaWRdID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlvLl9hYm9ydCh0cmFuc2FjdGlvbiwgJ3RpbWVvdXQnKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBDbGVhcnMgdGhlIHRpbWVvdXQgaW50ZXJ2YWwgc3RhcnRlZCBieSBfc3RhcnRUaW1lb3V0KCkuXG4gICAgKlxuICAgICogQG1ldGhvZCBfY2xlYXJUaW1lb3V0XG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIC0gVHJhbnNhY3Rpb24gaWQuXG4gICAgKi9cbiAgICBfY2xlYXJUaW1lb3V0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dFtpZF0pO1xuICAgICAgICBkZWxldGUgdGhpcy5fdGltZW91dFtpZF07XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBNZXRob2QgdGhhdCBkZXRlcm1pbmVzIGlmIGEgdHJhbnNhY3Rpb24gcmVzcG9uc2UgcXVhbGlmaWVzIGFzIHN1Y2Nlc3NcbiAgICAqIG9yIGZhaWx1cmUsIGJhc2VkIG9uIHRoZSByZXNwb25zZSBIVFRQIHN0YXR1cyBjb2RlLCBhbmQgZmlyZXMgdGhlXG4gICAgKiBhcHByb3ByaWF0ZSBzdWNjZXNzIG9yIGZhaWx1cmUgZXZlbnRzLlxuICAgICpcbiAgICAqIEBtZXRob2QgX3Jlc3VsdFxuICAgICogQHByaXZhdGVcbiAgICAqIEBzdGF0aWNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBvYmplY3QgZ2VuZXJhdGVkIGJ5IF9jcmVhdGUoKS5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgcGFzc2VkIHRvIGlvKCkuXG4gICAgKi9cbiAgICBfcmVzdWx0OiBmdW5jdGlvbih0cmFuc2FjdGlvbiwgY29uZmlnKSB7XG4gICAgICAgIHZhciBzdGF0dXM7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3NcbiAgICAgICAgLy8gYW4gWEhSIG9iamVjdCdzIHN0YXR1cyBwcm9wZXJ0eSwgYWZ0ZXIgYSByZXF1ZXN0IGlzIGFib3J0ZWQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGF0dXMgPSB0cmFuc2FjdGlvbi5jLnN0YXR1cztcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUUgcmVwb3J0cyBIVFRQIDIwNCBhcyBIVFRQIDEyMjMuXG4gICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNCB8fCBzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICAgIHRoaXMuc3VjY2Vzcyh0cmFuc2FjdGlvbiwgY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbHVyZSh0cmFuc2FjdGlvbiwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgIC8qKlxuICAgICogRXZlbnQgaGFuZGxlciBib3VuZCB0byBvbnJlYWR5c3RhdGVjaGFuZ2UuXG4gICAgKlxuICAgICogQG1ldGhvZCBfclNcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gb2JqZWN0IGdlbmVyYXRlZCBieSBfY3JlYXRlKCkuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IHBhc3NlZCB0byBZVUkuaW8oKS5cbiAgICAqL1xuICAgIF9yUzogZnVuY3Rpb24odHJhbnNhY3Rpb24sIGNvbmZpZykge1xuICAgICAgICB2YXIgaW8gPSB0aGlzO1xuXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5jLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcudGltZW91dCkge1xuICAgICAgICAgICAgICAgIGlvLl9jbGVhclRpbWVvdXQodHJhbnNhY3Rpb24uaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBZaWVsZCBpbiB0aGUgZXZlbnQgb2YgcmVxdWVzdCB0aW1lb3V0IG9yIGFib3J0LlxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpby5jb21wbGV0ZSh0cmFuc2FjdGlvbiwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpby5fcmVzdWx0KHRyYW5zYWN0aW9uLCBjb25maWcpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAvKipcbiAgICAqIFRlcm1pbmF0ZXMgYSB0cmFuc2FjdGlvbiBkdWUgdG8gYW4gZXhwbGljaXQgYWJvcnQgb3IgdGltZW91dC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIF9hYm9ydFxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBvYmplY3QgZ2VuZXJhdGVkIGJ5IF9jcmVhdGUoKS5cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIElkZW50aWZpZXMgdGltZWQgb3V0IG9yIGFib3J0ZWQgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBfYWJvcnQ6IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCB0eXBlKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbiAmJiB0cmFuc2FjdGlvbi5jKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5lID0gdHlwZTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmMuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgIC8qKlxuICAgICogUmVxdWVzdHMgYSB0cmFuc2FjdGlvbi4gYHNlbmQoKWAgaXMgaW1wbGVtZW50ZWQgYXMgYFkuaW8oKWAuICBFYWNoXG4gICAgKiB0cmFuc2FjdGlvbiBtYXkgaW5jbHVkZSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiAgSXRzIHByb3BlcnRpZXMgYXJlOlxuICAgICpcbiAgICAqIDxkbD5cbiAgICAqICAgPGR0Pm1ldGhvZDwvZHQ+XG4gICAgKiAgICAgPGRkPkhUVFAgbWV0aG9kIHZlcmIgKGUuZy4sIEdFVCBvciBQT1NUKS4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBub3RcbiAgICAqICAgICAgICAgbm90IGRlZmluZWQsIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgR0VULjwvZGQ+XG4gICAgKlxuICAgICogICA8ZHQ+ZGF0YTwvZHQ+XG4gICAgKiAgICAgPGRkPlRoaXMgaXMgdGhlIG5hbWUtdmFsdWUgc3RyaW5nIHRoYXQgd2lsbCBiZSBzZW50IGFzIHRoZVxuICAgICogICAgIHRyYW5zYWN0aW9uIGRhdGEuIElmIHRoZSByZXF1ZXN0IGlzIEhUVFAgR0VULCB0aGUgZGF0YSBiZWNvbWVcbiAgICAqICAgICBwYXJ0IG9mIHF1ZXJ5c3RyaW5nLiBJZiBIVFRQIFBPU1QsIHRoZSBkYXRhIGFyZSBzZW50IGluIHRoZVxuICAgICogICAgIG1lc3NhZ2UgYm9keS48L2RkPlxuICAgICpcbiAgICAqICAgPGR0PnhkcjwvZHQ+XG4gICAgKiAgICAgPGRkPkRlZmluZXMgdGhlIHRyYW5zcG9ydCB0byBiZSB1c2VkIGZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMuXG4gICAgKiAgICAgQnkgc2V0dGluZyB0aGlzIHByb3BlcnR5LCB0aGUgdHJhbnNhY3Rpb24gd2lsbCB1c2UgdGhlIHNwZWNpZmllZFxuICAgICogICAgIHRyYW5zcG9ydCBpbnN0ZWFkIG9mIFhNTEh0dHBSZXF1ZXN0LiBUaGUgcHJvcGVydGllcyBvZiB0aGVcbiAgICAqICAgICB0cmFuc3BvcnQgb2JqZWN0IGFyZTpcbiAgICAqICAgICA8ZGw+XG4gICAgKiAgICAgICA8ZHQ+dXNlPC9kdD5cbiAgICAqICAgICAgICAgPGRkPlRoZSB0cmFuc3BvcnQgdG8gYmUgdXNlZDogJ2ZsYXNoJyBvciAnbmF0aXZlJzwvZGQ+XG4gICAgKiAgICAgICA8ZHQ+ZGF0YVR5cGU8L2R0PlxuICAgICogICAgICAgICA8ZGQ+U2V0IHRoZSB2YWx1ZSB0byAnWE1MJyBpZiB0aGF0IGlzIHRoZSBleHBlY3RlZCByZXNwb25zZVxuICAgICogICAgICAgICBjb250ZW50IHR5cGUuPC9kZD5cbiAgICAqICAgICAgIDxkdD5jcmVkZW50aWFsczwvZHQ+XG4gICAgKiAgICAgICAgIDxkZD5TZXQgdGhlIHZhbHVlIHRvICd0cnVlJyB0byBzZXQgWEhSLndpdGhDcmVkZW50aWFscyBwcm9wZXJ0eSB0byB0cnVlLjwvZGQ+XG4gICAgKiAgICAgPC9kbD48L2RkPlxuICAgICpcbiAgICAqICAgPGR0PmZvcm08L2R0PlxuICAgICogICAgIDxkZD5Gb3JtIHNlcmlhbGl6YXRpb24gY29uZmlndXJhdGlvbiBvYmplY3QuICBJdHMgcHJvcGVydGllcyBhcmU6XG4gICAgKiAgICAgPGRsPlxuICAgICogICAgICAgPGR0PmlkPC9kdD5cbiAgICAqICAgICAgICAgPGRkPk5vZGUgb2JqZWN0IG9yIGlkIG9mIEhUTUwgZm9ybTwvZGQ+XG4gICAgKiAgICAgICA8ZHQ+dXNlRGlzYWJsZWQ8L2R0PlxuICAgICogICAgICAgICA8ZGQ+YHRydWVgIHRvIGFsc28gc2VyaWFsaXplIGRpc2FibGVkIGZvcm0gZmllbGQgdmFsdWVzXG4gICAgKiAgICAgICAgIChkZWZhdWx0cyB0byBgZmFsc2VgKTwvZGQ+XG4gICAgKiAgICAgPC9kbD48L2RkPlxuICAgICpcbiAgICAqICAgPGR0Pm9uPC9kdD5cbiAgICAqICAgICA8ZGQ+QXNzaWducyB0cmFuc2FjdGlvbiBldmVudCBzdWJzY3JpcHRpb25zLiBBdmFpbGFibGUgZXZlbnRzIGFyZTpcbiAgICAqICAgICA8ZGw+XG4gICAgKiAgICAgICA8ZHQ+c3RhcnQ8L2R0PlxuICAgICogICAgICAgICA8ZGQ+RmlyZXMgd2hlbiBhIHJlcXVlc3QgaXMgc2VudCB0byBhIHJlc291cmNlLjwvZGQ+XG4gICAgKiAgICAgICA8ZHQ+Y29tcGxldGU8L2R0PlxuICAgICogICAgICAgICA8ZGQ+RmlyZXMgd2hlbiB0aGUgdHJhbnNhY3Rpb24gaXMgY29tcGxldGUuPC9kZD5cbiAgICAqICAgICAgIDxkdD5zdWNjZXNzPC9kdD5cbiAgICAqICAgICAgICAgPGRkPkZpcmVzIHdoZW4gdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGlzIHdpdGhpbiB0aGUgMnh4XG4gICAgKiAgICAgICAgIHJhbmdlLjwvZGQ+XG4gICAgKiAgICAgICA8ZHQ+ZmFpbHVyZTwvZHQ+XG4gICAgKiAgICAgICAgIDxkZD5GaXJlcyB3aGVuIHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBpcyBvdXRzaWRlIHRoZSAyeHhcbiAgICAqICAgICAgICAgcmFuZ2UsIGlmIGFuIGV4Y2VwdGlvbiBvY2N1cnMsIGlmIHRoZSB0cmFuc2F0aW9uIGlzIGFib3J0ZWQsXG4gICAgKiAgICAgICAgIG9yIGlmIHRoZSB0cmFuc2FjdGlvbiBleGNlZWRzIGEgY29uZmlndXJlZCBgdGltZW91dGAuPC9kZD5cbiAgICAqICAgICAgIDxkdD5lbmQ8L2R0PlxuICAgICogICAgICAgICA8ZGQ+RmlyZXMgYXQgdGhlIGNvbmNsdXNpb24gb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgKiAgICAgICAgICAgIGxpZmVjeWNsZSwgYWZ0ZXIgYHN1Y2Nlc3NgIG9yIGBmYWlsdXJlYC48L2RkPlxuICAgICogICAgIDwvZGw+XG4gICAgKlxuICAgICogICAgIDxwPkNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgYHN0YXJ0YCBhbmQgYGVuZGAgcmVjZWl2ZSB0aGUgaWQgb2YgdGhlXG4gICAgKiAgICAgdHJhbnNhY3Rpb24gYXMgYSBmaXJzdCBhcmd1bWVudC4gRm9yIGBjb21wbGV0ZWAsIGBzdWNjZXNzYCwgYW5kXG4gICAgKiAgICAgYGZhaWx1cmVgLCBjYWxsYmFja3MgcmVjZWl2ZSB0aGUgaWQgYW5kIHRoZSByZXNwb25zZSBvYmplY3RcbiAgICAqICAgICAodXN1YWxseSB0aGUgWE1MSHR0cFJlcXVlc3QgaW5zdGFuY2UpLiAgSWYgdGhlIGBhcmd1bWVudHNgXG4gICAgKiAgICAgcHJvcGVydHkgd2FzIGluY2x1ZGVkIGluIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBwYXNzZWQgdG9cbiAgICAqICAgICBgWS5pbygpYCwgdGhlIGNvbmZpZ3VyZWQgZGF0YSB3aWxsIGJlIHBhc3NlZCB0byBhbGwgY2FsbGJhY2tzIGFzXG4gICAgKiAgICAgdGhlIGxhc3QgYXJndW1lbnQuPC9wPlxuICAgICogICAgIDwvZGQ+XG4gICAgKlxuICAgICogICA8ZHQ+c3luYzwvZHQ+XG4gICAgKiAgICAgPGRkPlBhc3MgYHRydWVgIHRvIG1ha2UgYSBzYW1lLWRvbWFpbiB0cmFuc2FjdGlvbiBzeW5jaHJvbm91cy5cbiAgICAqICAgICA8c3Ryb25nPkNBVkVBVDwvc3Ryb25nPjogVGhpcyB3aWxsIG5lZ2F0aXZlbHkgaW1wYWN0IHRoZSB1c2VyXG4gICAgKiAgICAgZXhwZXJpZW5jZS4gSGF2ZSBhIDxlbT52ZXJ5PC9lbT4gZ29vZCByZWFzb24gaWYgeW91IGludGVuZCB0byB1c2VcbiAgICAqICAgICB0aGlzLjwvZGQ+XG4gICAgKlxuICAgICogICA8ZHQ+Y29udGV4dDwvZHQ+XG4gICAgKiAgICAgPGRkPlRoZSBcImB0aGlzJ1wiIG9iamVjdCBmb3IgYWxsIGNvbmZpZ3VyZWQgZXZlbnQgaGFuZGxlcnMuIElmIGFcbiAgICAqICAgICBzcGVjaWZpYyBjb250ZXh0IGlzIG5lZWRlZCBmb3IgaW5kaXZpZHVhbCBjYWxsYmFja3MsIGJpbmQgdGhlXG4gICAgKiAgICAgY2FsbGJhY2sgdG8gYSBjb250ZXh0IHVzaW5nIGBZLmJpbmQoKWAuPC9kZD5cbiAgICAqXG4gICAgKiAgIDxkdD5oZWFkZXJzPC9kdD5cbiAgICAqICAgICA8ZGQ+T2JqZWN0IG1hcCBvZiB0cmFuc2FjdGlvbiBoZWFkZXJzIHRvIHNlbmQgdG8gdGhlIHNlcnZlci4gVGhlXG4gICAgKiAgICAgb2JqZWN0IGtleXMgYXJlIHRoZSBoZWFkZXIgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSBoZWFkZXJcbiAgICAqICAgICB2YWx1ZXMuPC9kZD5cbiAgICAqXG4gICAgKiAgIDxkdD51c2VybmFtZTwvZHQ+XG4gICAgKiAgICAgPGRkPlVzZXJuYW1lIHRvIHVzZSBpbiBhIEhUVFAgYXV0aGVudGljYXRpb24uPC9kZD5cbiAgICAqXG4gICAgKiAgIDxkdD5wYXNzd29yZDwvZHQ+XG4gICAgKiAgICAgPGRkPlBhc3N3b3JkIHRvIHVzZSBpbiBhIEhUVFAgYXV0aGVudGljYXRpb24uPC9kZD5cbiAgICAqXG4gICAgKiAgIDxkdD50aW1lb3V0PC9kdD5cbiAgICAqICAgICA8ZGQ+TWlsbGlzZWNvbmQgdGhyZXNob2xkIGZvciB0aGUgdHJhbnNhY3Rpb24gYmVmb3JlIGJlaW5nXG4gICAgKiAgICAgYXV0b21hdGljYWxseSBhYm9ydGVkLjwvZGQ+XG4gICAgKlxuICAgICogICA8ZHQ+YXJndW1lbnRzPC9kdD5cbiAgICAqICAgICA8ZGQ+VXNlci1kZWZpbmVkIGRhdGEgcGFzc2VkIHRvIGFsbCByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJzLlxuICAgICogICAgIFRoaXMgdmFsdWUgaXMgYXZhaWxhYmxlIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgaW4gdGhlIFwic3RhcnRcIiBhbmRcbiAgICAqICAgICBcImVuZFwiIGV2ZW50IGhhbmRsZXJzLiBJdCBpcyB0aGUgdGhpcmQgYXJndW1lbnQgaW4gdGhlIFwiY29tcGxldGVcIixcbiAgICAqICAgICBcInN1Y2Nlc3NcIiwgYW5kIFwiZmFpbHVyZVwiIGV2ZW50IGhhbmRsZXJzLiA8c3Ryb25nPkJlIHN1cmUgdG8gcXVvdGVcbiAgICAqICAgICB0aGlzIHByb3BlcnR5IG5hbWUgaW4gdGhlIHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb24gYXNcbiAgICAqICAgICBcImFyZ3VtZW50c1wiIGlzIGEgcmVzZXJ2ZWQgd29yZCBpbiBKYXZhU2NyaXB0PC9zdHJvbmc+IChlLmcuXG4gICAgKiAgICAgYFkuaW8oeyAuLi4sIFwiYXJndW1lbnRzXCI6IHN0dWZmIH0pYCkuPC9kZD5cbiAgICAqIDwvZGw+XG4gICAgKlxuICAgICogQG1ldGhvZCBzZW5kXG4gICAgKiBAcHVibGljXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJpIFF1YWxpZmllZCBwYXRoIHRvIHRyYW5zYWN0aW9uIHJlc291cmNlLlxuICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRyYW5zYWN0aW9uIGlkLCBpZiBhbHJlYWR5IHNldC5cbiAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAqL1xuICAgIHNlbmQ6IGZ1bmN0aW9uKHVyaSwgY29uZmlnLCBpZCkge1xuICAgICAgICB2YXIgdHJhbnNhY3Rpb24sIG1ldGhvZCwgaSwgbGVuLCBzeW5jLCBkYXRhLFxuICAgICAgICAgICAgaW8gPSB0aGlzLFxuICAgICAgICAgICAgdSA9IHVyaSxcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge307XG5cbiAgICAgICAgY29uZmlnID0gY29uZmlnID8gWS5PYmplY3QoY29uZmlnKSA6IHt9O1xuICAgICAgICB0cmFuc2FjdGlvbiA9IGlvLl9jcmVhdGUoY29uZmlnLCBpZCk7XG4gICAgICAgIG1ldGhvZCA9IGNvbmZpZy5tZXRob2QgPyBjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAnR0VUJztcbiAgICAgICAgc3luYyA9IGNvbmZpZy5zeW5jO1xuICAgICAgICBkYXRhID0gY29uZmlnLmRhdGE7XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIGEgbWFwIG9iamVjdCBpbnRvIGEga2V5LXZhbHVlIHN0cmluZyB1c2luZ1xuICAgICAgICAvLyBxdWVyeXN0cmluZy1zdHJpbmdpZnktc2ltcGxlLlxuICAgICAgICBpZiAoKFkuTGFuZy5pc09iamVjdChkYXRhKSAmJiAhZGF0YS5ub2RlVHlwZSkgJiYgIXRyYW5zYWN0aW9uLnVwbG9hZCkge1xuICAgICAgICAgICAgaWYgKFkuUXVlcnlTdHJpbmcgJiYgWS5RdWVyeVN0cmluZy5zdHJpbmdpZnkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgPSBZLlF1ZXJ5U3RyaW5nLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmZvcm0pIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuZm9ybS51cGxvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgZmlsZSB1cGxvYWQgdHJhbnNhY3Rpb24sIGNhbGxpbmdcbiAgICAgICAgICAgICAgICAvLyB1cGxvYWQoKSBpbiBpby11cGxvYWQtaWZyYW1lLlxuICAgICAgICAgICAgICAgIHJldHVybiBpby51cGxvYWQodHJhbnNhY3Rpb24sIHVyaSwgY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIEhUTUwgZm9ybSBkYXRhIGludG8gYSBrZXktdmFsdWUgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGRhdGEgPSBpby5fc2VyaWFsaXplKGNvbmZpZy5mb3JtLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgZmFsc3kgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZy4gVGhpcyB3YXkgSUUgY2FuJ3QgYmVcbiAgICAgICAgLy8gcmVkaWN1bG91cyBhbmQgdHJhbnNsYXRlIGB1bmRlZmluZWRgIHRvIFwidW5kZWZpbmVkXCIuXG4gICAgICAgIGRhdGEgfHwgKGRhdGEgPSAnJyk7XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnR0VUJzpcbiAgICAgICAgICAgICAgICBjYXNlICdIRUFEJzpcbiAgICAgICAgICAgICAgICBjYXNlICdERUxFVEUnOlxuICAgICAgICAgICAgICAgICAgICB1ID0gaW8uX2NvbmNhdCh1LCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdQT1NUJzpcbiAgICAgICAgICAgICAgICBjYXNlICdQVVQnOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBDb250ZW50LVR5cGUgaXMgZGVmaW5lZCBpbiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QsIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIGFzIGEgZGVmYXVsdCBoZWFkZXIsIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgnXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzID0gWS5tZXJnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCdcbiAgICAgICAgICAgICAgICAgICAgfSwgY29uZmlnLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi54ZHIpIHtcbiAgICAgICAgICAgIC8vIFJvdXRlIGRhdGEgdG8gaW8teGRyIG1vZHVsZSBmb3IgZmxhc2ggYW5kIFhEb21haW5SZXF1ZXN0LlxuICAgICAgICAgICAgcmV0dXJuIGlvLnhkcih1LCB0cmFuc2FjdGlvbiwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFuc2FjdGlvbi5ub3RpZnkpIHtcbiAgICAgICAgICAgIC8vIFJvdXRlIGRhdGEgdG8gY3VzdG9tIHRyYW5zcG9ydFxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uLmMuc2VuZCh0cmFuc2FjdGlvbiwgdXJpLCBjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzeW5jICYmICF0cmFuc2FjdGlvbi51cGxvYWQpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmMub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaW8uX3JTKHRyYW5zYWN0aW9uLCBjb25maWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBpcyB0byBiZSBzZXQgYXNcbiAgICAgICAgICAgIC8vIHN5bmNocm9ub3VzIG9yIGFzeW5jaHJvbm91cy5cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmMub3BlbihtZXRob2QsIHUsICFzeW5jLCBjb25maWcudXNlcm5hbWUgfHwgbnVsbCwgY29uZmlnLnBhc3N3b3JkIHx8IG51bGwpO1xuICAgICAgICAgICAgaW8uX3NldEhlYWRlcnModHJhbnNhY3Rpb24uYywgY29uZmlnLmhlYWRlcnMgfHwge30pO1xuICAgICAgICAgICAgaW8uc3RhcnQodHJhbnNhY3Rpb24sIGNvbmZpZyk7XG5cbiAgICAgICAgICAgIC8vIFdpbGwgd29yayBvbmx5IGluIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50IHRoZVxuICAgICAgICAgICAgLy8gQ3Jvc3MtT3JpZ2luIFJlc291cmNlIFNoYXJpbmcgZHJhZnQuXG4gICAgICAgICAgICBpZiAoY29uZmlnLnhkciAmJiBjb25maWcueGRyLmNyZWRlbnRpYWxzICYmIFNVUFBPUlRTX0NPUlMpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5jLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzaW5nIFwibnVsbFwiIHdpdGggSFRUUCBQT1NUIHdpbGwgcmVzdWx0IGluIGEgcmVxdWVzdFxuICAgICAgICAgICAgLy8gd2l0aCBubyBDb250ZW50LUxlbmd0aCBoZWFkZXIgZGVmaW5lZC5cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmMuc2VuZChkYXRhKTtcblxuICAgICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSByZXNwb25zZSBvYmplY3QgZm9yIHN5bmNocm9ub3VzIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyBtaXhpbmcgaWQgYW5kIGFyZ3VtZW50cyBwcm9wZXJ0aWVzIHdpdGggdGhlIHhoclxuICAgICAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgd2hpdGVsaXN0LlxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IFhIUl9QUk9QUy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtYSFJfUFJPUFNbaV1dID0gdHJhbnNhY3Rpb24uY1tYSFJfUFJPUFNbaV1dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb24uYy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5jLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpby5jb21wbGV0ZSh0cmFuc2FjdGlvbiwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpby5fcmVzdWx0KHRyYW5zYWN0aW9uLCBjb25maWcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi54ZHIpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGV4Y2VwdGlvbiBpcyB1c3VhbGx5IHRocm93biBieSBicm93c2Vyc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgZG8gbm90IHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgICAgICAgICAvLyBSZXRyeSB0aGUgcmVxdWVzdCB3aXRoIHRoZSBYRFIgdHJhbnNwb3J0IHNldFxuICAgICAgICAgICAgICAgIC8vIHRvICdmbGFzaCcuICBJZiB0aGUgRmxhc2ggdHJhbnNwb3J0IGlzIG5vdFxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemVkIG9yIGF2YWlsYWJsZSwgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2lsbCByZXNvbHZlIHRvIGEgdHJhbnNwb3J0IGVycm9yLlxuICAgICAgICAgICAgICAgIHJldHVybiBpby5fcmV0cnkodHJhbnNhY3Rpb24sIHVyaSwgY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW8uY29tcGxldGUodHJhbnNhY3Rpb24sIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaW8uX3Jlc3VsdCh0cmFuc2FjdGlvbiwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGNvbmZpZy50aW1lb3V0IGlzIGRlZmluZWQsIGFuZCB0aGUgcmVxdWVzdCBpcyBzdGFuZGFyZCBYSFIsXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGltZW91dCBwb2xsaW5nLlxuICAgICAgICBpZiAoY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIGlvLl9zdGFydFRpbWVvdXQodHJhbnNhY3Rpb24sIGNvbmZpZy50aW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdHJhbnNhY3Rpb24uaWQsXG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uLmMgPyBpby5fYWJvcnQodHJhbnNhY3Rpb24sICdhYm9ydCcpIDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNJblByb2dyZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb24uYyA/ICh0cmFuc2FjdGlvbi5jLnJlYWR5U3RhdGUgJSA0KSA6IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlvOiBpb1xuICAgICAgICB9O1xuICAgIH1cbn07XG5cbi8qKlxuTWV0aG9kIGZvciBpbml0aWF0aW5nIGFuIGFqYXggY2FsbC4gIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgdXJsIGVuZFxucG9pbnQgZm9yIHRoZSBjYWxsLiAgVGhlIHNlY29uZCBhcmd1bWVudCBpcyBhbiBvYmplY3QgdG8gY29uZmlndXJlIHRoZVxudHJhbnNhY3Rpb24gYW5kIGF0dGFjaCBldmVudCBzdWJzY3JpcHRpb25zLiAgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5zdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cbjxkbD5cbiAgPGR0Pm1ldGhvZDwvZHQ+XG4gICAgPGRkPkhUVFAgbWV0aG9kIHZlcmIgKGUuZy4sIEdFVCBvciBQT1NUKS4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBub3RcbiAgICAgICAgbm90IGRlZmluZWQsIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgR0VULjwvZGQ+XG5cbiAgPGR0PmRhdGE8L2R0PlxuICAgIDxkZD5UaGlzIGlzIHRoZSBuYW1lLXZhbHVlIHN0cmluZyB0aGF0IHdpbGwgYmUgc2VudCBhcyB0aGVcbiAgICB0cmFuc2FjdGlvbiBkYXRhLiBJZiB0aGUgcmVxdWVzdCBpcyBIVFRQIEdFVCwgdGhlIGRhdGEgYmVjb21lXG4gICAgcGFydCBvZiBxdWVyeXN0cmluZy4gSWYgSFRUUCBQT1NULCB0aGUgZGF0YSBhcmUgc2VudCBpbiB0aGVcbiAgICBtZXNzYWdlIGJvZHkuPC9kZD5cblxuICA8ZHQ+eGRyPC9kdD5cbiAgICA8ZGQ+RGVmaW5lcyB0aGUgdHJhbnNwb3J0IHRvIGJlIHVzZWQgZm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cy5cbiAgICBCeSBzZXR0aW5nIHRoaXMgcHJvcGVydHksIHRoZSB0cmFuc2FjdGlvbiB3aWxsIHVzZSB0aGUgc3BlY2lmaWVkXG4gICAgdHJhbnNwb3J0IGluc3RlYWQgb2YgWE1MSHR0cFJlcXVlc3QuIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgIHRyYW5zcG9ydCBvYmplY3QgYXJlOlxuICAgIDxkbD5cbiAgICAgIDxkdD51c2U8L2R0PlxuICAgICAgICA8ZGQ+VGhlIHRyYW5zcG9ydCB0byBiZSB1c2VkOiAnZmxhc2gnIG9yICduYXRpdmUnPC9kZD5cbiAgICAgIDxkdD5kYXRhVHlwZTwvZHQ+XG4gICAgICAgIDxkZD5TZXQgdGhlIHZhbHVlIHRvICdYTUwnIGlmIHRoYXQgaXMgdGhlIGV4cGVjdGVkIHJlc3BvbnNlXG4gICAgICAgIGNvbnRlbnQgdHlwZS48L2RkPlxuICAgIDwvZGw+PC9kZD5cblxuICA8ZHQ+Zm9ybTwvZHQ+XG4gICAgPGRkPkZvcm0gc2VyaWFsaXphdGlvbiBjb25maWd1cmF0aW9uIG9iamVjdC4gIEl0cyBwcm9wZXJ0aWVzIGFyZTpcbiAgICA8ZGw+XG4gICAgICA8ZHQ+aWQ8L2R0PlxuICAgICAgICA8ZGQ+Tm9kZSBvYmplY3Qgb3IgaWQgb2YgSFRNTCBmb3JtPC9kZD5cbiAgICAgIDxkdD51c2VEaXNhYmxlZDwvZHQ+XG4gICAgICAgIDxkZD5gdHJ1ZWAgdG8gYWxzbyBzZXJpYWxpemUgZGlzYWJsZWQgZm9ybSBmaWVsZCB2YWx1ZXNcbiAgICAgICAgKGRlZmF1bHRzIHRvIGBmYWxzZWApPC9kZD5cbiAgICA8L2RsPjwvZGQ+XG5cbiAgPGR0Pm9uPC9kdD5cbiAgICA8ZGQ+QXNzaWducyB0cmFuc2FjdGlvbiBldmVudCBzdWJzY3JpcHRpb25zLiBBdmFpbGFibGUgZXZlbnRzIGFyZTpcbiAgICA8ZGw+XG4gICAgICA8ZHQ+c3RhcnQ8L2R0PlxuICAgICAgICA8ZGQ+RmlyZXMgd2hlbiBhIHJlcXVlc3QgaXMgc2VudCB0byBhIHJlc291cmNlLjwvZGQ+XG4gICAgICA8ZHQ+Y29tcGxldGU8L2R0PlxuICAgICAgICA8ZGQ+RmlyZXMgd2hlbiB0aGUgdHJhbnNhY3Rpb24gaXMgY29tcGxldGUuPC9kZD5cbiAgICAgIDxkdD5zdWNjZXNzPC9kdD5cbiAgICAgICAgPGRkPkZpcmVzIHdoZW4gdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGlzIHdpdGhpbiB0aGUgMnh4XG4gICAgICAgIHJhbmdlLjwvZGQ+XG4gICAgICA8ZHQ+ZmFpbHVyZTwvZHQ+XG4gICAgICAgIDxkZD5GaXJlcyB3aGVuIHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBpcyBvdXRzaWRlIHRoZSAyeHhcbiAgICAgICAgcmFuZ2UsIGlmIGFuIGV4Y2VwdGlvbiBvY2N1cnMsIGlmIHRoZSB0cmFuc2F0aW9uIGlzIGFib3J0ZWQsXG4gICAgICAgIG9yIGlmIHRoZSB0cmFuc2FjdGlvbiBleGNlZWRzIGEgY29uZmlndXJlZCBgdGltZW91dGAuPC9kZD5cbiAgICAgIDxkdD5lbmQ8L2R0PlxuICAgICAgICA8ZGQ+RmlyZXMgYXQgdGhlIGNvbmNsdXNpb24gb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgIGxpZmVjeWNsZSwgYWZ0ZXIgYHN1Y2Nlc3NgIG9yIGBmYWlsdXJlYC48L2RkPlxuICAgIDwvZGw+XG5cbiAgICA8cD5DYWxsYmFjayBmdW5jdGlvbnMgZm9yIGBzdGFydGAgYW5kIGBlbmRgIHJlY2VpdmUgdGhlIGlkIG9mIHRoZVxuICAgIHRyYW5zYWN0aW9uIGFzIGEgZmlyc3QgYXJndW1lbnQuIEZvciBgY29tcGxldGVgLCBgc3VjY2Vzc2AsIGFuZFxuICAgIGBmYWlsdXJlYCwgY2FsbGJhY2tzIHJlY2VpdmUgdGhlIGlkIGFuZCB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gICAgKHVzdWFsbHkgdGhlIFhNTEh0dHBSZXF1ZXN0IGluc3RhbmNlKS4gIElmIHRoZSBgYXJndW1lbnRzYFxuICAgIHByb3BlcnR5IHdhcyBpbmNsdWRlZCBpbiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgcGFzc2VkIHRvXG4gICAgYFkuaW8oKWAsIHRoZSBjb25maWd1cmVkIGRhdGEgd2lsbCBiZSBwYXNzZWQgdG8gYWxsIGNhbGxiYWNrcyBhc1xuICAgIHRoZSBsYXN0IGFyZ3VtZW50LjwvcD5cbiAgICA8L2RkPlxuXG4gIDxkdD5zeW5jPC9kdD5cbiAgICA8ZGQ+UGFzcyBgdHJ1ZWAgdG8gbWFrZSBhIHNhbWUtZG9tYWluIHRyYW5zYWN0aW9uIHN5bmNocm9ub3VzLlxuICAgIDxzdHJvbmc+Q0FWRUFUPC9zdHJvbmc+OiBUaGlzIHdpbGwgbmVnYXRpdmVseSBpbXBhY3QgdGhlIHVzZXJcbiAgICBleHBlcmllbmNlLiBIYXZlIGEgPGVtPnZlcnk8L2VtPiBnb29kIHJlYXNvbiBpZiB5b3UgaW50ZW5kIHRvIHVzZVxuICAgIHRoaXMuPC9kZD5cblxuICA8ZHQ+Y29udGV4dDwvZHQ+XG4gICAgPGRkPlRoZSBcImB0aGlzJ1wiIG9iamVjdCBmb3IgYWxsIGNvbmZpZ3VyZWQgZXZlbnQgaGFuZGxlcnMuIElmIGFcbiAgICBzcGVjaWZpYyBjb250ZXh0IGlzIG5lZWRlZCBmb3IgaW5kaXZpZHVhbCBjYWxsYmFja3MsIGJpbmQgdGhlXG4gICAgY2FsbGJhY2sgdG8gYSBjb250ZXh0IHVzaW5nIGBZLmJpbmQoKWAuPC9kZD5cblxuICA8ZHQ+aGVhZGVyczwvZHQ+XG4gICAgPGRkPk9iamVjdCBtYXAgb2YgdHJhbnNhY3Rpb24gaGVhZGVycyB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIuIFRoZVxuICAgIG9iamVjdCBrZXlzIGFyZSB0aGUgaGVhZGVyIG5hbWVzIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgaGVhZGVyXG4gICAgdmFsdWVzLjwvZGQ+XG5cbiAgPGR0PnRpbWVvdXQ8L2R0PlxuICAgIDxkZD5NaWxsaXNlY29uZCB0aHJlc2hvbGQgZm9yIHRoZSB0cmFuc2FjdGlvbiBiZWZvcmUgYmVpbmdcbiAgICBhdXRvbWF0aWNhbGx5IGFib3J0ZWQuPC9kZD5cblxuICA8ZHQ+YXJndW1lbnRzPC9kdD5cbiAgICA8ZGQ+VXNlci1kZWZpbmVkIGRhdGEgcGFzc2VkIHRvIGFsbCByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJzLlxuICAgIFRoaXMgdmFsdWUgaXMgYXZhaWxhYmxlIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgaW4gdGhlIFwic3RhcnRcIiBhbmRcbiAgICBcImVuZFwiIGV2ZW50IGhhbmRsZXJzLiBJdCBpcyB0aGUgdGhpcmQgYXJndW1lbnQgaW4gdGhlIFwiY29tcGxldGVcIixcbiAgICBcInN1Y2Nlc3NcIiwgYW5kIFwiZmFpbHVyZVwiIGV2ZW50IGhhbmRsZXJzLiA8c3Ryb25nPkJlIHN1cmUgdG8gcXVvdGVcbiAgICB0aGlzIHByb3BlcnR5IG5hbWUgaW4gdGhlIHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb24gYXNcbiAgICBcImFyZ3VtZW50c1wiIGlzIGEgcmVzZXJ2ZWQgd29yZCBpbiBKYXZhU2NyaXB0PC9zdHJvbmc+IChlLmcuXG4gICAgYFkuaW8oeyAuLi4sIFwiYXJndW1lbnRzXCI6IHN0dWZmIH0pYCkuPC9kZD5cbjwvZGw+XG5cbkBtZXRob2QgaW9cbkBzdGF0aWNcbkBwYXJhbSB7U3RyaW5nfSB1cmwgcXVhbGlmaWVkIHBhdGggdG8gdHJhbnNhY3Rpb24gcmVzb3VyY2UuXG5AcGFyYW0ge09iamVjdH0gY29uZmlnIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdHJhbnNhY3Rpb24uXG5AcmV0dXJuIHtPYmplY3R9XG5AZm9yIFlVSVxuKiovXG5ZLmlvID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICAvLyBDYWxsaW5nIElPIHRocm91Z2ggdGhlIHN0YXRpYyBpbnRlcmZhY2Ugd2lsbCB1c2UgYW5kIHJldXNlXG4gICAgLy8gYW4gaW5zdGFuY2Ugb2YgSU8uXG4gICAgdmFyIHRyYW5zYWN0aW9uID0gWS5pby5fbWFwWydpbzowJ10gfHwgbmV3IElPKCk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnNlbmQuYXBwbHkodHJhbnNhY3Rpb24sIFt1cmwsIGNvbmZpZ10pO1xufTtcblxuLyoqXG5NZXRob2QgZm9yIHNldHRpbmcgYW5kIGRlbGV0aW5nIElPIEhUVFAgaGVhZGVycyB0byBiZSBzZW50IHdpdGggZXZlcnlcbnJlcXVlc3QuXG5cbkhvc3RlZCBhcyBhIHByb3BlcnR5IG9uIHRoZSBgaW9gIGZ1bmN0aW9uIChlLmcuIGBZLmlvLmhlYWRlcmApLlxuXG5AbWV0aG9kIGhlYWRlclxuQHBhcmFtIHtTdHJpbmd9IG5hbWUgSFRUUCBoZWFkZXJcbkBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBIVFRQIGhlYWRlciB2YWx1ZVxuQHN0YXRpY1xuKiovXG5ZLmlvLmhlYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgLy8gQ2FsbGluZyBJTyB0aHJvdWdoIHRoZSBzdGF0aWMgaW50ZXJmYWNlIHdpbGwgdXNlIGFuZCByZXVzZVxuICAgIC8vIGFuIGluc3RhbmNlIG9mIElPLlxuICAgIHZhciB0cmFuc2FjdGlvbiA9IFkuaW8uX21hcFsnaW86MCddIHx8IG5ldyBJTygpO1xuICAgIHRyYW5zYWN0aW9uLnNldEhlYWRlcihuYW1lLCB2YWx1ZSk7XG59O1xuXG5ZLklPID0gSU87XG4vLyBNYXAgb2YgYWxsIElPIGluc3RhbmNlcyBjcmVhdGVkLlxuWS5pby5fbWFwID0ge307XG52YXIgWEhSID0gd2luICYmIHdpbi5YTUxIdHRwUmVxdWVzdCxcbiAgICBYRFIgPSB3aW4gJiYgd2luLlhEb21haW5SZXF1ZXN0LFxuICAgIEFYID0gd2luICYmIHdpbi5BY3RpdmVYT2JqZWN0LFxuXG4gICAgLy8gQ2hlY2tzIGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlIGB3aXRoQ3JlZGVudGlhbHNgIGluIGFuIFhIUiBpbnN0YW5jZVxuICAgIC8vIG9iamVjdCwgd2hpY2ggd2lsbCBiZSBwcmVzZW50IGlmIHRoZSBlbnZpcm9ubWVudCBzdXBwb3J0cyBDT1JTLlxuICAgIFNVUFBPUlRTX0NPUlMgPSBYSFIgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gKG5ldyBYTUxIdHRwUmVxdWVzdCgpKTtcblxuXG5ZLm1peChZLklPLCB7XG4gICAgLyoqXG4gICAgKiBUaGUgSUQgb2YgdGhlIGRlZmF1bHQgSU8gdHJhbnNwb3J0LCBkZWZhdWx0cyB0byBgeGhyYFxuICAgICogQHByb3BlcnR5IF9kZWZhdWx0XG4gICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICogQHN0YXRpY1xuICAgICovXG4gICAgX2RlZmF1bHQ6ICd4aHInLFxuICAgIC8qKlxuICAgICpcbiAgICAqIEBtZXRob2QgZGVmYXVsdFRyYW5zcG9ydFxuICAgICogQHN0YXRpY1xuICAgICogQHBhcmFtIHtTdHJpbmd9IFtpZF0gVGhlIHRyYW5zcG9ydCB0byBzZXQgYXMgdGhlIGRlZmF1bHQsIGlmIGVtcHR5IGEgbmV3IHRyYW5zcG9ydCBpcyBjcmVhdGVkLlxuICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgdHJhbnNwb3J0IG9iamVjdCB3aXRoIGEgYHNlbmRgIG1ldGhvZFxuICAgICovXG4gICAgZGVmYXVsdFRyYW5zcG9ydDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBZLklPLl9kZWZhdWx0ID0gaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAgICAgICBjOiBZLklPLnRyYW5zcG9ydHNbWS5JTy5fZGVmYXVsdF0oKSxcbiAgICAgICAgICAgICAgICBub3RpZnk6IFkuSU8uX2RlZmF1bHQgPT09ICd4aHInID8gZmFsc2UgOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICogQW4gb2JqZWN0IGhhc2ggb2YgY3VzdG9tIHRyYW5zcG9ydHMgYXZhaWxhYmxlIHRvIElPXG4gICAgKiBAcHJvcGVydHkgdHJhbnNwb3J0c1xuICAgICogQHR5cGUge09iamVjdH1cbiAgICAqIEBzdGF0aWNcbiAgICAqL1xuICAgIHRyYW5zcG9ydHM6IHtcbiAgICAgICAgeGhyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gWEhSID8gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgOlxuICAgICAgICAgICAgICAgIEFYID8gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJykgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICB4ZHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBYRFIgPyBuZXcgWERvbWFpblJlcXVlc3QoKSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGlmcmFtZTogZnVuY3Rpb24gKCkgeyByZXR1cm4ge307IH0sXG4gICAgICAgIGZsYXNoOiBudWxsLFxuICAgICAgICBub2RlanM6IG51bGxcbiAgICB9LFxuICAgIC8qKlxuICAgICogQ3JlYXRlIGEgY3VzdG9tIHRyYW5zcG9ydCBvZiB0eXBlIGFuZCByZXR1cm4gaXQncyBvYmplY3RcbiAgICAqIEBtZXRob2QgY3VzdG9tVHJhbnNwb3J0XG4gICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSB0cmFuc3BvcnQgdG8gY3JlYXRlLlxuICAgICogQHN0YXRpY1xuICAgICovXG4gICAgY3VzdG9tVHJhbnNwb3J0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgbyA9IHsgYzogWS5JTy50cmFuc3BvcnRzW2lkXSgpIH07XG5cbiAgICAgICAgb1soaWQgPT09ICd4ZHInIHx8IGlkID09PSAnZmxhc2gnKSA/ICd4ZHInIDogJ25vdGlmeSddID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxufSk7XG5cblkubWl4KFkuSU8ucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgKiBGaXJlZCBmcm9tIHRoZSBub3RpZnkgbWV0aG9kIG9mIHRoZSB0cmFuc3BvcnQgd2hpY2ggaW4gdHVybiBmaXJlc1xuICAgICogdGhlIGV2ZW50IG9uIHRoZSBJTyBvYmplY3QuXG4gICAgKiBAbWV0aG9kIG5vdGlmeVxuICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGlzIHRyYW5zYWN0aW9uXG4gICAgKi9cbiAgICBub3RpZnk6IGZ1bmN0aW9uKGV2ZW50LCB0cmFuc2FjdGlvbiwgY29uZmlnKSB7XG4gICAgICAgIHZhciBpbyA9IHRoaXM7XG5cbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgICAgY2FzZSAndGltZW91dCc6XG4gICAgICAgICAgICBjYXNlICdhYm9ydCc6XG4gICAgICAgICAgICBjYXNlICd0cmFuc3BvcnQgZXJyb3InOlxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmMgPSB7IHN0YXR1czogMCwgc3RhdHVzVGV4dDogZXZlbnQgfTtcbiAgICAgICAgICAgICAgICBldmVudCA9ICdmYWlsdXJlJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaW9bZXZlbnRdLmFwcGx5KGlvLCBbdHJhbnNhY3Rpb24sIGNvbmZpZ10pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJldmVudC1jdXN0b20tYmFzZVwiLCBcInF1ZXJ5c3RyaW5nLXN0cmluZ2lmeS1zaW1wbGVcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnaW8tZm9ybScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuKiBFeHRlbmRzIElPIHRvIGVuYWJsZSBIVE1MIGZvcm0gZGF0YSBzZXJpYWxpemF0aW9uLCB3aGVuIHNwZWNpZmllZFxuKiBpbiB0aGUgdHJhbnNhY3Rpb24ncyBjb25maWd1cmF0aW9uIG9iamVjdC5cbiogQG1vZHVsZSBpb1xuKiBAc3VibW9kdWxlIGlvLWZvcm1cbiogQGZvciBJT1xuKi9cblxudmFyIGVVQyA9IGVuY29kZVVSSUNvbXBvbmVudDtcblxuLyoqXG4gKiBFbnVtZXJhdGUgdGhyb3VnaCBhbiBIVE1MIGZvcm0ncyBlbGVtZW50cyBjb2xsZWN0aW9uXG4gKiBhbmQgcmV0dXJuIGEgc3RyaW5nIGNvbXByaXNlZCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQG1ldGhvZCBzdHJpbmdpZnlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7Tm9kZXxTdHJpbmd9IGZvcm0gWVVJIGZvcm0gbm9kZSBvciBIVE1MIGZvcm0gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VEaXNhYmxlZD1mYWxzZV0gV2hldGhlciB0byBpbmNsdWRlIGRpc2FibGVkIGZpZWxkcy5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnMuZXh0cmFdIEV4dHJhIHZhbHVlcyB0byBpbmNsdWRlLiBNYXkgYmUgYSBxdWVyeSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzLlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5ZLklPLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKGZvcm0sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBzID0gWS5JTy5wcm90b3R5cGUuX3NlcmlhbGl6ZSh7XG4gICAgICAgIGlkOiBmb3JtLFxuICAgICAgICB1c2VEaXNhYmxlZDogb3B0aW9ucy51c2VEaXNhYmxlZFxuICAgIH0sXG4gICAgb3B0aW9ucy5leHRyYSAmJiB0eXBlb2Ygb3B0aW9ucy5leHRyYSA9PT0gJ29iamVjdCcgPyBZLlF1ZXJ5U3RyaW5nLnN0cmluZ2lmeShvcHRpb25zLmV4dHJhKSA6IG9wdGlvbnMuZXh0cmEpO1xuXG4gICAgcmV0dXJuIHM7XG59O1xuXG5ZLm1peChZLklPLnByb3RvdHlwZSwge1xuICAgLyoqXG4gICAgKiBFbnVtZXJhdGUgdGhyb3VnaCBhbiBIVE1MIGZvcm0ncyBlbGVtZW50cyBjb2xsZWN0aW9uXG4gICAgKiBhbmQgcmV0dXJuIGEgc3RyaW5nIGNvbXByaXNlZCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgKlxuICAgICogQG1ldGhvZCBfc2VyaWFsaXplXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtPYmplY3R9IGNcbiAgICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGMuaWQgWVVJIGZvcm0gbm9kZSBvciBIVE1MIGZvcm0gaWRcbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYy51c2VEaXNhYmxlZCBgdHJ1ZWAgdG8gaW5jbHVkZSBkaXNhYmxlZCBmaWVsZHNcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBzIEtleS12YWx1ZSBkYXRhIGRlZmluZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICovXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24oYywgcykge1xuICAgICAgICB2YXIgZGF0YSA9IFtdLFxuICAgICAgICAgICAgZGYgPSBjLnVzZURpc2FibGVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgaXRlbSA9IDAsXG4gICAgICAgICAgICBpZCA9ICh0eXBlb2YgYy5pZCA9PT0gJ3N0cmluZycpID8gYy5pZCA6IGMuaWQuZ2V0QXR0cmlidXRlKCdpZCcpLFxuICAgICAgICAgICAgZSwgZiwgbiwgdiwgZCwgaSwgaWwsIGosIGpsLCBvO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIGlkID0gWS5ndWlkKCdpbzonKTtcbiAgICAgICAgICAgIGMuaWQuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGYgPSBZLmNvbmZpZy5kb2MuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgICAgIGlmICghZiB8fCAhZi5lbGVtZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHMgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGZvcm0gZWxlbWVudHMgY29sbGVjdGlvbiB0byBjb25zdHJ1Y3QgdGhlXG4gICAgICAgIC8vIGxhYmVsLXZhbHVlIHBhaXJzLlxuICAgICAgICBmb3IgKGkgPSAwLCBpbCA9IGYuZWxlbWVudHMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgZSA9IGYuZWxlbWVudHNbaV07XG4gICAgICAgICAgICBkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgICAgIG4gPSBlLm5hbWU7XG5cbiAgICAgICAgICAgIGlmIChkZiA/IG4gOiBuICYmICFkKSB7XG4gICAgICAgICAgICAgICAgbiA9IGVVQyhuKSArICc9JztcbiAgICAgICAgICAgICAgICB2ID0gZVVDKGUudmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpLCBPcGVyYSwgRkYgYWxsIGRlZmF1bHQgb3B0aW9ucy52YWx1ZSBmcm9tIC50ZXh0IGlmXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIGF0dHJpYnV0ZSBub3Qgc3BlY2lmaWVkIGluIG1hcmt1cFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3Qtb25lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnNlbGVjdGVkSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBlLm9wdGlvbnNbZS5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2l0ZW0rK10gPSBuICsgZVVDKG8uYXR0cmlidXRlcy52YWx1ZSAmJiBvLmF0dHJpYnV0ZXMudmFsdWUuc3BlY2lmaWVkID8gby52YWx1ZSA6IG8udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0LW11bHRpcGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnNlbGVjdGVkSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGUuc2VsZWN0ZWRJbmRleCwgamwgPSBlLm9wdGlvbnMubGVuZ3RoOyBqIDwgamw7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gZS5vcHRpb25zW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaXRlbSsrXSA9IG4gKyBlVUMoby5hdHRyaWJ1dGVzLnZhbHVlICYmIG8uYXR0cmlidXRlcy52YWx1ZS5zcGVjaWZpZWQgPyBvLnZhbHVlIDogby50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2l0ZW0rK10gPSBuICsgdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0dWIgY2FzZSBhcyBYTUxIdHRwUmVxdWVzdCB3aWxsIG9ubHkgc2VuZCB0aGUgZmlsZSBwYXRoIGFzIGEgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0dWIgY2FzZSBmb3IgZmllbGRzZXQgZWxlbWVudCB3aGljaCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3R1YiBjYXNlIGZvciBpbnB1dCB0eXBlIHJlc2V0IGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0dWIgY2FzZSBmb3IgaW5wdXQgdHlwZSBidXR0b24gZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3VibWl0JzpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaXRlbSsrXSA9IG4gKyB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICBkYXRhW2l0ZW0rK10gPSBzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGEuam9pbignJicpO1xuICAgIH1cbn0sIHRydWUpO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJpby1iYXNlXCIsIFwibm9kZS1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2lvLXF1ZXVlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG5FeHRlbmRzIElPIHRvIGltcGxlbWVudCBRdWV1ZSBmb3Igc3luY2hyb25vdXNcbnRyYW5zYWN0aW9uIHByb2Nlc3NpbmcuXG5AbW9kdWxlIGlvXG5Ac3VibW9kdWxlIGlvLXF1ZXVlXG5AZm9yIElPXG4qKi9cbnZhciBpbyA9IFkuaW8uX21hcFsnaW86MCddIHx8IG5ldyBZLklPKCk7XG5cblkubWl4KFkuSU8ucHJvdG90eXBlLCB7XG4gICAvKipcbiAgICAqIEFycmF5IG9mIHRyYW5zYWN0aW9ucyBxdWV1ZWQgZm9yIHByb2Nlc3NpbmdcbiAgICAqXG4gICAgKiBAcHJvcGVydHkgX3FcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAc3RhdGljXG4gICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICovXG4gICAgX3E6IG5ldyBZLlF1ZXVlKCksXG4gICAgX3FBY3RpdmVJZDogbnVsbCxcbiAgICBfcUluaXQ6IGZhbHNlLFxuXG4gICAvKipcbiAgICAqIFByb3BlcnR5IHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBxdWV1ZSBpcyBzZXQgdG9cbiAgICAqIDEgKGFjdGl2ZSkgb3IgMCAoaW5hY3RpdmUpLiAgV2hlbiBpbmFjdGl2ZSwgdHJhbnNhY3Rpb25zXG4gICAgKiB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgcXVldWUgdW50aWwgdGhlIHF1ZXVlIGlzIHNldCB0byBhY3RpdmUuXG4gICAgKlxuICAgICogQHByb3BlcnR5IF9xU3RhdGVcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAc3RhdGljXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICovXG4gICAgX3FTdGF0ZTogMSxcblxuICAgLyoqXG4gICAgKiBNZXRob2QgUHJvY2VzcyB0aGUgZmlyc3QgdHJhbnNhY3Rpb24gZnJvbSB0aGVcbiAgICAqIHF1ZXVlIGluIEZJRk8gb3JkZXIuXG4gICAgKlxuICAgICogQG1ldGhvZCBfcVNoaWZ0XG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHN0YXRpY1xuICAgICovXG4gICAgX3FTaGlmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbyA9IHRoaXMsXG4gICAgICAgICAgICBvID0gaW8uX3EubmV4dCgpO1xuXG4gICAgICAgIGlvLl9xQWN0aXZlSWQgPSBvLmlkO1xuICAgICAgICBpby5fcVN0YXRlID0gMDtcbiAgICAgICAgaW8uc2VuZChvLnVyaSwgby5jZmcsIG8uaWQpO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogTWV0aG9kIGZvciBxdWV1ZWluZyBhIHRyYW5zYWN0aW9uIGJlZm9yZSB0aGUgcmVxdWVzdCBpcyBzZW50IHRvIHRoZVxuICAgICogcmVzb3VyY2UsIHRvIGVuc3VyZSBzZXF1ZW50aWFsIHByb2Nlc3NpbmcuXG4gICAgKlxuICAgICogQG1ldGhvZCBxdWV1ZVxuICAgICogQHN0YXRpY1xuICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICovXG4gICAgcXVldWU6IGZ1bmN0aW9uKHVyaSwgYykge1xuICAgICAgICB2YXIgaW8gPSB0aGlzLFxuICAgICAgICAgICAgbyA9IHsgdXJpOiB1cmksIGNmZzpjLCBpZDogdGhpcy5faWQrKyB9O1xuXG4gICAgICAgIGlmKCFpby5fcUluaXQpIHtcbiAgICAgICAgICAgIFkub24oJ2lvOmNvbXBsZXRlJywgZnVuY3Rpb24oaWQsIG8pIHsgaW8uX3FOZXh0KGlkKTsgfSwgaW8pO1xuICAgICAgICAgICAgaW8uX3FJbml0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlvLl9xLmFkZChvKTtcbiAgICAgICAgaWYgKGlvLl9xU3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgIGlvLl9xU2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgIH0sXG5cbiAgICBfcU5leHQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBpbyA9IHRoaXM7XG4gICAgICAgIGlvLl9xU3RhdGUgPSAxO1xuICAgICAgICBpZiAoaW8uX3FBY3RpdmVJZCA9PT0gaWQgJiYgaW8uX3Euc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgaW8uX3FTaGlmdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBNZXRob2QgZm9yIHByb21vdGluZyBhIHRyYW5zYWN0aW9uIHRvIHRoZSB0b3Agb2YgdGhlIHF1ZXVlLlxuICAgICpcbiAgICAqIEBtZXRob2QgcHJvbW90ZVxuICAgICogQHN0YXRpY1xuICAgICovXG4gICAgcVByb21vdGU6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdGhpcy5fcS5wcm9tb3RlKG8pO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogTWV0aG9kIGZvciByZW1vdmluZyBhIHNwZWNpZmljLCBwZW5kaW5nIHRyYW5zYWN0aW9uIGZyb21cbiAgICAqIHRoZSBxdWV1ZS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICogQHByaXZhdGVcbiAgICAqIEBzdGF0aWNcbiAgICAqL1xuICAgIHFSZW1vdmU6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdGhpcy5fcS5yZW1vdmUobyk7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBNZXRob2QgZm9yIGNhbmNlbCBhbGwgcGVuZGluZyB0cmFuc2FjdGlvbiBmcm9tXG4gICAgKiB0aGUgcXVldWUuXG4gICAgKlxuICAgICogQG1ldGhvZCBlbXB0eVxuICAgICogQHN0YXRpY1xuICAgICogQHNpbmNlIDMuNy4zXG4gICAgKi9cbiAgICBxRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9xID0gbmV3IFkuUXVldWUoKTtcbiAgICB9LFxuXG4gICAgcVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlvID0gdGhpcztcbiAgICAgICAgaW8uX3FTdGF0ZSA9IDE7XG5cbiAgICAgICAgaWYgKGlvLl9xLnNpemUoKSA+IDApIHtcbiAgICAgICAgICAgIGlvLl9xU2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgIC8qKlxuICAgICogTWV0aG9kIGZvciBzZXR0aW5nIHF1ZXVlIHByb2Nlc3NpbmcgdG8gaW5hY3RpdmUuXG4gICAgKiBUcmFuc2FjdGlvbiByZXF1ZXN0cyB0byBZVUkuaW8ucXVldWUoKSB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgcXVldWUsIGJ1dFxuICAgICogbm90IHByb2Nlc3NlZCB1bnRpbCB0aGUgcXVldWUgaXMgcmVzZXQgdG8gXCJhY3RpdmVcIi5cbiAgICAqXG4gICAgKiBAbWV0aG9kIF9zdG9wXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHN0YXRpY1xuICAgICovXG4gICAgcVN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9xU3RhdGUgPSAwO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogTWV0aG9kIHRvIHF1ZXJ5IHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIHF1ZXVlLlxuICAgICpcbiAgICAqIEBtZXRob2QgX3NpemVcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAc3RhdGljXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgKi9cbiAgICBxU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xLnNpemUoKTtcbiAgICB9XG5cbn0sIHRydWUpO1xuXG5mdW5jdGlvbiBfcXVldWUodSwgYykge1xuICAgIHJldHVybiBpby5xdWV1ZS5hcHBseShpbywgW3UsIGNdKTtcbn1cblxuX3F1ZXVlLnN0YXJ0ID0gZnVuY3Rpb24gKCkgeyBpby5xU3RhcnQoKTsgfTtcbl9xdWV1ZS5zdG9wID0gZnVuY3Rpb24gKCkgeyBpby5xU3RvcCgpOyB9O1xuX3F1ZXVlLnByb21vdGUgPSBmdW5jdGlvbiAobykgeyBpby5xUHJvbW90ZShvKTsgfTtcbl9xdWV1ZS5yZW1vdmUgPSBmdW5jdGlvbiAobykgeyBpby5xUmVtb3ZlKG8pOyB9O1xuX3F1ZXVlLnNpemUgPSBmdW5jdGlvbiAoKSB7IGlvLnFTaXplKCk7IH07XG5fcXVldWUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7IGlvLnFFbXB0eSgpOyB9O1xuWS5pby5xdWV1ZSA9IF9xdWV1ZTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiaW8tYmFzZVwiLCBcInF1ZXVlLXByb21vdGVcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnaW8tdXBsb2FkLWlmcmFtZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuRXh0ZW5kcyB0aGUgSU8gIHRvIGVuYWJsZSBmaWxlIHVwbG9hZHMsIHdpdGggSFRNTCBmb3Jtc1xudXNpbmcgYW4gaWZyYW1lIGFzIHRoZSB0cmFuc3BvcnQgbWVkaXVtLlxuQG1vZHVsZSBpb1xuQHN1Ym1vZHVsZSBpby11cGxvYWQtaWZyYW1lXG5AZm9yIElPXG4qKi9cblxudmFyIHcgPSBZLmNvbmZpZy53aW4sXG4gICAgZCA9IFkuY29uZmlnLmRvYyxcbiAgICBfc3RkID0gKGQuZG9jdW1lbnRNb2RlICYmIGQuZG9jdW1lbnRNb2RlID49IDgpLFxuICAgIF9kID0gZGVjb2RlVVJJQ29tcG9uZW50LFxuICAgIF9lbmQgPSBZLklPLnByb3RvdHlwZS5lbmQ7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgaWZyYW1lIHRyYW5zcG9ydGVkIHVzZWQgaW4gZmlsZSB1cGxvYWRcbiAqIHRyYW5zYWN0aW9ucywgYW5kIGJpbmRzIHRoZSByZXNwb25zZSBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBtZXRob2QgX2NGcmFtZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvIFRyYW5zYWN0aW9uIG9iamVjdCBnZW5lcmF0ZWQgYnkgX2NyZWF0ZSgpLlxuICogQHBhcmFtIHtPYmplY3R9IGMgQ29uZmlndXJhdGlvbiBvYmplY3QgcGFzc2VkIHRvIFlVSS5pbygpLlxuICogQHBhcmFtIHtPYmplY3R9IGlvXG4gKi9cbmZ1bmN0aW9uIF9jRnJhbWUobywgYywgaW8pIHtcbiAgICB2YXIgaSA9IFkuTm9kZS5jcmVhdGUoJzxpZnJhbWUgaWQ9XCJpb19pZnJhbWUnICsgby5pZCArICdcIiBuYW1lPVwiaW9faWZyYW1lJyArIG8uaWQgKyAnXCIgLz4nKTtcbiAgICAgICAgaS5fbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGkuX25vZGUuc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgICAgICBpLl9ub2RlLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgICAgIFkub25lKCdib2R5JykuYXBwZW5kQ2hpbGQoaSk7XG4gICAgLy8gQmluZCB0aGUgb25sb2FkIGhhbmRsZXIgdG8gdGhlIGlmcmFtZSB0byBkZXRlY3QgdGhlIGZpbGUgdXBsb2FkIHJlc3BvbnNlLlxuICAgIFkub24oXCJsb2FkXCIsIGZ1bmN0aW9uKCkgeyBpby5fdXBsb2FkQ29tcGxldGUobywgYyk7IH0sICcjaW9faWZyYW1lJyArIG8uaWQpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGlmcmFtZSB0cmFuc3BvcnQgdXNlZCBpbiB0aGUgZmlsZSB1cGxvYWRcbiAqIHRyYW5zYWN0aW9uLlxuICpcbiAqIEBtZXRob2QgX2RGcmFtZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgdHJhbnNhY3Rpb24gSUQgdXNlZCBpbiB0aGUgaWZyYW1lJ3MgY3JlYXRpb24uXG4gKi9cbmZ1bmN0aW9uIF9kRnJhbWUoaWQpIHtcblx0WS5FdmVudC5wdXJnZUVsZW1lbnQoJyNpb19pZnJhbWUnICsgaWQsIGZhbHNlKTtcblx0WS5vbmUoJ2JvZHknKS5yZW1vdmVDaGlsZChZLm9uZSgnI2lvX2lmcmFtZScgKyBpZCkpO1xufVxuXG5ZLm1peChZLklPLnByb3RvdHlwZSwge1xuICAgLyoqXG4gICAgKiBQYXJzZXMgdGhlIFBPU1QgZGF0YSBvYmplY3QgYW5kIGNyZWF0ZXMgaGlkZGVuIGZvcm0gZWxlbWVudHNcbiAgICAqIGZvciBlYWNoIGtleS12YWx1ZSwgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGUgSFRNTCBmb3JtIG9iamVjdC5cbiAgICAqIEBtZXRob2QgX2FkZERhdGFcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAc3RhdGljXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZiBIVE1MIGZvcm0gb2JqZWN0LlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHMgVGhlIGtleS12YWx1ZSBQT1NUIGRhdGEuXG4gICAgKiBAcmV0dXJuIHtBcnJheX0gbyBBcnJheSBvZiBjcmVhdGVkIGZpZWxkcy5cbiAgICAqL1xuICAgIF9hZGREYXRhOiBmdW5jdGlvbihmLCBzKSB7XG4gICAgICAgIC8vIFNlcmlhbGl6ZSBhbiBvYmplY3QgaW50byBhIGtleS12YWx1ZSBzdHJpbmcgdXNpbmdcbiAgICAgICAgLy8gcXVlcnlzdHJpbmctc3RyaW5naWZ5LXNpbXBsZS5cbiAgICAgICAgaWYgKFkuTGFuZy5pc09iamVjdChzKSkge1xuICAgICAgICAgICAgcyA9IFkuUXVlcnlTdHJpbmcuc3RyaW5naWZ5KHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG8gPSBbXSxcbiAgICAgICAgICAgIG0gPSBzLnNwbGl0KCc9JyksXG4gICAgICAgICAgICBpLCBsO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBtLmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIG9baV0gPSBkLmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBvW2ldLnR5cGUgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIG9baV0ubmFtZSA9IF9kKG1baV0uc3Vic3RyaW5nKG1baV0ubGFzdEluZGV4T2YoJyYnKSArIDEpKTtcbiAgICAgICAgICAgIG9baV0udmFsdWUgPSAoaSArIDEgPT09IGwpID8gX2QobVtpICsgMV0pIDogX2QobVtpICsgMV0uc3Vic3RyaW5nKDAsIChtW2kgKyAxXS5sYXN0SW5kZXhPZignJicpKSkpO1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChvW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogUmVtb3ZlcyB0aGUgY3VzdG9tIGZpZWxkcyBjcmVhdGVkIHRvIHBhc3MgYWRkaXRpb25hbCBQT1NUXG4gICAgKiBkYXRhLCBhbG9uZyB3aXRoIHRoZSBIVE1MIGZvcm0gZmllbGRzLlxuICAgICogQG1ldGhvZCBfcmVtb3ZlRGF0YVxuICAgICogQHByaXZhdGVcbiAgICAqIEBzdGF0aWNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBmIEhUTUwgZm9ybSBvYmplY3QuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbyBIVE1MIGZvcm0gZmllbGRzIGNyZWF0ZWQgZnJvbSBjb25maWd1cmF0aW9uLmRhdGEuXG4gICAgKi9cbiAgICBfcmVtb3ZlRGF0YTogZnVuY3Rpb24oZiwgbykge1xuICAgICAgICB2YXIgaSwgbDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gby5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGYucmVtb3ZlQ2hpbGQob1tpXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAvKipcbiAgICAqIFNldHMgdGhlIGFwcHJvcHJpYXRlIGF0dHJpYnV0ZXMgYW5kIHZhbHVlcyB0byB0aGUgSFRNTFxuICAgICogZm9ybSwgaW4gcHJlcGFyYXRpb24gb2YgYSBmaWxlIHVwbG9hZCB0cmFuc2FjdGlvbi5cbiAgICAqIEBtZXRob2QgX3NldEF0dHJzXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHN0YXRpY1xuICAgICogQHBhcmFtIHtPYmplY3R9IGYgSFRNTCBmb3JtIG9iamVjdC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpZCBUaGUgVHJhbnNhY3Rpb24gSUQuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdXJpIFF1YWxpZmllZCBwYXRoIHRvIHRyYW5zYWN0aW9uIHJlc291cmNlLlxuICAgICovXG4gICAgX3NldEF0dHJzOiBmdW5jdGlvbihmLCBpZCwgdXJpKSB7XG4gICAgICAgIC8vIFRyYWNrIG9yaWdpbmFsIEhUTUwgZm9ybSBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICB0aGlzLl9vcmlnaW5hbEZvcm1BdHRycyA9IHtcbiAgICAgICAgICAgIGFjdGlvbjogZi5nZXRBdHRyaWJ1dGUoJ2FjdGlvbicpLFxuICAgICAgICAgICAgdGFyZ2V0OiBmLmdldEF0dHJpYnV0ZSgndGFyZ2V0JylcbiAgICAgICAgfTtcblxuICAgICAgICBmLnNldEF0dHJpYnV0ZSgnYWN0aW9uJywgdXJpKTtcbiAgICAgICAgZi5zZXRBdHRyaWJ1dGUoJ21ldGhvZCcsICdQT1NUJyk7XG4gICAgICAgIGYuc2V0QXR0cmlidXRlKCd0YXJnZXQnLCAnaW9faWZyYW1lJyArIGlkICk7XG4gICAgICAgIGYuc2V0QXR0cmlidXRlKFkuVUEuaWUgJiYgIV9zdGQgPyAnZW5jb2RpbmcnIDogJ2VuY3R5cGUnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogUmVzZXQgdGhlIEhUTUwgZm9ybSBhdHRyaWJ1dGVzIHRvIHRoZWlyIG9yaWdpbmFsIHZhbHVlcy5cbiAgICAqIEBtZXRob2QgX3Jlc2V0QXR0cnNcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAc3RhdGljXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZiBIVE1MIGZvcm0gb2JqZWN0LlxuICAgICogQHBhcmFtIHtPYmplY3R9IGEgT2JqZWN0IG9mIG9yaWdpbmFsIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBfcmVzZXRBdHRyczogZnVuY3Rpb24oZiwgYSkge1xuICAgICAgICBZLk9iamVjdC5lYWNoKGEsIGZ1bmN0aW9uKHYsIHApIHtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgZi5zZXRBdHRyaWJ1dGUocCwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmLnJlbW92ZUF0dHJpYnV0ZShwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBTdGFydHMgdGltZW91dCBjb3VudCBpZiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAqIGhhcyBhIGRlZmluZWQgdGltZW91dCBwcm9wZXJ0eS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIF9zdGFydFVwbG9hZFRpbWVvdXRcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAc3RhdGljXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbyBUcmFuc2FjdGlvbiBvYmplY3QgZ2VuZXJhdGVkIGJ5IF9jcmVhdGUoKS5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjIENvbmZpZ3VyYXRpb24gb2JqZWN0IHBhc3NlZCB0byBZVUkuaW8oKS5cbiAgICAqL1xuICAgIF9zdGFydFVwbG9hZFRpbWVvdXQ6IGZ1bmN0aW9uKG8sIGMpIHtcbiAgICAgICAgdmFyIGlvID0gdGhpcztcblxuICAgICAgICBpby5fdGltZW91dFtvLmlkXSA9IHcuc2V0VGltZW91dChcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG8uc3RhdHVzID0gMDtcbiAgICAgICAgICAgICAgICBvLnN0YXR1c1RleHQgPSAndGltZW91dCc7XG4gICAgICAgICAgICAgICAgaW8uY29tcGxldGUobywgYyk7XG4gICAgICAgICAgICAgICAgaW8uZW5kKG8sIGMpO1xuICAgICAgICAgICAgfSwgYy50aW1lb3V0KTtcbiAgICB9LFxuXG4gICAvKipcbiAgICAqIENsZWFycyB0aGUgdGltZW91dCBpbnRlcnZhbCBzdGFydGVkIGJ5IF9zdGFydFVwbG9hZFRpbWVvdXQoKS5cbiAgICAqIEBtZXRob2QgX2NsZWFyVXBsb2FkVGltZW91dFxuICAgICogQHByaXZhdGVcbiAgICAqIEBzdGF0aWNcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAtIFRyYW5zYWN0aW9uIElELlxuICAgICovXG4gICAgX2NsZWFyVXBsb2FkVGltZW91dDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGlvID0gdGhpcztcblxuICAgICAgICB3LmNsZWFyVGltZW91dChpby5fdGltZW91dFtpZF0pO1xuICAgICAgICBkZWxldGUgaW8uX3RpbWVvdXRbaWRdO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogQm91bmQgdG8gdGhlIGlmcmFtZSdzIExvYWQgZXZlbnQgYW5kIHByb2Nlc3Nlc1xuICAgICogdGhlIHJlc3BvbnNlIGRhdGEuXG4gICAgKiBAbWV0aG9kIF91cGxvYWRDb21wbGV0ZVxuICAgICogQHByaXZhdGVcbiAgICAqIEBzdGF0aWNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvIFRoZSB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBfdXBsb2FkQ29tcGxldGU6IGZ1bmN0aW9uKG8sIGMpIHtcbiAgICAgICAgdmFyIGlvID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSBZLm9uZSgnI2lvX2lmcmFtZScgKyBvLmlkKS5nZXQoJ2NvbnRlbnRXaW5kb3cuZG9jdW1lbnQnKSxcbiAgICAgICAgICAgIGIgPSBkLm9uZSgnYm9keScpLFxuICAgICAgICAgICAgcDtcblxuICAgICAgICBpZiAoYy50aW1lb3V0KSB7XG4gICAgICAgICAgICBpby5fY2xlYXJVcGxvYWRUaW1lb3V0KG8uaWQpO1xuICAgICAgICB9XG5cblx0XHR0cnkge1xuXHRcdFx0aWYgKGIpIHtcblx0XHRcdFx0Ly8gV2hlbiBhIHJlc3BvbnNlIENvbnRlbnQtVHlwZSBvZiBcInRleHQvcGxhaW5cIiBpcyB1c2VkLCBGaXJlZm94IGFuZCBTYWZhcmlcblx0XHRcdFx0Ly8gd2lsbCB3cmFwIHRoZSByZXNwb25zZSBzdHJpbmcgd2l0aCA8cHJlPjwvcHJlPi5cblx0XHRcdFx0cCA9IGIub25lKCdwcmU6Zmlyc3QtY2hpbGQnKTtcblx0XHRcdFx0by5jLnJlc3BvbnNlVGV4dCA9IHAgPyBwLmdldCgndGV4dCcpIDogYi5nZXQoJ3RleHQnKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRvLmMucmVzcG9uc2VYTUwgPSBkLl9ub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAoZSkge1xuXHRcdFx0by5lID0gXCJ1cGxvYWQgZmFpbHVyZVwiO1xuXHRcdH1cblxuICAgICAgICBpby5jb21wbGV0ZShvLCBjKTtcbiAgICAgICAgaW8uZW5kKG8sIGMpO1xuICAgICAgICAvLyBUaGUgdHJhbnNhY3Rpb24gaXMgY29tcGxldGUsIHNvIGNhbGwgX2RGcmFtZSB0byByZW1vdmVcbiAgICAgICAgLy8gdGhlIGV2ZW50IGxpc3RlbmVyIGJvdW5kIHRvIHRoZSBpZnJhbWUgdHJhbnNwb3J0LCBhbmQgdGhlblxuICAgICAgICAvLyBkZXN0cm95IHRoZSBpZnJhbWUuXG4gICAgICAgIHcuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7IF9kRnJhbWUoby5pZCk7IH0sIDApO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogVXBsb2FkcyBIVE1MIGZvcm0gZGF0YSwgaW5jbHVzaXZlIG9mIGZpbGVzL2F0dGFjaG1lbnRzLFxuICAgICogdXNpbmcgdGhlIGlmcmFtZSBjcmVhdGVkIGluIF9jcmVhdGUgdG8gZmFjaWxpdGF0ZSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKiBAbWV0aG9kIF91cGxvYWRcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAc3RhdGljXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbyBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gdXJpIFF1YWxpZmllZCBwYXRoIHRvIHRyYW5zYWN0aW9uIHJlc291cmNlLlxuICAgICogQHBhcmFtIHtPYmplY3R9IGMgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIF91cGxvYWQ6IGZ1bmN0aW9uKG8sIHVyaSwgYykge1xuICAgICAgICB2YXIgaW8gPSB0aGlzLFxuICAgICAgICAgICAgZiA9ICh0eXBlb2YgYy5mb3JtLmlkID09PSAnc3RyaW5nJykgPyBkLmdldEVsZW1lbnRCeUlkKGMuZm9ybS5pZCkgOiBjLmZvcm0uaWQsXG4gICAgICAgICAgICBmaWVsZHM7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgSFRNTCBmb3JtIHByb3BlcnRpZXMgaW4gY2FzZSB0aGV5IGFyZVxuICAgICAgICAvLyBub3QgZGVmaW5lZCBpbiB0aGUgSFRNTCBmb3JtLlxuICAgICAgICBpby5fc2V0QXR0cnMoZiwgby5pZCwgdXJpKTtcbiAgICAgICAgaWYgKGMuZGF0YSkge1xuICAgICAgICAgICAgZmllbGRzID0gaW8uX2FkZERhdGEoZiwgYy5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHBvbGxpbmcgaWYgYSBjYWxsYmFjayBpcyBwcmVzZW50IGFuZCB0aGUgdGltZW91dFxuICAgICAgICAvLyBwcm9wZXJ0eSBoYXMgYmVlbiBkZWZpbmVkLlxuICAgICAgICBpZiAoYy50aW1lb3V0KSB7XG4gICAgICAgICAgICBpby5fc3RhcnRVcGxvYWRUaW1lb3V0KG8sIGMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgZmlsZSB1cGxvYWQuXG4gICAgICAgIGYuc3VibWl0KCk7XG4gICAgICAgIGlvLnN0YXJ0KG8sIGMpO1xuICAgICAgICBpZiAoYy5kYXRhKSB7XG4gICAgICAgICAgICBpby5fcmVtb3ZlRGF0YShmLCBmaWVsZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBvLmlkLFxuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG8uc3RhdHVzID0gMDtcbiAgICAgICAgICAgICAgICBvLnN0YXR1c1RleHQgPSAnYWJvcnQnO1xuICAgICAgICAgICAgICAgIGlmIChZLm9uZSgnI2lvX2lmcmFtZScgKyBvLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBfZEZyYW1lKG8uaWQpO1xuICAgICAgICAgICAgICAgICAgICBpby5jb21wbGV0ZShvLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgaW8uZW5kKG8sIGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0luUHJvZ3Jlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBZLm9uZSgnI2lvX2lmcmFtZScgKyBvLmlkKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbzogaW9cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgdXBsb2FkOiBmdW5jdGlvbihvLCB1cmksIGMpIHtcbiAgICAgICAgX2NGcmFtZShvLCBjLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwbG9hZChvLCB1cmksIGMpO1xuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBjb25maWcpIHtcbiAgICAgICAgdmFyIGZvcm0sIGlvO1xuXG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIGZvcm0gPSBjb25maWcuZm9ybTtcblxuICAgICAgICAgICAgaWYgKGZvcm0gJiYgZm9ybS51cGxvYWQpIHtcbiAgICAgICAgICAgICAgICBpbyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIEhUTUwgZm9ybSBhdHRyaWJ1dGVzIHRvIHRoZWlyIG9yaWdpbmFsIHZhbHVlcy5cbiAgICAgICAgICAgICAgICBmb3JtID0gKHR5cGVvZiBmb3JtLmlkID09PSAnc3RyaW5nJykgPyBkLmdldEVsZW1lbnRCeUlkKGZvcm0uaWQpIDogZm9ybS5pZDtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGZvcm0gc3RpbGwgZXhpc3RzIGJlZm9yZSByZXNldHRpbmcgaXQuXG4gICAgICAgICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW8uX3Jlc2V0QXR0cnMoZm9ybSwgdGhpcy5fb3JpZ2luYWxGb3JtQXR0cnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfZW5kLmNhbGwodGhpcywgdHJhbnNhY3Rpb24sIGNvbmZpZyk7XG4gICAgfVxufSwgdHJ1ZSk7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImlvLWJhc2VcIiwgXCJub2RlLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnaW8teGRyJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG5FeHRlbmRzIElPIHRvIHByb3ZpZGUgYW4gYWx0ZXJuYXRlLCBGbGFzaCB0cmFuc3BvcnQsIGZvciBtYWtpbmdcbmNyb3NzLWRvbWFpbiByZXF1ZXN0cy5cbkBtb2R1bGUgaW9cbkBzdWJtb2R1bGUgaW8teGRyXG5AZm9yIElPXG5AZGVwcmVjYXRlZFxuKiovXG5cbi8vIEhlbHBmdWwgcmVzb3VyY2VzIHdoZW4gd29ya2luZyB3aXRoIHRoZSBtZXNzIHRoYXQgaXMgWERvbWFpblJlcXVlc3Q6XG4vLyBodHRwOi8vd3d3LmN5cHJlc3Nub3J0aC5jb20vYmxvZy93ZWItcHJvZ3JhbW1pbmctYW5kLWRldmVsb3BtZW50L2ludGVybmV0LWV4cGxvcmVyLWFib3J0aW5nLWFqYXgtcmVxdWVzdHMtZml4ZWQvXG4vLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG5cbi8qKlxuRmlyZXMgd2hlbiB0aGUgWERSIHRyYW5zcG9ydCBpcyByZWFkeSBmb3IgdXNlLlxuQGV2ZW50IGlvOnhkclJlYWR5XG4qKi9cbnZhciBFX1hEUl9SRUFEWSA9IFkucHVibGlzaCgnaW86eGRyUmVhZHknLCB7IGZpcmVPbmNlOiB0cnVlIH0pLFxuXG4vKipcbk1hcCBvZiBzdG9yZWQgY29uZmlndXJhdGlvbiBvYmplY3RzIHdoZW4gdXNpbmdcbkZsYXNoIGFzIHRoZSB0cmFuc3BvcnQgZm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cy5cblxuQHByb3BlcnR5IF9jQlxuQHByaXZhdGVcbkB0eXBlIHtPYmplY3R9XG4qKi9cbl9jQiA9IHt9LFxuXG4vKipcbk1hcCBvZiB0cmFuc2FjdGlvbiBzaW11bGF0ZWQgcmVhZHlTdGF0ZSB2YWx1ZXNcbndoZW4gWERvbWFpblJlcXVlc3QgaXMgdGhlIHRyYW5zcG9ydC5cblxuQHByb3BlcnR5IF9yU1xuQHByaXZhdGVcbkB0eXBlIHtPYmplY3R9XG4qKi9cbl9yUyA9IHt9LFxuXG4vLyBEb2N1bWVudCByZWZlcmVuY2VcbmQgPSBZLmNvbmZpZy5kb2MsXG4vLyBXaW5kb3cgcmVmZXJlbmNlXG53ID0gWS5jb25maWcud2luLFxuLy8gWERvbWFpblJlcXVlc3QgY3Jvc3Mtb3JpZ2luIHJlcXVlc3QgZGV0ZWN0aW9uXG54ZHIgPSB3ICYmIHcuWERvbWFpblJlcXVlc3Q7XG5cbi8qKlxuTWV0aG9kIHRoYXQgY3JlYXRlcyB0aGUgRmxhc2ggdHJhbnNwb3J0IHN3Zi5cblxuQG1ldGhvZCBfc3dmXG5AcHJpdmF0ZVxuQHBhcmFtIHtTdHJpbmd9IHVyaSAtIGxvY2F0aW9uIG9mIGlvLnN3Zi5cbkBwYXJhbSB7U3RyaW5nfSB5aWQgLSBZVUkgc2FuZGJveCBpZC5cbkBwYXJhbSB7U3RyaW5nfSB1aWQgLSBJTyBpbnN0YW5jZSBpZC5cbioqL1xuZnVuY3Rpb24gX3N3Zih1cmksIHlpZCwgdWlkKSB7XG4gICAgdmFyIG8gPSAnPG9iamVjdCBpZD1cImlvX3N3ZlwiIHR5cGU9XCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiIGRhdGE9XCInICtcbiAgICAgICAgICAgIHVyaSArICdcIiB3aWR0aD1cIjBcIiBoZWlnaHQ9XCIwXCI+JyArXG4gICAgICAgICAgICAnPHBhcmFtIG5hbWU9XCJtb3ZpZVwiIHZhbHVlPVwiJyArIHVyaSArICdcIj4nICtcbiAgICAgICAgICAgICc8cGFyYW0gbmFtZT1cIkZsYXNoVmFyc1wiIHZhbHVlPVwieWlkPScgKyB5aWQgKyAnJnVpZD0nICsgdWlkICsgJ1wiPicgK1xuICAgICAgICAgICAgJzxwYXJhbSBuYW1lPVwiYWxsb3dTY3JpcHRBY2Nlc3NcIiB2YWx1ZT1cImFsd2F5c1wiPicgK1xuICAgICAgICAgICAgJzwvb2JqZWN0PicsXG4gICAgICAgIGMgPSBkLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgZC5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgIGMuaW5uZXJIVE1MID0gbztcbn1cblxuLyoqXG5DcmVhdGVzIGEgcmVzcG9uc2Ugb2JqZWN0IGZvciBYRFIgdHJhbnNhY3Rpb25zLCBmb3Igc3VjY2Vzc1xuYW5kIGZhaWx1cmUgY2FzZXMuXG5cbkBtZXRob2QgX2RhdGFcbkBwcml2YXRlXG5AcGFyYW0ge09iamVjdH0gbyAtIFRyYW5zYWN0aW9uIG9iamVjdCBnZW5lcmF0ZWQgYnkgX2NyZWF0ZSgpIGluIGlvLWJhc2UuXG5AcGFyYW0ge0Jvb2xlYW59IHUgLSBDb25maWd1cmF0aW9uIHhkci51c2UuXG5AcGFyYW0ge0Jvb2xlYW59IGQgLSBDb25maWd1cmF0aW9uIHhkci5kYXRhVHlwZS5cblxuQHJldHVybiB7T2JqZWN0fVxuKiovXG5mdW5jdGlvbiBfZGF0YShvLCB1LCBkKSB7XG4gICAgaWYgKHUgPT09ICdmbGFzaCcpIHtcbiAgICAgICAgby5jLnJlc3BvbnNlVGV4dCA9IGRlY29kZVVSSShvLmMucmVzcG9uc2VUZXh0KTtcbiAgICB9XG4gICAgaWYgKGQgPT09ICd4bWwnKSB7XG4gICAgICAgIG8uYy5yZXNwb25zZVhNTCA9IFkuRGF0YVR5cGUuWE1MLnBhcnNlKG8uYy5yZXNwb25zZVRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBvO1xufVxuXG4vKipcbk1ldGhvZCBmb3IgaW50aWF0aW5nIGFuIFhEUiB0cmFuc2FjdGlvbiBhYm9ydC5cblxuQG1ldGhvZCBfYWJvcnRcbkBwcml2YXRlXG5AcGFyYW0ge09iamVjdH0gbyAtIFRyYW5zYWN0aW9uIG9iamVjdCBnZW5lcmF0ZWQgYnkgX2NyZWF0ZSgpIGluIGlvLWJhc2UuXG5AcGFyYW0ge09iamVjdH0gYyAtIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdHJhbnNhY3Rpb24uXG4qKi9cbmZ1bmN0aW9uIF9hYm9ydChvLCBjKSB7XG4gICAgcmV0dXJuIG8uYy5hYm9ydChvLmlkLCBjKTtcbn1cblxuLyoqXG5NZXRob2QgZm9yIGRldGVybWluaW5nIGlmIGFuIFhEUiB0cmFuc2FjdGlvbiBoYXMgY29tcGxldGVkXG5hbmQgYWxsIGRhdGEgYXJlIHJlY2VpdmVkLlxuXG5AbWV0aG9kIF9pc0luUHJvZ3Jlc3NcbkBwcml2YXRlXG5AcGFyYW0ge09iamVjdH0gbyAtIFRyYW5zYWN0aW9uIG9iamVjdCBnZW5lcmF0ZWQgYnkgX2NyZWF0ZSgpIGluIGlvLWJhc2UuXG4qKi9cbmZ1bmN0aW9uIF9pc0luUHJvZ3Jlc3Mobykge1xuICAgIHJldHVybiB4ZHIgPyBfclNbby5pZF0gIT09IDQgOiBvLmMuaXNJblByb2dyZXNzKG8uaWQpO1xufVxuXG5ZLm1peChZLklPLnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgTWFwIG9mIGlvIHRyYW5zcG9ydHMuXG5cbiAgICBAcHJvcGVydHkgX3RyYW5zcG9ydFxuICAgIEBwcml2YXRlXG4gICAgQHR5cGUge09iamVjdH1cbiAgICAqKi9cbiAgICBfdHJhbnNwb3J0OiB7fSxcblxuICAgIC8qKlxuICAgIFNldHMgZXZlbnQgaGFuZGxlcnMgZm9yIFhEb21haW5SZXF1ZXN0IHRyYW5zYWN0aW9ucy5cblxuICAgIEBtZXRob2QgX2llRXZ0XG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQHBhcmFtIHtPYmplY3R9IG8gLSBUcmFuc2FjdGlvbiBvYmplY3QgZ2VuZXJhdGVkIGJ5IF9jcmVhdGUoKSBpbiBpby1iYXNlLlxuICAgIEBwYXJhbSB7T2JqZWN0fSBjIC0gY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqKi9cbiAgICBfaWVFdnQ6IGZ1bmN0aW9uKG8sIGMpIHtcbiAgICAgICAgdmFyIGlvID0gdGhpcyxcbiAgICAgICAgICAgIGkgPSBvLmlkLFxuICAgICAgICAgICAgdCA9ICd0aW1lb3V0JztcblxuICAgICAgICBvLmMub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkgeyBfclNbaV0gPSAzOyB9O1xuICAgICAgICBvLmMub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfclNbaV0gPSA0O1xuICAgICAgICAgICAgaW8ueGRyUmVzcG9uc2UoJ3N1Y2Nlc3MnLCBvLCBjKTtcbiAgICAgICAgfTtcbiAgICAgICAgby5jLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF9yU1tpXSA9IDQ7XG4gICAgICAgICAgICBpby54ZHJSZXNwb25zZSgnZmFpbHVyZScsIG8sIGMpO1xuICAgICAgICB9O1xuICAgICAgICBvLmMub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfclNbaV0gPSA0O1xuICAgICAgICAgICAgaW8ueGRyUmVzcG9uc2UodCwgbywgYyk7XG4gICAgICAgIH07XG4gICAgICAgIG8uY1t0XSA9IGNbdF0gfHwgMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgTWV0aG9kIGZvciBhY2Nlc3NpbmcgdGhlIHRyYW5zcG9ydCdzIGludGVyZmFjZSBmb3IgbWFraW5nIGFcbiAgICBjcm9zcy1kb21haW4gdHJhbnNhY3Rpb24uXG5cbiAgICBAbWV0aG9kIHhkclxuICAgIEBwYXJhbSB7U3RyaW5nfSB1cmkgLSBxdWFsaWZpZWQgcGF0aCB0byB0cmFuc2FjdGlvbiByZXNvdXJjZS5cbiAgICBAcGFyYW0ge09iamVjdH0gbyAtIFRyYW5zYWN0aW9uIG9iamVjdCBnZW5lcmF0ZWQgYnkgX2NyZWF0ZSgpIGluIGlvLWJhc2UuXG4gICAgQHBhcmFtIHtPYmplY3R9IGMgLSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICoqL1xuICAgIHhkcjogZnVuY3Rpb24odXJpLCBvLCBjKSB7XG4gICAgICAgIHZhciBpbyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGMueGRyLnVzZSA9PT0gJ2ZsYXNoJykge1xuICAgICAgICAgICAgLy8gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNhbm5vdCBiZSBzZXJpYWxpemVkIHNhZmVseVxuICAgICAgICAgICAgLy8gYWNyb3NzIEZsYXNoJ3MgRXh0ZXJuYWxJbnRlcmZhY2UuXG4gICAgICAgICAgICBfY0Jbby5pZF0gPSBjO1xuICAgICAgICAgICAgdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG8uYy5zZW5kKHVyaSwgeyBpZDogby5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogby51aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogYy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogYy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlvLnhkclJlc3BvbnNlKCd0cmFuc3BvcnQgZXJyb3InLCBvLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9jQltvLmlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBZLmlvLnhkci5kZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeGRyKSB7XG4gICAgICAgICAgICBpby5faWVFdnQobywgYyk7XG4gICAgICAgICAgICBvLmMub3BlbihjLm1ldGhvZCB8fCAnR0VUJywgdXJpKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBhc3luYyB0byBwcm90ZWN0IGFnYWluc3QgSUUgOCBvZGRpdGllcy5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgby5jLnNlbmQoYy5kYXRhKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgby5jLnNlbmQodXJpLCBvLCBjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogby5pZCxcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gby5jID8gX2Fib3J0KG8sIGMpIDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNJblByb2dyZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gby5jID8gX2lzSW5Qcm9ncmVzcyhvLmlkKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlvOiBpb1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBSZXNwb25zZSBjb250cm9sbGVyIGZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMgd2hlbiB1c2luZyB0aGVcbiAgICBGbGFzaCB0cmFuc3BvcnQgb3IgSUU4J3MgWERvbWFpblJlcXVlc3Qgb2JqZWN0LlxuXG4gICAgQG1ldGhvZCB4ZHJSZXNwb25zZVxuICAgIEBwYXJhbSB7U3RyaW5nfSBlIEV2ZW50IG5hbWVcbiAgICBAcGFyYW0ge09iamVjdH0gbyBUcmFuc2FjdGlvbiBvYmplY3QgZ2VuZXJhdGVkIGJ5IF9jcmVhdGUoKSBpbiBpby1iYXNlLlxuICAgIEBwYXJhbSB7T2JqZWN0fSBjIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgQHJldHVybiB7T2JqZWN0fVxuICAgICoqL1xuICAgIHhkclJlc3BvbnNlOiBmdW5jdGlvbihlLCBvLCBjKSB7XG4gICAgICAgIGMgPSBfY0Jbby5pZF0gPyBfY0Jbby5pZF0gOiBjO1xuICAgICAgICB2YXIgaW8gPSB0aGlzLFxuICAgICAgICAgICAgbSA9IHhkciA/IF9yUyA6IF9jQixcbiAgICAgICAgICAgIHUgPSBjLnhkci51c2UsXG4gICAgICAgICAgICBkID0gYy54ZHIuZGF0YVR5cGU7XG5cbiAgICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgaW8uc3RhcnQobywgYyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIC8vY2FzZSAnY29tcGxldGUnOlxuICAgICAgICAgICAgICAgIC8vVGhpcyBjYXNlIGlzIG5vdCB1c2VkIGJ5IEZsYXNoIG9yIFhEb21haW5SZXF1ZXN0LlxuICAgICAgICAgICAgICAgIC8vaW8uY29tcGxldGUobywgYyk7XG4gICAgICAgICAgICAgICAgLy9icmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxuICAgICAgICAgICAgICAgIGlvLnN1Y2Nlc3MoX2RhdGEobywgdSwgZCksIGMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtW28uaWRdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGltZW91dCc6XG4gICAgICAgICAgICBjYXNlICdhYm9ydCc6XG4gICAgICAgICAgICBjYXNlICd0cmFuc3BvcnQgZXJyb3InOlxuICAgICAgICAgICAgICAgIG8uYyA9IHsgc3RhdHVzOiAwLCBzdGF0dXNUZXh0OiBlIH07XG4gICAgICAgICAgICBjYXNlICdmYWlsdXJlJzpcbiAgICAgICAgICAgICAgICBpby5mYWlsdXJlKF9kYXRhKG8sIHUsIGQpLCBjKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbVtvLmlkXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICBGaXJlcyBldmVudCBcImlvOnhkclJlYWR5XCJcblxuICAgIEBtZXRob2QgX3hkclJlYWR5XG4gICAgQHByaXZhdGVcbiAgICBAcGFyYW0ge051bWJlcn0geWlkIC0gWVVJIHNhbmRib3ggaWQuXG4gICAgQHBhcmFtIHtOdW1iZXJ9IHVpZCAtIElPIGluc3RhbmNlIGlkLlxuICAgICoqL1xuICAgIF94ZHJSZWFkeTogZnVuY3Rpb24oeWlkLCB1aWQpIHtcbiAgICAgICAgWS5maXJlKEVfWERSX1JFQURZLCB5aWQsIHVpZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIEluaXRpYWxpemVzIHRoZSBkZXNpcmVkIHRyYW5zcG9ydC5cblxuICAgIEBtZXRob2QgdHJhbnNwb3J0XG4gICAgQHBhcmFtIHtPYmplY3R9IG8gLSBvYmplY3Qgb2YgdHJhbnNwb3J0IGNvbmZpZ3VyYXRpb25zLlxuICAgICoqL1xuICAgIHRyYW5zcG9ydDogZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoYy5pZCA9PT0gJ2ZsYXNoJykge1xuICAgICAgICAgICAgX3N3ZihZLlVBLmllID8gYy5zcmMgKyAnP2Q9JyArIG5ldyBEYXRlKCkudmFsdWVPZigpLnRvU3RyaW5nKCkgOiBjLnNyYywgWS5pZCwgYy51aWQpO1xuICAgICAgICAgICAgWS5JTy50cmFuc3BvcnRzLmZsYXNoID0gZnVuY3Rpb24oKSB7IHJldHVybiBkLmdldEVsZW1lbnRCeUlkKCdpb19zd2YnKTsgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbkZpcmVzIGV2ZW50IFwiaW86eGRyUmVhZHlcIlxuXG5AbWV0aG9kIHhkclJlYWR5XG5AcHJvdGVjdGVkXG5Ac3RhdGljXG5AcGFyYW0ge051bWJlcn0geWlkIC0gWVVJIHNhbmRib3ggaWQuXG5AcGFyYW0ge051bWJlcn0gdWlkIC0gSU8gaW5zdGFuY2UgaWQuXG4qKi9cblkuaW8ueGRyUmVhZHkgPSBmdW5jdGlvbih5aWQsIHVpZCl7XG4gICAgdmFyIGlvID0gWS5pby5fbWFwW3VpZF07XG4gICAgWS5pby54ZHIuZGVsYXkgPSAwO1xuICAgIGlvLl94ZHJSZWFkeS5hcHBseShpbywgW3lpZCwgdWlkXSk7XG59O1xuXG5ZLmlvLnhkclJlc3BvbnNlID0gZnVuY3Rpb24oZSwgbywgYyl7XG4gICAgdmFyIGlvID0gWS5pby5fbWFwW28udWlkXTtcbiAgICBpby54ZHJSZXNwb25zZS5hcHBseShpbywgW2UsIG8sIGNdKTtcbn07XG5cblkuaW8udHJhbnNwb3J0ID0gZnVuY3Rpb24oYyl7XG4gICAgdmFyIGlvID0gWS5pby5fbWFwWydpbzowJ10gfHwgbmV3IFkuSU8oKTtcbiAgICBjLnVpZCA9IGlvLl91aWQ7XG4gICAgaW8udHJhbnNwb3J0LmFwcGx5KGlvLCBbY10pO1xufTtcblxuLyoqXG5EZWxheSB2YWx1ZSB0byBjYWxsaW5nIHRoZSBGbGFzaCB0cmFuc3BvcnQsIGluIHRoZVxuZXZlbnQgaW8uc3dmIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy4gIE9uY2UgdGhlIEVfWERSX1JFQURZXG5ldmVudCBpcyBmaXJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIHNldCB0byAwLlxuXG5AcHJvcGVydHkgZGVsYXlcbkBzdGF0aWNcbkB0eXBlIHtOdW1iZXJ9XG4qKi9cblkuaW8ueGRyID0geyBkZWxheSA6IDEwMCB9O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJpby1iYXNlXCIsIFwiZGF0YXR5cGUteG1sLXBhcnNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ2pzb24tcGFyc2UnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG52YXIgX0pTT04gPSBZLmNvbmZpZy5nbG9iYWwuSlNPTjtcblxuWS5uYW1lc3BhY2UoJ0pTT04nKS5wYXJzZSA9IGZ1bmN0aW9uIChvYmosIHJldml2ZXIsIHNwYWNlKSB7XG4gICAgcmV0dXJuIF9KU09OLnBhcnNlKCh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyA/IG9iaiA6IG9iaiArICcnKSwgcmV2aXZlciwgc3BhY2UpO1xufTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wieXVpLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnanNvbi1zdHJpbmdpZnknLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIFByb3ZpZGVzIFkuSlNPTi5zdHJpbmdpZnkgbWV0aG9kIGZvciBjb252ZXJ0aW5nIG9iamVjdHMgdG8gSlNPTiBzdHJpbmdzLlxuICpcbiAqIEBtb2R1bGUganNvblxuICogQHN1Ym1vZHVsZSBqc29uLXN0cmluZ2lmeVxuICogQGZvciBKU09OXG4gKiBAc3RhdGljXG4gKi9cbnZhciBDT0xPTiAgICAgPSAnOicsXG4gICAgX0pTT04gICAgID0gWS5jb25maWcuZ2xvYmFsLkpTT047XG5cblkubWl4KFkubmFtZXNwYWNlKCdKU09OJyksIHtcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGEgRGF0ZSBpbnN0YW5jZSBhcyBhIFVUQyBkYXRlIHN0cmluZy4gIFVzZWQgaW50ZXJuYWxseSBieVxuICAgICAqIHN0cmluZ2lmeS4gIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSBuZWVkIERhdGVzIHNlcmlhbGl6ZWQgaW4gYVxuICAgICAqIGRpZmZlcmVudCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRhdGVUb1N0cmluZ1xuICAgICAqIEBwYXJhbSBkIHtEYXRlfSBUaGUgRGF0ZSB0byBzZXJpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZ2lmaWVkIERhdGUgaW4gVVRDIGZvcm1hdCBZWVlZLU1NLUREVEhIOm1tOlNTWlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBhIHJlcGxhY2VyIGZ1bmN0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGRhdGVUb1N0cmluZzogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZnVuY3Rpb24gX3plcm9QYWQodikge1xuICAgICAgICAgICAgcmV0dXJuIHYgPCAxMCA/ICcwJyArIHYgOiB2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKSAgICAgICAgICAgKyAnLScgK1xuICAgICAgICAgICAgICBfemVyb1BhZChkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgICAgICAgIF96ZXJvUGFkKGQuZ2V0VVRDRGF0ZSgpKSAgICAgICsgJ1QnICtcbiAgICAgICAgICAgICAgX3plcm9QYWQoZC5nZXRVVENIb3VycygpKSAgICAgKyBDT0xPTiArXG4gICAgICAgICAgICAgIF96ZXJvUGFkKGQuZ2V0VVRDTWludXRlcygpKSAgICsgQ09MT04gK1xuICAgICAgICAgICAgICBfemVyb1BhZChkLmdldFVUQ1NlY29uZHMoKSkgICArICdaJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogPHA+Q29udmVydHMgYW4gYXJiaXRyYXJ5IHZhbHVlIHRvIGEgSlNPTiBzdHJpbmcgcmVwcmVzZW50YXRpb24uPC9wPlxuICAgICAqXG4gICAgICogPHA+T2JqZWN0cyB3aXRoIGN5Y2xpY2FsIHJlZmVyZW5jZXMgd2lsbCB0cmlnZ2VyIGFuIGV4Y2VwdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiA8cD5JZiBhIHdoaXRlbGlzdCBpcyBwcm92aWRlZCwgb25seSBtYXRjaGluZyBvYmplY3Qga2V5cyB3aWxsIGJlXG4gICAgICogaW5jbHVkZWQuICBBbHRlcm5hdGVseSwgYSByZXBsYWNlciBmdW5jdGlvbiBtYXkgYmUgcGFzc2VkIGFzIHRoZVxuICAgICAqIHNlY29uZCBwYXJhbWV0ZXIuICBUaGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIG9uIGV2ZXJ5IHZhbHVlIGluIHRoZVxuICAgICAqIGlucHV0LCBhbmQgaXRzIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHRvIHNlcmlhbGl6ZSBzcGVjaWFsaXplZCBvYmplY3RzIG9yIGNsYXNzIGluc3RhbmNlcy48L3A+XG4gICAgICpcbiAgICAgKiA8cD5JZiBhIHBvc2l0aXZlIGludGVnZXIgb3Igbm9uLWVtcHR5IHN0cmluZyBpcyBwYXNzZWQgYXMgdGhlIHRoaXJkXG4gICAgICogcGFyYW1ldGVyLCB0aGUgb3V0cHV0IHdpbGwgYmUgZm9ybWF0dGVkIHdpdGggY2FycmlhZ2UgcmV0dXJucyBhbmRcbiAgICAgKiBpbmRlbnRhdGlvbiBmb3IgcmVhZGFiaWxpdHkuICBJZiBhIFN0cmluZyBpcyBwYXNzZWQgKHN1Y2ggYXMgXCJcXHRcIikgaXRcbiAgICAgKiB3aWxsIGJlIHVzZWQgb25jZSBmb3IgZWFjaCBpbmRlbnRhdGlvbiBsZXZlbC4gIElmIGEgbnVtYmVyIGlzIHBhc3NlZCxcbiAgICAgKiB0aGF0IG51bWJlciBvZiBzcGFjZXMgd2lsbCBiZSB1c2VkLjwvcD5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc3RyaW5naWZ5XG4gICAgICogQHBhcmFtIG8ge01JWEVEfSBhbnkgYXJiaXRyYXJ5IHZhbHVlIHRvIGNvbnZlcnQgdG8gSlNPTiBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdyB7QXJyYXl8RnVuY3Rpb259IChvcHRpb25hbCkgd2hpdGVsaXN0IG9mIGFjY2VwdGFibGUgb2JqZWN0XG4gICAgICogICAgICAgICAgICAgICAgICBrZXlzIHRvIGluY2x1ZGUsIG9yIGEgcmVwbGFjZXIgZnVuY3Rpb24gdG8gbW9kaWZ5IHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgcmF3IHZhbHVlIGJlZm9yZSBzZXJpYWxpemF0aW9uXG4gICAgICogQHBhcmFtIGluZCB7TnVtYmVyfFN0cmluZ30gKG9wdGlvbmFsKSBpbmRlbnRhdGlvbiBjaGFyYWN0ZXIgb3IgZGVwdGggb2ZcbiAgICAgKiAgICAgICAgICAgICAgICAgIHNwYWNlcyB0byBmb3JtYXQgdGhlIG91dHB1dC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEpTT04gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnB1dFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9KU09OLnN0cmluZ2lmeS5hcHBseShfSlNPTiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogPHA+TnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIGEgc3BlY2lhbCBjaGFyYWN0ZXIgd2l0aGluIGEgc2luZ2xlIGNhbGwgdG9cbiAgICAgKiBzdHJpbmdpZnkgdGhhdCBzaG91bGQgdHJpZ2dlciBwcm9tb3Rpb24gb2YgdGhhdCBjaGFyYWN0ZXIgdG8gYSBkZWRpY2F0ZWRcbiAgICAgKiBwcmVwcm9jZXNzIHN0ZXAgZm9yIGZ1dHVyZSBjYWxscy4gIFRoaXMgaXMgb25seSB1c2VkIGluIGVudmlyb25tZW50c1xuICAgICAqIHRoYXQgZG9uJ3Qgc3VwcG9ydCBuYXRpdmUgSlNPTiwgb3Igd2hlbiB1c2VOYXRpdmVKU09OU3RyaW5naWZ5IGlzIHNldCB0b1xuICAgICAqIGZhbHNlLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlNvLCBpZiBzZXQgdG8gNTAgYW5kIGFuIG9iamVjdCBpcyBwYXNzZWQgdG8gc3RyaW5naWZ5IHRoYXQgaW5jbHVkZXNcbiAgICAgKiBzdHJpbmdzIGNvbnRhaW5pbmcgdGhlIHNwZWNpYWwgY2hhcmFjdGVyIFxceDA3IG1vcmUgdGhhbiA1MCB0aW1lcyxcbiAgICAgKiBzdWJzZXF1ZW50IGNhbGxzIHRvIHN0cmluZ2lmeSB3aWxsIHByb2Nlc3Mgb2JqZWN0IHN0cmluZ3MgdGhyb3VnaCBhXG4gICAgICogZmFzdGVyIHNlcmlhbGl6YXRpb24gcGF0aCBmb3IgXFx4MDcgYmVmb3JlIHVzaW5nIHRoZSBnZW5lcmljLCBzbG93ZXIsXG4gICAgICogcmVwbGFjZW1lbnQgcHJvY2VzcyBmb3IgYWxsIHNwZWNpYWwgY2hhcmFjdGVycy48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UbyBwcmltZSB0aGUgcHJlcHJvY2Vzc29yIGNhY2hlLCBzZXQgdGhpcyB2YWx1ZSB0byAxLCB0aGVuIGNhbGxcbiAgICAgKiA8Y29kZT5ZLkpTT04uc3RyaW5naWZ5KFwiPGVtPihhbGwgc3BlY2lhbCBjaGFyYWN0ZXJzIHRvXG4gICAgICogY2FjaGUpPC9lbT5cIik7PC9jb2RlPiwgdGhlbiByZXR1cm4gdGhpcyBzZXR0aW5nIHRvIGEgbW9yZSBjb25zZXJ2YXRpdmVcbiAgICAgKiB2YWx1ZS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5TcGVjaWFsIGNoYXJhY3RlcnMgXFwgXCIgXFxiIFxcdCBcXG4gXFxmIFxcciBhcmUgYWxyZWFkeSBjYWNoZWQuPC9wPlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNoYXJDYWNoZVRocmVzaG9sZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZGVmYXVsdCAxMDBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGNoYXJDYWNoZVRocmVzaG9sZDogMTAwXG59KTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wieXVpLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnanNvbnAnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG52YXIgaXNGdW5jdGlvbiA9IFkuTGFuZy5pc0Z1bmN0aW9uO1xuXG4vKipcbiAqIDxwPlByb3ZpZGVzIGEgSlNPTlBSZXF1ZXN0IGNsYXNzIGZvciByZXBlYXRlZCBKU09OUCBjYWxscywgYW5kIGEgY29udmVuaWVuY2VcbiAqIG1ldGhvZCBZLmpzb25wKHVybCwgY2FsbGJhY2spIHRvIGluc3RhbnRpYXRlIGFuZCBzZW5kIGEgSlNPTlAgcmVxdWVzdC48L3A+XG4gKlxuICogPHA+Qm90aCB0aGUgY29uc3RydWN0b3IgYXMgd2VsbCBhcyB0aGUgY29udmVuaWVuY2UgZnVuY3Rpb24gdGFrZSB0d29cbiAqIHBhcmFtZXRlcnM6IGEgdXJsIHN0cmluZyBhbmQgYSBjYWxsYmFjay48L3A+XG4gKlxuICogPHA+VGhlIHVybCBwcm92aWRlZCBtdXN0IGluY2x1ZGUgdGhlIHBsYWNlaG9sZGVyIHN0cmluZ1xuICogJnF1b3Q7e2NhbGxiYWNrfSZxdW90OyB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgZHluYW1pY2FsbHlcbiAqIGdlbmVyYXRlZCByb3V0aW5nIGZ1bmN0aW9uIHRvIHBhc3MgdGhlIGRhdGEgdG8geW91ciBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEFuIGV4YW1wbGUgdXJsIG1pZ2h0IGxvb2sgbGlrZVxuICogJnF1b3Q7aHR0cDovL2V4YW1wbGUuY29tL3NlcnZpY2U/Y2FsbGJhY2s9e2NhbGxiYWNrfSZxdW90Oy48L3A+XG4gKlxuICogPHA+VGhlIHNlY29uZCBwYXJhbWV0ZXIgY2FuIGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSBKU09OXG4gKiBwYXlsb2FkIGFzIGl0cyBhcmd1bWVudCwgb3IgYSBjb25maWd1cmF0aW9uIG9iamVjdCBzdXBwb3J0aW5nIHRoZSBrZXlzOjwvcD5cbiAqIDx1bD5cbiAqICAgPGxpPm9uIC0gbWFwIG9mIGNhbGxiYWNrIHN1YnNjcmliZXJzXG4gKiAgICAgIDx1bD5cbiAqICAgICAgICAgPGxpPnN1Y2Nlc3MgLSBmdW5jdGlvbiBoYW5kbGVyIGZvciBzdWNjZXNzZnVsIHRyYW5zbWlzc2lvbjwvbGk+XG4gKiAgICAgICAgIDxsaT5mYWlsdXJlIC0gZnVuY3Rpb24gaGFuZGxlciBmb3IgZmFpbGVkIHRyYW5zbWlzc2lvbjwvbGk+XG4gKiAgICAgICAgIDxsaT50aW1lb3V0IC0gZnVuY3Rpb24gaGFuZGxlciBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgdGltZW91dDwvbGk+XG4gKiAgICAgIDwvdWw+XG4gKiAgPC9saT5cbiAqICA8bGk+Zm9ybWF0ICAtIG92ZXJyaWRlIGZ1bmN0aW9uIGZvciBpbnNlcnRpbmcgdGhlIHByb3h5IG5hbWUgaW4gdGhlIHVybDwvbGk+XG4gKiAgPGxpPnRpbWVvdXQgLSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBnaXZpbmcgdXA8L2xpPlxuICogIDxsaT5jb250ZXh0IC0gYmVjb21lcyA8Y29kZT50aGlzPC9jb2RlPiBpbiB0aGUgY2FsbGJhY2tzPC9saT5cbiAqICA8bGk+YXJncyAgICAtIGFycmF5IG9mIHN1YnNlcXVlbnQgcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBjYWxsYmFja3M8L2xpPlxuICogIDxsaT5hbGxvd0NhY2hlIC0gdXNlIHRoZSBzYW1lIHByb3h5IG5hbWUgZm9yIGFsbCByZXF1ZXN0cz8gKGJvb2xlYW4pPC9saT5cbiAqIDwvdWw+XG4gKlxuICogQG1vZHVsZSBqc29ucFxuICogQGNsYXNzIEpTT05QUmVxdWVzdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdXJsIHtTdHJpbmd9IHRoZSB1cmwgb2YgdGhlIEpTT05QIHNlcnZpY2VcbiAqIEBwYXJhbSBjYWxsYmFjayB7T2JqZWN0fEZ1bmN0aW9ufSB0aGUgZGVmYXVsdCBjYWxsYmFjayBjb25maWd1cmF0aW9uIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIEpTT05QUmVxdWVzdCgpIHtcbiAgICB0aGlzLl9pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbkpTT05QUmVxdWVzdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogU2V0IHVwIHRoZSBzdWNjZXNzIGFuZCBmYWlsdXJlIGhhbmRsZXJzIGFuZCB0aGUgcmVnZXggcGF0dGVybiB1c2VkXG4gICAgICogdG8gaW5zZXJ0IHRoZSB0ZW1wb3JhcnkgY2FsbGJhY2sgbmFtZSBpbiB0aGUgdXJsLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfaW5pdFxuICAgICAqIEBwYXJhbSB1cmwge1N0cmluZ30gdGhlIHVybCBvZiB0aGUgSlNPTlAgc2VydmljZVxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB7T2JqZWN0fEZ1bmN0aW9ufSBPcHRpb25hbCBzdWNjZXNzIGNhbGxiYWNrIG9yIGNvbmZpZ1xuICAgICAqICAgICAgICAgICAgICAgICAgb2JqZWN0IGNvbnRhaW5pbmcgc3VjY2VzcyBhbmQgZmFpbHVyZSBmdW5jdGlvbnMgYW5kXG4gICAgICogICAgICAgICAgICAgICAgICB0aGUgdXJsIHJlZ2V4LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5pdCA6IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb2YgdGhlIG51bWJlciBvZiByZXF1ZXN0cyBjdXJyZW50bHkgcGVuZGluZyByZXNwb25zZXMgcGVyXG4gICAgICAgICAqIGdlbmVyYXRlZCBwcm94eS4gIFVzZWQgdG8gZW5zdXJlIHRoZSBwcm94eSBpcyBub3QgZmx1c2hlZCBpZiB0aGVcbiAgICAgICAgICogcmVxdWVzdCB0aW1lcyBvdXQgYW5kIHRoZXJlIGlzIGEgdGltZW91dCBoYW5kbGVyIGFuZCBzdWNjZXNzXG4gICAgICAgICAqIGhhbmRsZXIsIGFuZCB1c2VkIGJ5IGNvbm5lY3Rpb25zIGNvbmZpZ3VyZWQgdG8gYWxsb3dDYWNoZSB0byBtYWtlXG4gICAgICAgICAqIHN1cmUgdGhlIHByb3h5IGlzbid0IGRlbGV0ZWQgdW50aWwgdGhlIGxhc3QgcmVzcG9uc2UgaGFzIHJldHVybmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX3JlcXVlc3RzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXF1ZXN0cyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb2YgdGhlIG51bWJlciBvZiB0aW1lb3V0cyByZWNlaXZlZCBmcm9tIHRoZSBkZXN0aW5hdGlvbiB1cmxcbiAgICAgICAgICogYnkgZ2VuZXJhdGVkIHByb3h5LiAgVXNlZCB0byBlbnN1cmUgdGhlIHByb3h5IGlzIG5vdCBmbHVzaGVkIGlmIHRoZVxuICAgICAgICAgKiByZXF1ZXN0IHRpbWVzIG91dCBhbmQgdGhlcmUgaXMgYSB0aW1lb3V0IGhhbmRsZXIgYW5kIHN1Y2Nlc3NcbiAgICAgICAgICogaGFuZGxlciwgYW5kIHVzZWQgYnkgY29ubmVjdGlvbnMgY29uZmlndXJlZCB0byBhbGxvd0NhY2hlIHRvIG1ha2VcbiAgICAgICAgICogc3VyZSB0aGUgcHJveHkgaXNuJ3QgZGVsZXRlZCB1bnRpbCB0aGUgbGFzdCByZXNwb25zZSBoYXMgcmV0dXJuZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdGltZW91dHNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RpbWVvdXRzID0ge307XG5cbiAgICAgICAgLy8gQWNjZXB0IGEgZnVuY3Rpb24sIGFuIG9iamVjdCwgb3Igbm90aGluZ1xuICAgICAgICBjYWxsYmFjayA9IChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkgP1xuICAgICAgICAgICAgeyBvbjogeyBzdWNjZXNzOiBjYWxsYmFjayB9IH0gOlxuICAgICAgICAgICAgY2FsbGJhY2sgfHwge307XG5cbiAgICAgICAgdmFyIHN1YnMgPSBjYWxsYmFjay5vbiB8fCB7fTtcblxuICAgICAgICBpZiAoIXN1YnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgc3Vicy5zdWNjZXNzID0gdGhpcy5fZGVmYXVsdENhbGxiYWNrKHVybCwgY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgZGVmYXVsdHMgYW5kIHN0b3JlXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IFkubWVyZ2Uoe1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncyAgIDogW10sXG4gICAgICAgICAgICAgICAgZm9ybWF0IDogdGhpcy5fZm9ybWF0LFxuICAgICAgICAgICAgICAgIGFsbG93Q2FjaGU6IGZhbHNlXG4gICAgICAgICAgICB9LCBjYWxsYmFjaywgeyBvbjogc3VicyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcHJvdmlkZSBsb2dpYyB0byBkZWZhdWx0IHRoZSBzdWNjZXNzIGNhbGxiYWNrIGlmXG4gICAgICogaXQgaXMgbm90IHByb3ZpZGVkIGF0IGNvbnN0cnVjdGlvbi4gIFRoaXMgaXMgb3ZlcnJpZGRlbiBieSBqc29ucC11cmwgdG9cbiAgICAgKiBwYXJzZSB0aGUgY2FsbGJhY2sgZnJvbSB0aGUgdXJsIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2RlZmF1bHRDYWxsYmFja1xuICAgICAqIEBwYXJhbSB1cmwge1N0cmluZ30gdGhlIHVybCBwYXNzZWQgYXQgY29uc3RydWN0aW9uXG4gICAgICogQHBhcmFtIGNvbmZpZyB7T2JqZWN0fSAob3B0aW9uYWwpIHRoZSBjb25maWcgb2JqZWN0IHBhc3NlZCBhdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0aW9uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgX2RlZmF1bHRDYWxsYmFjazogZnVuY3Rpb24gKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBJc3N1ZXMgdGhlIEpTT05QIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbmRcbiAgICAgKiBAcGFyYW0gYXJncyoge2FueX0gYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIHVybCBmb3JtYXR0ZXJcbiAgICAgKiAgICAgICAgICAgICAgYmV5b25kIHRoZSBiYXNlIHVybCBhbmQgdGhlIHByb3h5IGZ1bmN0aW9uIG5hbWVcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgICA9IHRoaXMsXG4gICAgICAgICAgICBhcmdzICAgPSBZLkFycmF5KGFyZ3VtZW50cywgMCwgdHJ1ZSksXG4gICAgICAgICAgICBjb25maWcgPSBzZWxmLl9jb25maWcsXG4gICAgICAgICAgICBwcm94eSAgPSBzZWxmLl9wcm94eSB8fCBZLmd1aWQoKSxcbiAgICAgICAgICAgIHVybDtcblxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFsbG93Q2FjaGUgYXMgdGltZSB2YWx1ZVxuICAgICAgICBpZiAoY29uZmlnLmFsbG93Q2FjaGUpIHtcbiAgICAgICAgICAgIHNlbGYuX3Byb3h5ID0gcHJveHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5fcmVxdWVzdHNbcHJveHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3JlcXVlc3RzW3Byb3h5XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuX3RpbWVvdXRzW3Byb3h5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmLl90aW1lb3V0c1twcm94eV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX3JlcXVlc3RzW3Byb3h5XSsrO1xuXG5cbiAgICAgICAgYXJncy51bnNoaWZ0KHNlbGYudXJsLCAnWVVJLkVudi5KU09OUC4nICsgcHJveHkpO1xuICAgICAgICB1cmwgPSBjb25maWcuZm9ybWF0LmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICAgIGlmICghY29uZmlnLm9uLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd3JhcChmbiwgaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzRnVuY3Rpb24oZm4pKSA/XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4ZWN1dGUgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlciA9ICdfcmVxdWVzdHMnO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKGNvbmZpZy5hbGxvd0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGxvdCBvZiB3cmFuZ2xpbmcgdG8gbWFrZSBzdXJlIHRpbWVvdXRzIHJlc3VsdCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmV3ZXIgc3VjY2VzcyBjYWxsYmFja3MsIGJ1dCB0aGUgcHJveHkgaXMgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFuZWQgdXAuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytzZWxmLl90aW1lb3V0c1twcm94eV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1zZWxmLl9yZXF1ZXN0c1twcm94eV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5fcmVxdWVzdHNbcHJveHldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlciA9ICdfdGltZW91dHMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLXNlbGZbY291bnRlcl1bcHJveHldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuX3JlcXVlc3RzW3Byb3h5XSAmJiAhc2VsZi5fdGltZW91dHNbcHJveHldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgWVVJLkVudi5KU09OUFtwcm94eV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkoY29uZmlnLmNvbnRleHQsIFtkYXRhXS5jb25jYXQoY29uZmlnLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wb3JhcnkgdW4tc2FuZGJveGVkIGZ1bmN0aW9uIGFsaWFzXG4gICAgICAgIC8vIFRPRE86IHF1ZXVpbmdcbiAgICAgICAgWVVJLkVudi5KU09OUFtwcm94eV0gPSB3cmFwKGNvbmZpZy5vbi5zdWNjZXNzKTtcblxuICAgICAgICAvLyBZLkdldCB0cmFuc2FjdGlvbnMgYmxvY2sgZWFjaCBvdGhlciBieSBkZXNpZ24sIGJ1dCBjYW4gZWFzaWx5XG4gICAgICAgIC8vICBiZSBtYWRlIG5vbi1ibG9ja2luZyBieSBqdXN0IGNhbGxpbmcgZXhlY3V0ZSgpIG9uIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1aS95dWkzL3B1bGwvMzkzI2lzc3VlY29tbWVudC0xMTk2MTYwOFxuICAgICAgICBZLkdldC5qcyh1cmwsIHtcbiAgICAgICAgICAgIG9uRmFpbHVyZSA6IHdyYXAoY29uZmlnLm9uLmZhaWx1cmUpLFxuICAgICAgICAgICAgb25UaW1lb3V0IDogd3JhcChjb25maWcub24udGltZW91dCwgdHJ1ZSksXG4gICAgICAgICAgICB0aW1lb3V0ICAgOiBjb25maWcudGltZW91dCxcbiAgICAgICAgICAgIGNoYXJzZXQgICA6IGNvbmZpZy5jaGFyc2V0LFxuICAgICAgICAgICAgYXR0cmlidXRlczogY29uZmlnLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBhc3luYyAgICAgOiBjb25maWcuYXN5bmNcbiAgICAgICAgfSkuZXhlY3V0ZSgpO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHVybCBmb3JtYXR0ZXIuICBMb29rcyBmb3IgY2FsbGJhY2s9IGluIHRoZSB1cmwgYW5kIGFwcGVuZHMgaXRcbiAgICAgKiBpZiBub3QgcHJlc2VudC4gIFRoZSBzdXBwbGllZCBwcm94eSBuYW1lIHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIHF1ZXJ5XG4gICAgICogcGFyYW0uICBPdmVycmlkZSB0aGlzIG1ldGhvZCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gYXMgdGhlXG4gICAgICogJnF1b3Q7Zm9ybWF0JnF1b3Q7IHByb3BlcnR5IGluIHRoZSBjb25maWcgb2JqZWN0IHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2Zvcm1hdFxuICAgICAqIEBwYXJhbSB1cmwgeyBTdHJpbmcgfSB0aGUgb3JpZ2luYWwgdXJsXG4gICAgICogQHBhcmFtIHByb3h5IHtTdHJpbmd9IHRoZSBmdW5jdGlvbiBuYW1lIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGEgcHJveHkgdG9cbiAgICAgKiAgICAgIHRoZSBjb25maWd1cmVkIGNhbGxiYWNrIG1ldGhvZHMuXG4gICAgICogQHBhcmFtIGFyZ3MqIHthbnl9IGFkZGl0aW9uYWwgYXJncyBwYXNzZWQgdG8gc2VuZCgpXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBmdWxseSBxdWFsaWZpZWQgSlNPTlAgdXJsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9mb3JtYXQ6IGZ1bmN0aW9uICh1cmwsIHByb3h5KSB7XG4gICAgICAgIHJldHVybiB1cmwucmVwbGFjZSgvXFx7Y2FsbGJhY2tcXH0vLCBwcm94eSk7XG4gICAgfVxufTtcblxuWS5KU09OUFJlcXVlc3QgPSBKU09OUFJlcXVlc3Q7XG5cbi8qKlxuICpcbiAqIEBtZXRob2QganNvbnBcbiAqIEBwYXJhbSB1cmwge1N0cmluZ30gdGhlIHVybCBvZiB0aGUgSlNPTlAgc2VydmljZSB3aXRoIHRoZSB7Y2FsbGJhY2t9XG4gKiAgICAgICAgICBwbGFjZWhvbGRlciB3aGVyZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gbmFtZSB0eXBpY2FsbHkgZ29lcy5cbiAqIEBwYXJhbSBjIHtGdW5jdGlvbnxPYmplY3R9IENhbGxiYWNrIGZ1bmN0aW9uIGFjY2VwdGluZyB0aGUgSlNPTiBwYXlsb2FkXG4gKiAgICAgICAgICBhcyBpdHMgYXJndW1lbnQsIG9yIGEgY29uZmlndXJhdGlvbiBvYmplY3QgKHNlZSBhYm92ZSkuXG4gKiBAcGFyYW0gYXJncyoge2FueX0gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byBzZW5kKClcbiAqIEByZXR1cm4ge0pTT05QUmVxdWVzdH1cbiAqIEBzdGF0aWNcbiAqIEBmb3IgWVVJXG4gKi9cblkuanNvbnAgPSBmdW5jdGlvbiAodXJsLGMpIHtcbiAgICB2YXIgcmVxID0gbmV3IFkuSlNPTlBSZXF1ZXN0KHVybCxjKTtcbiAgICByZXR1cm4gcmVxLnNlbmQuYXBwbHkocmVxLCBZLkFycmF5KGFyZ3VtZW50cywgMiwgdHJ1ZSkpO1xufTtcblxuaWYgKCFZVUkuRW52LkpTT05QKSB7XG4gICAgWVVJLkVudi5KU09OUCA9IHt9O1xufVxuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJnZXRcIiwgXCJvb3BcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnbm9kZS1iYXNlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBAbW9kdWxlIG5vZGVcbiAqIEBzdWJtb2R1bGUgbm9kZS1iYXNlXG4gKi9cblxudmFyIG1ldGhvZHMgPSBbXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBoYXMgdGhlIGdpdmVuIGNsYXNzTmFtZS5cbiAqIEBtZXRob2QgaGFzQ2xhc3NcbiAqIEBmb3IgTm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSB0aGUgY2xhc3MgbmFtZSB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBoYXMgdGhlIHNwZWNpZmllZCBjbGFzc1xuICovXG4gJ2hhc0NsYXNzJyxcblxuLyoqXG4gKiBBZGRzIGEgY2xhc3MgbmFtZSB0byB0aGUgbm9kZS5cbiAqIEBtZXRob2QgYWRkQ2xhc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgdGhlIGNsYXNzIG5hbWUgdG8gYWRkIHRvIHRoZSBub2RlJ3MgY2xhc3MgYXR0cmlidXRlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbiAnYWRkQ2xhc3MnLFxuXG4vKipcbiAqIFJlbW92ZXMgYSBjbGFzcyBuYW1lIGZyb20gdGhlIG5vZGUuXG4gKiBAbWV0aG9kIHJlbW92ZUNsYXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIHRoZSBjbGFzcyBuYW1lIHRvIHJlbW92ZSBmcm9tIHRoZSBub2RlJ3MgY2xhc3MgYXR0cmlidXRlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbiAncmVtb3ZlQ2xhc3MnLFxuXG4vKipcbiAqIFJlcGxhY2UgYSBjbGFzcyB3aXRoIGFub3RoZXIgY2xhc3Mgb24gdGhlIG5vZGUuXG4gKiBJZiBubyBvbGRDbGFzc05hbWUgaXMgcHJlc2VudCwgdGhlIG5ld0NsYXNzTmFtZSBpcyBzaW1wbHkgYWRkZWQuXG4gKiBAbWV0aG9kIHJlcGxhY2VDbGFzc1xuICogQHBhcmFtIHtTdHJpbmd9IG9sZENsYXNzTmFtZSB0aGUgY2xhc3MgbmFtZSB0byBiZSByZXBsYWNlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5ld0NsYXNzTmFtZSB0aGUgY2xhc3MgbmFtZSB0aGF0IHdpbGwgYmUgcmVwbGFjaW5nIHRoZSBvbGQgY2xhc3MgbmFtZVxuICogQGNoYWluYWJsZVxuICovXG4gJ3JlcGxhY2VDbGFzcycsXG5cbi8qKlxuICogSWYgdGhlIGNsYXNzTmFtZSBleGlzdHMgb24gdGhlIG5vZGUgaXQgaXMgcmVtb3ZlZCwgaWYgaXQgZG9lc24ndCBleGlzdCBpdCBpcyBhZGRlZC5cbiAqIEBtZXRob2QgdG9nZ2xlQ2xhc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgdGhlIGNsYXNzIG5hbWUgdG8gYmUgdG9nZ2xlZFxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBPcHRpb24gdG8gZm9yY2UgYWRkaW5nIG9yIHJlbW92aW5nIHRoZSBjbGFzcy5cbiAqIEBjaGFpbmFibGVcbiAqL1xuICd0b2dnbGVDbGFzcydcbl07XG5cblkuTm9kZS5pbXBvcnRNZXRob2QoWS5ET00sIG1ldGhvZHMpO1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgZWFjaCBub2RlIGhhcyB0aGUgZ2l2ZW4gY2xhc3NOYW1lLlxuICogQG1ldGhvZCBoYXNDbGFzc1xuICogQHNlZSBOb2RlLmhhc0NsYXNzXG4gKiBAZm9yIE5vZGVMaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIHRoZSBjbGFzcyBuYW1lIHRvIHNlYXJjaCBmb3JcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBib29sZWFucyBmb3IgZWFjaCBub2RlIGJvdW5kIHRvIHRoZSBOb2RlTGlzdC5cbiAqL1xuXG4vKipcbiAqIEFkZHMgYSBjbGFzcyBuYW1lIHRvIGVhY2ggbm9kZS5cbiAqIEBtZXRob2QgYWRkQ2xhc3NcbiAqIEBzZWUgTm9kZS5hZGRDbGFzc1xuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSB0aGUgY2xhc3MgbmFtZSB0byBhZGQgdG8gZWFjaCBub2RlJ3MgY2xhc3MgYXR0cmlidXRlXG4gKiBAY2hhaW5hYmxlXG4gKi9cblxuLyoqXG4gKiBSZW1vdmVzIGEgY2xhc3MgbmFtZSBmcm9tIGVhY2ggbm9kZS5cbiAqIEBtZXRob2QgcmVtb3ZlQ2xhc3NcbiAqIEBzZWUgTm9kZS5yZW1vdmVDbGFzc1xuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSB0aGUgY2xhc3MgbmFtZSB0byByZW1vdmUgZnJvbSBlYWNoIG5vZGUncyBjbGFzcyBhdHRyaWJ1dGVcbiAqIEBjaGFpbmFibGVcbiAqL1xuXG4vKipcbiAqIFJlcGxhY2UgYSBjbGFzcyB3aXRoIGFub3RoZXIgY2xhc3MgZm9yIGVhY2ggbm9kZS5cbiAqIElmIG5vIG9sZENsYXNzTmFtZSBpcyBwcmVzZW50LCB0aGUgbmV3Q2xhc3NOYW1lIGlzIHNpbXBseSBhZGRlZC5cbiAqIEBtZXRob2QgcmVwbGFjZUNsYXNzXG4gKiBAc2VlIE5vZGUucmVwbGFjZUNsYXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gb2xkQ2xhc3NOYW1lIHRoZSBjbGFzcyBuYW1lIHRvIGJlIHJlcGxhY2VkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmV3Q2xhc3NOYW1lIHRoZSBjbGFzcyBuYW1lIHRoYXQgd2lsbCBiZSByZXBsYWNpbmcgdGhlIG9sZCBjbGFzcyBuYW1lXG4gKiBAY2hhaW5hYmxlXG4gKi9cblxuLyoqXG4gKiBGb3IgZWFjaCBub2RlLCBpZiB0aGUgY2xhc3NOYW1lIGV4aXN0cyBvbiB0aGUgbm9kZSBpdCBpcyByZW1vdmVkLCBpZiBpdCBkb2Vzbid0IGV4aXN0IGl0IGlzIGFkZGVkLlxuICogQG1ldGhvZCB0b2dnbGVDbGFzc1xuICogQHNlZSBOb2RlLnRvZ2dsZUNsYXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIHRoZSBjbGFzcyBuYW1lIHRvIGJlIHRvZ2dsZWRcbiAqIEBjaGFpbmFibGVcbiAqL1xuWS5Ob2RlTGlzdC5pbXBvcnRNZXRob2QoWS5Ob2RlLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4vKipcbiAqIEBtb2R1bGUgbm9kZVxuICogQHN1Ym1vZHVsZSBub2RlLWJhc2VcbiAqL1xuXG52YXIgWV9Ob2RlID0gWS5Ob2RlLFxuICAgIFlfRE9NID0gWS5ET007XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBkb20gbm9kZSB1c2luZyB0aGUgcHJvdmlkZWQgbWFya3VwIHN0cmluZy5cbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBUaGUgbWFya3VwIHVzZWQgdG8gY3JlYXRlIHRoZSBlbGVtZW50LlxuICogVXNlIDxhIGhyZWY9XCIuLi9jbGFzc2VzL0VzY2FwZS5odG1sI21ldGhvZF9odG1sXCI+YFkuRXNjYXBlLmh0bWwoKWA8L2E+XG4gKiB0byBlc2NhcGUgaHRtbCBjb250ZW50LlxuICogQHBhcmFtIHtIVE1MRG9jdW1lbnR9IGRvYyBBbiBvcHRpb25hbCBkb2N1bWVudCBjb250ZXh0XG4gKiBAcmV0dXJuIHtOb2RlfSBBIE5vZGUgaW5zdGFuY2UgYm91bmQgdG8gYSBET00gbm9kZSBvciBmcmFnbWVudFxuICogQGZvciBOb2RlXG4gKi9cbllfTm9kZS5jcmVhdGUgPSBmdW5jdGlvbihodG1sLCBkb2MpIHtcbiAgICBpZiAoZG9jICYmIGRvYy5fbm9kZSkge1xuICAgICAgICBkb2MgPSBkb2MuX25vZGU7XG4gICAgfVxuICAgIHJldHVybiBZLm9uZShZX0RPTS5jcmVhdGUoaHRtbCwgZG9jKSk7XG59O1xuXG5ZLm1peChZX05vZGUucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBOb2RlIHVzaW5nIHRoZSBwcm92aWRlZCBtYXJrdXAgc3RyaW5nLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgVGhlIG1hcmt1cCB1c2VkIHRvIGNyZWF0ZSB0aGUgZWxlbWVudC5cbiAgICAgKiBVc2UgPGEgaHJlZj1cIi4uL2NsYXNzZXMvRXNjYXBlLmh0bWwjbWV0aG9kX2h0bWxcIj5gWS5Fc2NhcGUuaHRtbCgpYDwvYT5cbiAgICAgKiB0byBlc2NhcGUgaHRtbCBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTERvY3VtZW50fSBkb2MgQW4gb3B0aW9uYWwgZG9jdW1lbnQgY29udGV4dFxuICAgICAqIEByZXR1cm4ge05vZGV9IEEgTm9kZSBpbnN0YW5jZSBib3VuZCB0byBhIERPTSBub2RlIG9yIGZyYWdtZW50XG4gICAgICovXG4gICAgY3JlYXRlOiBZX05vZGUuY3JlYXRlLFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGUgY29udGVudCBiZWZvcmUgdGhlIHJlZmVyZW5jZSBub2RlLlxuICAgICAqIEBtZXRob2QgaW5zZXJ0XG4gICAgICogQHBhcmFtIHtTdHJpbmcgfCBOb2RlIHwgSFRNTEVsZW1lbnQgfCBOb2RlTGlzdCB8IEhUTUxDb2xsZWN0aW9ufSBjb250ZW50IFRoZSBjb250ZW50IHRvIGluc2VydC5cbiAgICAgKiBVc2UgPGEgaHJlZj1cIi4uL2NsYXNzZXMvRXNjYXBlLmh0bWwjbWV0aG9kX2h0bWxcIj5gWS5Fc2NhcGUuaHRtbCgpYDwvYT5cbiAgICAgKiB0byBlc2NhcGUgaHRtbCBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7SW50IHwgTm9kZSB8IEhUTUxFbGVtZW50IHwgU3RyaW5nfSB3aGVyZSBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IGF0LlxuICAgICAqIFBvc3NpYmxlIFwid2hlcmVcIiBhcmd1bWVudHNcbiAgICAgKiA8ZGw+XG4gICAgICogPGR0PlkuTm9kZTwvZHQ+XG4gICAgICogPGRkPlRoZSBOb2RlIHRvIGluc2VydCBiZWZvcmU8L2RkPlxuICAgICAqIDxkdD5IVE1MRWxlbWVudDwvZHQ+XG4gICAgICogPGRkPlRoZSBlbGVtZW50IHRvIGluc2VydCBiZWZvcmU8L2RkPlxuICAgICAqIDxkdD5JbnQ8L2R0PlxuICAgICAqIDxkZD5UaGUgaW5kZXggb2YgdGhlIGNoaWxkIGVsZW1lbnQgdG8gaW5zZXJ0IGJlZm9yZTwvZGQ+XG4gICAgICogPGR0PlwicmVwbGFjZVwiPC9kdD5cbiAgICAgKiA8ZGQ+UmVwbGFjZXMgdGhlIGV4aXN0aW5nIEhUTUw8L2RkPlxuICAgICAqIDxkdD5cImJlZm9yZVwiPC9kdD5cbiAgICAgKiA8ZGQ+SW5zZXJ0cyBiZWZvcmUgdGhlIGV4aXN0aW5nIEhUTUw8L2RkPlxuICAgICAqIDxkdD5cImJlZm9yZVwiPC9kdD5cbiAgICAgKiA8ZGQ+SW5zZXJ0cyBjb250ZW50IGJlZm9yZSB0aGUgbm9kZTwvZGQ+XG4gICAgICogPGR0PlwiYWZ0ZXJcIjwvZHQ+XG4gICAgICogPGRkPkluc2VydHMgY29udGVudCBhZnRlciB0aGUgbm9kZTwvZGQ+XG4gICAgICogPC9kbD5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgaW5zZXJ0OiBmdW5jdGlvbihjb250ZW50LCB3aGVyZSkge1xuICAgICAgICB0aGlzLl9pbnNlcnQoY29udGVudCwgd2hlcmUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2luc2VydDogZnVuY3Rpb24oY29udGVudCwgd2hlcmUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlLFxuICAgICAgICAgICAgcmV0ID0gbnVsbDtcblxuICAgICAgICBpZiAodHlwZW9mIHdoZXJlID09ICdudW1iZXInKSB7IC8vIGFsbG93IGluZGV4XG4gICAgICAgICAgICB3aGVyZSA9IHRoaXMuX25vZGUuY2hpbGROb2Rlc1t3aGVyZV07XG4gICAgICAgIH0gZWxzZSBpZiAod2hlcmUgJiYgd2hlcmUuX25vZGUpIHsgLy8gTm9kZVxuICAgICAgICAgICAgd2hlcmUgPSB3aGVyZS5fbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZW50ICYmIHR5cGVvZiBjb250ZW50ICE9ICdzdHJpbmcnKSB7IC8vIGFsbG93IE5vZGUgb3IgTm9kZUxpc3QvQXJyYXkgaW5zdGFuY2VzXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fbm9kZSB8fCBjb250ZW50Ll9ub2RlcyB8fCBjb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IFlfRE9NLmFkZEhUTUwobm9kZSwgY29udGVudCwgd2hlcmUpO1xuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIGNvbnRlbnQgYXMgdGhlIGZpcnN0Q2hpbGQgb2YgdGhlIG5vZGUuXG4gICAgICogQG1ldGhvZCBwcmVwZW5kXG4gICAgICogQHBhcmFtIHtTdHJpbmcgfCBOb2RlIHwgSFRNTEVsZW1lbnR9IGNvbnRlbnQgVGhlIGNvbnRlbnQgdG8gaW5zZXJ0LlxuICAgICAqIFVzZSA8YSBocmVmPVwiLi4vY2xhc3Nlcy9Fc2NhcGUuaHRtbCNtZXRob2RfaHRtbFwiPmBZLkVzY2FwZS5odG1sKClgPC9hPlxuICAgICAqIHRvIGVzY2FwZSBodG1sIGNvbnRlbnQuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHByZXBlbmQ6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0KGNvbnRlbnQsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHRoZSBjb250ZW50IGFzIHRoZSBsYXN0Q2hpbGQgb2YgdGhlIG5vZGUuXG4gICAgICogQG1ldGhvZCBhcHBlbmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZyB8IE5vZGUgfCBIVE1MRWxlbWVudH0gY29udGVudCBUaGUgY29udGVudCB0byBpbnNlcnQuXG4gICAgICogVXNlIDxhIGhyZWY9XCIuLi9jbGFzc2VzL0VzY2FwZS5odG1sI21ldGhvZF9odG1sXCI+YFkuRXNjYXBlLmh0bWwoKWA8L2E+XG4gICAgICogdG8gZXNjYXBlIGh0bWwgY29udGVudC5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwZW5kOiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydChjb250ZW50LCBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBhcHBlbmRDaGlsZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgSFRNTEVsZW1lbnQgfCBOb2RlfSBub2RlIE5vZGUgdG8gYmUgYXBwZW5kZWQuXG4gICAgICogVXNlIDxhIGhyZWY9XCIuLi9jbGFzc2VzL0VzY2FwZS5odG1sI21ldGhvZF9odG1sXCI+YFkuRXNjYXBlLmh0bWwoKWA8L2E+XG4gICAgICogdG8gZXNjYXBlIGh0bWwgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgYXBwZW5kZWQgbm9kZVxuICAgICAqL1xuICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiBZX05vZGUuc2NydWJWYWwodGhpcy5faW5zZXJ0KG5vZGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBpbnNlcnRCZWZvcmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZyB8IEhUTUxFbGVtZW50IHwgTm9kZX0gbmV3Tm9kZSBOb2RlIHRvIGJlIGFwcGVuZGVkXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IE5vZGV9IHJlZk5vZGUgTm9kZSB0byBiZSBpbnNlcnRlZCBiZWZvcmUuXG4gICAgICogVXNlIDxhIGhyZWY9XCIuLi9jbGFzc2VzL0VzY2FwZS5odG1sI21ldGhvZF9odG1sXCI+YFkuRXNjYXBlLmh0bWwoKWA8L2E+XG4gICAgICogdG8gZXNjYXBlIGh0bWwgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgaW5zZXJ0ZWQgbm9kZVxuICAgICAqL1xuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24obmV3Tm9kZSwgcmVmTm9kZSkge1xuICAgICAgICByZXR1cm4gWS5Ob2RlLnNjcnViVmFsKHRoaXMuX2luc2VydChuZXdOb2RlLCByZWZOb2RlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhlIG5vZGUgdG8gdGhlIGdpdmVuIG5vZGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgIC8vIGFwcGVuZFRvIHJldHVybnMgdGhlIG5vZGUgdGhhdCBoYXMgYmVlbiBjcmVhdGVkIGJlZm9yZWhhbmRcbiAgICAgKiAgICAgIFkuTm9kZS5jcmVhdGUoJzxwPjwvcD4nKS5hcHBlbmRUbygnYm9keScpLnNldCgndGV4dCcsICdoZWxsbyB3b3JsZCEnKTtcbiAgICAgKiBAbWV0aG9kIGFwcGVuZFRvXG4gICAgICogQHBhcmFtIHtOb2RlIHwgSFRNTEVsZW1lbnQgfCBTdHJpbmd9IG5vZGUgVGhlIG5vZGUgdG8gYXBwZW5kIHRvLlxuICAgICAqICBJZiBgbm9kZWAgaXMgYSBzdHJpbmcgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgY3NzIHNlbGVjdG9yIGFuZCBvbmx5IHRoZSBmaXJzdCBtYXRjaGluZyBub2RlIHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwZW5kVG86IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgWS5vbmUobm9kZSkuYXBwZW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIFxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQsIGFuZCBpcyBpbnRlbnRpb25hbGx5IGxlZnQgdW5kb2N1bWVudGVkLlxuICAgIC8vIFVzZSBgc2V0SFRNTGAgaW5zdGVhZC5cbiAgICBzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHRoaXMuX2luc2VydChjb250ZW50LCAncmVwbGFjZScpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIFxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQsIGFuZCBpcyBpbnRlbnRpb25hbGx5IGxlZnQgdW5kb2N1bWVudGVkLlxuICAgIC8vIFVzZSBgZ2V0SFRNTGAgaW5zdGVhZC5cbiAgICBnZXRDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChub2RlLl9ub2RlLm5vZGVUeXBlID09PSAxMSkgeyAvLyAxMSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG4gICAgICAgICAgICAvLyBcInRoaXNcIiwgd2hlbiBpdCBpcyBhIGRvY3VtZW50IGZyYWdtZW50LCBtdXN0IGJlIGNsb25lZCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGUgbm9kZXMgY29udGFpbmVkIGluIHRoZSBmcmFnbWVudCBhY3R1YWxseSBkaXNhcHBlYXIgb25jZVxuICAgICAgICAgICAgLy8gdGhlIGZyYWdtZW50IGlzIGFwcGVuZGVkIGFueXdoZXJlXG4gICAgICAgICAgICBub2RlID0gbm9kZS5jcmVhdGUoXCI8ZGl2Lz5cIikuYXBwZW5kKG5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmdldChcImlubmVySFRNTFwiKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBSZXBsYWNlcyB0aGUgbm9kZSdzIGN1cnJlbnQgaHRtbCBjb250ZW50IHdpdGggdGhlIGNvbnRlbnQgcHJvdmlkZWQuXG4gKiBOb3RlIHRoYXQgdGhpcyBwYXNzZXMgdG8gaW5uZXJIVE1MIGFuZCBpcyBub3QgZXNjYXBlZC5cbiAqIFVzZSA8YSBocmVmPVwiLi4vY2xhc3Nlcy9Fc2NhcGUuaHRtbCNtZXRob2RfaHRtbFwiPmBZLkVzY2FwZS5odG1sKClgPC9hPlxuICogdG8gZXNjYXBlIGh0bWwgY29udGVudCBvciBgc2V0KCd0ZXh0JylgIHRvIGFkZCBhcyB0ZXh0LlxuICogQG1ldGhvZCBzZXRIVE1MXG4gKiBAcGFyYW0ge1N0cmluZyB8IE5vZGUgfCBIVE1MRWxlbWVudCB8IE5vZGVMaXN0IHwgSFRNTENvbGxlY3Rpb259IGNvbnRlbnQgVGhlIGNvbnRlbnQgdG8gaW5zZXJ0XG4gKiBAY2hhaW5hYmxlXG4gKi9cblkuTm9kZS5wcm90b3R5cGUuc2V0SFRNTCA9IFkuTm9kZS5wcm90b3R5cGUuc2V0Q29udGVudDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub2RlJ3MgY3VycmVudCBodG1sIGNvbnRlbnQgKGUuZy4gaW5uZXJIVE1MKVxuICogQG1ldGhvZCBnZXRIVE1MXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBodG1sIGNvbnRlbnRcbiAqL1xuWS5Ob2RlLnByb3RvdHlwZS5nZXRIVE1MID0gWS5Ob2RlLnByb3RvdHlwZS5nZXRDb250ZW50O1xuXG5ZLk5vZGVMaXN0LmltcG9ydE1ldGhvZChZLk5vZGUucHJvdG90eXBlLCBbXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIGVhY2ggTm9kZSBpbnN0YW5jZVxuICAgICAqIEBmb3IgTm9kZUxpc3RcbiAgICAgKiBAbWV0aG9kIGFwcGVuZFxuICAgICAqIEBzZWUgTm9kZS5hcHBlbmRcbiAgICAgKi9cbiAgICAnYXBwZW5kJyxcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBlYWNoIE5vZGUgaW5zdGFuY2VcbiAgICAgKiBAZm9yIE5vZGVMaXN0XG4gICAgICogQG1ldGhvZCBpbnNlcnRcbiAgICAgKiBAc2VlIE5vZGUuaW5zZXJ0XG4gICAgICovXG4gICAgJ2luc2VydCcsXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gZWFjaCBOb2RlIGluc3RhbmNlXG4gICAgICogQGZvciBOb2RlTGlzdFxuICAgICAqIEBtZXRob2QgYXBwZW5kQ2hpbGRcbiAgICAgKiBAc2VlIE5vZGUuYXBwZW5kQ2hpbGRcbiAgICAgKi9cbiAgICAnYXBwZW5kQ2hpbGQnLFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIGVhY2ggTm9kZSBpbnN0YW5jZVxuICAgICAqIEBmb3IgTm9kZUxpc3RcbiAgICAgKiBAbWV0aG9kIGluc2VydEJlZm9yZVxuICAgICAqIEBzZWUgTm9kZS5pbnNlcnRCZWZvcmVcbiAgICAgKi9cbiAgICAnaW5zZXJ0QmVmb3JlJyxcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBlYWNoIE5vZGUgaW5zdGFuY2VcbiAgICAgKiBAZm9yIE5vZGVMaXN0XG4gICAgICogQG1ldGhvZCBwcmVwZW5kXG4gICAgICogQHNlZSBOb2RlLnByZXBlbmRcbiAgICAgKi9cbiAgICAncHJlcGVuZCcsXG5cbiAgICAnc2V0Q29udGVudCcsXG5cbiAgICAnZ2V0Q29udGVudCcsXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gZWFjaCBOb2RlIGluc3RhbmNlXG4gICAgICogTm90ZSB0aGF0IHRoaXMgcGFzc2VzIHRvIGlubmVySFRNTCBhbmQgaXMgbm90IGVzY2FwZWQuXG4gICAgICogVXNlIDxhIGhyZWY9XCIuLi9jbGFzc2VzL0VzY2FwZS5odG1sI21ldGhvZF9odG1sXCI+YFkuRXNjYXBlLmh0bWwoKWA8L2E+XG4gICAgICogdG8gZXNjYXBlIGh0bWwgY29udGVudCBvciBgc2V0KCd0ZXh0JylgIHRvIGFkZCBhcyB0ZXh0LlxuICAgICAqIEBmb3IgTm9kZUxpc3RcbiAgICAgKiBAbWV0aG9kIHNldEhUTUxcbiAgICAgKiBAc2VlIE5vZGUuc2V0SFRNTFxuICAgICAqL1xuICAgICdzZXRIVE1MJyxcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBlYWNoIE5vZGUgaW5zdGFuY2VcbiAgICAgKiBAZm9yIE5vZGVMaXN0XG4gICAgICogQG1ldGhvZCBnZXRIVE1MXG4gICAgICogQHNlZSBOb2RlLmdldEhUTUxcbiAgICAgKi9cbiAgICAnZ2V0SFRNTCdcbl0pO1xuLyoqXG4gKiBAbW9kdWxlIG5vZGVcbiAqIEBzdWJtb2R1bGUgbm9kZS1iYXNlXG4gKi9cblxudmFyIFlfTm9kZSA9IFkuTm9kZSxcbiAgICBZX0RPTSA9IFkuRE9NO1xuXG4vKipcbiAqIFN0YXRpYyBjb2xsZWN0aW9uIG9mIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICogQHByb3BlcnR5IEFUVFJTXG4gKiBAc3RhdGljXG4gKiBAdHlwZSBvYmplY3RcbiAqL1xuWV9Ob2RlLkFUVFJTID0ge1xuICAgIC8qKlxuICAgICAqIEFsbG93cyBmb3IgZ2V0dGluZyBhbmQgc2V0dGluZyB0aGUgdGV4dCBvZiBhbiBlbGVtZW50LlxuICAgICAqIEZvcm1hdHRpbmcgaXMgcHJlc2VydmVkIGFuZCBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIHRyZWF0ZWQgbGl0ZXJhbGx5LlxuICAgICAqIEBjb25maWcgdGV4dFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHRleHQ6IHtcbiAgICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBZX0RPTS5nZXRUZXh0KHRoaXMuX25vZGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldHRlcjogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICAgICAgWV9ET00uc2V0VGV4dCh0aGlzLl9ub2RlLCBjb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFsbG93cyBmb3IgZ2V0dGluZyBhbmQgc2V0dGluZyB0aGUgdGV4dCBvZiBhbiBlbGVtZW50LlxuICAgICAqIEZvcm1hdHRpbmcgaXMgcHJlc2VydmVkIGFuZCBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIHRyZWF0ZWQgbGl0ZXJhbGx5LlxuICAgICAqIEBjb25maWcgZm9yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgJ2Zvcic6IHtcbiAgICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBZX0RPTS5nZXRBdHRyaWJ1dGUodGhpcy5fbm9kZSwgJ2ZvcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldHRlcjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBZX0RPTS5zZXRBdHRyaWJ1dGUodGhpcy5fbm9kZSwgJ2ZvcicsIHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdvcHRpb25zJzoge1xuICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ29wdGlvbicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBOb2RlTGlzdCBpbnN0YW5jZSBvZiBhbGwgSFRNTEVsZW1lbnQgY2hpbGRyZW4uXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQGNvbmZpZyBjaGlsZHJlblxuICAgICAqIEB0eXBlIE5vZGVMaXN0XG4gICAgICovXG4gICAgJ2NoaWxkcmVuJzoge1xuICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLCBpLCBsZW47XG5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzW2ldLnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aF0gPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFkuYWxsKGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWx1ZToge1xuICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFlfRE9NLmdldFZhbHVlKHRoaXMuX25vZGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldHRlcjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBZX0RPTS5zZXRWYWx1ZSh0aGlzLl9ub2RlLCB2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblkuTm9kZS5pbXBvcnRNZXRob2QoWS5ET00sIFtcbiAgICAvKipcbiAgICAgKiBBbGxvd3Mgc2V0dGluZyBhdHRyaWJ1dGVzIG9uIERPTSBub2Rlcywgbm9ybWFsaXppbmcgaW4gc29tZSBjYXNlcy5cbiAgICAgKiBUaGlzIHBhc3NlcyB0aHJvdWdoIHRvIHRoZSBET00gbm9kZSwgYWxsb3dpbmcgZm9yIGN1c3RvbSBhdHRyaWJ1dGVzLlxuICAgICAqIEBtZXRob2Qgc2V0QXR0cmlidXRlXG4gICAgICogQGZvciBOb2RlXG4gICAgICogQGZvciBOb2RlTGlzdFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqL1xuICAgICdzZXRBdHRyaWJ1dGUnLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyBnZXR0aW5nIGF0dHJpYnV0ZXMgb24gRE9NIG5vZGVzLCBub3JtYWxpemluZyBpbiBzb21lIGNhc2VzLlxuICAgICAqIFRoaXMgcGFzc2VzIHRocm91Z2ggdG8gdGhlIERPTSBub2RlLCBhbGxvd2luZyBmb3IgY3VzdG9tIGF0dHJpYnV0ZXMuXG4gICAgICogQG1ldGhvZCBnZXRBdHRyaWJ1dGVcbiAgICAgKiBAZm9yIE5vZGVcbiAgICAgKiBAZm9yIE5vZGVMaXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgYXR0cmlidXRlIHZhbHVlXG4gICAgICovXG4gICAgJ2dldEF0dHJpYnV0ZSdcblxuXSk7XG4vKipcbiAqIEBtb2R1bGUgbm9kZVxuICogQHN1Ym1vZHVsZSBub2RlLWJhc2VcbiAqL1xuXG52YXIgWV9Ob2RlID0gWS5Ob2RlO1xudmFyIFlfTm9kZUxpc3QgPSBZLk5vZGVMaXN0O1xuLyoqXG4gKiBMaXN0IG9mIGV2ZW50cyB0aGF0IHJvdXRlIHRvIERPTSBldmVudHNcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBET01fRVZFTlRTXG4gKiBAZm9yIE5vZGVcbiAqL1xuXG5ZX05vZGUuRE9NX0VWRU5UUyA9IHtcbiAgICBhYm9ydDogMSxcbiAgICBiZWZvcmV1bmxvYWQ6IDEsXG4gICAgYmx1cjogMSxcbiAgICBjaGFuZ2U6IDEsXG4gICAgY2xpY2s6IDEsXG4gICAgY2xvc2U6IDEsXG4gICAgY29tbWFuZDogMSxcbiAgICBjb250ZXh0bWVudTogMSxcbiAgICBjb3B5OiAxLFxuICAgIGN1dDogMSxcbiAgICBkYmxjbGljazogMSxcbiAgICBET01Nb3VzZVNjcm9sbDogMSxcbiAgICBkcmFnOiAxLFxuICAgIGRyYWdzdGFydDogMSxcbiAgICBkcmFnZW50ZXI6IDEsXG4gICAgZHJhZ292ZXI6IDEsXG4gICAgZHJhZ2xlYXZlOiAxLFxuICAgIGRyYWdlbmQ6IDEsXG4gICAgZHJvcDogMSxcbiAgICBlcnJvcjogMSxcbiAgICBmb2N1czogMSxcbiAgICBrZXk6IDEsXG4gICAga2V5ZG93bjogMSxcbiAgICBrZXlwcmVzczogMSxcbiAgICBrZXl1cDogMSxcbiAgICBsb2FkOiAxLFxuICAgIG1lc3NhZ2U6IDEsXG4gICAgbW91c2Vkb3duOiAxLFxuICAgIG1vdXNlZW50ZXI6IDEsXG4gICAgbW91c2VsZWF2ZTogMSxcbiAgICBtb3VzZW1vdmU6IDEsXG4gICAgbW91c2VtdWx0aXdoZWVsOiAxLFxuICAgIG1vdXNlb3V0OiAxLFxuICAgIG1vdXNlb3ZlcjogMSxcbiAgICBtb3VzZXVwOiAxLFxuICAgIG1vdXNld2hlZWw6IDEsXG4gICAgb3JpZW50YXRpb25jaGFuZ2U6IDEsXG4gICAgcGFzdGU6IDEsXG4gICAgcmVzZXQ6IDEsXG4gICAgcmVzaXplOiAxLFxuICAgIHNlbGVjdDogMSxcbiAgICBzZWxlY3RzdGFydDogMSxcbiAgICBzdWJtaXQ6IDEsXG4gICAgc2Nyb2xsOiAxLFxuICAgIHRleHRJbnB1dDogMSxcbiAgICB1bmxvYWQ6IDEsXG4gICAgaW52YWxpZDogMVxufTtcblxuLy8gQWRkIGN1c3RvbSBldmVudCBhZGFwdG9ycyB0byB0aGlzIGxpc3QuICBUaGlzIHdpbGwgbWFrZSBpdCBzb1xuLy8gdGhhdCBkZWxlZ2F0ZSwga2V5LCBhdmFpbGFibGUsIGNvbnRlbnRyZWFkeSwgZXRjIGFsbCB3aWxsXG4vLyBiZSBhdmFpbGFibGUgdGhyb3VnaCBOb2RlLm9uXG5ZLm1peChZX05vZGUuRE9NX0VWRU5UUywgWS5FbnYuZXZ0LnBsdWdpbnMpO1xuXG5ZLmF1Z21lbnQoWV9Ob2RlLCBZLkV2ZW50VGFyZ2V0KTtcblxuWS5taXgoWV9Ob2RlLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIG5vZGUgYW5kIChvcHRpb25hbGx5KSBpdHMgc3VidHJlZVxuICAgICAqIEBtZXRob2QgcHVyZ2VcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlY3Vyc2UgKG9wdGlvbmFsKSBXaGV0aGVyIG9yIG5vdCB0byByZW1vdmUgbGlzdGVuZXJzIGZyb20gdGhlXG4gICAgICogbm9kZSdzIHN1YnRyZWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAob3B0aW9uYWwpIE9ubHkgcmVtb3ZlIGxpc3RlbmVycyBvZiB0aGUgc3BlY2lmaWVkIHR5cGVcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBwdXJnZTogZnVuY3Rpb24ocmVjdXJzZSwgdHlwZSkge1xuICAgICAgICBZLkV2ZW50LnB1cmdlRWxlbWVudCh0aGlzLl9ub2RlLCByZWN1cnNlLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59KTtcblxuWS5taXgoWS5Ob2RlTGlzdC5wcm90b3R5cGUsIHtcbiAgICBfcHJlcEV2dEFyZ3M6IGZ1bmN0aW9uKHR5cGUsIGZuLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIG1hcCB0byBZLm9uL2FmdGVyIHNpZ25hdHVyZSAodHlwZSwgZm4sIG5vZGVzLCBjb250ZXh0LCBhcmcxLCBhcmcyLCBldGMpXG4gICAgICAgIHZhciBhcmdzID0gWS5BcnJheShhcmd1bWVudHMsIDAsIHRydWUpO1xuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHsgLy8gdHlwZSBvbmx5IChldmVudCBoYXNoKSBqdXN0IGFkZCBub2Rlc1xuICAgICAgICAgICAgYXJnc1syXSA9IHRoaXMuX25vZGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoMiwgMCwgdGhpcy5fbm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJnc1szXSA9IGNvbnRleHQgfHwgdGhpczsgLy8gZGVmYXVsdCB0byBOb2RlTGlzdCBpbnN0YW5jZSBhcyBjb250ZXh0XG5cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIFN1YnNjcmliZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIGBOb2RlYCBpbiB0aGUgY29sbGVjdGlvbiB0byBleGVjdXRlXG4gICAgaW4gcmVzcG9uc2UgdG8gYSBET00gZXZlbnQuXG5cbiAgICBOT1RFOiBHZW5lcmFsbHksIHRoZSBgb24oKWAgbWV0aG9kIHNob3VsZCBiZSBhdm9pZGVkIG9uIGBOb2RlTGlzdHNgLCBpblxuICAgIGZhdm9yIG9mIHVzaW5nIGV2ZW50IGRlbGVnYXRpb24gZnJvbSBhIHBhcmVudCBOb2RlLiAgU2VlIHRoZSBFdmVudCB1c2VyXG4gICAgZ3VpZGUgZm9yIGRldGFpbHMuXG5cbiAgICBNb3N0IERPTSBldmVudHMgYXJlIGFzc29jaWF0ZWQgd2l0aCBhIHByZXZlbnRhYmxlIGRlZmF1bHQgYmVoYXZpb3IsIHN1Y2ggYXNcbiAgICBsaW5rIGNsaWNrcyBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2UuICBDYWxsYmFja3MgYXJlIHBhc3NlZCBhXG4gICAgYERPTUV2ZW50RmFjYWRlYCBvYmplY3QgYXMgdGhlaXIgZmlyc3QgYXJndW1lbnQgKHVzdWFsbHkgY2FsbGVkIGBlYCkgdGhhdFxuICAgIGNhbiBiZSB1c2VkIHRvIHByZXZlbnQgdGhpcyBkZWZhdWx0IGJlaGF2aW9yIHdpdGggYGUucHJldmVudERlZmF1bHQoKWAuIFNlZVxuICAgIHRoZSBgRE9NRXZlbnRGYWNhZGVgIEFQSSBmb3IgYWxsIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9uIHRoZVxuICAgIG9iamVjdC5cblxuICAgIEJ5IGRlZmF1bHQsIHRoZSBgdGhpc2Agb2JqZWN0IHdpbGwgYmUgdGhlIGBOb2RlTGlzdGAgdGhhdCB0aGUgc3Vic2NyaXB0aW9uXG4gICAgY2FtZSBmcm9tLCA8ZW0+bm90IHRoZSBgTm9kZWAgdGhhdCByZWNlaXZlZCB0aGUgZXZlbnQ8L2VtPi4gIFVzZVxuICAgIGBlLmN1cnJlbnRUYXJnZXRgIHRvIHJlZmVyIHRvIHRoZSBgTm9kZWAuXG5cbiAgICBSZXR1cm5pbmcgYGZhbHNlYCBmcm9tIGEgY2FsbGJhY2sgaXMgc3VwcG9ydGVkIGFzIGFuIGFsdGVybmF0aXZlIHRvIGNhbGxpbmdcbiAgICBgZS5wcmV2ZW50RGVmYXVsdCgpOyBlLnN0b3BQcm9wYWdhdGlvbigpO2AuICBIb3dldmVyLCBpdCBpcyByZWNvbW1lbmRlZCB0b1xuICAgIHVzZSB0aGUgZXZlbnQgbWV0aG9kcy5cblxuICAgIEBleGFtcGxlXG5cbiAgICAgICAgWS5hbGwoXCIuc2t1XCIpLm9uKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgZS5jdXJyZW50VGFyZ2V0IHRvIHJlZmVyIHRvIHRoZSBpbmRpdmlkdWFsIE5vZGVcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IFkuTXlBcHAuc2VhcmNoSW52ZW50b3J5KCBlLmN1cnJlbnRUYXJnZXQuZ2V0KCd2YWx1ZScpICk7XG4gICAgICAgICAgICAgICAgLy8gZXRjIC4uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIEBtZXRob2Qgb25cbiAgICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBpbiByZXNwb25zZSB0byB0aGUgZXZlbnRcbiAgICBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIE92ZXJyaWRlIGB0aGlzYCBvYmplY3QgaW4gY2FsbGJhY2tcbiAgICBAcGFyYW0ge0FueX0gW2FyZypdIDAuLm4gYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc3VwcGx5IHRvIHRoZSBzdWJzY3JpYmVyXG4gICAgQHJldHVybiB7RXZlbnRIYW5kbGV9IEEgc3Vic2NyaXB0aW9uIGhhbmRsZSBjYXBhYmxlIG9mIGRldGFjaGluZyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblxuICAgIEBmb3IgTm9kZUxpc3RcbiAgICAqKi9cbiAgICBvbjogZnVuY3Rpb24odHlwZSwgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFkub24uYXBwbHkoWSwgdGhpcy5fcHJlcEV2dEFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYW4gb25lLXRpbWUgZXZlbnQgbGlzdGVuZXIgdG8gZWFjaCBOb2RlIGJvdW5kIHRvIHRoZSBOb2RlTGlzdC5cbiAgICAgKiBAbWV0aG9kIG9uY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgYmVpbmcgbGlzdGVuZWQgZm9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGhhbmRsZXIgdG8gY2FsbCB3aGVuIHRoZSBldmVudCBmaXJlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGNhbGwgdGhlIGhhbmRsZXIgd2l0aC5cbiAgICAgKiBEZWZhdWx0IGlzIHRoZSBOb2RlTGlzdCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gQSBzdWJzY3JpcHRpb24gaGFuZGxlIGNhcGFibGUgb2YgZGV0YWNoaW5nIHRoYXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICogQGZvciBOb2RlTGlzdFxuICAgICAqL1xuICAgIG9uY2U6IGZ1bmN0aW9uKHR5cGUsIGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBZLm9uY2UuYXBwbHkoWSwgdGhpcy5fcHJlcEV2dEFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gZWFjaCBOb2RlIGJvdW5kIHRvIHRoZSBOb2RlTGlzdC5cbiAgICAgKiBUaGUgaGFuZGxlciBpcyBjYWxsZWQgb25seSBhZnRlciBhbGwgb24oKSBoYW5kbGVycyBhcmUgY2FsbGVkXG4gICAgICogYW5kIHRoZSBldmVudCBpcyBub3QgcHJldmVudGVkLlxuICAgICAqIEBtZXRob2QgYWZ0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgYmVpbmcgbGlzdGVuZWQgZm9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGhhbmRsZXIgdG8gY2FsbCB3aGVuIHRoZSBldmVudCBmaXJlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGNhbGwgdGhlIGhhbmRsZXIgd2l0aC5cbiAgICAgKiBEZWZhdWx0IGlzIHRoZSBOb2RlTGlzdCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gQSBzdWJzY3JpcHRpb24gaGFuZGxlIGNhcGFibGUgb2YgZGV0YWNoaW5nIHRoYXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICogQGZvciBOb2RlTGlzdFxuICAgICAqL1xuICAgIGFmdGVyOiBmdW5jdGlvbih0eXBlLCBmbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gWS5hZnRlci5hcHBseShZLCB0aGlzLl9wcmVwRXZ0QXJncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhbiBvbmUtdGltZSBldmVudCBsaXN0ZW5lciB0byBlYWNoIE5vZGUgYm91bmQgdG8gdGhlIE5vZGVMaXN0XG4gICAgICogdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmx5IGFmdGVyIGFsbCBvbigpIGhhbmRsZXJzIGFyZSBjYWxsZWQgYW5kIHRoZVxuICAgICAqIGV2ZW50IGlzIG5vdCBwcmV2ZW50ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG9uY2VBZnRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCBiZWluZyBsaXN0ZW5lZCBmb3JcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaGFuZGxlciB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGZpcmVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gY2FsbCB0aGUgaGFuZGxlciB3aXRoLlxuICAgICAqIERlZmF1bHQgaXMgdGhlIE5vZGVMaXN0IGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge0V2ZW50SGFuZGxlfSBBIHN1YnNjcmlwdGlvbiBoYW5kbGUgY2FwYWJsZSBvZiBkZXRhY2hpbmcgdGhhdFxuICAgICAqICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25cbiAgICAgKiBAZm9yIE5vZGVMaXN0XG4gICAgICovXG4gICAgb25jZUFmdGVyOiBmdW5jdGlvbih0eXBlLCBmbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gWS5vbmNlQWZ0ZXIuYXBwbHkoWSwgdGhpcy5fcHJlcEV2dEFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxufSk7XG5cbllfTm9kZUxpc3QuaW1wb3J0TWV0aG9kKFkuTm9kZS5wcm90b3R5cGUsIFtcbiAgICAvKipcbiAgICAgICogQ2FsbGVkIG9uIGVhY2ggTm9kZSBpbnN0YW5jZVxuICAgICAgKiBAbWV0aG9kIGRldGFjaFxuICAgICAgKiBAc2VlIE5vZGUuZGV0YWNoXG4gICAgICAqIEBmb3IgTm9kZUxpc3RcbiAgICAgICovXG4gICAgJ2RldGFjaCcsXG5cbiAgICAvKiogQ2FsbGVkIG9uIGVhY2ggTm9kZSBpbnN0YW5jZVxuICAgICAgKiBAbWV0aG9kIGRldGFjaEFsbFxuICAgICAgKiBAc2VlIE5vZGUuZGV0YWNoQWxsXG4gICAgICAqIEBmb3IgTm9kZUxpc3RcbiAgICAgICovXG4gICAgJ2RldGFjaEFsbCdcbl0pO1xuXG4vKipcblN1YnNjcmliZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaW4gcmVzcG9uc2UgdG8gYSBET00gZXZlbnQgb3IgY3VzdG9tXG5ldmVudC5cblxuTW9zdCBET00gZXZlbnRzIGFyZSBhc3NvY2lhdGVkIHdpdGggYSBwcmV2ZW50YWJsZSBkZWZhdWx0IGJlaGF2aW9yIHN1Y2ggYXNcbmxpbmsgY2xpY2tzIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZS4gIENhbGxiYWNrcyBhcmUgcGFzc2VkIGEgYERPTUV2ZW50RmFjYWRlYFxub2JqZWN0IGFzIHRoZWlyIGZpcnN0IGFyZ3VtZW50ICh1c3VhbGx5IGNhbGxlZCBgZWApIHRoYXQgY2FuIGJlIHVzZWQgdG9cbnByZXZlbnQgdGhpcyBkZWZhdWx0IGJlaGF2aW9yIHdpdGggYGUucHJldmVudERlZmF1bHQoKWAuIFNlZSB0aGVcbmBET01FdmVudEZhY2FkZWAgQVBJIGZvciBhbGwgYXZhaWxhYmxlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb24gdGhlIG9iamVjdC5cblxuSWYgdGhlIGV2ZW50IG5hbWUgcGFzc2VkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgbm90IGEgd2hpdGVsaXN0ZWQgRE9NIGV2ZW50LFxuaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgY3VzdG9tIGV2ZW50IHN1YnNjcmlwdGlvbnMsIGFsbG93aW5nXG5gbm9kZS5maXJlKCdjdXN0b21FdmVudE5hbWUnKWAgbGF0ZXIgaW4gdGhlIGNvZGUuICBSZWZlciB0byB0aGUgRXZlbnQgdXNlciBndWlkZVxuZm9yIHRoZSBmdWxsIERPTSBldmVudCB3aGl0ZWxpc3QuXG5cbkJ5IGRlZmF1bHQsIHRoZSBgdGhpc2Agb2JqZWN0IGluIHRoZSBjYWxsYmFjayB3aWxsIHJlZmVyIHRvIHRoZSBzdWJzY3JpYmVkXG5gTm9kZWAuXG5cblJldHVybmluZyBgZmFsc2VgIGZyb20gYSBjYWxsYmFjayBpcyBzdXBwb3J0ZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gY2FsbGluZ1xuYGUucHJldmVudERlZmF1bHQoKTsgZS5zdG9wUHJvcGFnYXRpb24oKTtgLiAgSG93ZXZlciwgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlXG50aGUgZXZlbnQgbWV0aG9kcy5cblxuQGV4YW1wbGVcblxuICAgIFkub25lKFwiI215LWZvcm1cIikub24oXCJzdWJtaXRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIHByb2NlZWQgd2l0aCBhamF4IGZvcm0gc3VibWlzc2lvbiBpbnN0ZWFkLi4uXG4gICAgfSk7XG5cbkBtZXRob2Qgb25cbkBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgaW4gcmVzcG9uc2UgdG8gdGhlIGV2ZW50XG5AcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIE92ZXJyaWRlIGB0aGlzYCBvYmplY3QgaW4gY2FsbGJhY2tcbkBwYXJhbSB7QW55fSBbYXJnKl0gMC4ubiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzdXBwbHkgdG8gdGhlIHN1YnNjcmliZXJcbkByZXR1cm4ge0V2ZW50SGFuZGxlfSBBIHN1YnNjcmlwdGlvbiBoYW5kbGUgY2FwYWJsZSBvZiBkZXRhY2hpbmcgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblxuQGZvciBOb2RlXG4qKi9cblxuWS5taXgoWS5Ob2RlLkFUVFJTLCB7XG4gICAgb2Zmc2V0SGVpZ2h0OiB7XG4gICAgICAgIHNldHRlcjogZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgWS5ET00uc2V0SGVpZ2h0KHRoaXMuX25vZGUsIGgpO1xuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvZmZzZXRXaWR0aDoge1xuICAgICAgICBzZXR0ZXI6IGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICAgIFkuRE9NLnNldFdpZHRoKHRoaXMuX25vZGUsIHcpO1xuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlLm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblkubWl4KFkuTm9kZS5wcm90b3R5cGUsIHtcbiAgICBzaXplVG86IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgbm9kZSA9IFkub25lKHcpO1xuICAgICAgICAgICAgdyA9IG5vZGUuZ2V0KCdvZmZzZXRXaWR0aCcpO1xuICAgICAgICAgICAgaCA9IG5vZGUuZ2V0KCdvZmZzZXRIZWlnaHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0QXR0cnMoe1xuICAgICAgICAgICAgb2Zmc2V0V2lkdGg6IHcsXG4gICAgICAgICAgICBvZmZzZXRIZWlnaHQ6IGhcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbmlmICghWS5jb25maWcuZG9jLmRvY3VtZW50RWxlbWVudC5oYXNBdHRyaWJ1dGUpIHsgLy8gSUUgPCA4XG4gICAgWS5Ob2RlLnByb3RvdHlwZS5oYXNBdHRyaWJ1dGUgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIGlmIChhdHRyID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoJ3ZhbHVlJykgIT09IFwiXCIpIHsgLy8gSUUgPCA4IGZhaWxzIHRvIHBvcHVsYXRlIHNwZWNpZmllZCB3aGVuIHNldCBpbiBIVE1MXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX25vZGUuYXR0cmlidXRlc1thdHRyXSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUuYXR0cmlidXRlc1thdHRyXS5zcGVjaWZpZWQpO1xuICAgIH07XG59XG5cbi8vIElFIHRocm93cyBhbiBlcnJvciB3aGVuIGNhbGxpbmcgZm9jdXMoKSBvbiBhbiBlbGVtZW50IHRoYXQncyBpbnZpc2libGUsIG5vdFxuLy8gZGlzcGxheWVkLCBvciBkaXNhYmxlZC5cblkuTm9kZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fbm9kZS5mb2N1cygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIElFIHRocm93cyBlcnJvciB3aGVuIHNldHRpbmcgaW5wdXQudHlwZSA9ICdoaWRkZW4nLFxuLy8gaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2hpZGRlbicpIGFuZCBpbnB1dC5hdHRyaWJ1dGVzLnR5cGUudmFsdWUgPSAnaGlkZGVuJ1xuWS5Ob2RlLkFUVFJTLnR5cGUgPSB7XG4gICAgc2V0dGVyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS50eXBlID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXRUeXBlID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkgeyAvLyBJRSBlcnJvcnMgd2hlbiBjaGFuZ2luZyB0aGUgdHlwZSBmcm9tIFwiaGlkZGVuJ1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUudHlwZSA9IHZhbDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRUeXBlIHx8IHRoaXMuX25vZGUudHlwZTtcbiAgICB9LFxuXG4gICAgX2J5cGFzc1Byb3h5OiB0cnVlIC8vIGRvbid0IHVwZGF0ZSBET00gd2hlbiB1c2luZyB3aXRoIEF0dHJpYnV0ZVxufTtcblxuaWYgKFkuY29uZmlnLmRvYy5jcmVhdGVFbGVtZW50KCdmb3JtJykuZWxlbWVudHMubm9kZVR5cGUpIHtcbiAgICAvLyBJRTogZWxlbWVudHMgY29sbGVjdGlvbiBpcyBhbHNvIEZPUk0gbm9kZSB3aGljaCB0cmlwcyB1cCBzY3J1YlZhbC5cbiAgICBZLk5vZGUuQVRUUlMuZWxlbWVudHMgPSB7XG4gICAgICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFsbCgnaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdCcpO1xuICAgICAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIG1hbmFnaW5nIGN1c3RvbSBOb2RlIGRhdGEuXG4gKlxuICogQG1vZHVsZSBub2RlXG4gKiBAbWFpbiBub2RlXG4gKiBAc3VibW9kdWxlIG5vZGUtZGF0YVxuICovXG5cblkubWl4KFkuTm9kZS5wcm90b3R5cGUsIHtcbiAgICBfaW5pdERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoISAoJ19kYXRhJyBpbiB0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG1ldGhvZCBnZXREYXRhXG4gICAgKiBAZm9yIE5vZGVcbiAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgYXJiaXRyYXJ5IGRhdGEgc3RvcmVkIG9uIGEgTm9kZSBpbnN0YW5jZS5cbiAgICAqIElmIG5vIGRhdGEgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBOb2RlLCBpdCB3aWxsIGF0dGVtcHQgdG8gcmV0cmlldmVcbiAgICAqIGEgdmFsdWUgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBIVE1MIGRhdGEgYXR0cmlidXRlLiAoZS5nLiBub2RlLmdldERhdGEoJ2ZvbycpXG4gICAgKiB3aWxsIGNoZWNrIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWZvbycpKS5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGRhdGEgZmllbGQgdG8gcmV0cmlldmUuXG4gICAgKiBJZiBubyBuYW1lIGlzIGdpdmVuLCBhbGwgZGF0YSBpcyByZXR1cm5lZC5cbiAgICAqIEByZXR1cm4ge2FueSB8IE9iamVjdH0gV2hhdGV2ZXIgaXMgc3RvcmVkIGF0IHRoZSBnaXZlbiBmaWVsZCxcbiAgICAqIG9yIGFuIG9iamVjdCBoYXNoIG9mIGFsbCBmaWVsZHMuXG4gICAgKi9cbiAgICBnZXREYXRhOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuX2luaXREYXRhKCk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgICAgIHJldCA9IGRhdGE7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHsgLy8gc2luZ2xlIGZpZWxkXG4gICAgICAgICAgICBpZiAobmFtZSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gZGF0YVtuYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGluaXRpYWxpemUgZnJvbSBIVE1MIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX2dldERhdGFBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT0gJ29iamVjdCcgJiYgZGF0YSAhPT0gbnVsbCkgeyAvLyBhbGwgZmllbGRzXG4gICAgICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgICAgIFkuT2JqZWN0LmVhY2goZGF0YSwgZnVuY3Rpb24odiwgbikge1xuICAgICAgICAgICAgICAgIHJldFtuXSA9IHY7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0ID0gdGhpcy5fZ2V0RGF0YUF0dHJpYnV0ZXMocmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG5cbiAgICB9LFxuXG4gICAgX2dldERhdGFBdHRyaWJ1dGVzOiBmdW5jdGlvbihyZXQpIHtcbiAgICAgICAgcmV0ID0gcmV0IHx8IHt9O1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBhdHRycyA9IHRoaXMuX25vZGUuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGxlbiA9IGF0dHJzLmxlbmd0aCxcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuREFUQV9QUkVGSVgsXG4gICAgICAgICAgICBwcmVmaXhMZW5ndGggPSBwcmVmaXgubGVuZ3RoLFxuICAgICAgICAgICAgbmFtZTtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIocHJlZml4TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoIShuYW1lIGluIHJldCkpIHsgLy8gb25seSBtZXJnZSBpZiBub3QgYWxyZWFkeSBzdG9yZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0W25hbWVdID0gdGhpcy5fZ2V0RGF0YUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIF9nZXREYXRhQXR0cmlidXRlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLkRBVEFfUFJFRklYICsgbmFtZTtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGUsXG4gICAgICAgICAgICBhdHRycyA9IG5vZGUuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGRhdGEgPSBhdHRycyAmJiBhdHRyc1tuYW1lXSAmJiBhdHRyc1tuYW1lXS52YWx1ZTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAbWV0aG9kIHNldERhdGFcbiAgICAqIEBmb3IgTm9kZVxuICAgICogQGRlc2NyaXB0aW9uIFN0b3JlcyBhcmJpdHJhcnkgZGF0YSBvbiBhIE5vZGUgaW5zdGFuY2UuXG4gICAgKiBUaGlzIGlzIG5vdCBzdG9yZWQgd2l0aCB0aGUgRE9NIG5vZGUuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gc2V0LiBJZiBubyB2YWxcbiAgICAqIGlzIGdpdmVuLCBuYW1lIGlzIHRyZWF0ZWQgYXMgdGhlIGRhdGEgYW5kIG92ZXJyaWRlcyBhbnkgZXhpc3RpbmcgZGF0YS5cbiAgICAqIEBwYXJhbSB7YW55fSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSBmaWVsZC5cbiAgICAqIEBjaGFpbmFibGVcbiAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICB0aGlzLl9pbml0RGF0YSgpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbbmFtZV0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG1ldGhvZCBjbGVhckRhdGFcbiAgICAqIEBmb3IgTm9kZVxuICAgICogQGRlc2NyaXB0aW9uIENsZWFycyBpbnRlcm5hbGx5IHN0b3JlZCBkYXRhLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGNsZWFyLiBJZiBubyBuYW1lXG4gICAgKiBpcyBnaXZlbiwgYWxsIGRhdGEgaXMgY2xlYXJlZC5cbiAgICAqIEBjaGFpbmFibGVcbiAgICAqL1xuICAgIGNsZWFyRGF0YTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoJ19kYXRhJyBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZGF0YVtuYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2RhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxuWS5taXgoWS5Ob2RlTGlzdC5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAqIEBtZXRob2QgZ2V0RGF0YVxuICAgICogQGZvciBOb2RlTGlzdFxuICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBhcmJpdHJhcnkgZGF0YSBzdG9yZWQgb24gZWFjaCBOb2RlIGluc3RhbmNlXG4gICAgKiBib3VuZCB0byB0aGUgTm9kZUxpc3QuXG4gICAgKiBAc2VlIE5vZGVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGRhdGEgZmllbGQgdG8gcmV0cmlldmUuXG4gICAgKiBJZiBubyBuYW1lIGlzIGdpdmVuLCBhbGwgZGF0YSBpcyByZXR1cm5lZC5cbiAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGUgZGF0YSBmb3IgZWFjaCBOb2RlIGluc3RhbmNlLlxuICAgICogb3IgYW4gb2JqZWN0IGhhc2ggb2YgYWxsIGZpZWxkcy5cbiAgICAqL1xuICAgIGdldERhdGE6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCkgPyBbbmFtZV0gOiBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZSgnZ2V0RGF0YScsIGFyZ3MsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEBtZXRob2Qgc2V0RGF0YVxuICAgICogQGZvciBOb2RlTGlzdFxuICAgICogQGRlc2NyaXB0aW9uIFN0b3JlcyBhcmJpdHJhcnkgZGF0YSBvbiBlYWNoIE5vZGUgaW5zdGFuY2UgYm91bmQgdG8gdGhlXG4gICAgKiAgTm9kZUxpc3QuIFRoaXMgaXMgbm90IHN0b3JlZCB3aXRoIHRoZSBET00gbm9kZS5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBzZXQuIElmIG5vIG5hbWVcbiAgICAqIGlzIGdpdmVuLCBuYW1lIGlzIHRyZWF0ZWQgYXMgdGhlIGRhdGEgYW5kIG92ZXJyaWRlcyBhbnkgZXhpc3RpbmcgZGF0YS5cbiAgICAqIEBwYXJhbSB7YW55fSB2YWwgVGhlIHZhbHVlIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSBmaWVsZC5cbiAgICAqIEBjaGFpbmFibGVcbiAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICB2YXIgYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID4gMSkgPyBbbmFtZSwgdmFsXSA6IFtuYW1lXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZSgnc2V0RGF0YScsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEBtZXRob2QgY2xlYXJEYXRhXG4gICAgKiBAZm9yIE5vZGVMaXN0XG4gICAgKiBAZGVzY3JpcHRpb24gQ2xlYXJzIGRhdGEgb24gYWxsIE5vZGUgaW5zdGFuY2VzIGJvdW5kIHRvIHRoZSBOb2RlTGlzdC5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBjbGVhci4gSWYgbm8gbmFtZVxuICAgICogaXMgZ2l2ZW4sIGFsbCBkYXRhIGlzIGNsZWFyZWQuXG4gICAgKiBAY2hhaW5hYmxlXG4gICAgKi9cbiAgICBjbGVhckRhdGE6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCkgPyBbbmFtZV0gOiBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZSgnY2xlYXJEYXRhJywgW25hbWVdKTtcbiAgICB9XG59KTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiZXZlbnQtYmFzZVwiLCBcIm5vZGUtY29yZVwiLCBcImRvbS1iYXNlXCIsIFwiZG9tLXN0eWxlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ25vZGUtY29yZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogVGhlIE5vZGUgVXRpbGl0eSBwcm92aWRlcyBhIERPTS1saWtlIGludGVyZmFjZSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBET00gbm9kZXMuXG4gKiBAbW9kdWxlIG5vZGVcbiAqIEBtYWluIG5vZGVcbiAqIEBzdWJtb2R1bGUgbm9kZS1jb3JlXG4gKi9cblxuLyoqXG4gKiBUaGUgTm9kZSBjbGFzcyBwcm92aWRlcyBhIHdyYXBwZXIgZm9yIG1hbmlwdWxhdGluZyBET00gTm9kZXMuXG4gKiBOb2RlIHByb3BlcnRpZXMgY2FuIGJlIGFjY2Vzc2VkIHZpYSB0aGUgc2V0L2dldCBtZXRob2RzLlxuICogVXNlIGBZLm9uZSgpYCB0byByZXRyaWV2ZSBOb2RlIGluc3RhbmNlcy5cbiAqXG4gKiA8c3Ryb25nPk5PVEU6PC9zdHJvbmc+IE5vZGUgcHJvcGVydGllcyBhcmUgYWNjZXNzZWQgdXNpbmdcbiAqIHRoZSA8Y29kZT5zZXQ8L2NvZGU+IGFuZCA8Y29kZT5nZXQ8L2NvZGU+IG1ldGhvZHMuXG4gKlxuICogQGNsYXNzIE5vZGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSB0aGUgRE9NIG5vZGUgdG8gYmUgbWFwcGVkIHRvIHRoZSBOb2RlIGluc3RhbmNlLlxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqL1xuXG4vLyBcImdsb2JhbHNcIlxudmFyIERPVCA9ICcuJyxcbiAgICBOT0RFX05BTUUgPSAnbm9kZU5hbWUnLFxuICAgIE5PREVfVFlQRSA9ICdub2RlVHlwZScsXG4gICAgT1dORVJfRE9DVU1FTlQgPSAnb3duZXJEb2N1bWVudCcsXG4gICAgVEFHX05BTUUgPSAndGFnTmFtZScsXG4gICAgVUlEID0gJ195dWlkJyxcbiAgICBFTVBUWV9PQkogPSB7fSxcblxuICAgIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcblxuICAgIFlfRE9NID0gWS5ET00sXG5cbiAgICBZX05vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlcyBpbiBET00gc3VidHJlZXMgdGhhdCBhcmUgbm90IG1hbmFnZWQgYnkgWVVJIGRvIG5vdCBuZWVkIHRvIGJlXG4gICAgICAgICAqIGluc3RhbnRpYXRlZCBhcyBZX05vZGVzLCBhbmQgWVVJIGNhY2hpbmcgcmVmZXJlbmNlcyB0byBzdWNoIG5vZGVzXG4gICAgICAgICAqIGxlYWRzIHRvIG1lbW9yeSBsZWFrcyB3aGVuIHRoZSBub2RlcyBhcmUgY3JlYXRlZCBhbmQgZGVzdHJveWVkXG4gICAgICAgICAqIGZyZXF1ZW50bHksIGFzIGlzIHRoZSBjYXNlIHdpdGggRE9NIHN1YnRyZWVzIHRoYXQgYXJlIG1hbmFnZWQgYnlcbiAgICAgICAgICogUmVhY3QuIEluIG9yZGVyIHRvIHNpZ25hbCB0byBZVUkgdGhhdCBub2RlcyBpbiBhIERPTSBzdWJ0cmVlIHNob3VsZFxuICAgICAgICAgKiBub3QgYmUgY2FjaGVkIGluIFlfTm9kZXMsIGFkZCB0aGUgYXR0cmlidXRlIGBkYXRhLXl1aS1pZ25vcmUtY2FjaGVgXG4gICAgICAgICAqIHRvIHRoZSByb290IG5vZGUgb2YgdGhlIERPTSBzdWJ0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5jbG9zZXN0ICYmIG5vZGUuY2xvc2VzdCgnW2RhdGEteXVpLWlnbm9yZS1jYWNoZV0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZ2V0RE9NTm9kZSkgeyAvLyBzdXBwb3J0IG9wdGlvbmFsIFwibmV3XCJcbiAgICAgICAgICAgIHJldHVybiBuZXcgWV9Ob2RlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBub2RlID0gWV9Ob2RlLl9mcm9tU3RyaW5nKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIE5PVEU6IHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVpZCA9IChub2RlLm5vZGVUeXBlICE9PSA5KSA/IG5vZGUudW5pcXVlSUQgOiBub2RlW1VJRF07XG5cbiAgICAgICAgaWYgKHVpZCAmJiBZX05vZGUuX2luc3RhbmNlc1t1aWRdICYmIFlfTm9kZS5faW5zdGFuY2VzW3VpZF0uX25vZGUgIT09IG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVbVUlEXSA9IG51bGw7IC8vIHVuc2V0IGV4aXN0aW5nIHVpZCB0byBwcmV2ZW50IGNvbGxpc2lvbiAodmlhIGNsb25lIG9yIGhhY2spXG4gICAgICAgIH1cblxuICAgICAgICB1aWQgPSB1aWQgfHwgWS5zdGFtcChub2RlKTtcbiAgICAgICAgaWYgKCF1aWQpIHsgLy8gc3RhbXAgZmFpbGVkOyBsaWtlbHkgSUUgbm9uLUhUTUxFbGVtZW50XG4gICAgICAgICAgICB1aWQgPSBZLmd1aWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbVUlEXSA9IHVpZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuZGVybHlpbmcgRE9NIG5vZGUgYm91bmQgdG8gdGhlIFkuTm9kZSBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgX25vZGVcbiAgICAgICAgICogQHR5cGUgSFRNTEVsZW1lbnRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlUHJveHkgPSBub2RlOyAvLyB3aGVuIGF1Z21lbnRlZCB3aXRoIEF0dHJpYnV0ZVxuXG4gICAgICAgIGlmICh0aGlzLl9pbml0UGx1Z2lucykgeyAvLyB3aGVuIGF1Z21lbnRlZCB3aXRoIFBsdWdpbi5Ib3N0XG4gICAgICAgICAgICB0aGlzLl9pbml0UGx1Z2lucygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHVzZWQgd2l0aCBwcmV2aW91cy9uZXh0L2FuY2VzdG9yIHRlc3RzXG4gICAgX3dyYXBGbiA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHZhciByZXQgPSBudWxsO1xuICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIHJldCA9ICh0eXBlb2YgZm4gPT0gJ3N0cmluZycpID9cbiAgICAgICAgICAgIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWS5TZWxlY3Rvci50ZXN0KG4sIGZuKTtcbiAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihZLm9uZShuKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuLy8gZW5kIFwiZ2xvYmFsc1wiXG5cbllfTm9kZS5BVFRSUyA9IHt9O1xuWV9Ob2RlLkRPTV9FVkVOVFMgPSB7fTtcblxuWV9Ob2RlLl9mcm9tU3RyaW5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmluZGV4T2YoJ2RvYycpID09PSAwKSB7IC8vIGRvYyBPUiBkb2N1bWVudFxuICAgICAgICAgICAgbm9kZSA9IFkuY29uZmlnLmRvYztcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmluZGV4T2YoJ3dpbicpID09PSAwKSB7IC8vIHdpbiBPUiB3aW5kb3dcbiAgICAgICAgICAgIG5vZGUgPSBZLmNvbmZpZy53aW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gWS5TZWxlY3Rvci5xdWVyeShub2RlLCBudWxsLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnRcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIFN0cmluZ1xuICogQHByb3BlcnR5IE5BTUVcbiAqL1xuWV9Ob2RlLk5BTUUgPSAnbm9kZSc7XG5cbi8qXG4gKiBUaGUgcGF0dGVybiB1c2VkIHRvIGlkZW50aWZ5IEFSSUEgYXR0cmlidXRlc1xuICovXG5ZX05vZGUucmVfYXJpYSA9IC9eKD86cm9sZSR8YXJpYS0pLztcblxuWV9Ob2RlLlNIT1dfVFJBTlNJVElPTiA9ICdmYWRlSW4nO1xuWV9Ob2RlLkhJREVfVFJBTlNJVElPTiA9ICdmYWRlT3V0JztcblxuLyoqXG4gKiBBIGxpc3Qgb2YgTm9kZSBpbnN0YW5jZXMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZFxuICogQHByaXZhdGVcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IF9pbnN0YW5jZXNcbiAqIEBzdGF0aWNcbiAqXG4gKi9cbllfTm9kZS5faW5zdGFuY2VzID0ge307XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBET00gbm9kZSBib3VuZCB0byBhIE5vZGUgaW5zdGFuY2VcbiAqIEBtZXRob2QgZ2V0RE9NTm9kZVxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gbm9kZSBUaGUgTm9kZSBpbnN0YW5jZSBvciBhbiBIVE1MRWxlbWVudFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBET00gbm9kZSBib3VuZCB0byB0aGUgTm9kZSBpbnN0YW5jZS4gIElmIGEgRE9NIG5vZGUgaXMgcGFzc2VkXG4gKiBhcyB0aGUgbm9kZSBhcmd1bWVudCwgaXQgaXMgc2ltcGx5IHJldHVybmVkLlxuICovXG5ZX05vZGUuZ2V0RE9NTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gKG5vZGUubm9kZVR5cGUpID8gbm9kZSA6IG5vZGUuX25vZGUgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrcyBOb2RlIHJldHVybiB2YWx1ZXMgYW5kIHdyYXBzIERPTSBOb2RlcyBhcyBZLk5vZGUgaW5zdGFuY2VzXG4gKiBhbmQgRE9NIENvbGxlY3Rpb25zIC8gQXJyYXlzIGFzIFkuTm9kZUxpc3QgaW5zdGFuY2VzLlxuICogT3RoZXIgcmV0dXJuIHZhbHVlcyBqdXN0IHBhc3MgdGhydS4gIElmIHVuZGVmaW5lZCBpcyByZXR1cm5lZCAoZS5nLiBubyByZXR1cm4pXG4gKiB0aGVuIHRoZSBOb2RlIGluc3RhbmNlIGlzIHJldHVybmVkIGZvciBjaGFpbmFiaWxpdHkuXG4gKiBAbWV0aG9kIHNjcnViVmFsXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MRWxlbWVudFtdfE5vZGV9IG5vZGUgVGhlIE5vZGUgaW5zdGFuY2Ugb3IgYW4gSFRNTEVsZW1lbnRcbiAqIEByZXR1cm4ge05vZGUgfCBOb2RlTGlzdCB8IEFueX0gRGVwZW5kcyBvbiB3aGF0IGlzIHJldHVybmVkIGZyb20gdGhlIERPTSBub2RlLlxuICovXG5ZX05vZGUuc2NydWJWYWwgPSBmdW5jdGlvbih2YWwsIG5vZGUpIHtcbiAgICBpZiAodmFsKSB7IC8vIG9ubHkgdHJ1dGh5IHZhbHVlcyBhcmUgcmlza3lcbiAgICAgICAgIGlmICh0eXBlb2YgdmFsID09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJykgeyAvLyBzYWZhcmkgbm9kZUxpc3QgPT09IGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoTk9ERV9UWVBFIGluIHZhbCB8fCBZX0RPTS5pc1dpbmRvdyh2YWwpKSB7Ly8gbm9kZSB8fCB3aW5kb3dcbiAgICAgICAgICAgICAgICB2YWwgPSBZLm9uZSh2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgU1ZHRWxlbWVudEluc3RhbmNlICE9PSAndW5kZWZpbmVkJyAmJiB2YWwuY29ycmVzcG9uZGluZ0VsZW1lbnQpIHsgLy8gc3ZnIG5vZGVcbiAgICAgICAgICAgICAgICB2YWwgPSBZLm9uZSh2YWwuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQgfHwgdmFsLmNvcnJlc3BvbmRpbmdFbGVtZW50KVxuICAgICAgICAgICAgfSBlbHNlIGlmICgodmFsLml0ZW0gJiYgIXZhbC5fbm9kZXMpIHx8IC8vIGRvbSBjb2xsZWN0aW9uIG9yIE5vZGUgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgKHZhbFswXSAmJiB2YWxbMF1bTk9ERV9UWVBFXSkpIHsgLy8gYXJyYXkgb2YgRE9NIE5vZGVzXG4gICAgICAgICAgICAgICAgdmFsID0gWS5hbGwodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsID0gbm9kZTsgLy8gZm9yIGNoYWluaW5nXG4gICAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgdmFsID0gbnVsbDsgLy8gSUU6IERPTSBudWxsIG5vdCB0aGUgc2FtZSBhcyBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQWRkcyBtZXRob2RzIHRvIHRoZSBZLk5vZGUgcHJvdG90eXBlLCByb3V0aW5nIHRocm91Z2ggc2NydWJWYWwuXG4gKiBAbWV0aG9kIGFkZE1ldGhvZFxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdGhhdCBiZWNvbWVzIHRoZSBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IEFuIG9wdGlvbmFsIGNvbnRleHQgdG8gY2FsbCB0aGUgbWV0aG9kIHdpdGhcbiAqIChkZWZhdWx0cyB0byB0aGUgTm9kZSBpbnN0YW5jZSlcbiAqIEByZXR1cm4ge2FueX0gRGVwZW5kcyBvbiB3aGF0IGlzIHJldHVybmVkIGZyb20gdGhlIERPTSBub2RlLlxuICovXG5ZX05vZGUuYWRkTWV0aG9kID0gZnVuY3Rpb24obmFtZSwgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAobmFtZSAmJiBmbiAmJiB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBZX05vZGUucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcmV0O1xuXG4gICAgICAgICAgICBpZiAoYXJnc1swXSAmJiBhcmdzWzBdLl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgYXJnc1swXSA9IGFyZ3NbMF0uX25vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhcmdzWzFdICYmIGFyZ3NbMV0uX25vZGUpIHtcbiAgICAgICAgICAgICAgICBhcmdzWzFdID0gYXJnc1sxXS5fbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdChub2RlLl9ub2RlKTtcblxuICAgICAgICAgICAgcmV0ID0gZm4uYXBwbHkoY29udGV4dCB8fCBub2RlLCBhcmdzKTtcblxuICAgICAgICAgICAgaWYgKHJldCkgeyAvLyBzY3J1YiB0cnV0aHlcbiAgICAgICAgICAgICAgICByZXQgPSBZX05vZGUuc2NydWJWYWwocmV0LCBub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKHR5cGVvZiByZXQgIT0gJ3VuZGVmaW5lZCcpIHx8IChyZXQgPSBub2RlKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICB9XG59O1xuXG4vKipcbiAqIEltcG9ydHMgdXRpbGl0eSBtZXRob2RzIHRvIGJlIGFkZGVkIGFzIFkuTm9kZSBtZXRob2RzLlxuICogQG1ldGhvZCBpbXBvcnRNZXRob2RcbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaG9zdCBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG1ldGhvZCB0byBpbXBvcnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGltcG9ydFxuICogQHBhcmFtIHtTdHJpbmd9IGFsdE5hbWUgQW4gb3B0aW9uYWwgbmFtZSB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGhvc3QgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCB0byBjYWxsIHRoZSBtZXRob2Qgd2l0aFxuICovXG5ZX05vZGUuaW1wb3J0TWV0aG9kID0gZnVuY3Rpb24oaG9zdCwgbmFtZSwgYWx0TmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJykge1xuICAgICAgICBhbHROYW1lID0gYWx0TmFtZSB8fCBuYW1lO1xuICAgICAgICBZX05vZGUuYWRkTWV0aG9kKGFsdE5hbWUsIGhvc3RbbmFtZV0sIGhvc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFkuQXJyYXkuZWFjaChuYW1lLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICBZX05vZGUuaW1wb3J0TWV0aG9kKGhvc3QsIG4pO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIE5vZGVMaXN0IGJhc2VkIG9uIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3IuXG4gKiBAbWV0aG9kIGFsbFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgQ1NTIHNlbGVjdG9yIHRvIHRlc3QgYWdhaW5zdC5cbiAqIEByZXR1cm4ge05vZGVMaXN0fSBBIE5vZGVMaXN0IGluc3RhbmNlIGZvciB0aGUgbWF0Y2hpbmcgSFRNTENvbGxlY3Rpb24vQXJyYXkuXG4gKiBAZm9yIFlVSVxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHNpbmdsZSBOb2RlIGluc3RhbmNlIGJvdW5kIHRvIHRoZSBub2RlIG9yIHRoZVxuICogZmlyc3QgZWxlbWVudCBtYXRjaGluZyB0aGUgZ2l2ZW4gc2VsZWN0b3IuIFJldHVybnMgbnVsbCBpZiBubyBtYXRjaCBmb3VuZC5cbiAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gRm9yIGNoYWluaW5nIHB1cnBvc2VzIHlvdSBtYXkgd2FudCB0b1xuICogdXNlIDxjb2RlPlkuYWxsPC9jb2RlPiwgd2hpY2ggcmV0dXJucyBhIE5vZGVMaXN0IHdoZW4gbm8gbWF0Y2ggaXMgZm91bmQuXG4gKiBAbWV0aG9kIG9uZVxuICogQHBhcmFtIHtTdHJpbmcgfCBIVE1MRWxlbWVudH0gbm9kZSBhIG5vZGUgb3IgU2VsZWN0b3JcbiAqIEByZXR1cm4ge05vZGUgfCBudWxsfSBhIE5vZGUgaW5zdGFuY2Ugb3IgbnVsbCBpZiBubyBtYXRjaCBmb3VuZC5cbiAqIEBmb3IgWVVJXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2luZ2xlIE5vZGUgaW5zdGFuY2UgYm91bmQgdG8gdGhlIG5vZGUgb3IgdGhlXG4gKiBmaXJzdCBlbGVtZW50IG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3Rvci4gUmV0dXJucyBudWxsIGlmIG5vIG1hdGNoIGZvdW5kLlxuICogPHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiBGb3IgY2hhaW5pbmcgcHVycG9zZXMgeW91IG1heSB3YW50IHRvXG4gKiB1c2UgPGNvZGU+WS5hbGw8L2NvZGU+LCB3aGljaCByZXR1cm5zIGEgTm9kZUxpc3Qgd2hlbiBubyBtYXRjaCBpcyBmb3VuZC5cbiAqIEBtZXRob2Qgb25lXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1N0cmluZyB8IEhUTUxFbGVtZW50fSBub2RlIGEgbm9kZSBvciBTZWxlY3RvclxuICogQHJldHVybiB7Tm9kZSB8IG51bGx9IGEgTm9kZSBpbnN0YW5jZSBvciBudWxsIGlmIG5vIG1hdGNoIGZvdW5kLlxuICogQGZvciBOb2RlXG4gKi9cbllfTm9kZS5vbmUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGluc3RhbmNlID0gbnVsbCxcbiAgICAgICAgY2FjaGVkTm9kZSxcbiAgICAgICAgdWlkO1xuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBub2RlID0gWV9Ob2RlLl9mcm9tU3RyaW5nKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIE5PVEU6IHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZ2V0RE9NTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7IC8vIE5PVEU6IHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2FmYXJpIHN2ZyBlbGVtZW50IGZpeCAtYmNcbiAgICAgICAgaWYgKHR5cGVvZiBTVkdFbGVtZW50SW5zdGFuY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUubm9kZVR5cGUgJiYgbm9kZS5jb3JyZXNwb25kaW5nRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IHx8IG5vZGUuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSB8fCBZLkRPTS5pc1dpbmRvdyhub2RlKSkgeyAvLyBhdm9pZCBiYWQgaW5wdXQgKG51bWJlcnMsIGJvb2xlYW4sIGV0YylcbiAgICAgICAgICAgIHVpZCA9IChub2RlLnVuaXF1ZUlEICYmIG5vZGUubm9kZVR5cGUgIT09IDkpID8gbm9kZS51bmlxdWVJRCA6IG5vZGUuX3l1aWQ7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IFlfTm9kZS5faW5zdGFuY2VzW3VpZF07IC8vIHJldXNlIGV4aXNpbmcgaW5zdGFuY2VzXG4gICAgICAgICAgICBjYWNoZWROb2RlID0gaW5zdGFuY2UgPyBpbnN0YW5jZS5fbm9kZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlIHx8IChjYWNoZWROb2RlICYmIG5vZGUgIT09IGNhY2hlZE5vZGUpKSB7IC8vIG5ldyBOb2RlIHdoZW4gbm9kZXMgZG9uJ3QgbWF0Y2hcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IG5ldyBZX05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMTEpIHsgLy8gZG9udCBjYWNoZSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICBZX05vZGUuX2luc3RhbmNlc1tpbnN0YW5jZVtVSURdXSA9IGluc3RhbmNlOyAvLyBjYWNoZSBub2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzZXR0ZXIgZm9yIERPTSBwcm9wZXJ0aWVzXG4gKiBDYWxsZWQgd2l0aCBpbnN0YW5jZSBjb250ZXh0ICh0aGlzID09PSB0aGUgTm9kZSBpbnN0YW5jZSlcbiAqIEBtZXRob2QgREVGQVVMVF9TRVRURVJcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUvcHJvcGVydHkgYmVpbmcgc2V0XG4gKiBAcGFyYW0ge2FueX0gdmFsIFRoZSB2YWx1ZSB0byBiZSBzZXRcbiAqIEByZXR1cm4ge2FueX0gVGhlIHZhbHVlXG4gKi9cbllfTm9kZS5ERUZBVUxUX1NFVFRFUiA9IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgIHZhciBub2RlID0gdGhpcy5fc3RhdGVQcm94eSxcbiAgICAgICAgc3RyUGF0aDtcblxuICAgIGlmIChuYW1lLmluZGV4T2YoRE9UKSA+IC0xKSB7XG4gICAgICAgIHN0clBhdGggPSBuYW1lO1xuICAgICAgICBuYW1lID0gbmFtZS5zcGxpdChET1QpO1xuICAgICAgICAvLyBvbmx5IGFsbG93IHdoZW4gZGVmaW5lZCBvbiBub2RlXG4gICAgICAgIFkuT2JqZWN0LnNldFZhbHVlKG5vZGUsIG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZVtuYW1lXSAhPSAndW5kZWZpbmVkJykgeyAvLyBwYXNzIHRocnUgRE9NIHByb3BlcnRpZXNcbiAgICAgICAgbm9kZVtuYW1lXSA9IHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBnZXR0ZXIgZm9yIERPTSBwcm9wZXJ0aWVzXG4gKiBDYWxsZWQgd2l0aCBpbnN0YW5jZSBjb250ZXh0ICh0aGlzID09PSB0aGUgTm9kZSBpbnN0YW5jZSlcbiAqIEBtZXRob2QgREVGQVVMVF9HRVRURVJcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUvcHJvcGVydHkgdG8gbG9vayB1cFxuICogQHJldHVybiB7YW55fSBUaGUgY3VycmVudCB2YWx1ZVxuICovXG5ZX05vZGUuREVGQVVMVF9HRVRURVIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9zdGF0ZVByb3h5LFxuICAgICAgICB2YWw7XG5cbiAgICBpZiAobmFtZS5pbmRleE9mICYmIG5hbWUuaW5kZXhPZihET1QpID4gLTEpIHtcbiAgICAgICAgdmFsID0gWS5PYmplY3QuZ2V0VmFsdWUobm9kZSwgbmFtZS5zcGxpdChET1QpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlW25hbWVdICE9ICd1bmRlZmluZWQnKSB7IC8vIHBhc3MgdGhydSBmcm9tIERPTVxuICAgICAgICB2YWwgPSBub2RlW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG59O1xuXG5ZLm1peChZX05vZGUucHJvdG90eXBlLCB7XG4gICAgREFUQV9QUkVGSVg6ICdkYXRhLScsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIGNhbGxlZCB3aGVuIG91dHB1dHRpbmcgTm9kZSBpbnN0YW5jZXMgYXMgc3RyaW5nc1xuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOb2RlIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RyID0gdGhpc1tVSURdICsgJzogbm90IGJvdW5kIHRvIGEgbm9kZScsXG4gICAgICAgICAgICBub2RlID0gdGhpcy5fbm9kZSxcbiAgICAgICAgICAgIGF0dHJzLCBpZCwgY2xhc3NOYW1lO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBhdHRycyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGlkID0gKGF0dHJzICYmIGF0dHJzLmlkKSA/IG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpIDogbnVsbDtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IChhdHRycyAmJiBhdHRycy5jbGFzc05hbWUpID8gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzTmFtZScpIDogbnVsbDtcbiAgICAgICAgICAgIHN0ciA9IG5vZGVbTk9ERV9OQU1FXTtcblxuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcjJyArIGlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcuJyArIGNsYXNzTmFtZS5yZXBsYWNlKCcgJywgJy4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogYWRkIHl1aWQ/XG4gICAgICAgICAgICBzdHIgKz0gJyAnICsgdGhpc1tVSURdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHZhbHVlIG9uIHRoZSBOb2RlIGluc3RhbmNlLlxuICAgICAqIFVubGVzcyBwcmUtY29uZmlndXJlZCAodmlhIGBOb2RlLkFUVFJTYCksIGdldCBoYW5kc1xuICAgICAqIG9mZiB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS4gIE9ubHkgdmFsaWRcbiAgICAgKiBhdHRyaWJ1dGVzL3Byb3BlcnRpZXMgZm9yIHRoZSBub2RlIHdpbGwgYmUgcXVlcmllZC5cbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJuIHthbnl9IFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICBpZiAodGhpcy5fZ2V0QXR0cikgeyAvLyB1c2UgQXR0cmlidXRlIGltcGxlXG4gICAgICAgICAgICB2YWwgPSB0aGlzLl9nZXRBdHRyKGF0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gdGhpcy5fZ2V0KGF0dHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgdmFsID0gWV9Ob2RlLnNjcnViVmFsKHZhbCwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWwgPSBudWxsOyAvLyBJRTogRE9NIG51bGwgaXMgbm90IHRydWUgbnVsbCAoZXZlbiB0aG91Z2ggdGhleSA9PT0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCBmb3IgZ2V0LlxuICAgICAqIEBtZXRob2QgX2dldFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm4ge2FueX0gVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIF9nZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgdmFyIGF0dHJDb25maWcgPSBZX05vZGUuQVRUUlNbYXR0cl0sXG4gICAgICAgICAgICB2YWw7XG5cbiAgICAgICAgaWYgKGF0dHJDb25maWcgJiYgYXR0ckNvbmZpZy5nZXR0ZXIpIHtcbiAgICAgICAgICAgIHZhbCA9IGF0dHJDb25maWcuZ2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoWV9Ob2RlLnJlX2FyaWEudGVzdChhdHRyKSkge1xuICAgICAgICAgICAgdmFsID0gdGhpcy5fbm9kZS5nZXRBdHRyaWJ1dGUoYXR0ciwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSBZX05vZGUuREVGQVVMVF9HRVRURVIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYW4gYXR0cmlidXRlIG9uIHRoZSBOb2RlIGluc3RhbmNlLlxuICAgICAqIFVubGVzcyBwcmUtY29uZmlndXJlZCAodmlhIE5vZGUuQVRUUlMpLCBzZXQgaGFuZHNcbiAgICAgKiBvZmYgdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUuICBPbmx5IHZhbGlkXG4gICAgICogYXR0cmlidXRlcy9wcm9wZXJ0aWVzIGZvciB0aGUgbm9kZSB3aWxsIGJlIHNldC5cbiAgICAgKiBUbyBzZXQgY3VzdG9tIGF0dHJpYnV0ZXMgdXNlIHNldEF0dHJpYnV0ZS5cbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgdG8gYmUgc2V0LlxuICAgICAqIEBwYXJhbSB7YW55fSB2YWwgVGhlIHZhbHVlIHRvIHNldCB0aGUgYXR0cmlidXRlIHRvLlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgICAgICB2YXIgYXR0ckNvbmZpZyA9IFlfTm9kZS5BVFRSU1thdHRyXTtcblxuICAgICAgICBpZiAodGhpcy5fc2V0QXR0cikgeyAvLyB1c2UgQXR0cmlidXRlIGltcGxlXG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHVzZSBzZXR0ZXJzIGlubGluZVxuICAgICAgICAgICAgaWYgKGF0dHJDb25maWcgJiYgYXR0ckNvbmZpZy5zZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBhdHRyQ29uZmlnLnNldHRlci5jYWxsKHRoaXMsIHZhbCwgYXR0cik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFlfTm9kZS5yZV9hcmlhLnRlc3QoYXR0cikpIHsgLy8gc3BlY2lhbCBjYXNlIEFyaWFcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBZX05vZGUuREVGQVVMVF9TRVRURVIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG11bHRpcGxlIGF0dHJpYnV0ZXMuXG4gICAgICogQG1ldGhvZCBzZXRBdHRyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyTWFwIGFuIG9iamVjdCBvZiBuYW1lL3ZhbHVlIHBhaXJzIHRvIHNldFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRBdHRyczogZnVuY3Rpb24oYXR0ck1hcCkge1xuICAgICAgICBpZiAodGhpcy5fc2V0QXR0cnMpIHsgLy8gdXNlIEF0dHJpYnV0ZSBpbXBsZVxuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cnMoYXR0ck1hcCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHVzZSBzZXR0ZXJzIGlubGluZVxuICAgICAgICAgICAgWS5PYmplY3QuZWFjaChhdHRyTWFwLCBmdW5jdGlvbih2LCBuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQobiwgdik7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB2YWx1ZXMgZm9yIHRoZSByZXF1ZXN0ZWQgYXR0cmlidXRlcy5cbiAgICAgKiBAbWV0aG9kIGdldEF0dHJzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cnMgYW4gYXJyYXkgb2YgYXR0cmlidXRlcyB0byBnZXQgdmFsdWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycy5cbiAgICAgKi9cbiAgICBnZXRBdHRyczogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICBpZiAodGhpcy5fZ2V0QXR0cnMpIHsgLy8gdXNlIEF0dHJpYnV0ZSBpbXBsZVxuICAgICAgICAgICAgdGhpcy5fZ2V0QXR0cnMoYXR0cnMpO1xuICAgICAgICB9IGVsc2UgeyAvLyB1c2Ugc2V0dGVycyBpbmxpbmVcbiAgICAgICAgICAgIFkuQXJyYXkuZWFjaChhdHRycywgZnVuY3Rpb24odiwgbikge1xuICAgICAgICAgICAgICAgIHJldFt2XSA9IHRoaXMuZ2V0KHYpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyBub2RlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBtYXRjaC5cbiAgICAgKiBOb2RlIGluc3RhbmNlcyBjYW4gYmUgY29tcGFyZWQgdG8gZWFjaCBvdGhlciBhbmQvb3IgSFRNTEVsZW1lbnRzLlxuICAgICAqIEBtZXRob2QgY29tcGFyZVRvXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IE5vZGV9IHJlZk5vZGUgVGhlIHJlZmVyZW5jZSBub2RlIHRvIGNvbXBhcmUgdG8gdGhlIG5vZGUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbm9kZXMgbWF0Y2gsIGZhbHNlIGlmIHRoZXkgZG8gbm90LlxuICAgICAqL1xuICAgIGNvbXBhcmVUbzogZnVuY3Rpb24ocmVmTm9kZSkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGU7XG5cbiAgICAgICAgaWYgKHJlZk5vZGUgJiYgcmVmTm9kZS5fbm9kZSkge1xuICAgICAgICAgICAgcmVmTm9kZSA9IHJlZk5vZGUuX25vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IHJlZk5vZGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBpcyBhcHBlbmRlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICogQG1ldGhvZCBpbkRvY1xuICAgICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZG9jIG9wdGlvbmFsIEFuIG9wdGlvbmFsIGRvY3VtZW50IHRvIGNoZWNrIGFnYWluc3QuXG4gICAgICogRGVmYXVsdHMgdG8gY3VycmVudCBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaXMgYXBwZW5kZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGluRG9jOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBkb2MgPSAoZG9jKSA/IGRvYy5fbm9kZSB8fCBkb2MgOiBub2RlW09XTkVSX0RPQ1VNRU5UXTtcbiAgICAgICAgICAgIGlmIChkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFlfRE9NLmNvbnRhaW5zKGRvYy5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBnZXRCeUlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGUsXG4gICAgICAgICAgICByZXQgPSBZX0RPTS5ieUlkKGlkLCBub2RlW09XTkVSX0RPQ1VNRU5UXSk7XG4gICAgICAgIGlmIChyZXQgJiYgWV9ET00uY29udGFpbnMobm9kZSwgcmV0KSkge1xuICAgICAgICAgICAgcmV0ID0gWS5vbmUocmV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZWFyZXN0IGFuY2VzdG9yIHRoYXQgcGFzc2VzIHRoZSB0ZXN0IGFwcGxpZWQgYnkgc3VwcGxpZWQgYm9vbGVhbiBtZXRob2QuXG4gICAgICogQG1ldGhvZCBhbmNlc3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgRnVuY3Rpb259IGZuIEEgc2VsZWN0b3Igc3RyaW5nIG9yIGJvb2xlYW4gbWV0aG9kIGZvciB0ZXN0aW5nIGVsZW1lbnRzLlxuICAgICAqIElmIGEgZnVuY3Rpb24gaXMgdXNlZCwgaXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgbm9kZSBiZWluZyB0ZXN0ZWQgYXMgdGhlIG9ubHkgYXJndW1lbnQuXG4gICAgICogSWYgZm4gaXMgbm90IHBhc3NlZCBhcyBhbiBhcmd1bWVudCwgdGhlIHBhcmVudCBub2RlIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0ZXN0U2VsZiBvcHRpb25hbCBXaGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIHRoZSBlbGVtZW50IGluIHRoZSBzY2FuXG4gICAgICogQHBhcmFtIHtTdHJpbmcgfCBGdW5jdGlvbn0gc3RvcEZuIG9wdGlvbmFsIEEgc2VsZWN0b3Igc3RyaW5nIG9yIGJvb2xlYW5cbiAgICAgKiBtZXRob2QgdG8gaW5kaWNhdGUgd2hlbiB0aGUgc2VhcmNoIHNob3VsZCBzdG9wLiBUaGUgc2VhcmNoIGJhaWxzIHdoZW4gdGhlIGZ1bmN0aW9uXG4gICAgICogcmV0dXJucyB0cnVlIG9yIHRoZSBzZWxlY3RvciBtYXRjaGVzLlxuICAgICAqIElmIGEgZnVuY3Rpb24gaXMgdXNlZCwgaXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgbm9kZSBiZWluZyB0ZXN0ZWQgYXMgdGhlIG9ubHkgYXJndW1lbnQuXG4gICAgICogQHJldHVybiB7Tm9kZX0gVGhlIG1hdGNoaW5nIE5vZGUgaW5zdGFuY2Ugb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBhbmNlc3RvcjogZnVuY3Rpb24oZm4sIHRlc3RTZWxmLCBzdG9wRm4pIHtcbiAgICAgICAgLy8gdGVzdFNlbGYgaXMgb3B0aW9uYWwsIGNoZWNrIGZvciBzdG9wRm4gYXMgMm5kIGFyZ1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgdGVzdFNlbGYgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHRlc3RTZWxmID09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBzdG9wRm4gPSB0ZXN0U2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBZLm9uZShZX0RPTS5hbmNlc3Rvcih0aGlzLl9ub2RlLCBfd3JhcEZuKGZuKSwgdGVzdFNlbGYsIF93cmFwRm4oc3RvcEZuKSkpO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFuY2VzdG9ycyB0aGF0IHBhc3MgdGhlIHRlc3QgYXBwbGllZCBieSBzdXBwbGllZCBib29sZWFuIG1ldGhvZC5cbiAgICAgKiBAbWV0aG9kIGFuY2VzdG9yc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgRnVuY3Rpb259IGZuIEEgc2VsZWN0b3Igc3RyaW5nIG9yIGJvb2xlYW4gbWV0aG9kIGZvciB0ZXN0aW5nIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdGVzdFNlbGYgb3B0aW9uYWwgV2hldGhlciBvciBub3QgdG8gaW5jbHVkZSB0aGUgZWxlbWVudCBpbiB0aGUgc2NhblxuICAgICAqIElmIGEgZnVuY3Rpb24gaXMgdXNlZCwgaXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgbm9kZSBiZWluZyB0ZXN0ZWQgYXMgdGhlIG9ubHkgYXJndW1lbnQuXG4gICAgICogQHJldHVybiB7Tm9kZUxpc3R9IEEgTm9kZUxpc3QgaW5zdGFuY2UgY29udGFpbmluZyB0aGUgbWF0Y2hpbmcgZWxlbWVudHNcbiAgICAgKi9cbiAgICBhbmNlc3RvcnM6IGZ1bmN0aW9uKGZuLCB0ZXN0U2VsZiwgc3RvcEZuKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiB0ZXN0U2VsZiA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdGVzdFNlbGYgPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHN0b3BGbiA9IHRlc3RTZWxmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBZLmFsbChZX0RPTS5hbmNlc3RvcnModGhpcy5fbm9kZSwgX3dyYXBGbihmbiksIHRlc3RTZWxmLCBfd3JhcEZuKHN0b3BGbikpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJldmlvdXMgbWF0Y2hpbmcgc2libGluZy5cbiAgICAgKiBSZXR1cm5zIHRoZSBuZWFyZXN0IGVsZW1lbnQgbm9kZSBzaWJsaW5nIGlmIG5vIG1ldGhvZCBwcm92aWRlZC5cbiAgICAgKiBAbWV0aG9kIHByZXZpb3VzXG4gICAgICogQHBhcmFtIHtTdHJpbmcgfCBGdW5jdGlvbn0gZm4gQSBzZWxlY3RvciBvciBib29sZWFuIG1ldGhvZCBmb3IgdGVzdGluZyBlbGVtZW50cy5cbiAgICAgKiBJZiBhIGZ1bmN0aW9uIGlzIHVzZWQsIGl0IHJlY2VpdmVzIHRoZSBjdXJyZW50IG5vZGUgYmVpbmcgdGVzdGVkIGFzIHRoZSBvbmx5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbF0gV2hldGhlciB0ZXh0IG5vZGVzIGFzIHdlbGwgYXMgZWxlbWVudCBub2RlcyBzaG91bGQgYmUgcmV0dXJuZWQsIG9yXG4gICAgICoganVzdCBlbGVtZW50IG5vZGVzIHdpbGwgYmUgcmV0dXJuZWQoZGVmYXVsdClcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBOb2RlIGluc3RhbmNlIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uKGZuLCBhbGwpIHtcbiAgICAgICAgcmV0dXJuIFkub25lKFlfRE9NLmVsZW1lbnRCeUF4aXModGhpcy5fbm9kZSwgJ3ByZXZpb3VzU2libGluZycsIF93cmFwRm4oZm4pLCBhbGwpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBtYXRjaGluZyBzaWJsaW5nLlxuICAgICAqIFJldHVybnMgdGhlIG5lYXJlc3QgZWxlbWVudCBub2RlIHNpYmxpbmcgaWYgbm8gbWV0aG9kIHByb3ZpZGVkLlxuICAgICAqIEBtZXRob2QgbmV4dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgRnVuY3Rpb259IGZuIEEgc2VsZWN0b3Igb3IgYm9vbGVhbiBtZXRob2QgZm9yIHRlc3RpbmcgZWxlbWVudHMuXG4gICAgICogSWYgYSBmdW5jdGlvbiBpcyB1c2VkLCBpdCByZWNlaXZlcyB0aGUgY3VycmVudCBub2RlIGJlaW5nIHRlc3RlZCBhcyB0aGUgb25seSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxdIFdoZXRoZXIgdGV4dCBub2RlcyBhcyB3ZWxsIGFzIGVsZW1lbnQgbm9kZXMgc2hvdWxkIGJlIHJldHVybmVkLCBvclxuICAgICAqIGp1c3QgZWxlbWVudCBub2RlcyB3aWxsIGJlIHJldHVybmVkKGRlZmF1bHQpXG4gICAgICogQHJldHVybiB7Tm9kZX0gTm9kZSBpbnN0YW5jZSBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIG5leHQ6IGZ1bmN0aW9uKGZuLCBhbGwpIHtcbiAgICAgICAgcmV0dXJuIFkub25lKFlfRE9NLmVsZW1lbnRCeUF4aXModGhpcy5fbm9kZSwgJ25leHRTaWJsaW5nJywgX3dyYXBGbihmbiksIGFsbCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBtYXRjaGluZyBzaWJsaW5ncy5cbiAgICAgKiBSZXR1cm5zIGFsbCBzaWJsaW5ncyBpZiBubyBtZXRob2QgcHJvdmlkZWQuXG4gICAgICogQG1ldGhvZCBzaWJsaW5nc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgRnVuY3Rpb259IGZuIEEgc2VsZWN0b3Igb3IgYm9vbGVhbiBtZXRob2QgZm9yIHRlc3RpbmcgZWxlbWVudHMuXG4gICAgICogSWYgYSBmdW5jdGlvbiBpcyB1c2VkLCBpdCByZWNlaXZlcyB0aGUgY3VycmVudCBub2RlIGJlaW5nIHRlc3RlZCBhcyB0aGUgb25seSBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJuIHtOb2RlTGlzdH0gTm9kZUxpc3QgaW5zdGFuY2UgYm91bmQgdG8gZm91bmQgc2libGluZ3NcbiAgICAgKi9cbiAgICBzaWJsaW5nczogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgcmV0dXJuIFkuYWxsKFlfRE9NLnNpYmxpbmdzKHRoaXMuX25vZGUsIF93cmFwRm4oZm4pKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHNpbmdsZSBOb2RlIGluc3RhbmNlLCB0aGUgZmlyc3QgZWxlbWVudCBtYXRjaGluZyB0aGUgZ2l2ZW5cbiAgICAgKiBDU1Mgc2VsZWN0b3IuXG4gICAgICogUmV0dXJucyBudWxsIGlmIG5vIG1hdGNoIGZvdW5kLlxuICAgICAqIEBtZXRob2Qgb25lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIENTUyBzZWxlY3RvciB0byB0ZXN0IGFnYWluc3QuXG4gICAgICogQHJldHVybiB7Tm9kZSB8IG51bGx9IEEgTm9kZSBpbnN0YW5jZSBmb3IgdGhlIG1hdGNoaW5nIEhUTUxFbGVtZW50IG9yIG51bGxcbiAgICAgKiBpZiBubyBtYXRjaCBmb3VuZC5cbiAgICAgKi9cbiAgICBvbmU6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBZLm9uZShZLlNlbGVjdG9yLnF1ZXJ5KHNlbGVjdG9yLCB0aGlzLl9ub2RlLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIE5vZGVMaXN0IGJhc2VkIG9uIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3IuXG4gICAgICogQG1ldGhvZCBhbGxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgQ1NTIHNlbGVjdG9yIHRvIHRlc3QgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJuIHtOb2RlTGlzdH0gQSBOb2RlTGlzdCBpbnN0YW5jZSBmb3IgdGhlIG1hdGNoaW5nIEhUTUxDb2xsZWN0aW9uL0FycmF5LlxuICAgICAqL1xuICAgIGFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIG5vZGVsaXN0O1xuXG4gICAgICAgIGlmICh0aGlzLl9ub2RlKSB7XG4gICAgICAgICAgICBub2RlbGlzdCA9IFkuYWxsKFkuU2VsZWN0b3IucXVlcnkoc2VsZWN0b3IsIHRoaXMuX25vZGUpKTtcbiAgICAgICAgICAgIG5vZGVsaXN0Ll9xdWVyeSA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgbm9kZWxpc3QuX3F1ZXJ5Um9vdCA9IHRoaXMuX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZWxpc3QgfHwgWS5hbGwoW10pO1xuICAgIH0sXG5cbiAgICAvLyBUT0RPOiBhbGxvdyBmbiB0ZXN0XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGUgc3VwcGxpZWQgbm9kZSBtYXRjaGVzIHRoZSBzdXBwbGllZCBzZWxlY3Rvci5cbiAgICAgKiBAbWV0aG9kIHRlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgQ1NTIHNlbGVjdG9yIHRvIHRlc3QgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICB0ZXN0OiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gWS5TZWxlY3Rvci50ZXN0KHRoaXMuX25vZGUsIHNlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbm9kZSBmcm9tIGl0cyBwYXJlbnQuXG4gICAgICogU2hvcnRjdXQgZm9yIG15Tm9kZS5nZXQoJ3BhcmVudE5vZGUnKS5yZW1vdmVDaGlsZChteU5vZGUpO1xuICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkZXN0cm95IHdoZXRoZXIgb3Igbm90IHRvIGNhbGwgZGVzdHJveSgpIG9uIHRoZSBub2RlXG4gICAgICogYWZ0ZXIgcmVtb3ZhbC5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKGRlc3Ryb3kpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlO1xuXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIG5vZGUgd2l0aCB0aGUgb3RoZXIgbm9kZS4gVGhpcyBpcyBhIERPTSB1cGRhdGUgb25seVxuICAgICAqIGFuZCBkb2VzIG5vdCBjaGFuZ2UgdGhlIG5vZGUgYm91bmQgdG8gdGhlIE5vZGUgaW5zdGFuY2UuXG4gICAgICogU2hvcnRjdXQgZm9yIG15Tm9kZS5nZXQoJ3BhcmVudE5vZGUnKS5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgbXlOb2RlKTtcbiAgICAgKiBAbWV0aG9kIHJlcGxhY2VcbiAgICAgKiBAcGFyYW0ge05vZGUgfCBIVE1MRWxlbWVudH0gbmV3Tm9kZSBOb2RlIHRvIGJlIGluc2VydGVkXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgcmVwbGFjZTogZnVuY3Rpb24obmV3Tm9kZSkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3Tm9kZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbmV3Tm9kZSA9IFlfTm9kZS5jcmVhdGUobmV3Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChZX05vZGUuZ2V0RE9NTm9kZShuZXdOb2RlKSwgbm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHJlcGxhY2VDaGlsZFxuICAgICAqIEBmb3IgTm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgSFRNTEVsZW1lbnQgfCBOb2RlfSBub2RlIE5vZGUgdG8gYmUgaW5zZXJ0ZWRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgTm9kZX0gcmVmTm9kZSBOb2RlIHRvIGJlIHJlcGxhY2VkXG4gICAgICogQHJldHVybiB7Tm9kZX0gVGhlIHJlcGxhY2VkIG5vZGVcbiAgICAgKi9cbiAgICByZXBsYWNlQ2hpbGQ6IGZ1bmN0aW9uKG5vZGUsIHJlZk5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBub2RlID0gWV9ET00uY3JlYXRlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFkub25lKHRoaXMuX25vZGUucmVwbGFjZUNoaWxkKFlfTm9kZS5nZXRET01Ob2RlKG5vZGUpLCBZX05vZGUuZ2V0RE9NTm9kZShyZWZOb2RlKSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOdWxscyBpbnRlcm5hbCBub2RlIHJlZmVyZW5jZXMsIHJlbW92ZXMgYW55IHBsdWdpbnMgYW5kIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBOb3RlIHRoYXQgZGVzdHJveSgpIHdpbGwgbm90IHJlbW92ZSB0aGUgbm9kZSBmcm9tIGl0cyBwYXJlbnQgb3IgZnJvbSB0aGUgRE9NLiBGb3IgdGhhdFxuICAgICAqIGZ1bmN0aW9uYWxpdHksIGNhbGwgcmVtb3ZlKHRydWUpLlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVjdXJzaXZlUHVyZ2UgKG9wdGlvbmFsKSBXaGV0aGVyIG9yIG5vdCB0byByZW1vdmUgbGlzdGVuZXJzIGZyb20gdGhlXG4gICAgICogbm9kZSdzIHN1YnRyZWUgKGRlZmF1bHQgaXMgZmFsc2UpXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbihyZWN1cnNpdmUpIHtcbiAgICAgICAgdmFyIFVJRCA9IFkuY29uZmlnLmRvYy51bmlxdWVJRCA/ICd1bmlxdWVJRCcgOiAnX3l1aWQnLFxuICAgICAgICAgICAgaW5zdGFuY2U7XG5cbiAgICAgICAgdGhpcy5wdXJnZSgpOyAvLyBUT0RPOiBvbmx5IHJlbW92ZSBldmVudHMgYWRkIHZpYSB0aGlzIE5vZGVcblxuICAgICAgICBpZiAodGhpcy51bnBsdWcpIHsgLy8gbWF5IG5vdCBiZSBhIFBsdWdpbkhvc3RcbiAgICAgICAgICAgIHRoaXMudW5wbHVnKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsZWFyRGF0YSgpO1xuXG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIFkuTm9kZUxpc3QuZWFjaCh0aGlzLmFsbCgnKicpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBZX05vZGUuX2luc3RhbmNlc1tub2RlW1VJRF1dO1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBwdXJnZSBpbiBjYXNlIGFkZGVkIGJ5IG90aGVyIG1lYW5zXG4gICAgICAgICAgICAgICAgICAgIFkuRXZlbnQucHVyZ2VFbGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXRlUHJveHkgPSBudWxsO1xuXG4gICAgICAgIGRlbGV0ZSBZX05vZGUuX2luc3RhbmNlc1t0aGlzLl95dWlkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhIG1ldGhvZCBvbiB0aGUgTm9kZSBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgaW52b2tlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGludm9rZVxuICAgICAqIEBwYXJhbSB7YW55fSBbYXJncypdIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm4ge2FueX0gV2hhdGV2ZXIgdGhlIHVuZGVybHkgbWV0aG9kIHJldHVybnMuXG4gICAgICogRE9NIE5vZGVzIGFuZCBDb2xsZWN0aW9ucyByZXR1cm4gdmFsdWVzXG4gICAgICogYXJlIGNvbnZlcnRlZCB0byBOb2RlL05vZGVMaXN0IGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGludm9rZTogZnVuY3Rpb24obWV0aG9kLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZSxcbiAgICAgICAgICAgIHJldDtcblxuICAgICAgICBpZiAoYSAmJiBhLl9ub2RlKSB7XG4gICAgICAgICAgICBhID0gYS5fbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiICYmIGIuX25vZGUpIHtcbiAgICAgICAgICAgIGIgPSBiLl9ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbm9kZVttZXRob2RdKGEsIGIsIGMsIGQsIGUpO1xuICAgICAgICByZXR1cm4gWV9Ob2RlLnNjcnViVmFsKHJldCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG1ldGhvZCBzd2FwXG4gICAgKiBAZGVzY3JpcHRpb24gU3dhcCBET00gbG9jYXRpb25zIHdpdGggdGhlIGdpdmVuIG5vZGUuXG4gICAgKiBUaGlzIGRvZXMgbm90IGNoYW5nZSB3aGljaCBET00gbm9kZSBlYWNoIE5vZGUgaW5zdGFuY2UgcmVmZXJzIHRvLlxuICAgICogQHBhcmFtIHtOb2RlfSBvdGhlck5vZGUgVGhlIG5vZGUgdG8gc3dhcCB3aXRoXG4gICAgICogQGNoYWluYWJsZVxuICAgICovXG4gICAgc3dhcDogWS5jb25maWcuZG9jLmRvY3VtZW50RWxlbWVudC5zd2FwTm9kZSA/XG4gICAgICAgIGZ1bmN0aW9uKG90aGVyTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZS5zd2FwTm9kZShZX05vZGUuZ2V0RE9NTm9kZShvdGhlck5vZGUpKTtcbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uKG90aGVyTm9kZSkge1xuICAgICAgICAgICAgb3RoZXJOb2RlID0gWV9Ob2RlLmdldERPTU5vZGUob3RoZXJOb2RlKTtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZSxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBvdGhlck5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBuZXh0U2libGluZyA9IG90aGVyTm9kZS5uZXh0U2libGluZztcblxuICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBvdGhlck5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvdGhlck5vZGUgPT09IG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG90aGVyTm9kZSwgbm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQob3RoZXJOb2RlLCBub2RlKTtcbiAgICAgICAgICAgICAgICBZX0RPTS5hZGRIVE1MKHBhcmVudCwgbm9kZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cblxuICAgIGhhc01ldGhvZDogZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZTtcbiAgICAgICAgcmV0dXJuICEhKG5vZGUgJiYgbWV0aG9kIGluIG5vZGUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZVttZXRob2RdICE9ICd1bmtub3duJyAmJlxuICAgICAgICAgICAgKHR5cGVvZiBub2RlW21ldGhvZF0gPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgIFN0cmluZyhub2RlW21ldGhvZF0pLmluZGV4T2YoJ2Z1bmN0aW9uJykgPT09IDEpKTsgLy8gSUUgcmVwb3J0cyBhcyBvYmplY3QsIHByZXBlbmRzIHNwYWNlXG4gICAgfSxcblxuICAgIGlzRnJhZ21lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0KCdub2RlVHlwZScpID09PSAxMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW5kIGRlc3Ryb3lzIGFsbCBvZiB0aGUgbm9kZXMgd2l0aGluIHRoZSBub2RlLlxuICAgICAqIEBtZXRob2QgZW1wdHlcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldCgnY2hpbGROb2RlcycpLnJlbW92ZSgpLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBET00gbm9kZSBib3VuZCB0byB0aGUgTm9kZSBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgZ2V0RE9NTm9kZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGdldERPTU5vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICB9XG59LCB0cnVlKTtcblxuWS5Ob2RlID0gWV9Ob2RlO1xuWS5vbmUgPSBZX05vZGUub25lO1xuLyoqXG4gKiBUaGUgTm9kZUxpc3QgbW9kdWxlIHByb3ZpZGVzIHN1cHBvcnQgZm9yIG1hbmFnaW5nIGNvbGxlY3Rpb25zIG9mIE5vZGVzLlxuICogQG1vZHVsZSBub2RlXG4gKiBAc3VibW9kdWxlIG5vZGUtY29yZVxuICovXG5cbi8qKlxuICogVGhlIE5vZGVMaXN0IGNsYXNzIHByb3ZpZGVzIGEgd3JhcHBlciBmb3IgbWFuaXB1bGF0aW5nIERPTSBOb2RlTGlzdHMuXG4gKiBOb2RlTGlzdCBwcm9wZXJ0aWVzIGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGhlIHNldC9nZXQgbWV0aG9kcy5cbiAqIFVzZSBZLmFsbCgpIHRvIHJldHJpZXZlIE5vZGVMaXN0IGluc3RhbmNlcy5cbiAqXG4gKiBAY2xhc3MgTm9kZUxpc3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIG5vZGVzIHtTdHJpbmd8ZWxlbWVudHxOb2RlfEFycmF5fSBBIHNlbGVjdG9yLCBET00gZWxlbWVudCwgTm9kZSwgbGlzdCBvZiBET00gZWxlbWVudHMsIG9yIGxpc3Qgb2YgTm9kZXMgd2l0aCB3aGljaCB0byBwb3B1bGF0ZSB0aGlzIE5vZGVMaXN0LlxuICovXG5cbnZhciBOb2RlTGlzdCA9IGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgdmFyIHRtcCA9IFtdO1xuXG4gICAgaWYgKG5vZGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09ICdzdHJpbmcnKSB7IC8vIHNlbGVjdG9yIHF1ZXJ5XG4gICAgICAgICAgICB0aGlzLl9xdWVyeSA9IG5vZGVzO1xuICAgICAgICAgICAgbm9kZXMgPSBZLlNlbGVjdG9yLnF1ZXJ5KG5vZGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy5ub2RlVHlwZSB8fCBZX0RPTS5pc1dpbmRvdyhub2RlcykpIHsgLy8gZG9tTm9kZSB8fCB3aW5kb3dcbiAgICAgICAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgU1ZHRWxlbWVudEluc3RhbmNlICE9PSAndW5kZWZpbmVkJyAmJiBub2Rlcy5jb3JyZXNwb25kaW5nRWxlbWVudCkgeyAvLyBzdmcgbm9kZSAtYmNcbiAgICAgICAgICAgIG5vZGVzID0gWyhub2Rlcy5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCB8fCBub2Rlcy5jb3JyZXNwb25kaW5nRWxlbWVudCldO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLl9ub2RlKSB7IC8vIFkuTm9kZVxuICAgICAgICAgICAgbm9kZXMgPSBbbm9kZXMuX25vZGVdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzWzBdICYmIG5vZGVzWzBdLl9ub2RlKSB7IC8vIGFsbG93IGFycmF5IG9mIFkuTm9kZXNcbiAgICAgICAgICAgIFkuQXJyYXkuZWFjaChub2RlcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKG5vZGUuX25vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm9kZXMgPSB0bXA7XG4gICAgICAgIH0gZWxzZSB7IC8vIGFycmF5IG9mIGRvbU5vZGVzIG9yIGRvbU5vZGVMaXN0IChubyBtaXhlZCBhcnJheSBvZiBZLk5vZGUvZG9tTm9kZXMpXG4gICAgICAgICAgICBub2RlcyA9IFkuQXJyYXkobm9kZXMsIDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHVuZGVybHlpbmcgYXJyYXkgb2YgRE9NIG5vZGVzIGJvdW5kIHRvIHRoZSBZLk5vZGVMaXN0IGluc3RhbmNlXG4gICAgICogQHByb3BlcnR5IF9ub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbm9kZXMgPSBub2RlcyB8fCBbXTtcbn07XG5cbk5vZGVMaXN0Lk5BTUUgPSAnTm9kZUxpc3QnO1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgRE9NIG5vZGVzIGJvdW5kIHRvIGEgTm9kZUxpc3QgaW5zdGFuY2VcbiAqIEBtZXRob2QgZ2V0RE9NTm9kZXNcbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge05vZGVMaXN0fSBub2RlbGlzdCBUaGUgTm9kZUxpc3QgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2YgRE9NIG5vZGVzIGJvdW5kIHRvIHRoZSBOb2RlTGlzdFxuICovXG5Ob2RlTGlzdC5nZXRET01Ob2RlcyA9IGZ1bmN0aW9uKG5vZGVsaXN0KSB7XG4gICAgcmV0dXJuIChub2RlbGlzdCAmJiBub2RlbGlzdC5fbm9kZXMpID8gbm9kZWxpc3QuX25vZGVzIDogbm9kZWxpc3Q7XG59O1xuXG5Ob2RlTGlzdC5lYWNoID0gZnVuY3Rpb24oaW5zdGFuY2UsIGZuLCBjb250ZXh0KSB7XG4gICAgdmFyIG5vZGVzID0gaW5zdGFuY2UuX25vZGVzO1xuICAgIGlmIChub2RlcyAmJiBub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgWS5BcnJheS5lYWNoKG5vZGVzLCBmbiwgY29udGV4dCB8fCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG59O1xuXG5Ob2RlTGlzdC5hZGRNZXRob2QgPSBmdW5jdGlvbihuYW1lLCBmbiwgY29udGV4dCkge1xuICAgIGlmIChuYW1lICYmIGZuKSB7XG4gICAgICAgIE5vZGVMaXN0LnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgICAgIFkuQXJyYXkuZWFjaCh0aGlzLl9ub2RlcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBVSUQgPSAobm9kZS51bmlxdWVJRCAmJiBub2RlLm5vZGVUeXBlICE9PSA5ICkgPyAndW5pcXVlSUQnIDogJ195dWlkJyxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBZLk5vZGUuX2luc3RhbmNlc1tub2RlW1VJRF1dLFxuICAgICAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBOb2RlTGlzdC5fZ2V0VGVtcE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eCA9IGNvbnRleHQgfHwgaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkoY3R4LCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXRbcmV0Lmxlbmd0aF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0bXAgcG9pbnRlclxuICAgICAgICAgICAgcmV0dXJuIHJldC5sZW5ndGggPyByZXQgOiB0aGlzO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgfVxufTtcblxuTm9kZUxpc3QuaW1wb3J0TWV0aG9kID0gZnVuY3Rpb24oaG9zdCwgbmFtZSwgYWx0TmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWx0TmFtZSA9IGFsdE5hbWUgfHwgbmFtZTtcbiAgICAgICAgTm9kZUxpc3QuYWRkTWV0aG9kKG5hbWUsIGhvc3RbbmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFkuQXJyYXkuZWFjaChuYW1lLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICBOb2RlTGlzdC5pbXBvcnRNZXRob2QoaG9zdCwgbik7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbk5vZGVMaXN0Ll9nZXRUZW1wTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgdG1wID0gTm9kZUxpc3QuX3RlbXBOb2RlO1xuICAgIGlmICghdG1wKSB7XG4gICAgICAgIHRtcCA9IFkuTm9kZS5jcmVhdGUoJzxkaXY+PC9kaXY+Jyk7XG4gICAgICAgIE5vZGVMaXN0Ll90ZW1wTm9kZSA9IHRtcDtcbiAgICB9XG5cbiAgICB0bXAuX25vZGUgPSBub2RlO1xuICAgIHRtcC5fc3RhdGVQcm94eSA9IG5vZGU7XG4gICAgcmV0dXJuIHRtcDtcbn07XG5cblkubWl4KE5vZGVMaXN0LnByb3RvdHlwZSwge1xuICAgIF9pbnZva2U6IGZ1bmN0aW9uKG1ldGhvZCwgYXJncywgZ2V0dGVyKSB7XG4gICAgICAgIHZhciByZXQgPSAoZ2V0dGVyKSA/IFtdIDogdGhpcztcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IG5vZGVbbWV0aG9kXS5hcHBseShub2RlLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChnZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIE5vZGUgaW5zdGFuY2UgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBtZXRob2QgaXRlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFyZ2V0IE5vZGUuXG4gICAgICogQHJldHVybiB7Tm9kZX0gVGhlIE5vZGUgaW5zdGFuY2UgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIGl0ZW06IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBZLm9uZSgodGhpcy5fbm9kZXMgfHwgW10pW2luZGV4XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIGVhY2ggTm9kZSBpbiB0aGUgTm9kZUxpc3QuXG4gICAgICogQG1ldGhvZCBlYWNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5LiBJdCByZWNlaXZlcyAzIGFyZ3VtZW50czpcbiAgICAgKiB0aGUgY3VycmVudCBub2RlIGluc3RhbmNlLCB0aGUgbm9kZSdzIGluZGV4LCBhbmQgdGhlIE5vZGVMaXN0IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgb3B0aW9uYWwgQW4gb3B0aW9uYWwgY29udGV4dCB0byBhcHBseSB0aGUgZnVuY3Rpb24gd2l0aFxuICAgICAqIERlZmF1bHQgY29udGV4dCBpcyB0aGUgY3VycmVudCBOb2RlIGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIFkuQXJyYXkuZWFjaCh0aGlzLl9ub2RlcywgZnVuY3Rpb24obm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIG5vZGUgPSBZLm9uZShub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgbm9kZSwgbm9kZSwgaW5kZXgsIGluc3RhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuXG4gICAgYmF0Y2g6IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBub2RlbGlzdCA9IHRoaXM7XG5cbiAgICAgICAgWS5BcnJheS5lYWNoKHRoaXMuX25vZGVzLCBmdW5jdGlvbihub2RlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gWS5Ob2RlLl9pbnN0YW5jZXNbbm9kZVtVSURdXTtcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IE5vZGVMaXN0Ll9nZXRUZW1wTm9kZShub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBpbnN0YW5jZSwgaW5zdGFuY2UsIGluZGV4LCBub2RlbGlzdCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZWxpc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIG5vZGUgdW50aWwgYSB0cnVlIHZhbHVlIGlzIHJldHVybmVkLlxuICAgICAqIEBtZXRob2Qgc29tZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBhcHBseS4gSXQgcmVjZWl2ZXMgMyBhcmd1bWVudHM6XG4gICAgICogdGhlIGN1cnJlbnQgbm9kZSBpbnN0YW5jZSwgdGhlIG5vZGUncyBpbmRleCwgYW5kIHRoZSBOb2RlTGlzdCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IG9wdGlvbmFsIEFuIG9wdGlvbmFsIGNvbnRleHQgdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb24gZnJvbS5cbiAgICAgKiBEZWZhdWx0IGNvbnRleHQgaXMgdGhlIGN1cnJlbnQgTm9kZSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBmdW5jdGlvbiByZXR1cm5lZCB0cnVlIGZvciBhbnkgbm9kZS5cbiAgICAgKi9cbiAgICBzb21lOiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gWS5BcnJheS5zb21lKHRoaXMuX25vZGVzLCBmdW5jdGlvbihub2RlLCBpbmRleCkge1xuICAgICAgICAgICAgbm9kZSA9IFkub25lKG5vZGUpO1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKGNvbnRleHQsIG5vZGUsIGluZGV4LCBpbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZG9jdW1lbkZyYWdtZW50IGZyb20gdGhlIG5vZGVzIGJvdW5kIHRvIHRoZSBOb2RlTGlzdCBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgdG9GcmFnXG4gICAgICogQHJldHVybiB7Tm9kZX0gYSBOb2RlIGluc3RhbmNlIGJvdW5kIHRvIHRoZSBkb2N1bWVudEZyYWdtZW50XG4gICAgICovXG4gICAgdG9GcmFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFkub25lKFkuRE9NLl9ubDJmcmFnKHRoaXMuX25vZGVzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBub2RlIGluIHRoZSBOb2RlTGlzdCBpbnN0YW5jZVxuICAgICAqIG9yIC0xIGlmIHRoZSBub2RlIGlzbid0IGZvdW5kLlxuICAgICAqIEBtZXRob2QgaW5kZXhPZlxuICAgICAqIEBwYXJhbSB7Tm9kZSB8IEhUTUxFbGVtZW50fSBub2RlIHRoZSBub2RlIHRvIHNlYXJjaCBmb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgbm9kZSB2YWx1ZSBvciAtMSBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBpbmRleE9mOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiBZLkFycmF5LmluZGV4T2YodGhpcy5fbm9kZXMsIFkuTm9kZS5nZXRET01Ob2RlKG5vZGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVycyB0aGUgTm9kZUxpc3QgaW5zdGFuY2UgZG93biB0byBvbmx5IG5vZGVzIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3Rvci5cbiAgICAgKiBAbWV0aG9kIGZpbHRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgdG8gZmlsdGVyIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtOb2RlTGlzdH0gTm9kZUxpc3QgY29udGFpbmluZyB0aGUgdXBkYXRlZCBjb2xsZWN0aW9uXG4gICAgICogQHNlZSBTZWxlY3RvclxuICAgICAqL1xuICAgIGZpbHRlcjogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIFkuYWxsKFkuU2VsZWN0b3IuZmlsdGVyKHRoaXMuX25vZGVzLCBzZWxlY3RvcikpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTm9kZUxpc3QgY29udGFpbmluZyBhbGwgbm9kZXMgYXQgZXZlcnkgbiBpbmRpY2VzLCB3aGVyZVxuICAgICAqIHJlbWFpbmRlciBuICUgaW5kZXggZXF1YWxzIHIuXG4gICAgICogKHplcm8tYmFzZWQgaW5kZXgpLlxuICAgICAqIEBtZXRob2QgbW9kdWx1c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBvZmZzZXQgdG8gdXNlIChyZXR1cm4gZXZlcnkgbnRoIG5vZGUpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgQW4gb3B0aW9uYWwgcmVtYWluZGVyIHRvIHVzZSB3aXRoIHRoZSBtb2R1bHVzIG9wZXJhdGlvbiAoZGVmYXVsdHMgdG8gemVybylcbiAgICAgKiBAcmV0dXJuIHtOb2RlTGlzdH0gTm9kZUxpc3QgY29udGFpbmluZyB0aGUgdXBkYXRlZCBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgbW9kdWx1czogZnVuY3Rpb24obiwgcikge1xuICAgICAgICByID0gciB8fCAwO1xuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgTm9kZUxpc3QuZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlLCBpKSB7XG4gICAgICAgICAgICBpZiAoaSAlIG4gPT09IHIpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gWS5hbGwobm9kZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE5vZGVMaXN0IGNvbnRhaW5pbmcgYWxsIG5vZGVzIGF0IG9kZCBpbmRpY2VzXG4gICAgICogKHplcm8tYmFzZWQgaW5kZXgpLlxuICAgICAqIEBtZXRob2Qgb2RkXG4gICAgICogQHJldHVybiB7Tm9kZUxpc3R9IE5vZGVMaXN0IGNvbnRhaW5pbmcgdGhlIHVwZGF0ZWQgY29sbGVjdGlvblxuICAgICAqL1xuICAgIG9kZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsdXMoMiwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTm9kZUxpc3QgY29udGFpbmluZyBhbGwgbm9kZXMgYXQgZXZlbiBpbmRpY2VzXG4gICAgICogKHplcm8tYmFzZWQgaW5kZXgpLCBpbmNsdWRpbmcgemVyby5cbiAgICAgKiBAbWV0aG9kIGV2ZW5cbiAgICAgKiBAcmV0dXJuIHtOb2RlTGlzdH0gTm9kZUxpc3QgY29udGFpbmluZyB0aGUgdXBkYXRlZCBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgZXZlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsdXMoMik7XG4gICAgfSxcblxuICAgIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXJ1bnMgdGhlIGluaXRpYWwgcXVlcnksIHdoZW4gY3JlYXRlZCB1c2luZyBhIHNlbGVjdG9yIHF1ZXJ5XG4gICAgICogQG1ldGhvZCByZWZyZXNoXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9jLFxuICAgICAgICAgICAgbm9kZXMgPSB0aGlzLl9ub2RlcyxcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5fcXVlcnksXG4gICAgICAgICAgICByb290ID0gdGhpcy5fcXVlcnlSb290O1xuXG4gICAgICAgIGlmIChxdWVyeSkge1xuICAgICAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzICYmIG5vZGVzWzBdICYmIG5vZGVzWzBdLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IG5vZGVzWzBdLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9ub2RlcyA9IFkuU2VsZWN0b3IucXVlcnkocXVlcnksIHJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBOb2RlTGlzdC5cbiAgICAgKiBAbWV0aG9kIHNpemVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIE5vZGVMaXN0LlxuICAgICAqL1xuICAgIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnN0YW5jZSBpcyBib3VuZCB0byBhbnkgbm9kZXNcbiAgICAgKiBAbWV0aG9kIGlzRW1wdHlcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgTm9kZUxpc3QgaXMgYm91bmQgdG8gYW55IG5vZGVzXG4gICAgICovXG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlcy5sZW5ndGggPCAxO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJyxcbiAgICAgICAgICAgIGVycm9yTXNnID0gdGhpc1tVSURdICsgJzogbm90IGJvdW5kIHRvIGFueSBub2RlcycsXG4gICAgICAgICAgICBub2RlcyA9IHRoaXMuX25vZGVzLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAobm9kZXMgJiYgbm9kZXNbMF0pIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIHN0ciArPSBub2RlW05PREVfTkFNRV07XG4gICAgICAgICAgICBpZiAobm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnIycgKyBub2RlLmlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJy4nICsgbm9kZS5jbGFzc05hbWUucmVwbGFjZSgnICcsICcuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcuLi5bJyArIG5vZGVzLmxlbmd0aCArICcgaXRlbXNdJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyIHx8IGVycm9yTXNnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBET00gbm9kZSBib3VuZCB0byB0aGUgTm9kZSBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgZ2V0RE9NTm9kZXNcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRET01Ob2RlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlcztcbiAgICB9XG59LCB0cnVlKTtcblxuTm9kZUxpc3QuaW1wb3J0TWV0aG9kKFkuTm9kZS5wcm90b3R5cGUsIFtcbiAgICAgLyoqXG4gICAgICAqIENhbGxlZCBvbiBlYWNoIE5vZGUgaW5zdGFuY2UuIE51bGxzIGludGVybmFsIG5vZGUgcmVmZXJlbmNlcyxcbiAgICAgICogcmVtb3ZlcyBhbnkgcGx1Z2lucyBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlY3Vyc2l2ZVB1cmdlIChvcHRpb25hbCkgV2hldGhlciBvciBub3QgdG9cbiAgICAgICogcmVtb3ZlIGxpc3RlbmVycyBmcm9tIHRoZSBub2RlJ3Mgc3VidHJlZSAoZGVmYXVsdCBpcyBmYWxzZSlcbiAgICAgICogQHNlZSBOb2RlLmRlc3Ryb3lcbiAgICAgICovXG4gICAgJ2Rlc3Ryb3knLFxuXG4gICAgIC8qKlxuICAgICAgKiBDYWxsZWQgb24gZWFjaCBOb2RlIGluc3RhbmNlLiBSZW1vdmVzIGFuZCBkZXN0cm95cyBhbGwgb2YgdGhlIG5vZGVzXG4gICAgICAqIHdpdGhpbiB0aGUgbm9kZVxuICAgICAgKiBAbWV0aG9kIGVtcHR5XG4gICAgICAqIEBjaGFpbmFibGVcbiAgICAgICogQHNlZSBOb2RlLmVtcHR5XG4gICAgICAqL1xuICAgICdlbXB0eScsXG5cbiAgICAgLyoqXG4gICAgICAqIENhbGxlZCBvbiBlYWNoIE5vZGUgaW5zdGFuY2UuIFJlbW92ZXMgdGhlIG5vZGUgZnJvbSBpdHMgcGFyZW50LlxuICAgICAgKiBTaG9ydGN1dCBmb3IgbXlOb2RlLmdldCgncGFyZW50Tm9kZScpLnJlbW92ZUNoaWxkKG15Tm9kZSk7XG4gICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVzdHJveSB3aGV0aGVyIG9yIG5vdCB0byBjYWxsIGRlc3Ryb3koKSBvbiB0aGUgbm9kZVxuICAgICAgKiBhZnRlciByZW1vdmFsLlxuICAgICAgKiBAY2hhaW5hYmxlXG4gICAgICAqIEBzZWUgTm9kZS5yZW1vdmVcbiAgICAgICovXG4gICAgJ3JlbW92ZScsXG5cbiAgICAgLyoqXG4gICAgICAqIENhbGxlZCBvbiBlYWNoIE5vZGUgaW5zdGFuY2UuIFNldHMgYW4gYXR0cmlidXRlIG9uIHRoZSBOb2RlIGluc3RhbmNlLlxuICAgICAgKiBVbmxlc3MgcHJlLWNvbmZpZ3VyZWQgKHZpYSBOb2RlLkFUVFJTKSwgc2V0IGhhbmRzXG4gICAgICAqIG9mZiB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS4gIE9ubHkgdmFsaWRcbiAgICAgICogYXR0cmlidXRlcy9wcm9wZXJ0aWVzIGZvciB0aGUgbm9kZSB3aWxsIGJlIHNldC5cbiAgICAgICogVG8gc2V0IGN1c3RvbSBhdHRyaWJ1dGVzIHVzZSBzZXRBdHRyaWJ1dGUuXG4gICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgdG8gYmUgc2V0LlxuICAgICAgKiBAcGFyYW0ge2FueX0gdmFsIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0by5cbiAgICAgICogQGNoYWluYWJsZVxuICAgICAgKiBAc2VlIE5vZGUuc2V0XG4gICAgICAqL1xuICAgICdzZXQnXG5dKTtcblxuLy8gb25lLW9mZiBpbXBsZW1lbnRhdGlvbiB0byBjb252ZXJ0IGFycmF5IG9mIE5vZGVzIHRvIE5vZGVMaXN0XG4vLyBlLmcuIFkuYWxsKCdpbnB1dCcpLmdldCgncGFyZW50Tm9kZScpO1xuXG4vKiogQ2FsbGVkIG9uIGVhY2ggTm9kZSBpbnN0YW5jZVxuICAqIEBtZXRob2QgZ2V0XG4gICogQHNlZSBOb2RlXG4gICovXG5Ob2RlTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oYXR0cikge1xuICAgIHZhciByZXQgPSBbXSxcbiAgICAgICAgbm9kZXMgPSB0aGlzLl9ub2RlcyxcbiAgICAgICAgaXNOb2RlTGlzdCA9IGZhbHNlLFxuICAgICAgICBnZXRUZW1wID0gTm9kZUxpc3QuX2dldFRlbXBOb2RlLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgdmFsO1xuXG4gICAgaWYgKG5vZGVzWzBdKSB7XG4gICAgICAgIGluc3RhbmNlID0gWS5Ob2RlLl9pbnN0YW5jZXNbbm9kZXNbMF0uX3l1aWRdIHx8IGdldFRlbXAobm9kZXNbMF0pO1xuICAgICAgICB2YWwgPSBpbnN0YW5jZS5fZ2V0KGF0dHIpO1xuICAgICAgICBpZiAodmFsICYmIHZhbC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgaXNOb2RlTGlzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBZLkFycmF5LmVhY2gobm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBZLk5vZGUuX2luc3RhbmNlc1tub2RlLl95dWlkXTtcblxuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IGdldFRlbXAobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWwgPSBpbnN0YW5jZS5fZ2V0KGF0dHIpO1xuICAgICAgICBpZiAoIWlzTm9kZUxpc3QpIHsgLy8gY29udmVydCBhcnJheSBvZiBOb2RlcyB0byBOb2RlTGlzdFxuICAgICAgICAgICAgdmFsID0gWS5Ob2RlLnNjcnViVmFsKHZhbCwgaW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0LnB1c2godmFsKTtcbiAgICB9KTtcblxuICAgIHJldHVybiAoaXNOb2RlTGlzdCkgPyBZLmFsbChyZXQpIDogcmV0O1xufTtcblxuWS5Ob2RlTGlzdCA9IE5vZGVMaXN0O1xuXG5ZLmFsbCA9IGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlTGlzdChub2Rlcyk7XG59O1xuXG5ZLk5vZGUuYWxsID0gWS5hbGw7XG4vKipcbiAqIEBtb2R1bGUgbm9kZVxuICogQHN1Ym1vZHVsZSBub2RlLWNvcmVcbiAqL1xuXG52YXIgWV9Ob2RlTGlzdCA9IFkuTm9kZUxpc3QsXG4gICAgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBBcnJheU1ldGhvZHMgPSB7XG4gICAgICAgIC8qKiBSZXR1cm5zIGEgbmV3IE5vZGVMaXN0IGNvbWJpbmluZyB0aGUgZ2l2ZW4gTm9kZUxpc3QocylcbiAgICAgICAgICAqIEBmb3IgTm9kZUxpc3RcbiAgICAgICAgICAqIEBtZXRob2QgY29uY2F0XG4gICAgICAgICAgKiBAcGFyYW0ge05vZGVMaXN0IHwgQXJyYXl9IHZhbHVlTiBBcnJheXMvTm9kZUxpc3RzIGFuZC9vciB2YWx1ZXMgdG9cbiAgICAgICAgICAqIGNvbmNhdGVuYXRlIHRvIHRoZSByZXN1bHRpbmcgTm9kZUxpc3RcbiAgICAgICAgICAqIEByZXR1cm4ge05vZGVMaXN0fSBBIG5ldyBOb2RlTGlzdCBjb21wcmlzZWQgb2YgdGhpcyBOb2RlTGlzdCBqb2luZWQgd2l0aCB0aGUgaW5wdXQuXG4gICAgICAgICAgKi9cbiAgICAgICAgJ2NvbmNhdCc6IDEsXG4gICAgICAgIC8qKiBSZW1vdmVzIHRoZSBsYXN0IGZyb20gdGhlIE5vZGVMaXN0IGFuZCByZXR1cm5zIGl0LlxuICAgICAgICAgICogQGZvciBOb2RlTGlzdFxuICAgICAgICAgICogQG1ldGhvZCBwb3BcbiAgICAgICAgICAqIEByZXR1cm4ge05vZGUgfCBudWxsfSBUaGUgbGFzdCBpdGVtIGluIHRoZSBOb2RlTGlzdCwgb3IgbnVsbCBpZiB0aGUgbGlzdCBpcyBlbXB0eS5cbiAgICAgICAgICAqL1xuICAgICAgICAncG9wJzogMCxcbiAgICAgICAgLyoqIEFkZHMgdGhlIGdpdmVuIE5vZGUocykgdG8gdGhlIGVuZCBvZiB0aGUgTm9kZUxpc3QuXG4gICAgICAgICAgKiBAZm9yIE5vZGVMaXN0XG4gICAgICAgICAgKiBAbWV0aG9kIHB1c2hcbiAgICAgICAgICAqIEBwYXJhbSB7Tm9kZSB8IEhUTUxFbGVtZW50fSBub2RlcyBPbmUgb3IgbW9yZSBub2RlcyB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgTm9kZUxpc3QuXG4gICAgICAgICAgKi9cbiAgICAgICAgJ3B1c2gnOiAwLFxuICAgICAgICAvKiogUmVtb3ZlcyB0aGUgZmlyc3QgaXRlbSBmcm9tIHRoZSBOb2RlTGlzdCBhbmQgcmV0dXJucyBpdC5cbiAgICAgICAgICAqIEBmb3IgTm9kZUxpc3RcbiAgICAgICAgICAqIEBtZXRob2Qgc2hpZnRcbiAgICAgICAgICAqIEByZXR1cm4ge05vZGUgfCBudWxsfSBUaGUgZmlyc3QgaXRlbSBpbiB0aGUgTm9kZUxpc3QsIG9yIG51bGwgaWYgdGhlIE5vZGVMaXN0IGlzIGVtcHR5LlxuICAgICAgICAgICovXG4gICAgICAgICdzaGlmdCc6IDAsXG4gICAgICAgIC8qKiBSZXR1cm5zIGEgbmV3IE5vZGVMaXN0IGNvbXByaXNpbmcgdGhlIE5vZGVzIGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICAgICAgICAqIEBmb3IgTm9kZUxpc3RcbiAgICAgICAgICAqIEBtZXRob2Qgc2xpY2VcbiAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiZWdpbiBaZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGJlZ2luIGV4dHJhY3Rpb24uXG4gICAgICAgICAgQXMgYSBuZWdhdGl2ZSBpbmRleCwgc3RhcnQgaW5kaWNhdGVzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLiBzbGljZSgtMikgZXh0cmFjdHMgdGhlIHNlY29uZC10by1sYXN0IGVsZW1lbnQgYW5kIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBaZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGVuZCBleHRyYWN0aW9uLiBzbGljZSBleHRyYWN0cyB1cCB0byBidXQgbm90IGluY2x1ZGluZyBlbmQuXG4gICAgICAgICAgc2xpY2UoMSw0KSBleHRyYWN0cyB0aGUgc2Vjb25kIGVsZW1lbnQgdGhyb3VnaCB0aGUgZm91cnRoIGVsZW1lbnQgKGVsZW1lbnRzIGluZGV4ZWQgMSwgMiwgYW5kIDMpLlxuICAgICAgICAgIEFzIGEgbmVnYXRpdmUgaW5kZXgsIGVuZCBpbmRpY2F0ZXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuIHNsaWNlKDIsLTEpIGV4dHJhY3RzIHRoZSB0aGlyZCBlbGVtZW50IHRocm91Z2ggdGhlIHNlY29uZC10by1sYXN0IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAgICAgIElmIGVuZCBpcyBvbWl0dGVkLCBzbGljZSBleHRyYWN0cyB0byB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAgICAqIEByZXR1cm4ge05vZGVMaXN0fSBBIG5ldyBOb2RlTGlzdCBjb21wcmlzZWQgb2YgdGhpcyBOb2RlTGlzdCBqb2luZWQgd2l0aCB0aGUgaW5wdXQuXG4gICAgICAgICAgKi9cbiAgICAgICAgJ3NsaWNlJzogMSxcbiAgICAgICAgLyoqIENoYW5nZXMgdGhlIGNvbnRlbnQgb2YgdGhlIE5vZGVMaXN0LCBhZGRpbmcgbmV3IGVsZW1lbnRzIHdoaWxlIHJlbW92aW5nIG9sZCBlbGVtZW50cy5cbiAgICAgICAgICAqIEBmb3IgTm9kZUxpc3RcbiAgICAgICAgICAqIEBtZXRob2Qgc3BsaWNlXG4gICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY2hhbmdpbmcgdGhlIGFycmF5LiBJZiBuZWdhdGl2ZSwgd2lsbCBiZWdpbiB0aGF0IG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgZW5kLlxuICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkgQW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2Ygb2xkIGFycmF5IGVsZW1lbnRzIHRvIHJlbW92ZS4gSWYgaG93TWFueSBpcyAwLCBubyBlbGVtZW50cyBhcmUgcmVtb3ZlZC4gSW4gdGhpcyBjYXNlLCB5b3Ugc2hvdWxkIHNwZWNpZnkgYXQgbGVhc3Qgb25lIG5ldyBlbGVtZW50LiBJZiBubyBob3dNYW55IHBhcmFtZXRlciBpcyBzcGVjaWZpZWQgKHNlY29uZCBzeW50YXggYWJvdmUsIHdoaWNoIGlzIGEgU3BpZGVyTW9ua2V5IGV4dGVuc2lvbiksIGFsbCBlbGVtZW50cyBhZnRlciBpbmRleCBhcmUgcmVtb3ZlZC5cbiAgICAgICAgICAqIHtOb2RlIHwgSFRNTEVsZW1lbnR8IGVsZW1lbnQxLCAuLi4sIGVsZW1lbnROXG4gICAgICAgICAgVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgYXJyYXkuIElmIHlvdSBkb24ndCBzcGVjaWZ5IGFueSBlbGVtZW50cywgc3BsaWNlIHNpbXBseSByZW1vdmVzIGVsZW1lbnRzIGZyb20gdGhlIGFycmF5LlxuICAgICAgICAgICogQHJldHVybiB7Tm9kZUxpc3R9IFRoZSBlbGVtZW50KHMpIHJlbW92ZWQuXG4gICAgICAgICAgKi9cbiAgICAgICAgJ3NwbGljZSc6IDEsXG4gICAgICAgIC8qKiBBZGRzIHRoZSBnaXZlbiBOb2RlKHMpIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIE5vZGVMaXN0LlxuICAgICAgICAgICogQGZvciBOb2RlTGlzdFxuICAgICAgICAgICogQG1ldGhvZCB1bnNoaWZ0XG4gICAgICAgICAgKiBAcGFyYW0ge05vZGUgfCBIVE1MRWxlbWVudH0gbm9kZXMgT25lIG9yIG1vcmUgbm9kZXMgdG8gYWRkIHRvIHRoZSBOb2RlTGlzdC5cbiAgICAgICAgICAqL1xuICAgICAgICAndW5zaGlmdCc6IDBcbiAgICB9O1xuXG5cblkuT2JqZWN0LmVhY2goQXJyYXlNZXRob2RzLCBmdW5jdGlvbihyZXR1cm5Ob2RlTGlzdCwgbmFtZSkge1xuICAgIFlfTm9kZUxpc3QucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgIHJldDtcblxuICAgICAgICB3aGlsZSAodHlwZW9mIChhcmcgPSBhcmd1bWVudHNbaSsrXSkgIT0gJ3VuZGVmaW5lZCcpIHsgLy8gdXNlIERPTSBub2Rlcy9ub2RlTGlzdHNcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmcuX25vZGUgfHwgYXJnLl9ub2RlcyB8fCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gQXJyYXlQcm90b1tuYW1lXS5hcHBseSh0aGlzLl9ub2RlcywgYXJncyk7XG5cbiAgICAgICAgaWYgKHJldHVybk5vZGVMaXN0KSB7XG4gICAgICAgICAgICByZXQgPSBZLmFsbChyZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gWS5Ob2RlLnNjcnViVmFsKHJldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59KTtcbi8qKlxuICogQG1vZHVsZSBub2RlXG4gKiBAc3VibW9kdWxlIG5vZGUtY29yZVxuICovXG5cblkuQXJyYXkuZWFjaChbXG4gICAgLyoqXG4gICAgICogUGFzc2VzIHRocm91Z2ggdG8gRE9NIG1ldGhvZC5cbiAgICAgKiBAZm9yIE5vZGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IE5vZGV9IG5vZGUgTm9kZSB0byBiZSByZW1vdmVkXG4gICAgICogQHJldHVybiB7Tm9kZX0gVGhlIHJlbW92ZWQgbm9kZVxuICAgICAqL1xuICAgICdyZW1vdmVDaGlsZCcsXG5cbiAgICAvKipcbiAgICAgKiBQYXNzZXMgdGhyb3VnaCB0byBET00gbWV0aG9kLlxuICAgICAqIEBtZXRob2QgaGFzQ2hpbGROb2Rlc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGhhcyBhbnkgY2hpbGROb2Rlc1xuICAgICAqL1xuICAgICdoYXNDaGlsZE5vZGVzJyxcblxuICAgIC8qKlxuICAgICAqIFBhc3NlcyB0aHJvdWdoIHRvIERPTSBtZXRob2QuXG4gICAgICogQG1ldGhvZCBjbG9uZU5vZGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgV2hldGhlciBvciBub3QgdG8gcGVyZm9ybSBhIGRlZXAgY2xvbmUsIHdoaWNoIGluY2x1ZGVzXG4gICAgICogc3VidHJlZSBhbmQgYXR0cmlidXRlc1xuICAgICAqIEByZXR1cm4ge05vZGV9IFRoZSBjbG9uZVxuICAgICAqL1xuICAgICdjbG9uZU5vZGUnLFxuXG4gICAgLyoqXG4gICAgICogUGFzc2VzIHRocm91Z2ggdG8gRE9NIG1ldGhvZC5cbiAgICAgKiBAbWV0aG9kIGhhc0F0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGUgVGhlIGF0dHJpYnV0ZSB0byB0ZXN0IGZvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhdHRyaWJ1dGUgaXMgcHJlc2VudFxuICAgICAqL1xuICAgICdoYXNBdHRyaWJ1dGUnLFxuXG4gICAgLyoqXG4gICAgICogUGFzc2VzIHRocm91Z2ggdG8gRE9NIG1ldGhvZC5cbiAgICAgKiBAbWV0aG9kIHNjcm9sbEludG9WaWV3XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgICdzY3JvbGxJbnRvVmlldycsXG5cbiAgICAvKipcbiAgICAgKiBQYXNzZXMgdGhyb3VnaCB0byBET00gbWV0aG9kLlxuICAgICAqIEBtZXRob2QgZ2V0RWxlbWVudHNCeVRhZ05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZSBUaGUgdGFnTmFtZSB0byBjb2xsZWN0XG4gICAgICogQHJldHVybiB7Tm9kZUxpc3R9IEEgTm9kZUxpc3QgcmVwcmVzZW50aW5nIHRoZSBIVE1MQ29sbGVjdGlvblxuICAgICAqL1xuICAgICdnZXRFbGVtZW50c0J5VGFnTmFtZScsXG5cbiAgICAvKipcbiAgICAgKiBQYXNzZXMgdGhyb3VnaCB0byBET00gbWV0aG9kLlxuICAgICAqIEBtZXRob2QgZm9jdXNcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgJ2ZvY3VzJyxcblxuICAgIC8qKlxuICAgICAqIFBhc3NlcyB0aHJvdWdoIHRvIERPTSBtZXRob2QuXG4gICAgICogQG1ldGhvZCBibHVyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgICdibHVyJyxcblxuICAgIC8qKlxuICAgICAqIFBhc3NlcyB0aHJvdWdoIHRvIERPTSBtZXRob2QuXG4gICAgICogT25seSB2YWxpZCBvbiBGT1JNIGVsZW1lbnRzXG4gICAgICogQG1ldGhvZCBzdWJtaXRcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgJ3N1Ym1pdCcsXG5cbiAgICAvKipcbiAgICAgKiBQYXNzZXMgdGhyb3VnaCB0byBET00gbWV0aG9kLlxuICAgICAqIE9ubHkgdmFsaWQgb24gRk9STSBlbGVtZW50c1xuICAgICAqIEBtZXRob2QgcmVzZXRcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgJ3Jlc2V0JyxcblxuICAgIC8qKlxuICAgICAqIFBhc3NlcyB0aHJvdWdoIHRvIERPTSBtZXRob2QuXG4gICAgICogQG1ldGhvZCBzZWxlY3RcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgICdzZWxlY3QnLFxuXG4gICAgLyoqXG4gICAgICogUGFzc2VzIHRocm91Z2ggdG8gRE9NIG1ldGhvZC5cbiAgICAgKiBPbmx5IHZhbGlkIG9uIFRBQkxFIGVsZW1lbnRzXG4gICAgICogQG1ldGhvZCBjcmVhdGVDYXB0aW9uXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgICdjcmVhdGVDYXB0aW9uJ1xuXG5dLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBZLk5vZGUucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmludm9rZShtZXRob2QsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59KTtcblxuLyoqXG4gKiBQYXNzZXMgdGhyb3VnaCB0byBET00gbWV0aG9kLlxuICogQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGUgVGhlIGF0dHJpYnV0ZSB0byBiZSByZW1vdmVkXG4gKiBAY2hhaW5hYmxlXG4gKi9cbiAvLyBvbmUtb2ZmIGltcGxlbWVudGF0aW9uIGR1ZSB0byBJRSByZXR1cm5pbmcgYm9vbGVhbiwgYnJlYWtpbmcgY2hhaW5pbmdcblkuTm9kZS5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xuICAgIHZhciBub2RlID0gdGhpcy5fbm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyLCAwKTsgLy8gY29tbWEgemVybyBmb3IgSUUgPCA4IHRvIGZvcmNlIGNhc2UtaW5zZW5zaXRpdmVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblkuTm9kZS5pbXBvcnRNZXRob2QoWS5ET00sIFtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgaXMgYW4gYW5jZXN0b3Igb2YgYW5vdGhlciBIVE1MIGVsZW1lbnQgaW4gdGhlIERPTSBoaWVyYXJjaHkuXG4gICAgICogQG1ldGhvZCBjb250YWluc1xuICAgICAqIEBwYXJhbSB7Tm9kZSB8IEhUTUxFbGVtZW50fSBuZWVkbGUgVGhlIHBvc3NpYmxlIG5vZGUgb3IgZGVzY2VuZGVudFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBpcyB0aGUgbmVlZGxlIGl0cyBhbmNlc3RvclxuICAgICAqL1xuICAgICdjb250YWlucycsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHNldHRpbmcgYXR0cmlidXRlcyBvbiBET00gbm9kZXMsIG5vcm1hbGl6aW5nIGluIHNvbWUgY2FzZXMuXG4gICAgICogVGhpcyBwYXNzZXMgdGhyb3VnaCB0byB0aGUgRE9NIG5vZGUsIGFsbG93aW5nIGZvciBjdXN0b20gYXR0cmlidXRlcy5cbiAgICAgKiBAbWV0aG9kIHNldEF0dHJpYnV0ZVxuICAgICAqIEBmb3IgTm9kZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqL1xuICAgICdzZXRBdHRyaWJ1dGUnLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyBnZXR0aW5nIGF0dHJpYnV0ZXMgb24gRE9NIG5vZGVzLCBub3JtYWxpemluZyBpbiBzb21lIGNhc2VzLlxuICAgICAqIFRoaXMgcGFzc2VzIHRocm91Z2ggdG8gdGhlIERPTSBub2RlLCBhbGxvd2luZyBmb3IgY3VzdG9tIGF0dHJpYnV0ZXMuXG4gICAgICogQG1ldGhvZCBnZXRBdHRyaWJ1dGVcbiAgICAgKiBAZm9yIE5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKi9cbiAgICAnZ2V0QXR0cmlidXRlJyxcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIHRoZSBnaXZlbiBIVE1MIGFyb3VuZCB0aGUgbm9kZS5cbiAgICAgKiBAbWV0aG9kIHdyYXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBUaGUgbWFya3VwIHRvIHdyYXAgYXJvdW5kIHRoZSBub2RlLlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAZm9yIE5vZGVcbiAgICAgKi9cbiAgICAnd3JhcCcsXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUuXG4gICAgICogQG1ldGhvZCB1bndyYXBcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgJ3Vud3JhcCcsXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgdW5pcXVlIElEIHRvIHRoZSBub2RlIGlmIG5vbmUgZXhpc3RzXG4gICAgICogQG1ldGhvZCBnZW5lcmF0ZUlEXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgZXhpc3Rpbmcgb3IgZ2VuZXJhdGVkIElEXG4gICAgICovXG4gICAgJ2dlbmVyYXRlSUQnXG5dKTtcblxuWS5Ob2RlTGlzdC5pbXBvcnRNZXRob2QoWS5Ob2RlLnByb3RvdHlwZSwgW1xuLyoqXG4gKiBBbGxvd3MgZ2V0dGluZyBhdHRyaWJ1dGVzIG9uIERPTSBub2Rlcywgbm9ybWFsaXppbmcgaW4gc29tZSBjYXNlcy5cbiAqIFRoaXMgcGFzc2VzIHRocm91Z2ggdG8gdGhlIERPTSBub2RlLCBhbGxvd2luZyBmb3IgY3VzdG9tIGF0dHJpYnV0ZXMuXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0ZVxuICogQHNlZSBOb2RlXG4gKiBAZm9yIE5vZGVMaXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlIG5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGF0dHJpYnV0ZSB2YWx1ZVxuICovXG5cbiAgICAnZ2V0QXR0cmlidXRlJyxcbi8qKlxuICogQWxsb3dzIHNldHRpbmcgYXR0cmlidXRlcyBvbiBET00gbm9kZXMsIG5vcm1hbGl6aW5nIGluIHNvbWUgY2FzZXMuXG4gKiBUaGlzIHBhc3NlcyB0aHJvdWdoIHRvIHRoZSBET00gbm9kZSwgYWxsb3dpbmcgZm9yIGN1c3RvbSBhdHRyaWJ1dGVzLlxuICogQG1ldGhvZCBzZXRBdHRyaWJ1dGVcbiAqIEBzZWUgTm9kZVxuICogQGZvciBOb2RlTGlzdFxuICogQGNoYWluYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICovXG4gICAgJ3NldEF0dHJpYnV0ZScsXG5cbi8qKlxuICogQWxsb3dzIGZvciByZW1vdmluZyBhdHRyaWJ1dGVzIG9uIERPTSBub2Rlcy5cbiAqIFRoaXMgcGFzc2VzIHRocm91Z2ggdG8gdGhlIERPTSBub2RlLCBhbGxvd2luZyBmb3IgY3VzdG9tIGF0dHJpYnV0ZXMuXG4gKiBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0ZVxuICogQHNlZSBOb2RlXG4gKiBAZm9yIE5vZGVMaXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlIHRvIHJlbW92ZVxuICovXG4gICAgJ3JlbW92ZUF0dHJpYnV0ZScsXG4vKipcbiAqIFJlbW92ZXMgdGhlIHBhcmVudCBub2RlIGZyb20gbm9kZSBpbiB0aGUgbGlzdC5cbiAqIEBtZXRob2QgdW53cmFwXG4gKiBAY2hhaW5hYmxlXG4gKi9cbiAgICAndW53cmFwJyxcbi8qKlxuICogV3JhcHMgdGhlIGdpdmVuIEhUTUwgYXJvdW5kIGVhY2ggbm9kZS5cbiAqIEBtZXRob2Qgd3JhcFxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgVGhlIG1hcmt1cCB0byB3cmFwIGFyb3VuZCB0aGUgbm9kZS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuICAgICd3cmFwJyxcblxuLyoqXG4gKiBBcHBsaWVzIGEgdW5pcXVlIElEIHRvIGVhY2ggbm9kZSBpZiBub25lIGV4aXN0c1xuICogQG1ldGhvZCBnZW5lcmF0ZUlEXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBleGlzdGluZyBvciBnZW5lcmF0ZWQgSURcbiAqL1xuICAgICdnZW5lcmF0ZUlEJ1xuXSk7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImRvbS1jb3JlXCIsIFwic2VsZWN0b3JcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnbm9kZS1ldmVudC1kZWxlZ2F0ZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogRnVuY3Rpb25hbGl0eSB0byBtYWtlIHRoZSBub2RlIGEgZGVsZWdhdGVkIGV2ZW50IGNvbnRhaW5lclxuICogQG1vZHVsZSBub2RlXG4gKiBAc3VibW9kdWxlIG5vZGUtZXZlbnQtZGVsZWdhdGVcbiAqL1xuXG4vKipcbiAqIDxwPlNldHMgdXAgYSBkZWxlZ2F0aW9uIGxpc3RlbmVyIGZvciBhbiBldmVudCBvY2N1cnJpbmcgaW5zaWRlIHRoZSBOb2RlLlxuICogVGhlIGRlbGVnYXRlZCBldmVudCB3aWxsIGJlIHZlcmlmaWVkIGFnYWluc3QgYSBzdXBwbGllZCBzZWxlY3RvciBvclxuICogZmlsdGVyaW5nIGZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGV2ZW50IHJlZmVyZW5jZXMgYXQgbGVhc3Qgb25lIG5vZGUgdGhhdFxuICogc2hvdWxkIHRyaWdnZXIgdGhlIHN1YnNjcmlwdGlvbiBjYWxsYmFjay48L3A+XG4gKlxuICogPHA+U2VsZWN0b3Igc3RyaW5nIGZpbHRlcnMgd2lsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjayBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlZFxuICogZnJvbSBhIG5vZGUgdGhhdCBtYXRjaGVzIGl0IG9yIGlzIGNvbnRhaW5lZCBpbiBhIG5vZGUgdGhhdCBtYXRjaGVzIGl0LlxuICogRnVuY3Rpb24gZmlsdGVycyBhcmUgY2FsbGVkIGZvciBlYWNoIE5vZGUgdXAgdGhlIHBhcmVudCBheGlzIHRvIHRoZVxuICogc3Vic2NyaWJpbmcgY29udGFpbmVyIG5vZGUsIGFuZCByZWNlaXZlIGF0IGVhY2ggbGV2ZWwgdGhlIE5vZGUgYW5kIHRoZSBldmVudFxuICogb2JqZWN0LiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdHJ1ZSAob3IgYSB0cnV0aHkgdmFsdWUpIGlmIHRoYXQgTm9kZVxuICogc2hvdWxkIHRyaWdnZXIgdGhlIHN1YnNjcmlwdGlvbiBjYWxsYmFjay4gIE5vdGUsIGl0IGlzIHBvc3NpYmxlIGZvciBmaWx0ZXJzXG4gKiB0byBtYXRjaCBtdWx0aXBsZSBOb2RlcyBmb3IgYSBzaW5nbGUgZXZlbnQuICBJbiB0aGlzIGNhc2UsIHRoZSBkZWxlZ2F0ZVxuICogY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCBtYXRjaGluZyBOb2RlLjwvcD5cbiAqXG4gKiA8cD5Gb3IgZWFjaCBtYXRjaGluZyBOb2RlLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCB3aXRoIGl0cyAndGhpcydcbiAqIG9iamVjdCBzZXQgdG8gdGhlIE5vZGUgbWF0Y2hlZCBieSB0aGUgZmlsdGVyICh1bmxlc3MgYSBzcGVjaWZpYyBjb250ZXh0IHdhc1xuICogcHJvdmlkZWQgZHVyaW5nIHN1YnNjcmlwdGlvbiksIGFuZCB0aGUgcHJvdmlkZWQgZXZlbnQnc1xuICogPGNvZGU+Y3VycmVudFRhcmdldDwvY29kZT4gd2lsbCBhbHNvIGJlIHNldCB0byB0aGUgbWF0Y2hpbmcgTm9kZS4gIFRoZVxuICogY29udGFpbmluZyBOb2RlIGZyb20gd2hpY2ggdGhlIHN1YnNjcmlwdGlvbiB3YXMgb3JpZ2luYWxseSBtYWRlIGNhbiBiZVxuICogcmVmZXJlbmNlZCBhcyA8Y29kZT5lLmNvbnRhaW5lcjwvY29kZT4uXG4gKlxuICogQG1ldGhvZCBkZWxlZ2F0ZVxuICogQHBhcmFtIHR5cGUge1N0cmluZ30gdGhlIGV2ZW50IHR5cGUgdG8gZGVsZWdhdGVcbiAqIEBwYXJhbSBmbiB7RnVuY3Rpb259IHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlLiAgVGhpcyBmdW5jdGlvblxuICogICAgICAgICAgICAgIHdpbGwgYmUgcHJvdmlkZWQgdGhlIGV2ZW50IG9iamVjdCBmb3IgdGhlIGRlbGVnYXRlZCBldmVudC5cbiAqIEBwYXJhbSBzcGVjIHtTdHJpbmd8RnVuY3Rpb259IGEgc2VsZWN0b3IgdGhhdCBtdXN0IG1hdGNoIHRoZSB0YXJnZXQgb2YgdGhlXG4gKiAgICAgICAgICAgICAgZXZlbnQgb3IgYSBmdW5jdGlvbiB0byB0ZXN0IHRhcmdldCBhbmQgaXRzIHBhcmVudHMgZm9yIGEgbWF0Y2hcbiAqIEBwYXJhbSBjb250ZXh0IHtPYmplY3R9IG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgc3BlY2lmaWVzIHdoYXQgJ3RoaXMnIHJlZmVycyB0by5cbiAqIEBwYXJhbSBhcmdzKiB7YW55fSAwLi5uIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3Mgb24gdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgIFRoZXNlIGFyZ3VtZW50cyB3aWxsIGJlIGFkZGVkIGFmdGVyIHRoZSBldmVudCBvYmplY3QuXG4gKiBAcmV0dXJuIHtFdmVudEhhbmRsZX0gdGhlIGRldGFjaCBoYW5kbGVcbiAqIEBmb3IgTm9kZVxuICovXG5ZLk5vZGUucHJvdG90eXBlLmRlbGVnYXRlID0gZnVuY3Rpb24odHlwZSkge1xuXG4gICAgdmFyIGFyZ3MgPSBZLkFycmF5KGFyZ3VtZW50cywgMCwgdHJ1ZSksXG4gICAgICAgIGluZGV4ID0gKFkuTGFuZy5pc09iamVjdCh0eXBlKSAmJiAhWS5MYW5nLmlzQXJyYXkodHlwZSkpID8gMSA6IDI7XG5cbiAgICBhcmdzLnNwbGljZShpbmRleCwgMCwgdGhpcy5fbm9kZSk7XG5cbiAgICByZXR1cm4gWS5kZWxlZ2F0ZS5hcHBseShZLCBhcmdzKTtcbn07XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcIm5vZGUtYmFzZVwiLCBcImV2ZW50LWRlbGVnYXRlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ25vZGUtZXZlbnQtc2ltdWxhdGUnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIEFkZHMgZnVuY3Rpb25hbGl0eSB0byBzaW11bGF0ZSBldmVudHMuXG4gKiBAbW9kdWxlIG5vZGVcbiAqIEBzdWJtb2R1bGUgbm9kZS1ldmVudC1zaW11bGF0ZVxuICovXG5cbi8qKlxuICogU2ltdWxhdGVzIGFuIGV2ZW50IG9uIHRoZSBub2RlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgKGkuZS4sIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAoT3B0aW9uYWwpIEV4dHJhIG9wdGlvbnMgdG8gY29weSBvbnRvIHRoZSBldmVudCBvYmplY3QuXG4gKiBAZm9yIE5vZGVcbiAqIEBtZXRob2Qgc2ltdWxhdGVcbiAqL1xuWS5Ob2RlLnByb3RvdHlwZS5zaW11bGF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBvcHRpb25zKSB7XG5cbiAgICBZLkV2ZW50LnNpbXVsYXRlKFkuTm9kZS5nZXRET01Ob2RlKHRoaXMpLCB0eXBlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSBoaWdoZXIgdXNlciBsZXZlbCBnZXN0dXJlIG9mIHRoZSBnaXZlbiBuYW1lIG9uIHRoaXMgbm9kZS5cbiAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBhIHNldCBvZiBsb3cgbGV2ZWwgdG91Y2ggZXZlbnRzKEFwcGxlIHNwZWNpZmljIGdlc3R1cmVcbiAqIGV2ZW50cyBhcyB3ZWxsIGZvciB0aGUgaU9TIHBsYXRmb3JtcykgYXN5bmNocm9ub3VzbHkuIE5vdGUgdGhhdCBnZXN0dXJlXG4gKiBzaW11bGF0aW9uIGlzIHJlbHlpbmcgb24gYFkuRXZlbnQuc2ltdWxhdGUoKWAgbWV0aG9kIHRvIGdlbmVyYXRlXG4gKiB0aGUgdG91Y2ggZXZlbnRzIHVuZGVyIHRoZSBob29kLiBUaGUgYFkuRXZlbnQuc2ltdWxhdGUoKWAgbWV0aG9kXG4gKiBpdHNlbGYgaXMgYSBzeW5jaHJvbm91cyBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIGdlc3R1cmVzIGFyZSBgdGFwYCwgYGRvdWJsZXRhcGAsIGBwcmVzc2AsIGBtb3ZlYCwgYGZsaWNrYCwgYHBpbmNoYFxuICogYW5kIGByb3RhdGVgLlxuICpcbiAqIFRoZSBgcGluY2hgIGdlc3R1cmUgaXMgdXNlZCB0byBzaW11bGF0ZSB0aGUgcGluY2hpbmcgYW5kIHNwcmVhZGluZyBvZiB0d29cbiAqIGZpbmdlcnMuIER1cmluZyBhIHBpbmNoIHNpbXVsYXRpb24sIHJvdGF0aW9uIGlzIGFsc28gcG9zc2libGUuIEVzc2VudGlhbGx5XG4gKiBgcGluY2hgIGFuZCBgcm90YXRlYCBzaW11bGF0aW9ucyBzaGFyZSB0aGUgc2FtZSBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGFsbG93XG4gKiBib3RoIHBpbmNoaW5nIGFuZCByb3RhdGlvbiBhdCB0aGUgc2FtZSB0aW1lLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIGBwaW5jaGBcbiAqIHJlcXVpcmVzIGBzdGFydGAgYW5kIGBlbmRgIG9wdGlvbiBwcm9wZXJ0aWVzIHdoaWxlIGByb3RhdGVgIHJlcXVpcmVzIGByb3RhdGlvbmBcbiAqIG9wdGlvbiBwcm9wZXJ0eS5cbiAqXG4gKiBUaGUgYHBpbmNoYCBhbmQgYHJvdGF0ZWAgZ2VzdHVyZXMgY2FuIGJlIGRlc2NyaWJlZCBhcyBwbGFjaW5nIDIgZmluZ2VycyBhbG9uZyBhXG4gKiBjaXJjbGUuIFBpbmNoaW5nIGFuZCBzcHJlYWRpbmcgY2FuIGJlIGRlc2NyaWJlZCBieSBzdGFydCBhbmQgZW5kIGNpcmNsZXMgd2hpbGVcbiAqIHJvdGF0aW9uIG9jY3VycyBvbiBhIHNpbmdsZSBjaXJjbGUuIElmIHRoZSByYWRpdXMgb2YgdGhlIHN0YXJ0IGNpcmNsZSBpcyBncmVhdGVyXG4gKiB0aGFuIHRoZSBlbmQgY2lyY2xlLCB0aGUgZ2VzdHVyZSBiZWNvbWVzIGEgcGluY2gsIG90aGVyd2lzZSBpdCBpcyBhIHNwcmVhZCBzcHJlYWQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIG5vZGUgPSBZLm9uZShcIiN0YXJnZXRcIik7XG4gKlxuICogICAgIC8vIGRvdWJsZSB0YXAgZXhhbXBsZVxuICogICAgIG5vZGUuc2ltdWxhdGVHZXN0dXJlKFwiZG91YmxldGFwXCIsIGZ1bmN0aW9uKCkge1xuICogICAgICAgICAvLyBteSBjYWxsYmFjayBmdW5jdGlvblxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBmbGljayBleGFtcGxlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgbm9kZSwgbW92ZSA1MCBwaXhlbHMgZG93biBmb3IgNTBtcylcbiAqICAgICBub2RlLnNpbXVsYXRlR2VzdHVyZShcImZsaWNrXCIsIHtcbiAqICAgICAgICAgYXhpczogeSxcbiAqICAgICAgICAgZGlzdGFuY2U6IC0xMDBcbiAqICAgICAgICAgZHVyYXRpb246IDUwXG4gKiAgICAgfSwgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIC8vIG15IGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIHNpbXVsYXRlIHJvdGF0aW5nIGEgbm9kZSA3NSBkZWdyZWVzIGNvdW50ZXItY2xvY2t3aXNlXG4gKiAgICAgbm9kZS5zaW11bGF0ZUdlc3R1cmUoXCJyb3RhdGVcIiwge1xuICogICAgICAgICByb3RhdGlvbjogLTc1XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIHNpbXVsYXRlIGEgcGluY2ggYW5kIGEgcm90YXRpb24gYXQgdGhlIHNhbWUgdGltZS5cbiAqICAgICAvLyBmaW5nZXJzIHN0YXJ0IG9uIGEgY2lyY2xlIG9mIHJhZGl1cyAxMDAgcHgsIHBsYWNlZCBhdCB0b3AvYm90dG9tXG4gKiAgICAgLy8gZmluZ2VycyBlbmQgb24gYSBjaXJjbGUgb2YgcmFkaXVzIDUwcHgsIHBsYWNlZCBhdCByaWdodC9sZWZ0XG4gKiAgICAgbm9kZS5zaW11bGF0ZUdlc3R1cmUoXCJwaW5jaFwiLCB7XG4gKiAgICAgICAgIHIxOiAxMDAsXG4gKiAgICAgICAgIHIyOiA1MCxcbiAqICAgICAgICAgc3RhcnQ6IDBcbiAqICAgICAgICAgcm90YXRpb246IDkwXG4gKiAgICAgfSk7XG4gKlxuICogQG1ldGhvZCBzaW11bGF0ZUdlc3R1cmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzdXBwb3J0ZWQgZ2VzdHVyZSB0byBzaW11bGF0ZS4gVGhlXG4gKiAgICAgIHN1cHBvcnRlZCBnZXN0dXJlIG5hbWUgaXMgb25lIG9mIFwidGFwXCIsIFwiZG91YmxldGFwXCIsIFwicHJlc3NcIiwgXCJtb3ZlXCIsXG4gKiAgICAgIFwiZmxpY2tcIiwgXCJwaW5jaFwiIGFuZCBcInJvdGF0ZVwiLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBFeHRyYSBvcHRpb25zIHVzZWQgdG8gZGVmaW5lIHRoZSBnZXN0dXJlIGJlaGF2aW9yOlxuICpcbiAqICAgICAgVmFsaWQgb3B0aW9ucyBwcm9wZXJ0aWVzIGZvciB0aGUgYHRhcGAgZ2VzdHVyZTpcbiAqXG4gKiAgICAgIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBvaW50XSAoT3B0aW9uYWwpIEluZGljYXRlcyB0aGUgW3gseV0gY29vcmRpbmF0ZXNcbiAqICAgICAgICB3aGVyZSB0aGUgdGFwIHNob3VsZCBiZSBzaW11bGF0ZWQuIERlZmF1bHQgaXMgdGhlIGNlbnRlciBvZiB0aGUgbm9kZVxuICogICAgICAgIGVsZW1lbnQuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ob2xkPTEwXSAoT3B0aW9uYWwpIFRoZSBob2xkIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgIFRoaXMgaXMgdGhlIHRpbWUgYmV0d2VlbiBgdG91Y2hzdGFydGAgYW5kIGB0b3VjaGVuZGAgZXZlbnQgZ2VuZXJhdGlvbi5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbWVzPTFdIChPcHRpb25hbCkgSW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgdGFwcy5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbGF5PTEwXSAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gKiAgICAgICAgYmVmb3JlIHRoZSBuZXh0IHRhcCBzaW11bGF0aW9uIGhhcHBlbnMuIFRoaXMgaXMgdmFsaWQgb25seSB3aGVuIGB0aW1lc2BcbiAqICAgICAgICBpcyBtb3JlIHRoYW4gMS5cbiAqXG4gKiAgICAgIFZhbGlkIG9wdGlvbnMgcHJvcGVydGllcyBmb3IgdGhlIGBkb3VibGV0YXBgIGdlc3R1cmU6XG4gKlxuICogICAgICBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5wb2ludF0gKE9wdGlvbmFsKSBJbmRpY2F0ZXMgdGhlIFt4LHldIGNvb3JkaW5hdGVzXG4gKiAgICAgICAgd2hlcmUgdGhlIGRvdWJsZXRhcCBzaG91bGQgYmUgc2ltdWxhdGVkLiBEZWZhdWx0IGlzIHRoZSBjZW50ZXIgb2YgdGhlXG4gKiAgICAgICAgbm9kZSBlbGVtZW50LlxuICpcbiAqICAgICAgVmFsaWQgb3B0aW9ucyBwcm9wZXJ0aWVzIGZvciB0aGUgYHByZXNzYCBnZXN0dXJlOlxuICpcbiAqICAgICAgQHBhcmFtIHtBcnJheX0gW29wdGlvbnMucG9pbnRdIChPcHRpb25hbCkgSW5kaWNhdGVzIHRoZSBbeCx5XSBjb29yZGluYXRlc1xuICogICAgICAgIHdoZXJlIHRoZSBwcmVzcyBzaG91bGQgYmUgc2ltdWxhdGVkLiBEZWZhdWx0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIG5vZGVcbiAqICAgICAgICBlbGVtZW50LlxuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaG9sZD0zMDAwXSAoT3B0aW9uYWwpIFRoZSBob2xkIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgIFRoaXMgaXMgdGhlIHRpbWUgYmV0d2VlbiBgdG91Y2hzdGFydGAgYW5kIGB0b3VjaGVuZGAgZXZlbnQgZ2VuZXJhdGlvbi5cbiAqICAgICAgICBEZWZhdWx0IGlzIDMwMDBtcyAoMyBzZWNvbmRzKS5cbiAqXG4gKiAgICAgIFZhbGlkIG9wdGlvbnMgcHJvcGVydGllcyBmb3IgdGhlIGBtb3ZlYCBnZXN0dXJlOlxuICpcbiAqICAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBhdGhdIChPcHRpb25hbCkgSW5kaWNhdGVzIHRoZSBwYXRoIG9mIHRoZSBmaW5nZXJcbiAqICAgICAgICBtb3ZlbWVudC4gSXQncyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBvcHRpb25hbCBwcm9wZXJ0aWVzOiBgcG9pbnRgLFxuICogICAgICAgIGB4ZGlzdGAgYW5kICBgeWRpc3RgLlxuICogICAgICAgIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBhdGgucG9pbnRdIEEgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGdlc3R1cmUuXG4gKiAgICAgICAgICBEZWZhdWx0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIG5vZGUgZWxlbWVudC5cbiAqICAgICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGF0aC54ZGlzdD0yMDBdIEEgZGlzdGFuY2UgdG8gbW92ZSBpbiBwaXhlbHNcbiAqICAgICAgICAgIGFsb25nIHRoZSBYIGF4aXMuIEEgbmVnYXRpdmUgZGlzdGFuY2UgdmFsdWUgaW5kaWNhdGVzIG1vdmluZyBsZWZ0LlxuICogICAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYXRoLnlkaXN0PTBdIEEgZGlzdGFuY2UgdG8gbW92ZSBpbiBwaXhlbHNcbiAqICAgICAgICAgIGFsb25nIHRoZSBZIGF4aXMuIEEgbmVnYXRpdmUgZGlzdGFuY2UgdmFsdWUgaW5kaWNhdGVzIG1vdmluZyB1cC5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTEwMDBdIChPcHRpb25hbCkgVGhlIGR1cmF0aW9uIG9mIHRoZVxuICogICAgICAgIGdlc3R1cmUgaW4gbWlsbGlzZWNvbmRzLlxuICpcbiAqICAgICAgVmFsaWQgb3B0aW9ucyBwcm9wZXJ0aWVzIGZvciB0aGUgYGZsaWNrYCBnZXN0dXJlOlxuICpcbiAqICAgICAgQHBhcmFtIHtBcnJheX0gW29wdGlvbnMucG9pbnRdIChPcHRpb25hbCkgSW5kaWNhdGVzIHRoZSBbeCwgeV0gY29vcmRpbmF0ZXNcbiAqICAgICAgICB3aGVyZSB0aGUgZmxpY2sgc2hvdWxkIGJlIHNpbXVsYXRlZC4gRGVmYXVsdCBpcyB0aGUgY2VudGVyIG9mIHRoZVxuICogICAgICAgIG5vZGUgZWxlbWVudC5cbiAqICAgICAgQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmF4aXM9J3gnXSAoT3B0aW9uYWwpIFZhbGlkIHZhbHVlcyBhcmUgZWl0aGVyXG4gKiAgICAgICAgXCJ4XCIgb3IgXCJ5XCIuIEluZGljYXRlcyBheGlzIHRvIG1vdmUgYWxvbmcuIFRoZSBmbGljayBjYW4gbW92ZSB0byBvbmUgb2ZcbiAqICAgICAgICA0IGRpcmVjdGlvbnMobGVmdCwgcmlnaHQsIHVwIGFuZCBkb3duKS5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlPTIwMF0gKE9wdGlvbmFsKSBEaXN0YW5jZSB0byBtb3ZlIGluIHBpeGVsc1xuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb249MTAwMF0gKE9wdGlvbmFsKSBUaGUgZHVyYXRpb24gb2YgdGhlXG4gKiAgICAgICAgZ2VzdHVyZSBpbiBtaWxsaXNlY29uZHMuIFVzZXIgZ2l2ZW4gdmFsdWUgY291bGQgYmUgYXV0b21hdGljYWxseVxuICogICAgICAgIGFkanVzdGVkIGJ5IHRoZSBmcmFtZXdvcmsgaWYgaXQgaXMgYmVsb3cgdGhlIG1pbmltdW0gdmVsb2NpdHkgdG8gYmVcbiAqICAgICAgICBhIGZsaWNrIGdlc3R1cmUuXG4gKlxuICogICAgICBWYWxpZCBvcHRpb25zIHByb3BlcnRpZXMgZm9yIHRoZSBgcGluY2hgIGdlc3R1cmU6XG4gKlxuICogICAgICBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jZW50ZXJdIChPcHRpb25hbCkgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIHdoZXJlXG4gKiAgICAgICAgdHdvIGZpbmdlcnMgYXJlIHBsYWNlZC4gRGVmYXVsdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBub2RlIGVsZW1lbnQuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yMV0gKFJlcXVpcmVkKSBQaXhlbCByYWRpdXMgb2YgdGhlIHN0YXJ0IGNpcmNsZVxuICogICAgICAgIHdoZXJlIDIgZmluZ2VycyB3aWxsIGJlIG9uIHdoZW4gdGhlIGdlc3R1cmUgc3RhcnRzLiBUaGUgY2lyY2xlcyBhcmVcbiAqICAgICAgICBjZW50ZXJlZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50LlxuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucjJdIChSZXF1aXJlZCkgUGl4ZWwgcmFkaXVzIG9mIHRoZSBlbmQgY2lyY2xlXG4gKiAgICAgICAgd2hlbiB0aGlzIGdlc3R1cmUgZW5kcy5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTEwMDBdIChPcHRpb25hbCkgVGhlIGR1cmF0aW9uIG9mIHRoZVxuICogICAgICAgIGdlc3R1cmUgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhcnQ9MF0gKE9wdGlvbmFsKSBTdGFydGluZyBkZWdyZWUgb2YgdGhlIGZpcnN0XG4gKiAgICAgICAgZmluZ2VyLiBUaGUgdmFsdWUgaXMgcmVsYXRpdmUgdG8gdGhlIHBhdGggb2YgdGhlIG5vcnRoLiBEZWZhdWx0IGlzIDBcbiAqICAgICAgICAoaS5lLiwgMTI6MDAgb24gYSBjbG9jaykuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yb3RhdGlvbj0wXSAoT3B0aW9uYWwpIERlZ3JlZXMgdG8gcm90YXRlIGZyb21cbiAqICAgICAgICB0aGUgc3RhcnRpbmcgZGVncmVlLiBBIG5lZ2F0aXZlIHZhbHVlIG1lYW5zIHJvdGF0aW9uIHRvIHRoZVxuICogICAgICAgIGNvdW50ZXItY2xvY2t3aXNlIGRpcmVjdGlvbi5cbiAqXG4gKiAgICAgIFZhbGlkIG9wdGlvbnMgcHJvcGVydGllcyBmb3IgdGhlIGByb3RhdGVgIGdlc3R1cmU6XG4gKlxuICogICAgICBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jZW50ZXJdIChPcHRpb25hbCkgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIHdoZXJlXG4gKiAgICAgICAgdHdvIGZpbmdlcnMgYXJlIHBsYWNlZC4gRGVmYXVsdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBub2RlIGVsZW1lbnQuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yMV0gKE9wdGlvbmFsKSBQaXhlbCByYWRpdXMgb2YgdGhlIHN0YXJ0IGNpcmNsZVxuICogICAgICAgIHdoZXJlIDIgZmluZ2VycyB3aWxsIGJlIG9uIHdoZW4gdGhlIGdlc3R1cmUgc3RhcnRzLiBUaGUgY2lyY2xlcyBhcmVcbiAqICAgICAgICBjZW50ZXJlZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50LiBEZWZhdWx0IGlzIGEgZm91cnRoIG9mIHRoZSBub2RlXG4gKiAgICAgICAgZWxlbWVudCB3aWR0aCBvciBoZWlnaHQsIHdoaWNoZXZlciBpcyBzbWFsbGVyLlxuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucjJdIChPcHRpb25hbCkgUGl4ZWwgcmFkaXVzIG9mIHRoZSBlbmQgY2lyY2xlXG4gKiAgICAgICAgd2hlbiB0aGlzIGdlc3R1cmUgZW5kcy4gRGVmYXVsdCBpcyBhIGZvdXJ0aCBvZiB0aGUgbm9kZSBlbGVtZW50IHdpZHRoIG9yXG4gKiAgICAgICAgaGVpZ2h0LCB3aGljaGV2ZXIgaXMgc21hbGxlci5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTEwMDBdIChPcHRpb25hbCkgVGhlIGR1cmF0aW9uIG9mIHRoZVxuICogICAgICAgIGdlc3R1cmUgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhcnQ9MF0gKE9wdGlvbmFsKSBTdGFydGluZyBkZWdyZWUgb2YgdGhlIGZpcnN0XG4gKiAgICAgICAgZmluZ2VyLiBUaGUgdmFsdWUgaXMgcmVsYXRpdmUgdG8gdGhlIHBhdGggb2YgdGhlIG5vcnRoLiBEZWZhdWx0IGlzIDBcbiAqICAgICAgICAoaS5lLiwgMTI6MDAgb24gYSBjbG9jaykuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yb3RhdGlvbl0gKFJlcXVpcmVkKSBEZWdyZWVzIHRvIHJvdGF0ZSBmcm9tXG4gKiAgICAgICAgdGhlIHN0YXJ0aW5nIGRlZ3JlZS4gQSBuZWdhdGl2ZSB2YWx1ZSBtZWFucyByb3RhdGlvbiB0byB0aGVcbiAqICAgICAgICBjb3VudGVyLWNsb2Nrd2lzZSBkaXJlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBhc3luY2hyb25vdXNlIGdlc3R1cmVcbiAqICAgICAgc2ltdWxhdGlvbiBpcyBjb21wbGV0ZWQuXG4gKiAgICAgIEBwYXJhbSB7RXJyb3J9IGNiLmVyciBBbiBlcnJvciBvYmplY3QgaWYgdGhlIHNpbXVsYXRpb24gaXMgZmFpbGVkLlxuICogQGZvciBOb2RlXG4gKi9cblkuTm9kZS5wcm90b3R5cGUuc2ltdWxhdGVHZXN0dXJlID0gZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMsIGNiKSB7XG5cbiAgICBZLkV2ZW50LnNpbXVsYXRlR2VzdHVyZSh0aGlzLCBuYW1lLCBvcHRpb25zLCBjYik7XG59O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJub2RlLWJhc2VcIiwgXCJldmVudC1zaW11bGF0ZVwiLCBcImdlc3R1cmUtc2ltdWxhdGVcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnbm9kZS1sb2FkJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBFeHRlbmRlZCBOb2RlIGludGVyZmFjZSB3aXRoIGEgYmFzaWMgSU8gQVBJLlxuICogQG1vZHVsZSBub2RlXG4gKiBAc3VibW9kdWxlIG5vZGUtbG9hZFxuICovXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgSU8gY29tcGxldGUgaGFuZGxlci5cbiAqIEBtZXRob2QgX2lvQ29tcGxldGVcbiAqIEBwcm90ZWN0ZWRcbiAqIEBmb3IgTm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgVGhlIHJlc3BvbnNlIGNvZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgYW5kIHNlbGVjdG9yXG4gKi9cblxuWS5Ob2RlLnByb3RvdHlwZS5faW9Db21wbGV0ZSA9IGZ1bmN0aW9uKGNvZGUsIHJlc3BvbnNlLCBhcmdzKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gYXJnc1swXSxcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWzFdLFxuICAgICAgICB0bXAsXG4gICAgICAgIGNvbnRlbnQ7XG5cbiAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXNwb25zZS5yZXNwb25zZVRleHQ7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgdG1wID0gWS5ET00uY3JlYXRlKGNvbnRlbnQpO1xuICAgICAgICAgICAgY29udGVudCA9IFkuU2VsZWN0b3IucXVlcnkoc2VsZWN0b3IsIHRtcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDb250ZW50KGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBjb2RlLCByZXNwb25zZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMb2FkcyBjb250ZW50IGZyb20gdGhlIGdpdmVuIHVybCBhbmQgcmVwbGFjZXMgdGhlIE5vZGUnc1xuICogZXhpc3RpbmcgY29udGVudCB3aXRoIHRoZSByZW1vdGUgY29udGVudC5cbiAqIEBtZXRob2QgbG9hZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGxvYWQgdmlhIFhNTEh0dHBSZXF1ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIEFuIG9wdGlvbmFsIHNlbGVjdG9yIHJlcHJlc2VudGluZyBhIHN1YnNldCBvZiBhbiBIVE1MIGRvY3VtZW50IHRvIGxvYWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIGNvbnRlbnQgaGFzIGJlZW4gbG9hZGVkLlxuICogQGNoYWluYWJsZVxuICovXG5ZLk5vZGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbih1cmwsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICBzZWxlY3RvciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgICBjb21wbGV0ZTogdGhpcy5faW9Db21wbGV0ZVxuICAgICAgICB9LFxuICAgICAgICBhcmd1bWVudHM6IFtzZWxlY3RvciwgY2FsbGJhY2tdXG4gICAgfTtcblxuICAgIFkuaW8odXJsLCBjb25maWcpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wibm9kZS1iYXNlXCIsIFwiaW8tYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdub2RlLXBsdWdpbmhvc3QnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIEBtb2R1bGUgbm9kZVxuICogQHN1Ym1vZHVsZSBub2RlLXBsdWdpbmhvc3RcbiAqL1xuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHRvIGJlIGluc3RhbnRpYXRlZCBhdCB0aGUgY2xhc3MgbGV2ZWwgKHBsdWdpbnNcbiAqIHdoaWNoIHNob3VsZCBiZSBwbHVnZ2VkIGludG8gZXZlcnkgaW5zdGFuY2Ugb2YgTm9kZSBieSBkZWZhdWx0KS5cbiAqXG4gKiBAbWV0aG9kIHBsdWdcbiAqIEBzdGF0aWNcbiAqIEBmb3IgTm9kZVxuICogQHBhcmFtIHtGdW5jdGlvbiB8IEFycmF5fSBwbHVnaW4gRWl0aGVyIHRoZSBwbHVnaW4gY2xhc3MsIGFuIGFycmF5IG9mIHBsdWdpbiBjbGFzc2VzIG9yIGFuIGFycmF5IG9mIG9iamVjdHMgKHdpdGggZm4gYW5kIGNmZyBwcm9wZXJ0aWVzIGRlZmluZWQpXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIChPcHRpb25hbCkgSWYgcGx1Z2luIGlzIHRoZSBwbHVnaW4gY2xhc3MsIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgcGx1Z2luXG4gKi9cblkuTm9kZS5wbHVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBZLkFycmF5KGFyZ3VtZW50cyk7XG4gICAgYXJncy51bnNoaWZ0KFkuTm9kZSk7XG4gICAgWS5QbHVnaW4uSG9zdC5wbHVnLmFwcGx5KFkuQmFzZSwgYXJncyk7XG4gICAgcmV0dXJuIFkuTm9kZTtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlcnMgYW55IGNsYXNzIGxldmVsIHBsdWdpbnMgd2hpY2ggaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgYnkgdGhlIE5vZGVcbiAqXG4gKiBAbWV0aG9kIHVucGx1Z1xuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb24gfCBBcnJheX0gcGx1Z2luIFRoZSBwbHVnaW4gY2xhc3MsIG9yIGFuIGFycmF5IG9mIHBsdWdpbiBjbGFzc2VzXG4gKi9cblkuTm9kZS51bnBsdWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFkuQXJyYXkoYXJndW1lbnRzKTtcbiAgICBhcmdzLnVuc2hpZnQoWS5Ob2RlKTtcbiAgICBZLlBsdWdpbi5Ib3N0LnVucGx1Zy5hcHBseShZLkJhc2UsIGFyZ3MpO1xuICAgIHJldHVybiBZLk5vZGU7XG59O1xuXG5ZLm1peChZLk5vZGUsIFkuUGx1Z2luLkhvc3QsIGZhbHNlLCBudWxsLCAxKTtcblxuLy8gcnVuIFBsdWdpbkhvc3QgY29uc3RydWN0b3Igb24gY2FjaGVkIE5vZGUgaW5zdGFuY2VzXG5ZLk9iamVjdC5lYWNoKFkuTm9kZS5faW5zdGFuY2VzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIFkuUGx1Z2luLkhvc3QuYXBwbHkobm9kZSk7XG59KTtcblxuLy8gYWxsb3cgYmF0Y2hpbmcgb2YgcGx1Zy91bnBsdWcgdmlhIE5vZGVMaXN0XG4vLyBkb2Vzbid0IHVzZSBOb2RlTGlzdC5pbXBvcnRNZXRob2QgYmVjYXVzZSB3ZSBuZWVkIHJlYWwgTm9kZXMgKG5vdCB0bXBOb2RlKVxuLyoqXG4gKiBBZGRzIGEgcGx1Z2luIHRvIGVhY2ggbm9kZSBpbiB0aGUgTm9kZUxpc3QuXG4gKiBUaGlzIHdpbGwgaW5zdGFudGlhdGUgdGhlIHBsdWdpbiBhbmQgYXR0YWNoIGl0IHRvIHRoZSBjb25maWd1cmVkIG5hbWVzcGFjZSBvbiBlYWNoIG5vZGVcbiAqIEBtZXRob2QgcGx1Z1xuICogQGZvciBOb2RlTGlzdFxuICogQHBhcmFtIFAge0Z1bmN0aW9uIHwgT2JqZWN0IHxBcnJheX0gQWNjZXB0cyB0aGUgcGx1Z2luIGNsYXNzLCBvciBhblxuICogb2JqZWN0IHdpdGggYSBcImZuXCIgcHJvcGVydHkgc3BlY2lmeWluZyB0aGUgcGx1Z2luIGNsYXNzIGFuZFxuICogYSBcImNmZ1wiIHByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBQbHVnaW4uXG4gKiA8cD5cbiAqIEFkZGl0aW9uYWxseSBhbiBBcnJheSBjYW4gYWxzbyBiZSBwYXNzZWQgaW4sIHdpdGggdGhlIGFib3ZlIGZ1bmN0aW9uIG9yXG4gKiBvYmplY3QgdmFsdWVzLCBhbGxvd2luZyB0aGUgdXNlciB0byBhZGQgbXVsdGlwbGUgcGx1Z2lucyBpbiBhIHNpbmdsZSBjYWxsLlxuICogPC9wPlxuICogQHBhcmFtIGNvbmZpZyAoT3B0aW9uYWwpIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgcGx1Z2luIGNsYXNzLCB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gKiBjYW4gYmUgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBwbHVnaW4uXG4gKiBAY2hhaW5hYmxlXG4gKi9cblkuTm9kZUxpc3QucHJvdG90eXBlLnBsdWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBZLk5vZGVMaXN0LmVhY2godGhpcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBZLk5vZGUucHJvdG90eXBlLnBsdWcuYXBwbHkoWS5vbmUobm9kZSksIGFyZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcGx1Z2luIGZyb20gYWxsIG5vZGVzIGluIHRoZSBOb2RlTGlzdC4gVGhpcyB3aWxsIGRlc3Ryb3kgdGhlXG4gKiBwbHVnaW4gaW5zdGFuY2UgYW5kIGRlbGV0ZSB0aGUgbmFtZXNwYWNlIGVhY2ggbm9kZS5cbiAqIEBtZXRob2QgdW5wbHVnXG4gKiBAZm9yIE5vZGVMaXN0XG4gKiBAcGFyYW0ge1N0cmluZyB8IEZ1bmN0aW9ufSBwbHVnaW4gVGhlIG5hbWVzcGFjZSBvZiB0aGUgcGx1Z2luLCBvciB0aGUgcGx1Z2luIGNsYXNzIHdpdGggdGhlIHN0YXRpYyBOUyBuYW1lc3BhY2UgcHJvcGVydHkgZGVmaW5lZC4gSWYgbm90IHByb3ZpZGVkLFxuICogYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucyBhcmUgdW5wbHVnZ2VkLlxuICogQGNoYWluYWJsZVxuICovXG5ZLk5vZGVMaXN0LnByb3RvdHlwZS51bnBsdWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBZLk5vZGVMaXN0LmVhY2godGhpcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBZLk5vZGUucHJvdG90eXBlLnVucGx1Zy5hcHBseShZLm9uZShub2RlKSwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJub2RlLWJhc2VcIiwgXCJwbHVnaW5ob3N0XCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ25vZGUtc2NyZWVuJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBFeHRlbmRlZCBOb2RlIGludGVyZmFjZSBmb3IgbWFuYWdpbmcgcmVnaW9ucyBhbmQgc2NyZWVuIHBvc2l0aW9uaW5nLlxuICogQWRkcyBzdXBwb3J0IGZvciBwb3NpdGlvbmluZyBlbGVtZW50cyBhbmQgbm9ybWFsaXplcyB3aW5kb3cgc2l6ZSBhbmQgc2Nyb2xsIGRldGVjdGlvbi5cbiAqIEBtb2R1bGUgbm9kZVxuICogQHN1Ym1vZHVsZSBub2RlLXNjcmVlblxuICovXG5cbi8vIHRoZXNlIGFyZSBhbGwgXCJzYWZlXCIgcmV0dXJucywgbm8gd3JhcHBpbmcgcmVxdWlyZWRcblkuZWFjaChbXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5uZXIgd2lkdGggb2YgdGhlIHZpZXdwb3J0IChleGx1ZGVzIHNjcm9sbGJhcikuXG4gICAgICogQGNvbmZpZyB3aW5XaWR0aFxuICAgICAqIEBmb3IgTm9kZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgJ3dpbldpZHRoJyxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlubmVyIGhlaWdodCBvZiB0aGUgdmlld3BvcnQgKGV4bHVkZXMgc2Nyb2xsYmFyKS5cbiAgICAgKiBAY29uZmlnIHdpbkhlaWdodFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgJ3dpbkhlaWdodCcsXG5cbiAgICAvKipcbiAgICAgKiBEb2N1bWVudCB3aWR0aFxuICAgICAqIEBjb25maWcgZG9jV2lkdGhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgICdkb2NXaWR0aCcsXG5cbiAgICAvKipcbiAgICAgKiBEb2N1bWVudCBoZWlnaHRcbiAgICAgKiBAY29uZmlnIGRvY0hlaWdodFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgJ2RvY0hlaWdodCcsXG5cbiAgICAvKipcbiAgICAgKiBQaXhlbCBkaXN0YW5jZSB0aGUgcGFnZSBoYXMgYmVlbiBzY3JvbGxlZCBob3Jpem9udGFsbHlcbiAgICAgKiBAY29uZmlnIGRvY1Njcm9sbFhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgICdkb2NTY3JvbGxYJyxcblxuICAgIC8qKlxuICAgICAqIFBpeGVsIGRpc3RhbmNlIHRoZSBwYWdlIGhhcyBiZWVuIHNjcm9sbGVkIHZlcnRpY2FsbHlcbiAgICAgKiBAY29uZmlnIGRvY1Njcm9sbFlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgICdkb2NTY3JvbGxZJ1xuICAgIF0sXG4gICAgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBZLk5vZGUuQVRUUlNbbmFtZV0gPSB7XG4gICAgICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoWS5Ob2RlLmdldERPTU5vZGUodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFkuRE9NW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbik7XG5cblkuTm9kZS5BVFRSUy5zY3JvbGxMZWZ0ID0ge1xuICAgIGdldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub2RlID0gWS5Ob2RlLmdldERPTU5vZGUodGhpcyk7XG4gICAgICAgIHJldHVybiAoJ3Njcm9sbExlZnQnIGluIG5vZGUpID8gbm9kZS5zY3JvbGxMZWZ0IDogWS5ET00uZG9jU2Nyb2xsWChub2RlKTtcbiAgICB9LFxuXG4gICAgc2V0dGVyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBZLk5vZGUuZ2V0RE9NTm9kZSh0aGlzKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICgnc2Nyb2xsTGVmdCcgaW4gbm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2Nyb2xsTGVmdCA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5kb2N1bWVudCB8fCBub2RlLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgICAgWS5ET00uX2dldFdpbihub2RlKS5zY3JvbGxUbyh2YWwsIFkuRE9NLmRvY1Njcm9sbFkobm9kZSkpOyAvLyBzY3JvbGwgd2luZG93IGlmIHdpbiBvciBkb2NcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblkuTm9kZS5BVFRSUy5zY3JvbGxUb3AgPSB7XG4gICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBZLk5vZGUuZ2V0RE9NTm9kZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuICgnc2Nyb2xsVG9wJyBpbiBub2RlKSA/IG5vZGUuc2Nyb2xsVG9wIDogWS5ET00uZG9jU2Nyb2xsWShub2RlKTtcbiAgICB9LFxuXG4gICAgc2V0dGVyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBZLk5vZGUuZ2V0RE9NTm9kZSh0aGlzKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICgnc2Nyb2xsVG9wJyBpbiBub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zY3JvbGxUb3AgPSB2YWw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZG9jdW1lbnQgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIFkuRE9NLl9nZXRXaW4obm9kZSkuc2Nyb2xsVG8oWS5ET00uZG9jU2Nyb2xsWChub2RlKSwgdmFsKTsgLy8gc2Nyb2xsIHdpbmRvdyBpZiB3aW4gb3IgZG9jXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5ZLk5vZGUuaW1wb3J0TWV0aG9kKFkuRE9NLCBbXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIG5vZGUgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0WFlcbiAqIEBmb3IgTm9kZVxuICogQHJldHVybiB7QXJyYXl9IFRoZSBYWSBwb3NpdGlvbiBvZiB0aGUgbm9kZVxuKi9cbiAgICAnZ2V0WFknLFxuXG4vKipcbiAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgaW4gcGFnZSBjb29yZGluYXRlcywgcmVnYXJkbGVzcyBvZiBob3cgdGhlIG5vZGUgaXMgcG9zaXRpb25lZC5cbiAqIEBtZXRob2Qgc2V0WFlcbiAqIEBwYXJhbSB7QXJyYXl9IHh5IENvbnRhaW5zIFggJiBZIHZhbHVlcyBmb3IgbmV3IHBvc2l0aW9uIChjb29yZGluYXRlcyBhcmUgcGFnZS1iYXNlZClcbiAqIEBjaGFpbmFibGVcbiAqL1xuICAgICdzZXRYWScsXG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBnZXRYXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBub2RlXG4qL1xuICAgICdnZXRYJyxcblxuLyoqXG4gKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGluIHBhZ2UgY29vcmRpbmF0ZXMsIHJlZ2FyZGxlc3Mgb2YgaG93IHRoZSBub2RlIGlzIHBvc2l0aW9uZWQuXG4gKiBAbWV0aG9kIHNldFhcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggdmFsdWUgZm9yIG5ldyBwb3NpdGlvbiAoY29vcmRpbmF0ZXMgYXJlIHBhZ2UtYmFzZWQpXG4gKiBAY2hhaW5hYmxlXG4gKi9cbiAgICAnc2V0WCcsXG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBnZXRZXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBub2RlXG4qL1xuICAgICdnZXRZJyxcblxuLyoqXG4gKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGluIHBhZ2UgY29vcmRpbmF0ZXMsIHJlZ2FyZGxlc3Mgb2YgaG93IHRoZSBub2RlIGlzIHBvc2l0aW9uZWQuXG4gKiBAbWV0aG9kIHNldFlcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgdmFsdWUgZm9yIG5ldyBwb3NpdGlvbiAoY29vcmRpbmF0ZXMgYXJlIHBhZ2UtYmFzZWQpXG4gKiBAY2hhaW5hYmxlXG4gKi9cbiAgICAnc2V0WScsXG5cbi8qKlxuICogU3dhcHMgdGhlIFhZIHBvc2l0aW9uIG9mIHRoaXMgbm9kZSB3aXRoIGFub3RoZXIgbm9kZS5cbiAqIEBtZXRob2Qgc3dhcFhZXG4gKiBAcGFyYW0ge05vZGUgfCBIVE1MRWxlbWVudH0gb3RoZXJOb2RlIFRoZSBub2RlIHRvIHN3YXAgd2l0aC5cbiAqIEBjaGFpbmFibGVcbiAqL1xuICAgICdzd2FwWFknXG5dKTtcblxuLyoqXG4gKiBAbW9kdWxlIG5vZGVcbiAqIEBzdWJtb2R1bGUgbm9kZS1zY3JlZW5cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSByZWdpb24gb2JqZWN0IGZvciB0aGUgbm9kZVxuICogQGNvbmZpZyByZWdpb25cbiAqIEBmb3IgTm9kZVxuICogQHR5cGUgTm9kZVxuICovXG5ZLk5vZGUuQVRUUlMucmVnaW9uID0ge1xuICAgIGdldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5nZXRET01Ob2RlKCksXG4gICAgICAgICAgICByZWdpb247XG5cbiAgICAgICAgaWYgKG5vZGUgJiYgIW5vZGUudGFnTmFtZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDkpIHsgLy8gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFkuRE9NLmlzV2luZG93KG5vZGUpKSB7XG4gICAgICAgICAgICByZWdpb24gPSBZLkRPTS52aWV3cG9ydFJlZ2lvbihub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZ2lvbiA9IFkuRE9NLnJlZ2lvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVnaW9uO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHJlZ2lvbiBvYmplY3QgZm9yIHRoZSBub2RlJ3Mgdmlld3BvcnRcbiAqIEBjb25maWcgdmlld3BvcnRSZWdpb25cbiAqIEB0eXBlIE5vZGVcbiAqL1xuWS5Ob2RlLkFUVFJTLnZpZXdwb3J0UmVnaW9uID0ge1xuICAgIGdldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBZLkRPTS52aWV3cG9ydFJlZ2lvbihZLk5vZGUuZ2V0RE9NTm9kZSh0aGlzKSk7XG4gICAgfVxufTtcblxuWS5Ob2RlLmltcG9ydE1ldGhvZChZLkRPTSwgJ2luVmlld3BvcnRSZWdpb24nKTtcblxuLy8gdGhlc2UgbmVlZCBzcGVjaWFsIHRyZWF0bWVudCB0byBleHRyYWN0IDJuZCBub2RlIGFyZ1xuLyoqXG4gKiBDb21wYXJlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBub2RlIHdpdGggYW5vdGhlciBub2RlIG9yIHJlZ2lvblxuICogQG1ldGhvZCBpbnRlcnNlY3RcbiAqIEBmb3IgTm9kZVxuICogQHBhcmFtIHtOb2RlfE9iamVjdH0gbm9kZTIgVGhlIG5vZGUgb3IgcmVnaW9uIHRvIGNvbXBhcmUgd2l0aC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhbHRSZWdpb24gQW4gYWx0ZXJuYXRlIHJlZ2lvbiB0byB1c2UgKHJhdGhlciB0aGFuIHRoaXMgbm9kZSdzKS5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSByZWdpb25zLlxuICovXG5ZLk5vZGUucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uKG5vZGUyLCBhbHRSZWdpb24pIHtcbiAgICB2YXIgbm9kZTEgPSBZLk5vZGUuZ2V0RE9NTm9kZSh0aGlzKTtcbiAgICBpZiAoWS5pbnN0YW5jZU9mKG5vZGUyLCBZLk5vZGUpKSB7IC8vIG1pZ2h0IGJlIGEgcmVnaW9uIG9iamVjdFxuICAgICAgICBub2RlMiA9IFkuTm9kZS5nZXRET01Ob2RlKG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIFkuRE9NLmludGVyc2VjdChub2RlMSwgbm9kZTIsIGFsdFJlZ2lvbik7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgd2l0aGluIHRoZSBnaXZlbiByZWdpb24uXG4gKiBAbWV0aG9kIGluUmVnaW9uXG4gKiBAcGFyYW0ge05vZGV8T2JqZWN0fSBub2RlMiBUaGUgbm9kZSBvciByZWdpb24gdG8gY29tcGFyZSB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBhbGwgV2hldGhlciBvciBub3QgYWxsIG9mIHRoZSBub2RlIG11c3QgYmUgaW4gdGhlIHJlZ2lvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhbHRSZWdpb24gQW4gYWx0ZXJuYXRlIHJlZ2lvbiB0byB1c2UgKHJhdGhlciB0aGFuIHRoaXMgbm9kZSdzKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgaW4gcmVnaW9uLCBmYWxzZSBpZiBub3QuXG4gKi9cblkuTm9kZS5wcm90b3R5cGUuaW5SZWdpb24gPSBmdW5jdGlvbihub2RlMiwgYWxsLCBhbHRSZWdpb24pIHtcbiAgICB2YXIgbm9kZTEgPSBZLk5vZGUuZ2V0RE9NTm9kZSh0aGlzKTtcbiAgICBpZiAoWS5pbnN0YW5jZU9mKG5vZGUyLCBZLk5vZGUpKSB7IC8vIG1pZ2h0IGJlIGEgcmVnaW9uIG9iamVjdFxuICAgICAgICBub2RlMiA9IFkuTm9kZS5nZXRET01Ob2RlKG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIFkuRE9NLmluUmVnaW9uKG5vZGUxLCBub2RlMiwgYWxsLCBhbHRSZWdpb24pO1xufTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wiZG9tLXNjcmVlblwiLCBcIm5vZGUtYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdub2RlLXN0eWxlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuKGZ1bmN0aW9uKFkpIHtcbi8qKlxuICogRXh0ZW5kZWQgTm9kZSBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nIG5vZGUgc3R5bGVzLlxuICogQG1vZHVsZSBub2RlXG4gKiBAc3VibW9kdWxlIG5vZGUtc3R5bGVcbiAqL1xuXG5ZLm1peChZLk5vZGUucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBub2RlLlxuICAgICAqIFVzZSBjYW1lbENhc2UgKGUuZy4gJ2JhY2tncm91bmRDb2xvcicpIGZvciBtdWx0aS13b3JkIHByb3BlcnRpZXMuXG4gICAgICogQG1ldGhvZCBzZXRTdHlsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBzdHlsZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsIFRoZSB2YWx1ZS5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgICAgICBZLkRPTS5zZXRTdHlsZSh0aGlzLl9ub2RlLCBhdHRyLCB2YWwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtdWx0aXBsZSBzdHlsZSBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlLlxuICAgICAqIFVzZSBjYW1lbENhc2UgKGUuZy4gJ2JhY2tncm91bmRDb2xvcicpIGZvciBtdWx0aS13b3JkIHByb3BlcnRpZXMuXG4gICAgICogQG1ldGhvZCBzZXRTdHlsZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBBbiBvYmplY3QgbGl0ZXJhbCBvZiBwcm9wZXJ0eTp2YWx1ZSBwYWlycy5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U3R5bGVzOiBmdW5jdGlvbihoYXNoKSB7XG4gICAgICAgIFkuRE9NLnNldFN0eWxlcyh0aGlzLl9ub2RlLCBoYXNoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0eWxlJ3MgY3VycmVudCB2YWx1ZS5cbiAgICAgKiBVc2UgY2FtZWxDYXNlIChlLmcuICdiYWNrZ3JvdW5kQ29sb3InKSBmb3IgbXVsdGktd29yZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBtZXRob2QgZ2V0U3R5bGVcbiAgICAgKiBAZm9yIE5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgc3R5bGUgYXR0cmlidXRlIHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHN0eWxlIHByb3BlcnR5IGZvciB0aGUgZWxlbWVudC5cbiAgICAgKi9cblxuICAgICBnZXRTdHlsZTogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICByZXR1cm4gWS5ET00uZ2V0U3R5bGUodGhpcy5fbm9kZSwgYXR0cik7XG4gICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHN0eWxlIHByb3BlcnR5LlxuICAgICAqIFVzZSBjYW1lbENhc2UgKGUuZy4gJ2JhY2tncm91bmRDb2xvcicpIGZvciBtdWx0aS13b3JkIHByb3BlcnRpZXMuXG4gICAgICogQG1ldGhvZCBnZXRDb21wdXRlZFN0eWxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIHN0eWxlIGF0dHJpYnV0ZSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb21wdXRlZCB2YWx1ZSBvZiB0aGUgc3R5bGUgcHJvcGVydHkgZm9yIHRoZSBlbGVtZW50LlxuICAgICAqL1xuICAgICBnZXRDb21wdXRlZFN0eWxlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIHJldHVybiBZLkRPTS5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX25vZGUsIGF0dHIpO1xuICAgICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcyBmb3IgZWFjaCBub2RlLlxuICogVXNlIGNhbWVsQ2FzZSAoZS5nLiAnYmFja2dyb3VuZENvbG9yJykgZm9yIG11bHRpLXdvcmQgcHJvcGVydGllcy5cbiAqIEBtZXRob2QgZ2V0U3R5bGVcbiAqIEBmb3IgTm9kZUxpc3RcbiAqIEBzZWUgTm9kZS5nZXRTdHlsZVxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIHN0eWxlIGF0dHJpYnV0ZSB0byByZXRyaWV2ZS5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgY3VycmVudCB2YWx1ZXMgb2YgdGhlIHN0eWxlIHByb3BlcnR5IGZvciB0aGUgZWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGNvbXB1dGVkIHZhbHVlIGZvciBlYWNoIG5vZGUuXG4gKiBVc2UgY2FtZWxDYXNlIChlLmcuICdiYWNrZ3JvdW5kQ29sb3InKSBmb3IgbXVsdGktd29yZCBwcm9wZXJ0aWVzLlxuICogQG1ldGhvZCBnZXRDb21wdXRlZFN0eWxlXG4gKiBAc2VlIE5vZGUuZ2V0Q29tcHV0ZWRTdHlsZVxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIHN0eWxlIGF0dHJpYnV0ZSB0byByZXRyaWV2ZS5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgY29tcHV0ZWQgdmFsdWVzIGZvciBlYWNoIG5vZGUuXG4gKi9cblxuLyoqXG4gKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb24gZWFjaCBub2RlLlxuICogVXNlIGNhbWVsQ2FzZSAoZS5nLiAnYmFja2dyb3VuZENvbG9yJykgZm9yIG11bHRpLXdvcmQgcHJvcGVydGllcy5cbiAqIEBtZXRob2Qgc2V0U3R5bGVcbiAqIEBzZWUgTm9kZS5zZXRTdHlsZVxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIHN0eWxlIGF0dHJpYnV0ZSB0byBzZXQuXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbCBUaGUgdmFsdWUuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblxuLyoqXG4gKiBTZXRzIG11bHRpcGxlIHN0eWxlIHByb3BlcnRpZXMgb24gZWFjaCBub2RlLlxuICogVXNlIGNhbWVsQ2FzZSAoZS5nLiAnYmFja2dyb3VuZENvbG9yJykgZm9yIG11bHRpLXdvcmQgcHJvcGVydGllcy5cbiAqIEBtZXRob2Qgc2V0U3R5bGVzXG4gKiBAc2VlIE5vZGUuc2V0U3R5bGVzXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBBbiBvYmplY3QgbGl0ZXJhbCBvZiBwcm9wZXJ0eTp2YWx1ZSBwYWlycy5cbiAqIEBjaGFpbmFibGVcbiAqL1xuXG4vLyBUaGVzZSBhcmUgYnJva2VuIG91dCB0byBoYW5kbGUgdW5kZWZpbmVkIHJldHVybiAoYXZvaWQgZmFsc2UgcG9zaXRpdmUgZm9yXG4vLyBjaGFpbmFibGUpXG5cblkuTm9kZUxpc3QuaW1wb3J0TWV0aG9kKFkuTm9kZS5wcm90b3R5cGUsIFsnZ2V0U3R5bGUnLCAnZ2V0Q29tcHV0ZWRTdHlsZScsICdzZXRTdHlsZScsICdzZXRTdHlsZXMnXSk7XG59KShZKTtcbi8qKlxuICogQG1vZHVsZSBub2RlXG4gKiBAc3VibW9kdWxlIG5vZGUtYmFzZVxuICovXG5cbnZhciBZX05vZGUgPSBZLk5vZGU7XG5cblkubWl4KFlfTm9kZS5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbm9kZSB2aXNpYmxlLlxuICAgICAqIElmIHRoZSBcInRyYW5zaXRpb25cIiBtb2R1bGUgaXMgbG9hZGVkLCBzaG93IG9wdGlvbmFsbHlcbiAgICAgKiBhbmltYXRlcyB0aGUgc2hvd2luZyBvZiB0aGUgbm9kZSB1c2luZyBlaXRoZXIgdGhlIGRlZmF1bHRcbiAgICAgKiB0cmFuc2l0aW9uIGVmZmVjdCAoJ2ZhZGVJbicpLCBvciB0aGUgZ2l2ZW4gbmFtZWQgZWZmZWN0LlxuICAgICAqIEBtZXRob2Qgc2hvd1xuICAgICAqIEBmb3IgTm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEEgbmFtZWQgVHJhbnNpdGlvbiBlZmZlY3QgdG8gdXNlIGFzIHRoZSBzaG93IGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIE9wdGlvbnMgdG8gdXNlIHdpdGggdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSB0cmFuc2l0aW9uIGNvbXBsZXRlcy5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLnRvZ2dsZVZpZXcodHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIGZvciBzaG93aW5nIG5vZGVzLlxuICAgICAqIERlZmF1bHQgaXMgdG8gcmVtb3ZlIHRoZSBoaWRkZW4gYXR0cmlidXRlIGFuZCByZXNldCB0aGUgQ1NTIHN0eWxlLmRpc3BsYXkgcHJvcGVydHkuXG4gICAgICogQG1ldGhvZCBfc2hvd1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3Nob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnaGlkZGVuJyk7XG5cbiAgICAgICAgLy8gRm9yIGJhY2stY29tcGF0IHdlIG5lZWQgdG8gbGVhdmUgdGhpcyBpbiBmb3IgYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBkbyBub3QgdmlzdWFsbHkgaGlkZSBhIG5vZGUgdmlhIHRoZSBoaWRkZW4gYXR0cmlidXRlXG4gICAgICAgIC8vIGFuZCBmb3IgdXNlcnMgdGhhdCBjaGVjayB2aXNpYmlsaXR5IGJhc2VkIG9uIHN0eWxlIGRpc3BsYXkuXG4gICAgICAgIHRoaXMuc2V0U3R5bGUoJ2Rpc3BsYXknLCAnJyk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgUmV0dXJucyB3aGV0aGVyIHRoZSBub2RlIGlzIGhpZGRlbiBieSBZVUkgb3Igbm90LiBUaGUgaGlkZGVuIHN0YXR1cyBpc1xuICAgIGRldGVybWluZWQgYnkgdGhlICdoaWRkZW4nIGF0dHJpYnV0ZSBhbmQgdGhlIHZhbHVlIG9mIHRoZSAnZGlzcGxheScgQ1NTXG4gICAgcHJvcGVydHkuXG5cbiAgICBAbWV0aG9kIF9pc0hpZGRlblxuICAgIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgbm9kZSBpcyBoaWRkZW4uXG4gICAgQHByaXZhdGVcbiAgICAqKi9cbiAgICBfaXNIaWRkZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIHRoaXMuaGFzQXR0cmlidXRlKCdoaWRkZW4nKSB8fCBZLkRPTS5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX25vZGUsICdkaXNwbGF5JykgPT09ICdub25lJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgb3IgaGlkZXMgdGhlIG5vZGUuXG4gICAgICogSWYgdGhlIFwidHJhbnNpdGlvblwiIG1vZHVsZSBpcyBsb2FkZWQsIHRvZ2dsZVZpZXcgb3B0aW9uYWxseVxuICAgICAqIGFuaW1hdGVzIHRoZSB0b2dnbGluZyBvZiB0aGUgbm9kZSB1c2luZyBnaXZlbiBuYW1lZCBlZmZlY3QuXG4gICAgICogQG1ldGhvZCB0b2dnbGVWaWV3XG4gICAgICogQGZvciBOb2RlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb25dIEFuIG9wdGlvbmFsIGJvb2xlYW4gdmFsdWUgdG8gZm9yY2UgdGhlIG5vZGUgdG8gYmUgc2hvd24gb3IgaGlkZGVuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIHRyYW5zaXRpb24gY29tcGxldGVzLlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB0b2dnbGVWaWV3OiBmdW5jdGlvbihvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlVmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3RvZ2dsZVZpZXc6IGZ1bmN0aW9uKG9uLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgLy8gYmFzZSBvbiBjdXJyZW50IHN0YXRlIGlmIG5vdCBmb3JjaW5nXG4gICAgICAgIGlmICh0eXBlb2Ygb24gIT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBvbiA9ICh0aGlzLl9pc0hpZGRlbigpKSA/IDEgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zaG93KCk7XG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBub2RlLlxuICAgICAqIElmIHRoZSBcInRyYW5zaXRpb25cIiBtb2R1bGUgaXMgbG9hZGVkLCBoaWRlIG9wdGlvbmFsbHlcbiAgICAgKiBhbmltYXRlcyB0aGUgaGlkaW5nIG9mIHRoZSBub2RlIHVzaW5nIGVpdGhlciB0aGUgZGVmYXVsdFxuICAgICAqIHRyYW5zaXRpb24gZWZmZWN0ICgnZmFkZU91dCcpLCBvciB0aGUgZ2l2ZW4gbmFtZWQgZWZmZWN0LlxuICAgICAqIEBtZXRob2QgaGlkZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEEgbmFtZWQgVHJhbnNpdGlvbiBlZmZlY3QgdG8gdXNlIGFzIHRoZSBzaG93IGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIE9wdGlvbnMgdG8gdXNlIHdpdGggdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSB0cmFuc2l0aW9uIGNvbXBsZXRlcy5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgaGlkZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLnRvZ2dsZVZpZXcoZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBmb3IgaGlkaW5nIG5vZGVzLlxuICAgICAqIERlZmF1bHQgaXMgdG8gc2V0IHRoZSBoaWRkZW4gYXR0cmlidXRlIHRvIHRydWUgYW5kIHNldCB0aGUgQ1NTIHN0eWxlLmRpc3BsYXkgdG8gJ25vbmUnLlxuICAgICAqIEBtZXRob2QgX2hpZGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9oaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcblxuICAgICAgICAvLyBGb3IgYmFjay1jb21wYXQgd2UgbmVlZCB0byBsZWF2ZSB0aGlzIGluIGZvciBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIGRvIG5vdCB2aXN1YWxseSBoaWRlIGEgbm9kZSB2aWEgdGhlIGhpZGRlbiBhdHRyaWJ1dGVcbiAgICAgICAgLy8gYW5kIGZvciB1c2VycyB0aGF0IGNoZWNrIHZpc2liaWxpdHkgYmFzZWQgb24gc3R5bGUgZGlzcGxheS5cbiAgICAgICAgdGhpcy5zZXRTdHlsZSgnZGlzcGxheScsICdub25lJyk7XG4gICAgfVxufSk7XG5cblkuTm9kZUxpc3QuaW1wb3J0TWV0aG9kKFkuTm9kZS5wcm90b3R5cGUsIFtcbiAgICAvKipcbiAgICAgKiBNYWtlcyBlYWNoIG5vZGUgdmlzaWJsZS5cbiAgICAgKiBJZiB0aGUgXCJ0cmFuc2l0aW9uXCIgbW9kdWxlIGlzIGxvYWRlZCwgc2hvdyBvcHRpb25hbGx5XG4gICAgICogYW5pbWF0ZXMgdGhlIHNob3dpbmcgb2YgdGhlIG5vZGUgdXNpbmcgZWl0aGVyIHRoZSBkZWZhdWx0XG4gICAgICogdHJhbnNpdGlvbiBlZmZlY3QgKCdmYWRlSW4nKSwgb3IgdGhlIGdpdmVuIG5hbWVkIGVmZmVjdC5cbiAgICAgKiBAbWV0aG9kIHNob3dcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBBIG5hbWVkIFRyYW5zaXRpb24gZWZmZWN0IHRvIHVzZSBhcyB0aGUgc2hvdyBlZmZlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBPcHRpb25zIHRvIHVzZSB3aXRoIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciB0aGUgdHJhbnNpdGlvbiBjb21wbGV0ZXMuXG4gICAgICogQGZvciBOb2RlTGlzdFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICAnc2hvdycsXG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyBlYWNoIG5vZGUuXG4gICAgICogSWYgdGhlIFwidHJhbnNpdGlvblwiIG1vZHVsZSBpcyBsb2FkZWQsIGhpZGUgb3B0aW9uYWxseVxuICAgICAqIGFuaW1hdGVzIHRoZSBoaWRpbmcgb2YgdGhlIG5vZGUgdXNpbmcgZWl0aGVyIHRoZSBkZWZhdWx0XG4gICAgICogdHJhbnNpdGlvbiBlZmZlY3QgKCdmYWRlT3V0JyksIG9yIHRoZSBnaXZlbiBuYW1lZCBlZmZlY3QuXG4gICAgICogQG1ldGhvZCBoaWRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQSBuYW1lZCBUcmFuc2l0aW9uIGVmZmVjdCB0byB1c2UgYXMgdGhlIHNob3cgZWZmZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgT3B0aW9ucyB0byB1c2Ugd2l0aCB0aGUgdHJhbnNpdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIHRyYW5zaXRpb24gY29tcGxldGVzLlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICAnaGlkZScsXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBvciBoaWRlcyBlYWNoIG5vZGUuXG4gICAgICogSWYgdGhlIFwidHJhbnNpdGlvblwiIG1vZHVsZSBpcyBsb2FkZWQsIHRvZ2dsZVZpZXcgb3B0aW9uYWxseVxuICAgICAqIGFuaW1hdGVzIHRoZSB0b2dnbGluZyBvZiB0aGUgbm9kZXMgdXNpbmcgZ2l2ZW4gbmFtZWQgZWZmZWN0LlxuICAgICAqIEBtZXRob2QgdG9nZ2xlVmlld1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uXSBBbiBvcHRpb25hbCBib29sZWFuIHZhbHVlIHRvIGZvcmNlIHRoZSBub2RlcyB0byBiZSBzaG93biBvciBoaWRkZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciB0aGUgdHJhbnNpdGlvbiBjb21wbGV0ZXMuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgICd0b2dnbGVWaWV3J1xuXSk7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImRvbS1zdHlsZVwiLCBcIm5vZGUtYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdvb3AnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbkFkZHMgb2JqZWN0IGluaGVyaXRhbmNlIGFuZCBtYW5pcHVsYXRpb24gdXRpbGl0aWVzIHRvIHRoZSBZVUkgaW5zdGFuY2UuIFRoaXNcbm1vZHVsZSBpcyByZXF1aXJlZCBieSBtb3N0IFlVSSBjb21wb25lbnRzLlxuXG5AbW9kdWxlIG9vcFxuKiovXG5cbnZhciBMICAgICAgICAgICAgPSBZLkxhbmcsXG4gICAgQSAgICAgICAgICAgID0gWS5BcnJheSxcbiAgICBPUCAgICAgICAgICAgPSBPYmplY3QucHJvdG90eXBlLFxuICAgIENMT05FX01BUktFUiA9ICdffnl1aW1+XycsXG5cbiAgICBoYXNPd24gICA9IE9QLmhhc093blByb3BlcnR5LFxuICAgIHRvU3RyaW5nID0gT1AudG9TdHJpbmc7XG5cbi8qKlxuQ2FsbHMgdGhlIHNwZWNpZmllZCBfYWN0aW9uXyBtZXRob2Qgb24gX29fIGlmIGl0IGV4aXN0cy4gT3RoZXJ3aXNlLCBpZiBfb18gaXMgYW5cbmFycmF5LCBjYWxscyB0aGUgX2FjdGlvbl8gbWV0aG9kIG9uIGBZLkFycmF5YCwgb3IgaWYgX29fIGlzIGFuIG9iamVjdCwgY2FsbHMgdGhlXG5fYWN0aW9uXyBtZXRob2Qgb24gYFkuT2JqZWN0YC5cblxuSWYgX29fIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBpdCB3aWxsIGJlIGNvZXJjZWQgdG8gYW4gYXJyYXkuXG5cblRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIGFycmF5L29iamVjdCBpdGVyYXRpb24gbWV0aG9kcyB0aGF0IHNoYXJlXG5zaWduYXR1cmVzLCBzdWNoIGFzIGBlYWNoKClgLCBgc29tZSgpYCwgZXRjLlxuXG5AbWV0aG9kIGRpc3BhdGNoXG5AcGFyYW0ge09iamVjdH0gbyBBcnJheSBvciBvYmplY3QgdG8gZGlzcGF0Y2ggdG8uXG5AcGFyYW0ge0Z1bmN0aW9ufSBmIEl0ZXJhdGlvbiBjYWxsYmFjay5cbiAgICBAcGFyYW0ge01peGVkfSBmLnZhbHVlIFZhbHVlIGJlaW5nIGl0ZXJhdGVkLlxuICAgIEBwYXJhbSB7TWl4ZWR9IGYua2V5IEN1cnJlbnQgb2JqZWN0IGtleSBvciBhcnJheSBpbmRleC5cbiAgICBAcGFyYW0ge01peGVkfSBmLm9iamVjdCBPYmplY3Qgb3IgYXJyYXkgYmVpbmcgaXRlcmF0ZWQuXG5AcGFyYW0ge09iamVjdH0gYyBgdGhpc2Agb2JqZWN0IHRvIGJpbmQgdGhlIGl0ZXJhdGlvbiBjYWxsYmFjayB0by5cbkBwYXJhbSB7Qm9vbGVhbn0gcHJvdG8gSWYgYHRydWVgLCBwcm90b3R5cGUgcHJvcGVydGllcyBvZiBvYmplY3RzIHdpbGwgYmVcbiAgICBpdGVyYXRlZC5cbkBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gRnVuY3Rpb24gbmFtZSB0byBiZSBkaXNwYXRjaGVkIG9uIF9vXy4gRm9yIGV4YW1wbGU6XG4gICAgJ3NvbWUnLCAnZWFjaCcsIGV0Yy5cbkBwcml2YXRlXG5AcmV0dXJuIHtNaXhlZH0gUmV0dXJucyB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGNob3NlbiBpdGVyYXRpb24gYWN0aW9uLCB3aGljaFxuICAgIHZhcmllcy5cbioqL1xuZnVuY3Rpb24gZGlzcGF0Y2gobywgZiwgYywgcHJvdG8sIGFjdGlvbikge1xuICAgIGlmIChvICYmIG9bYWN0aW9uXSAmJiBvICE9PSBZKSB7XG4gICAgICAgIHJldHVybiBvW2FjdGlvbl0uY2FsbChvLCBmLCBjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKEEudGVzdChvKSkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBBW2FjdGlvbl0obywgZiwgYyk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFbYWN0aW9uXShZLkFycmF5KG8sIDAsIHRydWUpLCBmLCBjKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFkuT2JqZWN0W2FjdGlvbl0obywgZiwgYywgcHJvdG8pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbkF1Z21lbnRzIHRoZSBfcmVjZWl2ZXJfIHdpdGggcHJvdG90eXBlIHByb3BlcnRpZXMgZnJvbSB0aGUgX3N1cHBsaWVyXy4gVGhlXG5yZWNlaXZlciBtYXkgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBvciBhbiBvYmplY3QuIFRoZSBzdXBwbGllciBtdXN0IGJlIGFcbmNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuXG5JZiB0aGUgX3JlY2VpdmVyXyBpcyBhbiBvYmplY3QsIHRoZW4gdGhlIF9zdXBwbGllcl8gY29uc3RydWN0b3Igd2lsbCBiZSBjYWxsZWRcbmltbWVkaWF0ZWx5IGFmdGVyIF9yZWNlaXZlcl8gaXMgYXVnbWVudGVkLCB3aXRoIF9yZWNlaXZlcl8gYXMgdGhlIGB0aGlzYCBvYmplY3QuXG5cbklmIHRoZSBfcmVjZWl2ZXJfIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHRoZW4gYWxsIHByb3RvdHlwZSBtZXRob2RzIG9mXG5fc3VwcGxpZXJfIHRoYXQgYXJlIGNvcGllZCB0byBfcmVjZWl2ZXJfIHdpbGwgYmUgc2VxdWVzdGVyZWQsIGFuZCB0aGVcbl9zdXBwbGllcl8gY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkIGltbWVkaWF0ZWx5LiBUaGUgZmlyc3QgdGltZSBhbnlcbnNlcXVlc3RlcmVkIG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIF9yZWNlaXZlcl8ncyBwcm90b3R5cGUsIGFsbCBzZXF1ZXN0ZXJlZFxubWV0aG9kcyB3aWxsIGJlIGltbWVkaWF0ZWx5IGNvcGllZCB0byB0aGUgX3JlY2VpdmVyXydzIHByb3RvdHlwZSwgdGhlXG5fc3VwcGxpZXJfJ3MgY29uc3RydWN0b3Igd2lsbCBiZSBleGVjdXRlZCwgYW5kIGZpbmFsbHkgdGhlIG5ld2x5IHVuc2VxdWVzdGVyZWRcbm1ldGhvZCB0aGF0IHdhcyBjYWxsZWQgd2lsbCBiZSBleGVjdXRlZC5cblxuVGhpcyBzZXF1ZXN0ZXJpbmcgbG9naWMgc291bmRzIGxpa2UgYSBidW5jaCBvZiBjb21wbGljYXRlZCB2b29kb28sIGJ1dCBpdCBtYWtlc1xuaXQgY2hlYXAgdG8gcGVyZm9ybSBmcmVxdWVudCBhdWdtZW50YXRpb24gYnkgZW5zdXJpbmcgdGhhdCBzdXBwbGllcnMnXG5jb25zdHJ1Y3RvcnMgYXJlIG9ubHkgY2FsbGVkIGlmIGEgc3VwcGxpZWQgbWV0aG9kIGlzIGFjdHVhbGx5IHVzZWQuIElmIG5vbmUgb2ZcbnRoZSBzdXBwbGllZCBtZXRob2RzIGlzIGV2ZXIgdXNlZCwgdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gdGFrZSB0aGUgcGVyZm9ybWFuY2VcbmhpdCBvZiBjYWxsaW5nIHRoZSBfc3VwcGxpZXJfJ3MgY29uc3RydWN0b3IuXG5cbkBtZXRob2QgYXVnbWVudFxuQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IHJlY2VpdmVyIE9iamVjdCBvciBmdW5jdGlvbiB0byBiZSBhdWdtZW50ZWQuXG5AcGFyYW0ge0Z1bmN0aW9ufSBzdXBwbGllciBGdW5jdGlvbiB0aGF0IHN1cHBsaWVzIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcyB3aXRoXG4gIHdoaWNoIHRvIGF1Z21lbnQgdGhlIF9yZWNlaXZlcl8uXG5AcGFyYW0ge0Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdIElmIGB0cnVlYCwgcHJvcGVydGllcyBhbHJlYWR5IG9uIHRoZSByZWNlaXZlclxuICB3aWxsIGJlIG92ZXJ3cml0dGVuIGlmIGZvdW5kIG9uIHRoZSBzdXBwbGllcidzIHByb3RvdHlwZS5cbkBwYXJhbSB7U3RyaW5nW119IFt3aGl0ZWxpc3RdIEFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLiBJZiBzcGVjaWZpZWQsXG4gIG9ubHkgdGhlIHdoaXRlbGlzdGVkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcmVjZWl2ZXIsIGFuZFxuICBhbGwgb3RoZXJzIHdpbGwgYmUgaWdub3JlZC5cbkBwYXJhbSB7QXJyYXl8YW55fSBbYXJnc10gQXJndW1lbnQgb3IgYXJyYXkgb2YgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gIHN1cHBsaWVyJ3MgY29uc3RydWN0b3Igd2hlbiBpbml0aWFsaXppbmcuXG5AcmV0dXJuIHtGdW5jdGlvbn0gQXVnbWVudGVkIG9iamVjdC5cbkBmb3IgWVVJXG4qKi9cblkuYXVnbWVudCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3VwcGxpZXIsIG92ZXJ3cml0ZSwgd2hpdGVsaXN0LCBhcmdzKSB7XG4gICAgdmFyIHJQcm90byAgICA9IHJlY2VpdmVyLnByb3RvdHlwZSxcbiAgICAgICAgc2VxdWVzdGVyID0gclByb3RvICYmIHN1cHBsaWVyLFxuICAgICAgICBzUHJvdG8gICAgPSBzdXBwbGllci5wcm90b3R5cGUsXG4gICAgICAgIHRvICAgICAgICA9IHJQcm90byB8fCByZWNlaXZlcixcblxuICAgICAgICBjb3B5LFxuICAgICAgICBuZXdQcm90b3R5cGUsXG4gICAgICAgIHJlcGxhY2VtZW50cyxcbiAgICAgICAgc2VxdWVzdGVyZWQsXG4gICAgICAgIHVuc2VxdWVzdGVyO1xuXG4gICAgYXJncyA9IGFyZ3MgPyBZLkFycmF5KGFyZ3MpIDogW107XG5cbiAgICBpZiAoc2VxdWVzdGVyKSB7XG4gICAgICAgIG5ld1Byb3RvdHlwZSA9IHt9O1xuICAgICAgICByZXBsYWNlbWVudHMgPSB7fTtcbiAgICAgICAgc2VxdWVzdGVyZWQgID0ge307XG5cbiAgICAgICAgY29weSA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlIHx8ICEoa2V5IGluIHJQcm90bykpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVzdGVyZWRba2V5XSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3RvdHlwZVtrZXldID0gcmVwbGFjZW1lbnRzW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5zZXF1ZXN0ZXIodGhpcywgdmFsdWUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvdG90eXBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdW5zZXF1ZXN0ZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGZuLCBmbkFyZ3MpIHtcbiAgICAgICAgICAgIC8vIFVuc2VxdWVzdGVyIGFsbCBzZXF1ZXN0ZXJlZCBmdW5jdGlvbnMuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2VxdWVzdGVyZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoc2VxdWVzdGVyZWQsIGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGluc3RhbmNlW2tleV0gPT09IHJlcGxhY2VtZW50c1trZXldKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5XSA9IHNlcXVlc3RlcmVkW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBzdXBwbGllciBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIHN1cHBsaWVyLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcblxuICAgICAgICAgICAgLy8gRmluYWxseSwgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgc2VxdWVzdGVyZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoaW5zdGFuY2UsIGZuQXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHdoaXRlbGlzdCkge1xuICAgICAgICAgICAgWS5BcnJheS5lYWNoKHdoaXRlbGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBzUHJvdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29weShzUHJvdG9bbmFtZV0sIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgWS5PYmplY3QuZWFjaChzUHJvdG8sIGNvcHksIG51bGwsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgWS5taXgodG8sIG5ld1Byb3RvdHlwZSB8fCBzUHJvdG8sIG92ZXJ3cml0ZSwgd2hpdGVsaXN0KTtcblxuICAgIGlmICghc2VxdWVzdGVyKSB7XG4gICAgICAgIHN1cHBsaWVyLmFwcGx5KHRvLCBhcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjZWl2ZXI7XG59O1xuXG4vKipcbiAqIENvcGllcyBvYmplY3QgcHJvcGVydGllcyBmcm9tIHRoZSBzdXBwbGllciB0byB0aGUgcmVjZWl2ZXIuIElmIHRoZSB0YXJnZXQgaGFzXG4gKiB0aGUgcHJvcGVydHksIGFuZCB0aGUgcHJvcGVydHkgaXMgYW4gb2JqZWN0LCB0aGUgdGFyZ2V0IG9iamVjdCB3aWxsIGJlXG4gKiBhdWdtZW50ZWQgd2l0aCB0aGUgc3VwcGxpZXIncyB2YWx1ZS5cbiAqXG4gKiBAbWV0aG9kIGFnZ3JlZ2F0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlY2VpdmVyIE9iamVjdCB0byByZWNlaXZlIHRoZSBhdWdtZW50YXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gc3VwcGxpZXIgT2JqZWN0IHRoYXQgc3VwcGxpZXMgdGhlIHByb3BlcnRpZXMgd2l0aCB3aGljaCB0b1xuICogICAgIGF1Z21lbnQgdGhlIHJlY2VpdmVyLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXSBJZiBgdHJ1ZWAsIHByb3BlcnRpZXMgYWxyZWFkeSBvbiB0aGUgcmVjZWl2ZXJcbiAqICAgICB3aWxsIGJlIG92ZXJ3cml0dGVuIGlmIGZvdW5kIG9uIHRoZSBzdXBwbGllci5cbiAqIEBwYXJhbSB7U3RyaW5nW119IFt3aGl0ZWxpc3RdIFdoaXRlbGlzdC4gSWYgc3VwcGxpZWQsIG9ubHkgcHJvcGVydGllcyBpbiB0aGlzXG4gKiAgICAgbGlzdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHJlY2VpdmVyLlxuICogQHJldHVybiB7T2JqZWN0fSBBdWdtZW50ZWQgb2JqZWN0LlxuICovXG5ZLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKHIsIHMsIG92LCB3bCkge1xuICAgIHJldHVybiBZLm1peChyLCBzLCBvdiwgd2wsIDAsIHRydWUpO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IHRvIHNldCB1cCB0aGUgcHJvdG90eXBlLCBjb25zdHJ1Y3RvciBhbmQgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzIHRvXG4gKiBzdXBwb3J0IGFuIGluaGVyaXRhbmNlIHN0cmF0ZWd5IHRoYXQgY2FuIGNoYWluIGNvbnN0cnVjdG9ycyBhbmQgbWV0aG9kcy5cbiAqIFN0YXRpYyBtZW1iZXJzIHdpbGwgbm90IGJlIGluaGVyaXRlZC5cbiAqXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gciAgIHRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcyB0aGUgb2JqZWN0IHRvIGluaGVyaXQuXG4gKiBAcGFyYW0ge29iamVjdH0gcHggcHJvdG90eXBlIHByb3BlcnRpZXMgdG8gYWRkL292ZXJyaWRlLlxuICogQHBhcmFtIHtvYmplY3R9IHN4IHN0YXRpYyBwcm9wZXJ0aWVzIHRvIGFkZC9vdmVycmlkZS5cbiAqIEByZXR1cm4ge29iamVjdH0gdGhlIGV4dGVuZGVkIG9iamVjdC5cbiAqL1xuWS5leHRlbmQgPSBmdW5jdGlvbihyLCBzLCBweCwgc3gpIHtcbiAgICBpZiAoIXMgfHwgIXIpIHtcbiAgICAgICAgWS5lcnJvcignZXh0ZW5kIGZhaWxlZCwgdmVyaWZ5IGRlcGVuZGVuY2llcycpO1xuICAgIH1cblxuICAgIHZhciBzcCA9IHMucHJvdG90eXBlLCBycCA9IFkuT2JqZWN0KHNwKTtcbiAgICByLnByb3RvdHlwZSA9IHJwO1xuXG4gICAgcnAuY29uc3RydWN0b3IgPSByO1xuICAgIHIuc3VwZXJjbGFzcyA9IHNwO1xuXG4gICAgLy8gYXNzaWduIGNvbnN0cnVjdG9yIHByb3BlcnR5XG4gICAgaWYgKHMgIT0gT2JqZWN0ICYmIHNwLmNvbnN0cnVjdG9yID09IE9QLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHNwLmNvbnN0cnVjdG9yID0gcztcbiAgICB9XG5cbiAgICAvLyBhZGQgcHJvdG90eXBlIG92ZXJyaWRlc1xuICAgIGlmIChweCkge1xuICAgICAgICBZLm1peChycCwgcHgsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGFkZCBvYmplY3Qgb3ZlcnJpZGVzXG4gICAgaWYgKHN4KSB7XG4gICAgICAgIFkubWl4KHIsIHN4LCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0gaW5cbiAqIGEgY29sbGVjdGlvbi4gIFN1cHBvcnRzIGFycmF5cywgb2JqZWN0cywgYW5kXG4gKiBOb2RlTGlzdHNcbiAqIEBtZXRob2QgZWFjaFxuICogQHBhcmFtIHtvYmplY3R9IG8gdGhlIG9iamVjdCB0byBpdGVyYXRlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZiB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZS4gIFRoaXMgZnVuY3Rpb25cbiAqIHJlY2VpdmVzIHRoZSB2YWx1ZSwga2V5LCBhbmQgb2JqZWN0IGFzIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge29iamVjdH0gYyB0aGUgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvdG8gaWYgdHJ1ZSwgcHJvdG90eXBlIHByb3BlcnRpZXMgYXJlXG4gKiBpdGVyYXRlZCBvbiBvYmplY3RzLlxuICogQHJldHVybiB7WVVJfSB0aGUgWVVJIGluc3RhbmNlLlxuICovXG5ZLmVhY2ggPSBmdW5jdGlvbihvLCBmLCBjLCBwcm90bykge1xuICAgIHJldHVybiBkaXNwYXRjaChvLCBmLCBjLCBwcm90bywgJ2VhY2gnKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0gaW5cbiAqIGEgY29sbGVjdGlvbi4gIFRoZSBvcGVyYXRpb24gc3RvcHMgaWYgdGhlIGZ1bmN0aW9uXG4gKiByZXR1cm5zIHRydWUuIFN1cHBvcnRzIGFycmF5cywgb2JqZWN0cywgYW5kXG4gKiBOb2RlTGlzdHMuXG4gKiBAbWV0aG9kIHNvbWVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvIHRoZSBvYmplY3QgdG8gaXRlcmF0ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGYgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuICBUaGlzIGZ1bmN0aW9uXG4gKiByZWNlaXZlcyB0aGUgdmFsdWUsIGtleSwgYW5kIG9iamVjdCBhcyBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtvYmplY3R9IGMgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHByb3RvIGlmIHRydWUsIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFyZVxuICogaXRlcmF0ZWQgb24gb2JqZWN0cy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGZ1bmN0aW9uIGV2ZXIgcmV0dXJucyB0cnVlLFxuICogZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5ZLnNvbWUgPSBmdW5jdGlvbihvLCBmLCBjLCBwcm90bykge1xuICAgIHJldHVybiBkaXNwYXRjaChvLCBmLCBjLCBwcm90bywgJ3NvbWUnKTtcbn07XG5cbi8qKlxuRGVlcCBvYmplY3QvYXJyYXkgY29weS4gRnVuY3Rpb24gY2xvbmVzIGFyZSBhY3R1YWxseSB3cmFwcGVycyBhcm91bmQgdGhlXG5vcmlnaW5hbCBmdW5jdGlvbi4gQXJyYXktbGlrZSBvYmplY3RzIGFyZSB0cmVhdGVkIGFzIGFycmF5cy4gUHJpbWl0aXZlcyBhcmVcbnJldHVybmVkIHVudG91Y2hlZC4gT3B0aW9uYWxseSwgYSBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWQgdG8gaGFuZGxlIG90aGVyIGRhdGFcbnR5cGVzLCBmaWx0ZXIga2V5cywgdmFsaWRhdGUgdmFsdWVzLCBldGMuXG5cbioqTm90ZToqKiBDbG9uaW5nIGEgbm9uLXRyaXZpYWwgb2JqZWN0IGlzIGEgcmVhc29uYWJseSBoZWF2eSBvcGVyYXRpb24sIGR1ZSB0b1xudGhlIG5lZWQgdG8gcmVjdXJzaXZlbHkgaXRlcmF0ZSBkb3duIG5vbi1wcmltaXRpdmUgcHJvcGVydGllcy4gQ2xvbmUgc2hvdWxkIGJlXG51c2VkIG9ubHkgd2hlbiBhIGRlZXAgY2xvbmUgZG93biB0byBsZWFmIGxldmVsIHByb3BlcnRpZXMgaXMgZXhwbGljaXRseVxucmVxdWlyZWQuIFRoaXMgbWV0aG9kIHdpbGwgYWxzb1xuXG5JbiBtYW55IGNhc2VzIChmb3IgZXhhbXBsZSwgd2hlbiB0cnlpbmcgdG8gaXNvbGF0ZSBvYmplY3RzIHVzZWQgYXMgaGFzaGVzIGZvclxuY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzKSwgYSBzaGFsbG93IGNvcHksIHVzaW5nIGBZLm1lcmdlKClgIGlzIG5vcm1hbGx5XG5zdWZmaWNpZW50LiBJZiBtb3JlIHRoYW4gb25lIGxldmVsIG9mIGlzb2xhdGlvbiBpcyByZXF1aXJlZCwgYFkubWVyZ2UoKWAgY2FuIGJlXG51c2VkIHNlbGVjdGl2ZWx5IGF0IGVhY2ggbGV2ZWwgd2hpY2ggbmVlZHMgdG8gYmUgaXNvbGF0ZWQgZnJvbSB0aGUgb3JpZ2luYWxcbndpdGhvdXQgZ29pbmcgYWxsIHRoZSB3YXkgdG8gbGVhZiBwcm9wZXJ0aWVzLlxuXG5AbWV0aG9kIGNsb25lXG5AcGFyYW0ge29iamVjdH0gbyB3aGF0IHRvIGNsb25lLlxuQHBhcmFtIHtib29sZWFufSBzYWZlIGlmIHRydWUsIG9iamVjdHMgd2lsbCBub3QgaGF2ZSBwcm90b3R5cGUgaXRlbXMgZnJvbSB0aGVcbiAgICBzb3VyY2UuIElmIGZhbHNlLCB0aGV5IHdpbGwuIEluIHRoaXMgY2FzZSwgdGhlIG9yaWdpbmFsIGlzIGluaXRpYWxseVxuICAgIHByb3RlY3RlZCwgYnV0IHRoZSBjbG9uZSBpcyBub3QgY29tcGxldGVseSBpbW11bmUgZnJvbSBjaGFuZ2VzIHRvIHRoZSBzb3VyY2VcbiAgICBvYmplY3QgcHJvdG90eXBlLiBBbHNvLCBjbG9uZWQgcHJvdG90eXBlIGl0ZW1zIHRoYXQgYXJlIGRlbGV0ZWQgZnJvbSB0aGVcbiAgICBjbG9uZSB3aWxsIHJlc3VsdCBpbiB0aGUgdmFsdWUgb2YgdGhlIHNvdXJjZSBwcm90b3R5cGUgYmVpbmcgZXhwb3NlZC4gSWZcbiAgICBvcGVyYXRpbmcgb24gYSBub24tc2FmZSBjbG9uZSwgaXRlbXMgc2hvdWxkIGJlIG51bGxlZCBvdXQgcmF0aGVyIHRoYW5cbiAgICBkZWxldGVkLlxuQHBhcmFtIHtmdW5jdGlvbn0gZiBvcHRpb25hbCBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYSBjb2xsZWN0aW9uOyBpdFxuICAgIHdpbGwgYmUgZXhlY3V0ZWQgcHJpb3IgdG8gYXBwbHlpbmcgdGhlIHZhbHVlIHRvIHRoZSBuZXcgb2JqZWN0LlxuICAgIFJldHVybiBmYWxzZSB0byBwcmV2ZW50IHRoZSBjb3B5LlxuQHBhcmFtIHtvYmplY3R9IGMgb3B0aW9uYWwgZXhlY3V0aW9uIGNvbnRleHQgZm9yIGYuXG5AcGFyYW0ge29iamVjdH0gb3duZXIgT3duZXIgb2JqZWN0IHBhc3NlZCB3aGVuIGNsb25lIGlzIGl0ZXJhdGluZyBhbiBvYmplY3QuXG4gICAgVXNlZCB0byBzZXQgdXAgY29udGV4dCBmb3IgY2xvbmVkIGZ1bmN0aW9ucy5cbkBwYXJhbSB7b2JqZWN0fSBjbG9uZWQgaGFzaCBvZiBwcmV2aW91c2x5IGNsb25lZCBvYmplY3RzIHRvIGF2b2lkIG11bHRpcGxlXG4gICAgY2xvbmVzLlxuQHJldHVybiB7QXJyYXl8T2JqZWN0fSB0aGUgY2xvbmVkIG9iamVjdC5cbioqL1xuWS5jbG9uZSA9IGZ1bmN0aW9uKG8sIHNhZmUsIGYsIGMsIG93bmVyLCBjbG9uZWQpIHtcbiAgICB2YXIgbzIsIG1hcmtlZCwgc3RhbXA7XG5cbiAgICAvLyBEb2VzIG5vdCBhdHRlbXB0IHRvIGNsb25lOlxuICAgIC8vXG4gICAgLy8gKiBOb24tdHlwZW9mLW9iamVjdCB2YWx1ZXMsIFwicHJpbWl0aXZlXCIgdmFsdWVzIGRvbid0IG5lZWQgY2xvbmluZy5cbiAgICAvL1xuICAgIC8vICogWVVJIGluc3RhbmNlcywgY2xvbmluZyBjb21wbGV4IG9iamVjdCBsaWtlIFlVSSBpbnN0YW5jZXMgaXMgbm90XG4gICAgLy8gICBhZHZpc2VkLCB0aGlzIGlzIGxpa2UgY2xvbmluZyB0aGUgd29ybGQuXG4gICAgLy9cbiAgICAvLyAqIERPTSBub2RlcyAoIzI1MjgyNTApLCBjb21tb24gaG9zdCBvYmplY3RzIGxpa2UgRE9NIG5vZGVzIGNhbm5vdCBiZVxuICAgIC8vICAgXCJzdWJjbGFzc2VkXCIgaW4gRmlyZWZveCBhbmQgb2xkIHZlcnNpb25zIG9mIElFLiBUcnlpbmcgdG8gdXNlXG4gICAgLy8gICBgT2JqZWN0LmNyZWF0ZSgpYCBvciBgWS5leHRlbmQoKWAgb24gYSBET00gbm9kZSB3aWxsIHRocm93IGFuIGVycm9yIGluXG4gICAgLy8gICB0aGVzZSBicm93c2Vycy5cbiAgICAvL1xuICAgIC8vIEluc3RhZCwgdGhlIHBhc3NlZC1pbiBgb2Agd2lsbCBiZSByZXR1cm4gYXMtaXMgd2hlbiBpdCBtYXRjaGVzIG9uZSBvZiB0aGVcbiAgICAvLyBhYm92ZSBjcml0ZXJpYS5cbiAgICBpZiAoIUwuaXNPYmplY3QobykgfHxcbiAgICAgICAgICAgIFkuaW5zdGFuY2VPZihvLCBZVUkpIHx8XG4gICAgICAgICAgICAoby5hZGRFdmVudExpc3RlbmVyIHx8IG8uYXR0YWNoRXZlbnQpKSB7XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuXG4gICAgbWFya2VkID0gY2xvbmVkIHx8IHt9O1xuXG4gICAgc3dpdGNoIChMLnR5cGUobykpIHtcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobyk7XG4gICAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgICAgICAvLyBpZiB3ZSBkbyB0aGlzIHdlIG5lZWQgdG8gc2V0IHRoZSBmbGFncyB0b29cbiAgICAgICAgICAgIC8vIHJldHVybiBuZXcgUmVnRXhwKG8uc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAvLyBvMiA9IFkuYmluZChvLCBvd25lcik7XG4gICAgICAgICAgICAvLyBicmVhaztcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICBvMiA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgIC8vICMyNTI4MjUwIG9ubHkgb25lIGNsb25lIG9mIGEgZ2l2ZW4gb2JqZWN0IHNob3VsZCBiZSBjcmVhdGVkLlxuICAgICAgICAgICAgaWYgKG9bQ0xPTkVfTUFSS0VSXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZWRbb1tDTE9ORV9NQVJLRVJdXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhbXAgPSBZLmd1aWQoKTtcblxuICAgICAgICAgICAgaWYgKHNhZmUpIHtcbiAgICAgICAgICAgICAgbzIgPSB7fVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc3FzcCBjaGFuZ2UgdG8gWVVJXG4gICAgICAgICAgICAgIC8vIE1vZGVsIGRhdGEgZmlyc3Qgc2V0IGJ5IGBpbW1lcmAgbWFrZXMgZWFjaCBmaWVsZCBoYXZlIHByb3BlcnR5IGB3cml0ZWFibGU6IGZhbHNlYC4gV2Ugc2hhbGxvdyBjbG9uZVxuICAgICAgICAgICAgICAvLyBvIHNvIG8yJ3MgcHJvdG90eXBlIGZpZWxkcyBhcmUgd3JpdGVhYmxlIGFuZCBjYW4gYmUgcHV0IG9uIG8ywqBwcm9wZXJseSBpbiBZLmVhY2ggYmVsb3dcbiAgICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXlUb0NvcHlUb1Byb3RvdHlwZSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5VG9Db3B5VG9Qcm90b3R5cGUpKSB7XG4gICAgICAgICAgICAgICAgICBwcm90b3R5cGVba2V5VG9Db3B5VG9Qcm90b3R5cGVdID0gb1trZXlUb0NvcHlUb1Byb3RvdHlwZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG8yID0gWS5PYmplY3QocHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb1tDTE9ORV9NQVJLRVJdID0gc3RhbXA7XG4gICAgICAgICAgICBtYXJrZWRbc3RhbXBdID0gbztcbiAgICB9XG5cbiAgICBZLmVhY2gobywgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoKGsgfHwgayA9PT0gMCkgJiYgKCFmIHx8IChmLmNhbGwoYyB8fCB0aGlzLCB2LCBrLCB0aGlzLCBvKSAhPT0gZmFsc2UpKSkge1xuICAgICAgICAgICAgaWYgKGsgIT09IENMT05FX01BUktFUikge1xuICAgICAgICAgICAgICAgIGlmIChrID09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAob1trXSA9PT0gbykge1xuICAgICAgICAgICAgICAgIC8vICAgICB0aGlzW2tdID0gdGhpcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFkuY2xvbmUodiwgc2FmZSwgZiwgYywgb3duZXIgfHwgbywgbWFya2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBvMik7XG5cbiAgICBpZiAoIWNsb25lZCkge1xuICAgICAgICBZLk9iamVjdC5lYWNoKG1hcmtlZCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgaWYgKHZbQ0xPTkVfTUFSS0VSXSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2W0NMT05FX01BUktFUl07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2W0NMT05FX01BUktFUl0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIG1hcmtlZCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG8yO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIGluIHRoZVxuICogc3VwcGxpZWQgb2JqZWN0J3MgY29udGV4dCwgb3B0aW9uYWxseSBhZGRpbmcgYW55IGFkZGl0aW9uYWxcbiAqIHN1cHBsaWVkIHBhcmFtZXRlcnMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJndW1lbnRzIGNvbGxlY3Rpb24gdGhlXG4gKiBzdXBwbGllZCB0byB0aGUgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZiB0aGUgZnVuY3Rpb24gdG8gYmluZCwgb3IgYSBmdW5jdGlvbiBuYW1lXG4gKiB0byBleGVjdXRlIG9uIHRoZSBjb250ZXh0IG9iamVjdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjIHRoZSBleGVjdXRpb24gY29udGV4dC5cbiAqIEBwYXJhbSB7YW55fSBhcmdzKiAwLi5uIGFyZ3VtZW50cyB0byBpbmNsdWRlIGJlZm9yZSB0aGUgYXJndW1lbnRzIHRoZVxuICogZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSB0aGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuWS5iaW5kID0gZnVuY3Rpb24oZiwgYykge1xuICAgIHZhciB4YXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID9cbiAgICAgICAgICAgIFkuQXJyYXkoYXJndW1lbnRzLCAyLCB0cnVlKSA6IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZm4gPSBMLmlzU3RyaW5nKGYpID8gY1tmXSA6IGYsXG4gICAgICAgICAgICBhcmdzID0gKHhhcmdzKSA/XG4gICAgICAgICAgICAgICAgeGFyZ3MuY29uY2F0KFkuQXJyYXkoYXJndW1lbnRzLCAwLCB0cnVlKSkgOiBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjIHx8IGZuLCBhcmdzKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIGluIHRoZVxuICogc3VwcGxpZWQgb2JqZWN0J3MgY29udGV4dCwgb3B0aW9uYWxseSBhZGRpbmcgYW55IGFkZGl0aW9uYWxcbiAqIHN1cHBsaWVkIHBhcmFtZXRlcnMgdG8gdGhlIGVuZCBvZiB0aGUgYXJndW1lbnRzIHRoZSBmdW5jdGlvblxuICogaXMgZXhlY3V0ZWQgd2l0aC5cbiAqXG4gKiBAbWV0aG9kIHJiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZiB0aGUgZnVuY3Rpb24gdG8gYmluZCwgb3IgYSBmdW5jdGlvbiBuYW1lXG4gKiB0byBleGVjdXRlIG9uIHRoZSBjb250ZXh0IG9iamVjdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjIHRoZSBleGVjdXRpb24gY29udGV4dC5cbiAqIEBwYXJhbSB7YW55fSBhcmdzKiAwLi5uIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhlIGVuZCBvZlxuICogYXJndW1lbnRzIGNvbGxlY3Rpb24gc3VwcGxpZWQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQHJldHVybiB7ZnVuY3Rpb259IHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5ZLnJiaW5kID0gZnVuY3Rpb24oZiwgYykge1xuICAgIHZhciB4YXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gWS5BcnJheShhcmd1bWVudHMsIDIsIHRydWUpIDogbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmbiA9IEwuaXNTdHJpbmcoZikgPyBjW2ZdIDogZixcbiAgICAgICAgICAgIGFyZ3MgPSAoeGFyZ3MpID9cbiAgICAgICAgICAgICAgICBZLkFycmF5KGFyZ3VtZW50cywgMCwgdHJ1ZSkuY29uY2F0KHhhcmdzKSA6IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGMgfHwgZm4sIGFyZ3MpO1xuICAgIH07XG59O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJ5dWktYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdwbHVnaW4nLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgdGhlIGJhc2UgUGx1Z2luIGNsYXNzLCB3aGljaCBwbHVnaW4gZGV2ZWxvcGVycyBzaG91bGQgZXh0ZW5kLCB3aGVuIGNyZWF0aW5nIGN1c3RvbSBwbHVnaW5zXG4gICAgICpcbiAgICAgKiBAbW9kdWxlIHBsdWdpblxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBQbHVnaW4gaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQGNsYXNzIFBsdWdpbi5CYXNlXG4gICAgICogQGV4dGVuZHMgQmFzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBwcm9wZXJ0eSBuYW1lL3ZhbHVlIHBhaXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBsdWdpbihjb25maWcpIHtcbiAgICAgICAgaWYgKCEgKHRoaXMuaGFzSW1wbCAmJiB0aGlzLmhhc0ltcGwoWS5QbHVnaW4uQmFzZSkpICkge1xuICAgICAgICAgICAgUGx1Z2luLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFBsdWdpbi5wcm90b3R5cGUuaW5pdGlhbGl6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBkZWZpbmluZyB0aGUgc2V0IG9mIGF0dHJpYnV0ZXMgc3VwcG9ydGVkIGJ5IHRoZSBQbHVnaW4uQmFzZSBjbGFzc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IEFUVFJTXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIFBsdWdpbi5BVFRSUyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBsdWdpbidzIGhvc3Qgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0cmlidXRlIGhvc3RcbiAgICAgICAgICogQHdyaXRlb25jZVxuICAgICAgICAgKiBAdHlwZSBQbHVnaW4uSG9zdFxuICAgICAgICAgKi9cbiAgICAgICAgaG9zdCA6IHtcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIFBsdWdpbi5CYXNlIGNsYXNzLiBQbHVnaW5zIGV4dGVuZGluZ1xuICAgICAqIFBsdWdpbi5CYXNlIHNob3VsZCBzZXQgdGhlaXIgb3duIE5BTUUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgTkFNRVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBQbHVnaW4uTkFNRSA9ICdwbHVnaW4nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoZSB0aGUgcGx1Z2luIHdpbGwgYmUgYXR0YWNoZWQgdG9cbiAgICAgKiB3aGVuIHBsdWdnZWQgaW50byBhIFBsdWdpbiBIb3N0LiBQbHVnaW5zIGV4dGVuZGluZyBQbHVnaW4uQmFzZSxcbiAgICAgKiBzaG91bGQgc2V0IHRoZWlyIG93biBOUyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBOU1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBQbHVnaW4uTlMgPSAncGx1Z2luJztcblxuICAgIFkuZXh0ZW5kKFBsdWdpbiwgWS5CYXNlLCB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIGV2ZW50IGhhbmRsZXMgZm9yIGV2ZW50IGxpc3RlbmVycyBvciBBT1AgaW5qZWN0ZWQgbWV0aG9kc1xuICAgICAgICAgKiBhcHBsaWVkIGJ5IHRoZSBwbHVnaW4gdG8gdGhlIGhvc3Qgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2hhbmRsZXNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUgQXJyYXlcbiAgICAgICAgICogQHZhbHVlIG51bGxcbiAgICAgICAgICovXG4gICAgICAgIF9oYW5kbGVzOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplciBsaWZlY3ljbGUgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIHByb3BlcnR5IG5hbWUvdmFsdWUgcGFpcnMuXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplciA6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcyA9IFtdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cnVjdG9yIGxpZmVjeWNsZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogUmVtb3ZlcyBhbnkgZXZlbnQgbGlzdGVuZXJzIG9yIGluamVjdGVkIG1ldGhvZHMgYXBwbGllZCBieSB0aGUgUGx1Z2luXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJ1Y3RvclxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIGhhbmRsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9oYW5kbGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaV0uZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0ZW5zIGZvciB0aGUgXCJvblwiIG1vbWVudCBvZiBldmVudHMgZmlyZWQgYnkgdGhlIGhvc3QsXG4gICAgICAgICAqIG9yIGluamVjdHMgY29kZSBcImJlZm9yZVwiIGEgZ2l2ZW4gbWV0aG9kIG9uIHRoZSBob3N0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGRvQmVmb3JlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdHJNZXRob2Qge1N0cmluZ30gVGhlIGV2ZW50IHRvIGxpc3RlbiBmb3IsIG9yIG1ldGhvZCB0byBpbmplY3QgbG9naWMgYmVmb3JlLlxuICAgICAgICAgKiBAcGFyYW0gZm4ge0Z1bmN0aW9ufSBUaGUgaGFuZGxlciBmdW5jdGlvbi4gRm9yIGV2ZW50cywgdGhlIFwib25cIiBtb21lbnQgbGlzdGVuZXIuIEZvciBtZXRob2RzLCB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBiZWZvcmUgdGhlIGdpdmVuIG1ldGhvZCBpcyBleGVjdXRlZC5cbiAgICAgICAgICogQHBhcmFtIGNvbnRleHQge09iamVjdH0gQW4gb3B0aW9uYWwgY29udGV4dCB0byBjYWxsIHRoZSBoYW5kbGVyIHdpdGguIFRoZSBkZWZhdWx0IGNvbnRleHQgaXMgdGhlIHBsdWdpbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHJldHVybiBoYW5kbGUge0V2ZW50SGFuZGxlfSBUaGUgZGV0YWNoIGhhbmRsZSBmb3IgdGhlIGhhbmRsZXIuXG4gICAgICAgICAqL1xuICAgICAgICBkb0JlZm9yZTogZnVuY3Rpb24oc3RyTWV0aG9kLCBmbiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGhvc3QgPSB0aGlzLmdldChcImhvc3RcIiksIGhhbmRsZTtcblxuICAgICAgICAgICAgaWYgKHN0ck1ldGhvZCBpbiBob3N0KSB7IC8vIG1ldGhvZFxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IHRoaXMuYmVmb3JlSG9zdE1ldGhvZChzdHJNZXRob2QsIGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG9zdC5vbikgeyAvLyBldmVudFxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IHRoaXMub25Ib3N0RXZlbnQoc3RyTWV0aG9kLCBmbiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RlbnMgZm9yIHRoZSBcImFmdGVyXCIgbW9tZW50IG9mIGV2ZW50cyBmaXJlZCBieSB0aGUgaG9zdCxcbiAgICAgICAgICogb3IgaW5qZWN0cyBjb2RlIFwiYWZ0ZXJcIiBhIGdpdmVuIG1ldGhvZCBvbiB0aGUgaG9zdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBkb0FmdGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdHJNZXRob2Qge1N0cmluZ30gVGhlIGV2ZW50IHRvIGxpc3RlbiBmb3IsIG9yIG1ldGhvZCB0byBpbmplY3QgbG9naWMgYWZ0ZXIuXG4gICAgICAgICAqIEBwYXJhbSBmbiB7RnVuY3Rpb259IFRoZSBoYW5kbGVyIGZ1bmN0aW9uLiBGb3IgZXZlbnRzLCB0aGUgXCJhZnRlclwiIG1vbWVudCBsaXN0ZW5lci4gRm9yIG1ldGhvZHMsIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBnaXZlbiBtZXRob2QgaXMgZXhlY3V0ZWQuXG4gICAgICAgICAqIEBwYXJhbSBjb250ZXh0IHtPYmplY3R9IEFuIG9wdGlvbmFsIGNvbnRleHQgdG8gY2FsbCB0aGUgaGFuZGxlciB3aXRoLiBUaGUgZGVmYXVsdCBjb250ZXh0IGlzIHRoZSBwbHVnaW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEByZXR1cm4gaGFuZGxlIHtFdmVudEhhbmRsZX0gVGhlIGRldGFjaCBoYW5kbGUgZm9yIHRoZSBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGRvQWZ0ZXI6IGZ1bmN0aW9uKHN0ck1ldGhvZCwgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBob3N0ID0gdGhpcy5nZXQoXCJob3N0XCIpLCBoYW5kbGU7XG5cbiAgICAgICAgICAgIGlmIChzdHJNZXRob2QgaW4gaG9zdCkgeyAvLyBtZXRob2RcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSB0aGlzLmFmdGVySG9zdE1ldGhvZChzdHJNZXRob2QsIGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG9zdC5hZnRlcikgeyAvLyBldmVudFxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IHRoaXMuYWZ0ZXJIb3N0RXZlbnQoc3RyTWV0aG9kLCBmbiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RlbnMgZm9yIHRoZSBcIm9uXCIgbW9tZW50IG9mIGV2ZW50cyBmaXJlZCBieSB0aGUgaG9zdCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIExpc3RlbmVycyBhdHRhY2hlZCB0aHJvdWdoIHRoaXMgbWV0aG9kIHdpbGwgYmUgZGV0YWNoZWQgd2hlbiB0aGUgcGx1Z2luIGlzIHVucGx1Z2dlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBvbkhvc3RFdmVudFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZyB8IE9iamVjdH0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZXhlY3V0aW9uIGNvbnRleHQuIERlZmF1bHRzIHRvIHRoZSBwbHVnaW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEByZXR1cm4gaGFuZGxlIHtFdmVudEhhbmRsZX0gVGhlIGRldGFjaCBoYW5kbGUgZm9yIHRoZSBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIG9uSG9zdEV2ZW50IDogZnVuY3Rpb24odHlwZSwgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLmdldChcImhvc3RcIikub24odHlwZSwgZm4sIGNvbnRleHQgfHwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2goaGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RlbnMgZm9yIHRoZSBcIm9uXCIgbW9tZW50IG9mIGV2ZW50cyBmaXJlZCBieSB0aGUgaG9zdCBvYmplY3Qgb25lIHRpbWUgb25seS5cbiAgICAgICAgICogVGhlIGxpc3RlbmVyIGlzIGltbWVkaWF0ZWx5IGRldGFjaGVkIHdoZW4gaXQgaXMgZXhlY3V0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIExpc3RlbmVycyBhdHRhY2hlZCB0aHJvdWdoIHRoaXMgbWV0aG9kIHdpbGwgYmUgZGV0YWNoZWQgd2hlbiB0aGUgcGx1Z2luIGlzIHVucGx1Z2dlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBvbmNlSG9zdEV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgT2JqZWN0fSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBleGVjdXRpb24gY29udGV4dC4gRGVmYXVsdHMgdG8gdGhlIHBsdWdpbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHJldHVybiBoYW5kbGUge0V2ZW50SGFuZGxlfSBUaGUgZGV0YWNoIGhhbmRsZSBmb3IgdGhlIGxpc3RlbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgb25jZUhvc3RFdmVudCA6IGZ1bmN0aW9uKHR5cGUsIGZuLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gdGhpcy5nZXQoXCJob3N0XCIpLm9uY2UodHlwZSwgZm4sIGNvbnRleHQgfHwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2goaGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RlbnMgZm9yIHRoZSBcImFmdGVyXCIgbW9tZW50IG9mIGV2ZW50cyBmaXJlZCBieSB0aGUgaG9zdCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIExpc3RlbmVycyBhdHRhY2hlZCB0aHJvdWdoIHRoaXMgbWV0aG9kIHdpbGwgYmUgZGV0YWNoZWQgd2hlbiB0aGUgcGx1Z2luIGlzIHVucGx1Z2dlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhZnRlckhvc3RFdmVudFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZyB8IE9iamVjdH0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZXhlY3V0aW9uIGNvbnRleHQuIERlZmF1bHRzIHRvIHRoZSBwbHVnaW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEByZXR1cm4gaGFuZGxlIHtFdmVudEhhbmRsZX0gVGhlIGRldGFjaCBoYW5kbGUgZm9yIHRoZSBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGFmdGVySG9zdEV2ZW50IDogZnVuY3Rpb24odHlwZSwgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLmdldChcImhvc3RcIikuYWZ0ZXIodHlwZSwgZm4sIGNvbnRleHQgfHwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2goaGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RlbnMgZm9yIHRoZSBcImFmdGVyXCIgbW9tZW50IG9mIGV2ZW50cyBmaXJlZCBieSB0aGUgaG9zdCBvYmplY3Qgb25lIHRpbWUgb25seS5cbiAgICAgICAgICogVGhlIGxpc3RlbmVyIGlzIGltbWVkaWF0ZWx5IGRldGFjaGVkIHdoZW4gaXQgaXMgZXhlY3V0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIExpc3RlbmVycyBhdHRhY2hlZCB0aHJvdWdoIHRoaXMgbWV0aG9kIHdpbGwgYmUgZGV0YWNoZWQgd2hlbiB0aGUgcGx1Z2luIGlzIHVucGx1Z2dlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBvbmNlQWZ0ZXJIb3N0RXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmcgfCBPYmplY3R9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lci5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGV4ZWN1dGlvbiBjb250ZXh0LiBEZWZhdWx0cyB0byB0aGUgcGx1Z2luIGluc3RhbmNlLlxuICAgICAgICAgKiBAcmV0dXJuIGhhbmRsZSB7RXZlbnRIYW5kbGV9IFRoZSBkZXRhY2ggaGFuZGxlIGZvciB0aGUgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBvbmNlQWZ0ZXJIb3N0RXZlbnQgOiBmdW5jdGlvbih0eXBlLCBmbiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMuZ2V0KFwiaG9zdFwiKS5vbmNlQWZ0ZXIodHlwZSwgZm4sIGNvbnRleHQgfHwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2goaGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluamVjdHMgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBiZWZvcmUgYSBnaXZlbiBtZXRob2Qgb24gaG9zdCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGRldGFjaGVkIHdoZW4gdGhlIHBsdWdpbiBpcyB1bnBsdWdnZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgYmVmb3JlSG9zdE1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW5qZWN0IHRoZSBmdW5jdGlvbiBiZWZvcmUuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBleGVjdXRpb24gY29udGV4dC4gRGVmYXVsdHMgdG8gdGhlIHBsdWdpbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHJldHVybiBoYW5kbGUge0V2ZW50SGFuZGxlfSBUaGUgZGV0YWNoIGhhbmRsZSBmb3IgdGhlIGluamVjdGVkIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlSG9zdE1ldGhvZCA6IGZ1bmN0aW9uKHN0ck1ldGhvZCwgZm4sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBZLkRvLmJlZm9yZShmbiwgdGhpcy5nZXQoXCJob3N0XCIpLCBzdHJNZXRob2QsIGNvbnRleHQgfHwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2goaGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluamVjdHMgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBhIGdpdmVuIG1ldGhvZCBvbiBob3N0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIHdpbGwgYmUgZGV0YWNoZWQgd2hlbiB0aGUgcGx1Z2luIGlzIHVucGx1Z2dlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhZnRlckhvc3RNZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGluamVjdCB0aGUgZnVuY3Rpb24gYWZ0ZXIuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBleGVjdXRpb24gY29udGV4dC4gRGVmYXVsdHMgdG8gdGhlIHBsdWdpbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHJldHVybiBoYW5kbGUge0V2ZW50SGFuZGxlfSBUaGUgZGV0YWNoIGhhbmRsZSBmb3IgdGhlIGluamVjdGVkIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJIb3N0TWV0aG9kIDogZnVuY3Rpb24oc3RyTWV0aG9kLCBmbiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IFkuRG8uYWZ0ZXIoZm4sIHRoaXMuZ2V0KFwiaG9zdFwiKSwgc3RyTWV0aG9kLCBjb250ZXh0IHx8IHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcy5wdXNoKGhhbmRsZSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLk5BTUUgKyAnWycgKyB0aGlzLmNvbnN0cnVjdG9yLk5TICsgJ10nO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBZLm5hbWVzcGFjZShcIlBsdWdpblwiKS5CYXNlID0gUGx1Z2luO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJiYXNlLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgncGx1Z2luaG9zdC1iYXNlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBhdWdtZW50YWJsZSBQbHVnaW5Ib3N0IGludGVyZmFjZSwgd2hpY2ggY2FuIGJlIGFkZGVkIHRvIGFueSBjbGFzcy5cbiAgICAgKiBAbW9kdWxlIHBsdWdpbmhvc3RcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBhdWdtZW50YWJsZSBQbHVnaW5Ib3N0IGludGVyZmFjZSwgd2hpY2ggY2FuIGJlIGFkZGVkIHRvIGFueSBjbGFzcy5cbiAgICAgKiBAbW9kdWxlIHBsdWdpbmhvc3QtYmFzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogPHA+XG4gICAgICogQW4gYXVnbWVudGFibGUgY2xhc3MsIHdoaWNoIHByb3ZpZGVzIHRoZSBhdWdtZW50ZWQgY2xhc3Mgd2l0aCB0aGUgYWJpbGl0eSB0byBob3N0IHBsdWdpbnMuXG4gICAgICogSXQgYWRkcyA8YSBocmVmPVwiI21ldGhvZF9wbHVnXCI+cGx1ZzwvYT4gYW5kIDxhIGhyZWY9XCIjbWV0aG9kX3VucGx1Z1wiPnVucGx1ZzwvYT4gbWV0aG9kcyB0byB0aGUgYXVnbWVudGVkIGNsYXNzLCB3aGljaCBjYW5cbiAgICAgKiBiZSB1c2VkIHRvIGFkZCBvciByZW1vdmUgcGx1Z2lucyBmcm9tIGluc3RhbmNlcyBvZiB0aGUgY2xhc3MuXG4gICAgICogPC9wPlxuICAgICAqXG4gICAgICogPHA+UGx1Z2lucyBjYW4gYWxzbyBiZSBhZGRlZCB0aHJvdWdoIHRoZSBjb25zdHJ1Y3RvciBjb25maWd1cmF0aW9uIG9iamVjdCBwYXNzZWQgdG8gdGhlIGhvc3QgY2xhc3MnIGNvbnN0cnVjdG9yIHVzaW5nXG4gICAgICogdGhlIFwicGx1Z2luc1wiIHByb3BlcnR5LiBTdXBwb3J0ZWQgdmFsdWVzIGZvciB0aGUgXCJwbHVnaW5zXCIgcHJvcGVydHkgYXJlIHRob3NlIGRlZmluZWQgYnkgdGhlIDxhIGhyZWY9XCIjbWV0aG9kX3BsdWdcIj5wbHVnPC9hPiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSB0aGUgZm9sbG93aW5nIGNvZGUgd291bGQgYWRkIHRoZSBBbmltUGx1Z2luIGFuZCBJT1BsdWdpbiB0byBPdmVybGF5ICh0aGUgcGx1Z2luIGhvc3QpOlxuICAgICAqIDx4bXA+XG4gICAgICogdmFyIG8gPSBuZXcgT3ZlcmxheSh7cGx1Z2luczogWyBBbmltUGx1Z2luLCB7Zm46SU9QbHVnaW4sIGNmZzp7c2VjdGlvbjpcImhlYWRlclwifX1dfSk7XG4gICAgICogPC94bXA+XG4gICAgICogPC9wPlxuICAgICAqIDxwPlxuICAgICAqIFBsdWcuSG9zdCdzIHByb3RlY3RlZCA8YSBocmVmPVwiI21ldGhvZF9pbml0UGx1Z2luc1wiPl9pbml0UGx1Z2luczwvYT4gYW5kIDxhIGhyZWY9XCIjbWV0aG9kX2Rlc3Ryb3lQbHVnaW5zXCI+X2Rlc3Ryb3lQbHVnaW5zPC9hPlxuICAgICAqIG1ldGhvZHMgc2hvdWxkIGJlIGludm9rZWQgYnkgdGhlIGhvc3QgY2xhc3MgYXQgdGhlIGFwcHJvcHJpYXRlIHBvaW50IGluIHRoZSBob3N0J3MgbGlmZWN5bGUuXG4gICAgICogPC9wPlxuICAgICAqXG4gICAgICogQGNsYXNzIFBsdWdpbi5Ib3N0XG4gICAgICovXG5cbiAgICB2YXIgTCA9IFkuTGFuZztcblxuICAgIGZ1bmN0aW9uIFBsdWdpbkhvc3QoKSB7XG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSB7fTtcbiAgICB9XG5cbiAgICBQbHVnaW5Ib3N0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIHBsdWdpbiB0byB0aGUgaG9zdCBvYmplY3QuIFRoaXMgd2lsbCBpbnN0YW50aWF0ZSB0aGVcbiAgICAgICAgICogcGx1Z2luIGFuZCBhdHRhY2ggaXQgdG8gdGhlIGNvbmZpZ3VyZWQgbmFtZXNwYWNlIG9uIHRoZSBob3N0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwbHVnXG4gICAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAgICogQHBhcmFtIFAge0Z1bmN0aW9uIHwgT2JqZWN0IHxBcnJheX0gQWNjZXB0cyB0aGUgcGx1Z2luIGNsYXNzLCBvciBhblxuICAgICAgICAgKiBvYmplY3Qgd2l0aCBhIFwiZm5cIiBwcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSBwbHVnaW4gY2xhc3MgYW5kXG4gICAgICAgICAqIGEgXCJjZmdcIiBwcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgUGx1Z2luLlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogQWRkaXRpb25hbGx5IGFuIEFycmF5IGNhbiBhbHNvIGJlIHBhc3NlZCBpbiwgd2l0aCB0aGUgYWJvdmUgZnVuY3Rpb24gb3JcbiAgICAgICAgICogb2JqZWN0IHZhbHVlcywgYWxsb3dpbmcgdGhlIHVzZXIgdG8gYWRkIG11bHRpcGxlIHBsdWdpbnMgaW4gYSBzaW5nbGUgY2FsbC5cbiAgICAgICAgICogPC9wPlxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnIChPcHRpb25hbCkgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBwbHVnaW4gY2xhc3MsIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAgICAgICAgICogY2FuIGJlIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgcGx1Z2luLlxuICAgICAgICAgKiBAcmV0dXJuIHtCYXNlfSBBIHJlZmVyZW5jZSB0byB0aGUgaG9zdCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHBsdWc6IGZ1bmN0aW9uKFBsdWdpbiwgY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgaSwgbG4sIG5zO1xuXG4gICAgICAgICAgICBpZiAoTC5pc0FycmF5KFBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsbiA9IFBsdWdpbi5sZW5ndGg7IGkgPCBsbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1ZyhQbHVnaW5baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFBsdWdpbiAmJiAhTC5pc0Z1bmN0aW9uKFBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gUGx1Z2luLmNmZztcbiAgICAgICAgICAgICAgICAgICAgUGx1Z2luID0gUGx1Z2luLmZuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFBsdWdpbiBzaG91bGQgYmUgZm4gYnkgbm93XG4gICAgICAgICAgICAgICAgaWYgKFBsdWdpbiAmJiBQbHVnaW4uTlMpIHtcbiAgICAgICAgICAgICAgICAgICAgbnMgPSBQbHVnaW4uTlM7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuaG9zdCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKG5zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbbnNdLnNldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tuc10uc2V0QXR0cnMoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbnNdID0gbmV3IFBsdWdpbihjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGx1Z2luc1tuc10gPSBQbHVnaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIHBsdWdpbiBmcm9tIHRoZSBob3N0IG9iamVjdC4gVGhpcyB3aWxsIGRlc3Ryb3kgdGhlXG4gICAgICAgICAqIHBsdWdpbiBpbnN0YW5jZSBhbmQgZGVsZXRlIHRoZSBuYW1lc3BhY2UgZnJvbSB0aGUgaG9zdCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgdW5wbHVnXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgRnVuY3Rpb259IHBsdWdpbiBUaGUgbmFtZXNwYWNlIG9mIHRoZSBwbHVnaW4sIG9yIHRoZSBwbHVnaW4gY2xhc3Mgd2l0aCB0aGUgc3RhdGljIE5TIG5hbWVzcGFjZSBwcm9wZXJ0eSBkZWZpbmVkLiBJZiBub3QgcHJvdmlkZWQsXG4gICAgICAgICAqIGFsbCByZWdpc3RlcmVkIHBsdWdpbnMgYXJlIHVucGx1Z2dlZC5cbiAgICAgICAgICogQHJldHVybiB7QmFzZX0gQSByZWZlcmVuY2UgdG8gdGhlIGhvc3Qgb2JqZWN0XG4gICAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAgICovXG4gICAgICAgIHVucGx1ZzogZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgICAgICB2YXIgbnMgPSBwbHVnaW4sXG4gICAgICAgICAgICAgICAgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbnM7XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoTC5pc0Z1bmN0aW9uKHBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbnMgPSBwbHVnaW4uTlM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChucyAmJiAoIXBsdWdpbnNbbnNdIHx8IHBsdWdpbnNbbnNdICE9PSBwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBucyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbbnNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tuc10uZGVzdHJveSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbnNdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW25zXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luc1tuc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwbHVnaW5zW25zXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChucyBpbiB0aGlzLl9wbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wbHVnaW5zLmhhc093blByb3BlcnR5KG5zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bnBsdWcobnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgYSBwbHVnaW4gaGFzIHBsdWdnZWQgaW50byB0aGlzIGhvc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaGFzUGx1Z2luXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBucyBUaGUgcGx1Z2luJ3MgbmFtZXNwYWNlXG4gICAgICAgICAqIEByZXR1cm4ge1BsdWdpbn0gUmV0dXJucyBhIHRydXRoeSB2YWx1ZSAodGhlIHBsdWdpbiBpbnN0YW5jZSkgaWYgcHJlc2VudCwgb3IgdW5kZWZpbmVkIGlmIG5vdC5cbiAgICAgICAgICovXG4gICAgICAgIGhhc1BsdWdpbiA6IGZ1bmN0aW9uKG5zKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3BsdWdpbnNbbnNdICYmIHRoaXNbbnNdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgc3RhdGljIHBsdWdpbnMgcmVnaXN0ZXJlZCBvbiB0aGUgaG9zdCAodXNpbmcgdGhlXG4gICAgICAgICAqIEJhc2UucGx1ZyBzdGF0aWMgbWV0aG9kKSBhbmQgYW55IHBsdWdpbnMgcGFzc2VkIHRvIHRoZVxuICAgICAgICAgKiBpbnN0YW5jZSB0aHJvdWdoIHRoZSBcInBsdWdpbnNcIiBjb25maWd1cmF0aW9uIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIF9pbml0UGx1Z2luc1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIHByb3BlcnR5IG5hbWUvdmFsdWUgcGFpcnMuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgICAgIF9pbml0UGx1Z2luczogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLl9wbHVnaW5zID0gdGhpcy5fcGx1Z2lucyB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRDb25maWdQbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdENvbmZpZ1BsdWdpbnMoY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5wbHVncyBhbmQgZGVzdHJveXMgYWxsIHBsdWdpbnMgb24gdGhlIGhvc3RcbiAgICAgICAgICogQG1ldGhvZCBfZGVzdHJveVBsdWdpbnNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9kZXN0cm95UGx1Z2luczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnVucGx1ZygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFkubmFtZXNwYWNlKFwiUGx1Z2luXCIpLkhvc3QgPSBQbHVnaW5Ib3N0O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJ5dWktYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdwbHVnaW5ob3N0LWNvbmZpZycsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHBsdWdpbmhvc3QgY29uc3RydWN0b3IgY29uZmlndXJhdGlvbiBhbmQgc3RhdGljIGNvbmZpZ3VyYXRpb24gc3VwcG9ydFxuICAgICAqIEBzdWJtb2R1bGUgcGx1Z2luaG9zdC1jb25maWdcbiAgICAgKi9cblxuICAgIHZhciBQbHVnaW5Ib3N0ID0gWS5QbHVnaW4uSG9zdCxcbiAgICAgICAgTCA9IFkuTGFuZztcblxuICAgIC8qKlxuICAgICAqIEEgcHJvdGVjdGVkIGluaXRpYWxpemF0aW9uIG1ldGhvZCwgdXNlZCBieSB0aGUgaG9zdCBjbGFzcyB0byBpbml0aWFsaXplXG4gICAgICogcGx1Z2luIGNvbmZpZ3VyYXRpb25zIHBhc3NlZCB0aGUgY29uc3RydWN0b3IsIHRocm91Z2ggdGhlIGNvbmZpZyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBIb3N0IG9iamVjdHMgc2hvdWxkIGludm9rZSB0aGlzIG1ldGhvZCBhdCB0aGUgYXBwcm9wcmlhdGUgdGltZSBpbiB0aGVpclxuICAgICAqIGNvbnN0cnVjdGlvbiBsaWZlY3ljbGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9pbml0Q29uZmlnUGx1Z2luc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3JcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGZvciBQbHVnaW4uSG9zdFxuICAgICAqL1xuICAgIFBsdWdpbkhvc3QucHJvdG90eXBlLl9pbml0Q29uZmlnUGx1Z2lucyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuXG4gICAgICAgIC8vIENsYXNzIENvbmZpZ3VyYXRpb25cbiAgICAgICAgdmFyIGNsYXNzZXMgPSAodGhpcy5fZ2V0Q2xhc3NlcykgPyB0aGlzLl9nZXRDbGFzc2VzKCkgOiBbdGhpcy5jb25zdHJ1Y3Rvcl0sXG4gICAgICAgICAgICBwbHVnID0gW10sXG4gICAgICAgICAgICB1bnBsdWcgPSB7fSxcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLCBpLCBjbGFzc1BsdWcsIGNsYXNzVW5wbHVnLCBwbHVnaW5DbGFzc05hbWU7XG5cbiAgICAgICAgLy8gVE9ETzogUm9vbSBmb3Igb3B0aW1pemF0aW9uLiBDYW4gd2UgYXBwbHkgc3RhdGljYWxseS91bnBsdWcgaW4gc2FtZSBwYXNzP1xuICAgICAgICBmb3IgKGkgPSBjbGFzc2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IGNsYXNzZXNbaV07XG5cbiAgICAgICAgICAgIGNsYXNzVW5wbHVnID0gY29uc3RydWN0b3IuX1VOUExVRztcbiAgICAgICAgICAgIGlmIChjbGFzc1VucGx1Zykge1xuICAgICAgICAgICAgICAgIC8vIHN1YmNsYXNzZXMgb3Zlci13cml0ZVxuICAgICAgICAgICAgICAgIFkubWl4KHVucGx1ZywgY2xhc3NVbnBsdWcsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGFzc1BsdWcgPSBjb25zdHJ1Y3Rvci5fUExVRztcbiAgICAgICAgICAgIGlmIChjbGFzc1BsdWcpIHtcbiAgICAgICAgICAgICAgICAvLyBzdWJjbGFzc2VzIG92ZXItd3JpdGVcbiAgICAgICAgICAgICAgICBZLm1peChwbHVnLCBjbGFzc1BsdWcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChwbHVnaW5DbGFzc05hbWUgaW4gcGx1Zykge1xuICAgICAgICAgICAgaWYgKHBsdWcuaGFzT3duUHJvcGVydHkocGx1Z2luQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICghdW5wbHVnW3BsdWdpbkNsYXNzTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnKHBsdWdbcGx1Z2luQ2xhc3NOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlciBDb25maWd1cmF0aW9uXG4gICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIHRoaXMucGx1Zyhjb25maWcucGx1Z2lucyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHBsdWdpbnMgdG8gYmUgaW5zdGFudGlhdGVkIGF0IHRoZSBjbGFzcyBsZXZlbCAocGx1Z2luc1xuICAgICAqIHdoaWNoIHNob3VsZCBiZSBwbHVnZ2VkIGludG8gZXZlcnkgaW5zdGFuY2Ugb2YgdGhlIGNsYXNzIGJ5IGRlZmF1bHQpLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBwbHVnXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9zdENsYXNzIFRoZSBob3N0IGNsYXNzIG9uIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBwbHVnaW5zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbiB8IEFycmF5fSBwbHVnaW4gRWl0aGVyIHRoZSBwbHVnaW4gY2xhc3MsIGFuIGFycmF5IG9mIHBsdWdpbiBjbGFzc2VzIG9yIGFuIGFycmF5IG9mIG9iamVjdHMgKHdpdGggZm4gYW5kIGNmZyBwcm9wZXJ0aWVzIGRlZmluZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAoT3B0aW9uYWwpIElmIHBsdWdpbiBpcyB0aGUgcGx1Z2luIGNsYXNzLCB0aGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIHBsdWdpblxuICAgICAqIEBmb3IgUGx1Z2luLkhvc3RcbiAgICAgKi9cbiAgICBQbHVnaW5Ib3N0LnBsdWcgPSBmdW5jdGlvbihob3N0Q2xhc3MsIHBsdWdpbiwgY29uZmlnKSB7XG4gICAgICAgIC8vIENhbm5vdCBwbHVnIGludG8gQmFzZSwgc2luY2UgUGx1Z2lucyBkZXJpdmUgZnJvbSBCYXNlIFsgd2lsbCBjYXVzZSBpbmZpbml0ZSByZWN1cnJzaW9uIF1cbiAgICAgICAgdmFyIHAsIGksIGwsIG5hbWU7XG5cbiAgICAgICAgaWYgKGhvc3RDbGFzcyAhPT0gWS5CYXNlKSB7XG4gICAgICAgICAgICBob3N0Q2xhc3MuX1BMVUcgPSBob3N0Q2xhc3MuX1BMVUcgfHwge307XG5cbiAgICAgICAgICAgIGlmICghTC5pc0FycmF5KHBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbiA9IHtmbjpwbHVnaW4sIGNmZzpjb25maWd9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwbHVnaW4gPSBbcGx1Z2luXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHBsdWdpbi5sZW5ndGg7IGkgPCBsO2krKykge1xuICAgICAgICAgICAgICAgIHAgPSBwbHVnaW5baV07XG4gICAgICAgICAgICAgICAgbmFtZSA9IHAuTkFNRSB8fCBwLmZuLk5BTUU7XG4gICAgICAgICAgICAgICAgaG9zdENsYXNzLl9QTFVHW25hbWVdID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVycyBhbnkgY2xhc3MgbGV2ZWwgcGx1Z2lucyB3aGljaCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBieSB0aGUgaG9zdCBjbGFzcywgb3IgYW55XG4gICAgICogb3RoZXIgY2xhc3MgaW4gdGhlIGhpZXJhcmNoeS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdW5wbHVnXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9zdENsYXNzIFRoZSBob3N0IGNsYXNzIGZyb20gd2hpY2ggdG8gdW5yZWdpc3RlciB0aGUgcGx1Z2luc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24gfCBBcnJheX0gcGx1Z2luIFRoZSBwbHVnaW4gY2xhc3MsIG9yIGFuIGFycmF5IG9mIHBsdWdpbiBjbGFzc2VzXG4gICAgICogQGZvciBQbHVnaW4uSG9zdFxuICAgICAqL1xuICAgIFBsdWdpbkhvc3QudW5wbHVnID0gZnVuY3Rpb24oaG9zdENsYXNzLCBwbHVnaW4pIHtcbiAgICAgICAgdmFyIHAsIGksIGwsIG5hbWU7XG5cbiAgICAgICAgaWYgKGhvc3RDbGFzcyAhPT0gWS5CYXNlKSB7XG4gICAgICAgICAgICBob3N0Q2xhc3MuX1VOUExVRyA9IGhvc3RDbGFzcy5fVU5QTFVHIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoIUwuaXNBcnJheShwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luID0gW3BsdWdpbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBwbHVnaW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHBsdWdpbltpXTtcbiAgICAgICAgICAgICAgICBuYW1lID0gcC5OQU1FO1xuICAgICAgICAgICAgICAgIGlmICghaG9zdENsYXNzLl9QTFVHW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RDbGFzcy5fVU5QTFVHW25hbWVdID0gcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaG9zdENsYXNzLl9QTFVHW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcInBsdWdpbmhvc3QtYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdwcm9taXNlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG5XcmFwcyB0aGUgZXhlY3V0aW9uIG9mIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLCBwcm92aWRpbmcgYSBwcm9taXNlIG9iamVjdCB0aGF0XG5jYW4gYmUgdXNlZCB0byBzdWJzY3JpYmUgdG8gdGhlIHZhcmlvdXMgd2F5cyB0aGUgb3BlcmF0aW9uIG1heSB0ZXJtaW5hdGUuXG5cbldoZW4gdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5LCBjYWxsIHRoZSBSZXNvbHZlcidzIGByZXNvbHZlKClgXG5tZXRob2QsIHBhc3NpbmcgYW55IHJlbGV2YW50IHJlc3BvbnNlIGRhdGEgZm9yIHN1YnNjcmliZXJzLiAgSWYgdGhlIG9wZXJhdGlvblxuZW5jb3VudGVycyBhbiBlcnJvciBvciBpcyB1bnN1Y2Nlc3NmdWwgaW4gc29tZSB3YXksIGNhbGwgYHJlamVjdCgpYCwgYWdhaW5cbnBhc3NpbmcgYW55IHJlbGV2YW50IGRhdGEgZm9yIHN1YnNjcmliZXJzLlxuXG5UaGUgUmVzb2x2ZXIgb2JqZWN0IHNob3VsZCBiZSBzaGFyZWQgb25seSB3aXRoIHRoZSBjb2RlIHJlc3Bvc2libGUgZm9yXG5yZXNvbHZpbmcgb3IgcmVqZWN0aW5nIGl0LiBQdWJsaWMgYWNjZXNzIGZvciB0aGUgUmVzb2x2ZXIgaXMgdGhyb3VnaCBpdHNcbl9wcm9taXNlXywgd2hpY2ggaXMgcmV0dXJuZWQgZnJvbSB0aGUgUmVzb2x2ZXIncyBgcHJvbWlzZWAgcHJvcGVydHkuIFdoaWxlIGJvdGhcblJlc29sdmVyIGFuZCBwcm9taXNlIGFsbG93IHN1YnNjcmlwdGlvbnMgdG8gdGhlIFJlc29sdmVyJ3Mgc3RhdGUgY2hhbmdlcywgdGhlXG5wcm9taXNlIG1heSBiZSBleHBvc2VkIHRvIG5vbi1jb250cm9sbGluZyBjb2RlLiBJdCBpcyB0aGUgcHJlZmVyYWJsZSBpbnRlcmZhY2VcbmZvciBhZGRpbmcgc3Vic2NyaXB0aW9ucy5cblxuU3Vic2NyaWJlIHRvIHN0YXRlIGNoYW5nZXMgaW4gdGhlIFJlc29sdmVyIHdpdGggdGhlIHByb21pc2Unc1xuYHRoZW4oY2FsbGJhY2ssIGVycmJhY2spYCBtZXRob2QuICBgdGhlbigpYCB3cmFwcyB0aGUgcGFzc2VkIGNhbGxiYWNrcyBpbiBhXG5uZXcgUmVzb2x2ZXIgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcHJvbWlzZSwgYWxsb3dpbmcgY2hhaW5pbmcgb2ZcbmFzeW5jaHJvbm91cyBvciBzeW5jaHJvbm91cyBvcGVyYXRpb25zLiBFLmcuXG5gcHJvbWlzZS50aGVuKHNvbWVBc3luY0Z1bmMpLnRoZW4oYW5vdGhlckFzeW5jRnVuYylgXG5cbkBtb2R1bGUgcHJvbWlzZVxuQHNpbmNlIDMuOS4wXG4qKi9cblxudmFyIExhbmcgID0gWS5MYW5nLFxuICAgIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuQSBwcm9taXNlIHJlcHJlc2VudHMgYSB2YWx1ZSB0aGF0IG1heSBub3QgeWV0IGJlIGF2YWlsYWJsZS4gUHJvbWlzZXMgYWxsb3dcbnlvdSB0byBjaGFpbiBhc3luY2hyb25vdXMgb3BlcmF0aW9ucywgd3JpdGUgc3luY2hyb25vdXMgbG9va2luZyBjb2RlIGFuZFxuaGFuZGxlIGVycm9ycyB0aHJvdWdob3V0IHRoZSBwcm9jZXNzLlxuXG5UaGlzIGNvbnN0cnVjdG9yIHRha2VzIGEgZnVuY3Rpb24gYXMgYSBwYXJhbWV0ZXIgd2hlcmUgeW91IGNhbiBpbnNlcnQgdGhlIGxvZ2ljXG50aGF0IGZ1bGZpbGxzIG9yIHJlamVjdHMgdGhpcyBwcm9taXNlLiBUaGUgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIHRoZSByZWplY3Rpb25cbnJlYXNvbiBjYW4gYmUgYW55IEphdmFTY3JpcHQgdmFsdWUuIEl0J3MgZW5jb3VyYWdlZCB0aGF0IHJlamVjdGlvbiByZWFzb25zIGJlXG5lcnJvciBvYmplY3RzXG5cbjxwcmU+PGNvZGU+XG52YXIgZnVsZmlsbGVkID0gbmV3IFkuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHJlc29sdmUoJ0kgYW0gYSBmdWxmaWxsZWQgcHJvbWlzZScpO1xufSk7XG5cbnZhciByZWplY3RlZCA9IG5ldyBZLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ0kgYW0gYSByZWplY3RlZCBwcm9taXNlJykpO1xufSk7XG48L2NvZGU+PC9wcmU+XG5cbkBjbGFzcyBQcm9taXNlXG5AY29uc3RydWN0b3JcbkBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gd2hlcmUgdG8gaW5zZXJ0IHRoZSBsb2dpYyB0aGF0IHJlc29sdmVzIHRoaXNcbiAgICAgICAgcHJvbWlzZS4gUmVjZWl2ZXMgYHJlc29sdmVgIGFuZCBgcmVqZWN0YCBmdW5jdGlvbnMgYXMgcGFyYW1ldGVycy5cbiAgICAgICAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgc3luY2hyb25vdXNseS5cbioqL1xuZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZm4pO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlciA9IG5ldyBQcm9taXNlLlJlc29sdmVyKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgQSByZWZlcmVuY2UgdG8gdGhlIHJlc29sdmVyIG9iamVjdCB0aGF0IGhhbmRsZXMgdGhpcyBwcm9taXNlXG5cbiAgICBAcHJvcGVydHkgX3Jlc29sdmVyXG4gICAgQHR5cGUgT2JqZWN0XG4gICAgQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuX3Jlc29sdmVyID0gcmVzb2x2ZXI7XG5cbiAgICB0cnkge1xuICAgICAgICBmbi5jYWxsKHRoaXMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZXIucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIHJlc29sdmVyLnJlamVjdChyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlc29sdmVyLnJlamVjdChlKTtcbiAgICB9XG59XG5cblkubWl4KFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgU2NoZWR1bGUgZXhlY3V0aW9uIG9mIGEgY2FsbGJhY2sgdG8gZWl0aGVyIG9yIGJvdGggb2YgXCJmdWxmaWxsXCIgYW5kXG4gICAgXCJyZWplY3RcIiByZXNvbHV0aW9ucyBmb3IgdGhpcyBwcm9taXNlLiBUaGUgY2FsbGJhY2tzIGFyZSB3cmFwcGVkIGluIGEgbmV3XG4gICAgcHJvbWlzZSBhbmQgdGhhdCBwcm9taXNlIGlzIHJldHVybmVkLiAgVGhpcyBhbGxvd3Mgb3BlcmF0aW9uIGNoYWluaW5nIGFsYVxuICAgIGBmdW5jdGlvbkEoKS50aGVuKGZ1bmN0aW9uQikudGhlbihmdW5jdGlvbkMpYCB3aGVyZSBgZnVuY3Rpb25BYCByZXR1cm5zXG4gICAgYSBwcm9taXNlLCBhbmQgYGZ1bmN0aW9uQmAgYW5kIGBmdW5jdGlvbkNgIF9tYXlfIHJldHVybiBwcm9taXNlcy5cblxuICAgIEFzeW5jaHJvbmljaXR5IG9mIHRoZSBjYWxsYmFja3MgaXMgZ3VhcmFudGVlZC5cblxuICAgIEBtZXRob2QgdGhlblxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgIHJlc29sdmVzIHN1Y2Nlc3NmdWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJiYWNrXSBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBwcm9taXNlXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXMgdW5zdWNjZXNzZnVsbHlcbiAgICBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2Ugd3JhcHBpbmcgdGhlIHJlc29sdXRpb24gb2YgZWl0aGVyIFwicmVzb2x2ZVwiIG9yXG4gICAgICAgICAgICAgICAgXCJyZWplY3RcIiBjYWxsYmFja1xuICAgICoqL1xuICAgIHRoZW46IGZ1bmN0aW9uIChjYWxsYmFjaywgZXJyYmFjaykge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgcmVzb2x2ZXIgPSB0aGlzLl9yZXNvbHZlcjtcblxuICAgICAgICAvLyB1c2luZyB0aGlzLmNvbnN0cnVjdG9yIGFsbG93cyBmb3IgY3VzdG9taXplZCBwcm9taXNlcyB0byBiZVxuICAgICAgICAvLyByZXR1cm5lZCBpbnN0ZWFkIG9mIHBsYWluIG9uZXNcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICByZXNvbHZlci5fYWRkQ2FsbGJhY2tzKFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGNhbGxiYWNrcyBhcmUgZnVuY3Rpb25zLiBJZiBub3QsIGRlZmF1bHQgdG9cbiAgICAgICAgICAgICAgICAvLyBgcmVzb2x2ZWAgYW5kIGByZWplY3RgIHJlc3BlY3RpdmVseS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgd3JhcHBpbmcgb2YgdGhlIGNhbGxiYWNrcyBpcyBkb25lIGhlcmUgYW5kIG5vdCBpblxuICAgICAgICAgICAgICAgIC8vIGBfYWRkQ2FsbGJhY2tzYCBiZWNhdXNlIGl0IGlzIGEgZmVhdHVyZSBzcGVjaWZpYyB0byAgYHRoZW5gLlxuICAgICAgICAgICAgICAgIC8vIElmIGBkb25lYCBpcyBhZGRlZCB0byBwcm9taXNlcyBpdCB3b3VsZCBjYWxsIGBfYWRkQ2FsbGJhY2tzYFxuICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgZGVmYXVsdGluZyB0byBhbnl0aGluZyBhbmQgd2l0aG91dCB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuX3dyYXAocmVzb2x2ZSwgcmVqZWN0LCBjYWxsYmFjaykgOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHR5cGVvZiBlcnJiYWNrID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fd3JhcChyZXNvbHZlLCByZWplY3QsIGVycmJhY2spIDogcmVqZWN0XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgQSBzaG9ydGhhbmQgZm9yIGBwcm9taXNlLnRoZW4odW5kZWZpbmVkLCBjYWxsYmFjaylgLlxuXG4gICAgUmV0dXJucyBhIG5ldyBwcm9taXNlIGFuZCB0aGUgZXJyb3IgY2FsbGJhY2sgZ2V0cyB0aGUgc2FtZSB0cmVhdG1lbnQgYXMgaW5cbiAgICBgdGhlbmA6IGVycm9ycyBnZXQgY2F1Z2h0IGFuZCB0dXJuZWQgaW50byByZWplY3Rpb25zLCBhbmQgdGhlIHJldHVybiB2YWx1ZVxuICAgIG9mIHRoZSBjYWxsYmFjayBiZWNvbWVzIHRoZSBmdWxmaWxsZWQgdmFsdWUgb2YgdGhlIHJldHVybmVkIHByb21pc2UuXG5cbiAgICBAbWV0aG9kIGNhdGNoXG4gICAgQHBhcmFtIFtGdW5jdGlvbl0gZXJyYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgaW4gY2FzZSB0aGlzIHByb21pc2UgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdGVkXG4gICAgQHJldHVybiB7UHJvbWlzZX0gQSBuZXcgcHJvbWlzZSBtb2RpZmllZCBieSB0aGUgYmVoYXZpb3Igb2YgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICoqL1xuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChlcnJiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBlcnJiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIG9wZXJhdGlvbi4gUG9zc2libGUgcmVzdWx0cyBhcmVcbiAgICBcInBlbmRpbmdcIiwgXCJmdWxmaWxsZWRcIiwgYW5kIFwicmVqZWN0ZWRcIi5cblxuICAgIEBtZXRob2QgZ2V0U3RhdHVzXG4gICAgQHJldHVybiB7U3RyaW5nfVxuICAgIEBkZXByZWNhdGVkXG4gICAgKiovXG4gICAgZ2V0U3RhdHVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlci5nZXRTdGF0dXMoKTtcbiAgICB9XG59KTtcblxuLyoqXG5XcmFwcyB0aGUgY2FsbGJhY2sgaW4gYW5vdGhlciBmdW5jdGlvbiB0byBjYXRjaCBleGNlcHRpb25zIGFuZCB0dXJuIHRoZW0gaW50b1xucmVqZWN0aW9ucy5cblxuQG1ldGhvZCBfd3JhcFxuQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBSZXNvbHZpbmcgZnVuY3Rpb24gb2YgdGhlIHJlc29sdmVyIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcyB0aGlzIHByb21pc2VcbkBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBSZWplY3Rpb24gZnVuY3Rpb24gb2YgdGhlIHJlc29sdmVyIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcyB0aGlzIHByb21pc2VcbkBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIHdyYXBcbkByZXR1cm4ge0Z1bmN0aW9ufVxuQHByaXZhdGVcbioqL1xuUHJvbWlzZS5fd3JhcCA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGZuKSB7XG4gICAgLy8gY2FsbGJhY2tzIGFuZCBlcnJiYWNrcyBvbmx5IGdldCBvbmUgYXJndW1lbnRcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlT3JSZWFzb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyBQcm9taXNlcyBtb2RlbCBleGNlcHRpb24gaGFuZGxpbmcgdGhyb3VnaCBjYWxsYmFja3NcbiAgICAgICAgLy8gbWFraW5nIGJvdGggc3luY2hyb25vdXMgYW5kIGFzeW5jaHJvbm91cyBlcnJvcnMgYmVoYXZlXG4gICAgICAgIC8vIHRoZSBzYW1lIHdheVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBhcmd1bWVudCBjb21pbmcgaW4gdG8gdGhlIGNhbGxiYWNrL2VycmJhY2sgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHJlc29sdXRpb24gb2YgdGhlIHBhcmVudCBwcm9taXNlLlxuICAgICAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGFzIGEgbm9ybWFsIGZ1bmN0aW9uLCB3aXRoIG5vXG4gICAgICAgICAgICAvLyBzcGVjaWFsIHZhbHVlIGZvciB8dGhpc3wsIGFzIHBlciBQcm9taXNlcyBBK1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4odmFsdWVPclJlYXNvbik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUuc3RhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdOb24tZXJyb3IgZXJyb3I6IFBsZWFzZSB0aHJvdyBhY3R1YWwgZXJyb3JzIScgKyAnXFxuJyArIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9O1xufTtcblxuLyoqXG5DaGVja3MgaWYgYW4gb2JqZWN0IG9yIHZhbHVlIGlzIGEgcHJvbWlzZS4gVGhpcyBpcyBjcm9zcy1pbXBsZW1lbnRhdGlvblxuY29tcGF0aWJsZSwgc28gcHJvbWlzZXMgcmV0dXJuZWQgZnJvbSBvdGhlciBsaWJyYXJpZXMgb3IgbmF0aXZlIGNvbXBvbmVudHNcbnRoYXQgYXJlIGNvbXBhdGlibGUgd2l0aCB0aGUgUHJvbWlzZXMgQSsgc3BlYyBzaG91bGQgYmUgcmVjb2duaXplZCBieSB0aGlzXG5tZXRob2QuXG5cbkBtZXRob2QgaXNQcm9taXNlXG5AcGFyYW0ge0FueX0gb2JqIFRoZSBvYmplY3QgdG8gdGVzdFxuQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgb2JqZWN0IGlzIGEgcHJvbWlzZSBvciBub3RcbkBzdGF0aWNcbioqL1xuUHJvbWlzZS5pc1Byb21pc2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHRoZW47XG4gICAgLy8gV2UgdGVzdCBwcm9taXNlcyBieSBzdHJ1Y3R1cmUgdG8gYmUgYWJsZSB0byBpZGVudGlmeSBvdGhlclxuICAgIC8vIGltcGxlbWVudGF0aW9ucycgcHJvbWlzZXMuIFRoaXMgaXMgaW1wb3J0YW50IGZvciBjcm9zcyBjb21wYXRpYmlsaXR5IGFuZFxuICAgIC8vIEluIHBhcnRpY3VsYXIgWS53aGVuIHdoaWNoIHNob3VsZCByZWNvZ25pemUgYW55IGtpbmQgb2YgcHJvbWlzZVxuICAgIC8vIFVzZSB0cnkuLi5jYXRjaCB3aGVuIHJldHJpZXZpbmcgb2JqLnRoZW4uIFJldHVybiBmYWxzZSBpZiBpdCB0aHJvd3NcbiAgICAvLyBTZWUgUHJvbWlzZXMvQSsgMS4xXG4gICAgdHJ5IHtcbiAgICAgICAgdGhlbiA9IG9iai50aGVuO1xuICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgcmV0dXJuIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nO1xufTtcblxuLyoqXG5FbnN1cmVzIHRoYXQgYSBjZXJ0YWluIHZhbHVlIGlzIGEgcHJvbWlzZS4gSWYgaXQgaXMgbm90IGEgcHJvbWlzZSwgaXQgd3JhcHMgaXRcbmluIG9uZS5cblxuVGhpcyBtZXRob2QgY2FuIGJlIGNvcGllZCBvciBpbmhlcml0ZWQgaW4gc3ViY2xhc3Nlcy4gSW4gdGhhdCBjYXNlIGl0IHdpbGxcbmNoZWNrIHRoYXQgdGhlIHZhbHVlIHBhc3NlZCB0byBpdCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgY29ycmVjdCBjbGFzcy5cblRoaXMgbWVhbnMgdGhhdCBgUHJvbWlzZVN1YmNsYXNzLnJlc29sdmUoKWAgd2lsbCBhbHdheXMgcmV0dXJuIGluc3RhbmNlcyBvZlxuYFByb21pc2VTdWJjbGFzc2AuXG5cbkBtZXRob2QgcmVzb2x2ZVxuQHBhcmFtIHtBbnl9IEFueSBvYmplY3QgdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBhIHByb21pc2VcbkByZXR1cm4ge1Byb21pc2V9XG5Ac3RhdGljXG4qKi9cblByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlLmlzUHJvbWlzZSh2YWx1ZSkgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IHRoaXMgPyB2YWx1ZSA6XG4gICAgICAgIC8qanNoaW50IG5ld2NhcDogZmFsc2UgKi9cbiAgICAgICAgbmV3IHRoaXMoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgLypqc2hpbnQgbmV3Y2FwOiB0cnVlICovXG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG59O1xuXG4vKipcbkEgc2hvcnRoYW5kIGZvciBjcmVhdGluZyBhIHJlamVjdGVkIHByb21pc2UuXG5cbkBtZXRob2QgcmVqZWN0XG5AcGFyYW0ge0FueX0gcmVhc29uIFJlYXNvbiBmb3IgdGhlIHJlamVjdGlvbiBvZiB0aGlzIHByb21pc2UuIFVzdWFsbHkgYW4gRXJyb3JcbiAgICBPYmplY3RcbkByZXR1cm4ge1Byb21pc2V9IEEgcmVqZWN0ZWQgcHJvbWlzZVxuQHN0YXRpY1xuKiovXG5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvKmpzaGludCBuZXdjYXA6IGZhbHNlICovXG4gICAgcmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvKmpzaGludCBuZXdjYXA6IHRydWUgKi9cbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG59O1xuXG4vKipcblJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgd2hlbiBhbGwgdmFsdWVzIGFyZSByZXNvbHZlZCBvclxuYW55IGlzIHJlamVjdGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3Igd2FpdGluZyBmb3IgdGhlIHJlc29sdXRpb24gb2YgbXVsdGlwbGVcbnByb21pc2VzLCBzdWNoIGFzIHJlYWRpbmcgbXVsdGlwbGUgZmlsZXMgaW4gTm9kZS5qcyBvciBtYWtpbmcgbXVsdGlwbGUgWEhSXG5yZXF1ZXN0cyBpbiB0aGUgYnJvd3Nlci5cblxuQG1ldGhvZCBhbGxcbkBwYXJhbSB7QW55W119IHZhbHVlcyBBbiBhcnJheSBvZiBhbnkga2luZCBvZiB2YWx1ZXMsIHByb21pc2VzIG9yIG5vdC4gSWYgYSB2YWx1ZSBpcyBub3RcbkByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgYWxsIHRoZSBmdWxmaWxsbWVudCB2YWx1ZXNcbkBzdGF0aWNcbioqL1xuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdmFyIFByb21pc2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICghTGFuZy5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdQcm9taXNlLmFsbCBleHBlY3RzIGFuIGFycmF5IG9mIHZhbHVlcyBvciBwcm9taXNlcycpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICAgaSAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCAgICA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHRzICAgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBvbmVEb25lKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIHJlbWFpbmluZy0tO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1tpXSkudGhlbihvbmVEb25lKGkpLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcblJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgd2hlbiBhbnkgb2YgdmFsdWVzIGlzIGVpdGhlclxucmVzb2x2ZWQgb3IgcmVqZWN0ZWQuIENhbiBiZSB1c2VkIGZvciBwcm92aWRpbmcgZWFybHkgZmVlZGJhY2sgaW4gdGhlIFVJXG53aGlsZSBvdGhlciBvcGVyYXRpb25zIGFyZSBzdGlsbCBwZW5kaW5nLlxuXG5AbWV0aG9kIHJhY2VcbkBwYXJhbSB7QW55W119IHZhbHVlcyBBbiBhcnJheSBvZiB2YWx1ZXMgb3IgcHJvbWlzZXNcbkByZXR1cm4ge1Byb21pc2V9XG5Ac3RhdGljXG4qKi9cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICB2YXIgUHJvbWlzZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKCFMYW5nLmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1Byb21pc2UucmFjZSBleHBlY3RzIGFuIGFycmF5IG9mIHZhbHVlcyBvciBwcm9taXNlcycpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8ganVzdCBnbyB0aHJvdWdoIHRoZSBsaXN0IGFuZCByZXNvbHZlIGFuZCByZWplY3QgYXQgdGhlIGZpcnN0IGNoYW5nZVxuICAgICAgICAvLyBUaGlzIGFidXNlcyB0aGUgZmFjdCB0aGF0IGNhbGxpbmcgcmVzb2x2ZS9yZWplY3QgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgLy8gZG9lc24ndCBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoZSByZXR1cm5lZCBwcm9taXNlXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBjb3VudCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblkuUHJvbWlzZSA9IFByb21pc2U7XG4vKipcblJlcHJlc2VudHMgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gUHJvdmlkZXMgYVxuc3RhbmRhcmQgQVBJIGZvciBzdWJzY3JpYmluZyB0byB0aGUgbW9tZW50IHRoYXQgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMgZWl0aGVyXG5zdWNjZXNzZnVsbHkgKGBmdWxmaWxsKClgKSBvciB1bnN1Y2Nlc3NmdWxseSAoYHJlamVjdCgpYCkuXG5cbkBjbGFzcyBQcm9taXNlLlJlc29sdmVyXG5AY29uc3RydWN0b3JcbkBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBUaGUgcHJvbWlzZSBpbnN0YW5jZSB0aGlzIHJlc29sdmVyIHdpbGwgYmUgaGFuZGxpbmdcbioqL1xuZnVuY3Rpb24gUmVzb2x2ZXIocHJvbWlzZSkge1xuICAgIC8qKlxuICAgIExpc3Qgb2Ygc3VjY2VzcyBjYWxsYmFja3NcblxuICAgIEBwcm9wZXJ0eSBfY2FsbGJhY2tzXG4gICAgQHR5cGUgQXJyYXlcbiAgICBAcHJpdmF0ZVxuICAgICoqL1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgTGlzdCBvZiBmYWlsdXJlIGNhbGxiYWNrc1xuXG4gICAgQHByb3BlcnR5IF9lcnJiYWNrc1xuICAgIEB0eXBlIEFycmF5XG4gICAgQHByaXZhdGVcbiAgICAqKi9cbiAgICB0aGlzLl9lcnJiYWNrcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgVGhlIHByb21pc2UgZm9yIHRoaXMgUmVzb2x2ZXIuXG5cbiAgICBAcHJvcGVydHkgcHJvbWlzZVxuICAgIEB0eXBlIFByb21pc2VcbiAgICBAZGVwcmVjYXRlZFxuICAgICoqL1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG5cbiAgICAvKipcbiAgICBUaGUgc3RhdHVzIG9mIHRoZSBvcGVyYXRpb24uIFRoaXMgcHJvcGVydHkgbWF5IHRha2Ugb25seSBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIHZhbHVlczogJ3BlbmRpbmcnLCAnZnVsZmlsbGVkJyBvciAncmVqZWN0ZWQnLlxuXG4gICAgQHByb3BlcnR5IF9zdGF0dXNcbiAgICBAdHlwZSBTdHJpbmdcbiAgICBAZGVmYXVsdCAncGVuZGluZydcbiAgICBAcHJpdmF0ZVxuICAgICoqL1xuICAgIHRoaXMuX3N0YXR1cyA9ICdwZW5kaW5nJztcblxuICAgIC8qKlxuICAgIFRoaXMgdmFsdWUgdGhhdCB0aGlzIHByb21pc2UgcmVwcmVzZW50cy5cblxuICAgIEBwcm9wZXJ0eSBfcmVzdWx0XG4gICAgQHR5cGUgQW55XG4gICAgQHByaXZhdGVcbiAgICAqKi9cbiAgICB0aGlzLl9yZXN1bHQgPSBudWxsO1xufVxuXG5ZLm1peChSZXNvbHZlci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICBSZXNvbHZlcyB0aGUgcHJvbWlzZSwgc2lnbmFsaW5nIHN1Y2Nlc3NmdWwgY29tcGxldGlvbiBvZiB0aGVcbiAgICByZXByZXNlbnRlZCBvcGVyYXRpb24uIEFsbCBcIm9uRnVsZmlsbGVkXCIgc3Vic2NyaXB0aW9ucyBhcmUgZXhlY3V0ZWQgYW5kIHBhc3NlZFxuICAgIHRoZSB2YWx1ZSBwcm92aWRlZCB0byB0aGlzIG1ldGhvZC4gQWZ0ZXIgY2FsbGluZyBgZnVsZmlsbCgpYCwgYHJlamVjdCgpYCBhbmRcbiAgICBgbm90aWZ5KClgIGFyZSBkaXNhYmxlZC5cblxuICAgIEBtZXRob2QgZnVsZmlsbFxuICAgIEBwYXJhbSB7QW55fSB2YWx1ZSBWYWx1ZSB0byBwYXNzIGFsb25nIHRvIHRoZSBcIm9uRnVsZmlsbGVkXCIgc3Vic2NyaWJlcnNcbiAgICAqKi9cbiAgICBmdWxmaWxsOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9jYWxsYmFja3MsIHRoaXMuX3Jlc3VsdCk7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjYWxsYmFjayBsaXN0IHNvIHRoYXQgZnV0dXJlIGNhbGxzIHRvIGZ1bGZpbGwoKVxuICAgICAgICAgICAgLy8gd29uJ3QgY2FsbCB0aGUgc2FtZSBjYWxsYmFja3MgYWdhaW4uIFByb21pc2VzIGtlZXAgYSBsaXN0XG4gICAgICAgICAgICAvLyBvZiBjYWxsYmFja3MsIHRoZXkncmUgbm90IHRoZSBzYW1lIGFzIGV2ZW50cy4gSW4gcHJhY3RpY2UsXG4gICAgICAgICAgICAvLyBjYWxscyB0byBmdWxmaWxsKCkgYWZ0ZXIgdGhlIGZpcnN0IG9uZSBzaG91bGQgbm90IGJlIG1hZGUgYnlcbiAgICAgICAgICAgIC8vIHRoZSB1c2VyIGJ1dCBieSB0aGVuKClcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBPbmNlIGEgcHJvbWlzZSBnZXRzIGZ1bGZpbGxlZCBpdCBjYW4ndCBiZSByZWplY3RlZCwgc29cbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIHBvaW50IGluIGtlZXBpbmcgdGhlIGxpc3QuIFJlbW92ZSBpdCB0byBoZWxwXG4gICAgICAgICAgICAvLyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIHRoaXMuX2VycmJhY2tzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICBSZXNvbHZlcyB0aGUgcHJvbWlzZSwgc2lnbmFsaW5nICp1bipzdWNjZXNzZnVsIGNvbXBsZXRpb24gb2YgdGhlXG4gICAgcmVwcmVzZW50ZWQgb3BlcmF0aW9uLiBBbGwgXCJvblJlamVjdGVkXCIgc3Vic2NyaXB0aW9ucyBhcmUgZXhlY3V0ZWQgd2l0aFxuICAgIHRoZSB2YWx1ZSBwcm92aWRlZCB0byB0aGlzIG1ldGhvZC4gQWZ0ZXIgY2FsbGluZyBgcmVqZWN0KClgLCBgcmVzb2x2ZSgpYFxuICAgIGFuZCBgbm90aWZ5KClgIGFyZSBkaXNhYmxlZC5cblxuICAgIEBtZXRob2QgcmVqZWN0XG4gICAgQHBhcmFtIHtBbnl9IHZhbHVlIFZhbHVlIHRvIHBhc3MgYWxvbmcgdG8gdGhlIFwicmVqZWN0XCIgc3Vic2NyaWJlcnNcbiAgICAqKi9cbiAgICByZWplY3Q6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHQgPSByZWFzb247XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2VycmJhY2tzLCB0aGlzLl9yZXN1bHQpO1xuXG4gICAgICAgICAgICAvLyBTZWUgZnVsZmlsbCgpXG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fZXJyYmFja3MgPSBbXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgIEdpdmVuIGEgY2VydGFpbiB2YWx1ZSBBIHBhc3NlZCBhcyBhIHBhcmFtZXRlciwgdGhpcyBtZXRob2QgcmVzb2x2ZXMgdGhlXG4gICAgcHJvbWlzZSB0byB0aGUgdmFsdWUgQS5cblxuICAgIElmIEEgaXMgYSBwcm9taXNlLCBgcmVzb2x2ZWAgd2lsbCBjYXVzZSB0aGUgcmVzb2x2ZXIgdG8gYWRvcHQgdGhlIHN0YXRlIG9mIEFcbiAgICBhbmQgb25jZSBBIGlzIHJlc29sdmVkLCBpdCB3aWxsIHJlc29sdmUgdGhlIHJlc29sdmVyJ3MgcHJvbWlzZSBhcyB3ZWxsLlxuICAgIFRoaXMgYmVoYXZpb3IgXCJmbGF0dGVuc1wiIEEgYnkgY2FsbGluZyBgdGhlbmAgcmVjdXJzaXZlbHkgYW5kIGVzc2VudGlhbGx5XG4gICAgZGlzYWxsb3dzIHByb21pc2VzLWZvci1wcm9taXNlcy5cblxuICAgIFRoaXMgaXMgdGhlIGRlZmF1bHQgYWxnb3JpdGhtIHVzZWQgd2hlbiB1c2luZyB0aGUgZnVuY3Rpb24gcGFzc2VkIGFzIHRoZVxuICAgIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBUaGlzIG1lYW5zIHRoYXRcbiAgICB0aGUgZm9sbG93aW5nIGNvZGUgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSAnaGVsbG8gd29ybGQnOlxuXG4gICAgICAgIHZhciBwcm9taXNlMSA9IG5ldyBZLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoJ2hlbGxvIHdvcmxkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJvbWlzZTIgPSBuZXcgWS5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHByb21pc2UxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb21pc2UyLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBhc3NlcnQodmFsdWUgPT09ICdoZWxsbyB3b3JsZCcpOyAvLyB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgQG1ldGhvZCByZXNvbHZlXG4gICAgQHBhcmFtIFtBbnldIHZhbHVlIEEgcmVndWxhciBKUyB2YWx1ZSBvciBhIHByb21pc2VcbiAgICAqL1xuICAgIHJlc29sdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKFByb21pc2UuaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHNlbGYucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZnVsZmlsbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgU2NoZWR1bGUgZXhlY3V0aW9uIG9mIGEgY2FsbGJhY2sgdG8gZWl0aGVyIG9yIGJvdGggb2YgXCJyZXNvbHZlXCIgYW5kXG4gICAgXCJyZWplY3RcIiByZXNvbHV0aW9ucyBmb3IgdGhlIFJlc29sdmVyLiAgVGhlIGNhbGxiYWNrc1xuICAgIGFyZSB3cmFwcGVkIGluIGEgbmV3IFJlc29sdmVyIGFuZCB0aGF0IFJlc29sdmVyJ3MgY29ycmVzcG9uZGluZyBwcm9taXNlXG4gICAgaXMgcmV0dXJuZWQuICBUaGlzIGFsbG93cyBvcGVyYXRpb24gY2hhaW5pbmcgYWxhXG4gICAgYGZ1bmN0aW9uQSgpLnRoZW4oZnVuY3Rpb25CKS50aGVuKGZ1bmN0aW9uQylgIHdoZXJlIGBmdW5jdGlvbkFgIHJldHVybnNcbiAgICBhIHByb21pc2UsIGFuZCBgZnVuY3Rpb25CYCBhbmQgYGZ1bmN0aW9uQ2AgX21heV8gcmV0dXJuIHByb21pc2VzLlxuXG4gICAgQG1ldGhvZCB0aGVuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBSZXNvbHZlclxuICAgICAgICAgICAgICAgIHJlc29sdmVzIHN1Y2Nlc3NmdWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJiYWNrXSBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBSZXNvbHZlclxuICAgICAgICAgICAgICAgIHJlc29sdmVzIHVuc3VjY2Vzc2Z1bGx5XG4gICAgQHJldHVybiB7UHJvbWlzZX0gVGhlIHByb21pc2Ugb2YgYSBuZXcgUmVzb2x2ZXIgd3JhcHBpbmcgdGhlIHJlc29sdXRpb25cbiAgICAgICAgICAgICAgICBvZiBlaXRoZXIgXCJyZXNvbHZlXCIgb3IgXCJyZWplY3RcIiBjYWxsYmFja1xuICAgIEBkZXByZWNhdGVkXG4gICAgKiovXG4gICAgdGhlbjogZnVuY3Rpb24gKGNhbGxiYWNrLCBlcnJiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2UudGhlbihjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIFNjaGVkdWxlIGV4ZWN1dGlvbiBvZiBhIGNhbGxiYWNrIHRvIGVpdGhlciBvciBib3RoIG9mIFwicmVzb2x2ZVwiIGFuZFxuICAgIFwicmVqZWN0XCIgcmVzb2x1dGlvbnMgb2YgdGhpcyByZXNvbHZlci4gSWYgdGhlIHJlc29sdmVyIGlzIG5vdCBwZW5kaW5nLFxuICAgIHRoZSBjb3JyZWN0IGNhbGxiYWNrIGdldHMgY2FsbGVkIGF1dG9tYXRpY2FsbHkuXG5cbiAgICBAbWV0aG9kIF9hZGRDYWxsYmFja3NcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIFJlc29sdmVyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5XG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2VycmJhY2tdIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIFJlc29sdmVyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXMgdW5zdWNjZXNzZnVsbHlcbiAgICBAcHJpdmF0ZVxuICAgICoqL1xuICAgIF9hZGRDYWxsYmFja3M6IGZ1bmN0aW9uIChjYWxsYmFjaywgZXJyYmFjaykge1xuICAgICAgICB2YXIgY2FsbGJhY2tMaXN0ID0gdGhpcy5fY2FsbGJhY2tzLFxuICAgICAgICAgICAgZXJyYmFja0xpc3QgID0gdGhpcy5fZXJyYmFja3MsXG4gICAgICAgICAgICBzdGF0dXMgICAgICAgPSB0aGlzLl9zdGF0dXMsXG4gICAgICAgICAgICByZXN1bHQgICAgICAgPSB0aGlzLl9yZXN1bHQ7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrTGlzdCAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrTGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyYmFja0xpc3QgJiYgdHlwZW9mIGVycmJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycmJhY2tMaXN0LnB1c2goZXJyYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIHByb21pc2UgaXMgYWxyZWFkeSBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQsIG5vdGlmeSB0aGUgbmV3bHkgYWRkZWRcbiAgICAgICAgLy8gY2FsbGJhY2tzIGJ5IGNhbGxpbmcgZnVsZmlsbCgpIG9yIHJlamVjdCgpXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bGZpbGwocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIFJlc29sdmVyIGFzIGEgc3RyaW5nIFwicGVuZGluZ1wiLFxuICAgIFwiZnVsZmlsbGVkXCIsIG9yIFwicmVqZWN0ZWRcIi5cblxuICAgIEBtZXRob2QgZ2V0U3RhdHVzXG4gICAgQHJldHVybiB7U3RyaW5nfVxuICAgIEBkZXByZWNhdGVkXG4gICAgKiovXG4gICAgZ2V0U3RhdHVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgIEV4ZWN1dGVzIGFuIGFycmF5IG9mIGNhbGxiYWNrcyBmcm9tIGEgc3BlY2lmaWVkIGNvbnRleHQsIHBhc3NpbmcgYSBzZXQgb2ZcbiAgICBhcmd1bWVudHMuXG5cbiAgICBAbWV0aG9kIF9ub3RpZnlcbiAgICBAcGFyYW0ge0Z1bmN0aW9uW119IHN1YnMgVGhlIGFycmF5IG9mIHN1YnNjcmliZXIgY2FsbGJhY2tzXG4gICAgQHBhcmFtIHtBbnl9IHJlc3VsdCBWYWx1ZSB0byBwYXNzIHRoZSBjYWxsYmFja3NcbiAgICBAcHJvdGVjdGVkXG4gICAgKiovXG4gICAgX25vdGlmeTogZnVuY3Rpb24gKHN1YnMsIHJlc3VsdCkge1xuICAgICAgICAvLyBTaW5jZSBjYWxsYmFjayBsaXN0cyBhcmUgcmVzZXQgc3luY2hyb25vdXNseSwgdGhlIHN1YnMgbGlzdCBuZXZlclxuICAgICAgICAvLyBjaGFuZ2VzIGFmdGVyIF9ub3RpZnkoKSByZWNlaXZlcyBpdC4gQXZvaWQgY2FsbGluZyBZLnNvb24oKSBmb3JcbiAgICAgICAgLy8gYW4gZW1wdHkgbGlzdFxuICAgICAgICBpZiAoc3Vicy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgYWxsIGNhbGxiYWNrcyBhZnRlciBZLnNvb24gdG8gZ3VhcmFudGVlXG4gICAgICAgICAgICAvLyBhc3luY2hyb25pY2l0eS4gQmVjYXVzZSBzZXRUaW1lb3V0IGNhbiBjYXVzZSB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgLy8gZGVsYXlzIHRoYXQgKmNhbiogYmVjb21lIG5vdGljZWFibGUgaW4gc29tZSBzaXR1YXRpb25zXG4gICAgICAgICAgICAvLyAoZXNwZWNpYWxseSBpbiBOb2RlLmpzKVxuICAgICAgICAgICAgWS5zb29uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbGVuO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3Vicy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzW2ldKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0sIHRydWUpO1xuXG5ZLlByb21pc2UuUmVzb2x2ZXIgPSBSZXNvbHZlcjtcbi8qKlxuQWJzdHJhY3Rpb24gQVBJIGFsbG93aW5nIHlvdSB0byBpbnRlcmFjdCB3aXRoIHByb21pc2VzIG9yIHJhdyB2YWx1ZXMgYXMgaWYgdGhleVxud2VyZSBwcm9taXNlcy4gSWYgYSBub24tcHJvbWlzZSBvYmplY3QgaXMgcGFzc2VkIGluLCBhIG5ldyBSZXNvbHZlciBpcyBjcmVhdGVkXG5hbmQgc2NoZWR1bGVkIHRvIHJlc29sdmUgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUuXG5cbkluIGVpdGhlciBjYXNlLCBhIHByb21pc2UgaXMgcmV0dXJuZWQuICBJZiBlaXRoZXIgX2NhbGxiYWNrXyBvciBfZXJyYmFja18gYXJlXG5wcm92aWRlZCwgdGhlIHByb21pc2UgcmV0dXJuZWQgaXMgdGhlIG9uZSByZXR1cm5lZCBmcm9tIGNhbGxpbmdcbmBwcm9taXNlLnRoZW4oY2FsbGJhY2ssIGVycmJhY2spYCBvbiB0aGUgcHJvdmlkZWQgb3IgY3JlYXRlZCBwcm9taXNlLiAgSWYgbmVpdGhlclxuYXJlIHByb3ZpZGVkLCB0aGUgb3JpZ2luYWwgcHJvbWlzZSBpcyByZXR1cm5lZC5cblxuQGZvciBZVUlcbkBtZXRob2Qgd2hlblxuQHBhcmFtIHtBbnl9IHByb21pc2UgUHJvbWlzZSBvYmplY3Qgb3IgdmFsdWUgdG8gd3JhcCBpbiBhIHJlc29sdmVkIHByb21pc2VcbkBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgdG8gZXhlY3V0ZSBpZiB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZFxuQHBhcmFtIHtGdW5jdGlvbn0gW2VycmJhY2tdIGNhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWRcbkByZXR1cm4ge1Byb21pc2V9XG4qKi9cblkud2hlbiA9IGZ1bmN0aW9uIChwcm9taXNlLCBjYWxsYmFjaywgZXJyYmFjaykge1xuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHJvbWlzZSk7XG5cbiAgICByZXR1cm4gKGNhbGxiYWNrIHx8IGVycmJhY2spID8gcHJvbWlzZS50aGVuKGNhbGxiYWNrLCBlcnJiYWNrKSA6IHByb21pc2U7XG59O1xuLyoqXG5SZXR1cm5zIGEgbmV3IHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gYWxsIG9wZXJhdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG5UYWtlcyBib3RoIGFueSBudW1lciBvZiB2YWx1ZXMgYXMgYXJndW1lbnRzLiBJZiBhbiBhcmd1bWVudCBpcyBhIG5vdCBhIHByb21pc2UsXG5pdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSBuZXcgcHJvbWlzZSwgc2FtZSBhcyBpbiBgWS53aGVuKClgLlxuXG5AZm9yIFlVSVxuQG1ldGhvZCBiYXRjaFxuQHBhcmFtIHtBbnl9IG9wZXJhdGlvbiogQW55IG51bWJlciBvZiBZLlByb21pc2Ugb2JqZWN0cyBvciByZWd1bGFyIEpTIHZhbHVlc1xuQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSBmdWxmaWxsZWQgd2hlbiBhbGwgcHJvdmlkZWQgcHJvbWlzZXMgYXJlXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkXG4qKi9cblkuYmF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJ0aW1lcnNcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgncXVlcnlzdHJpbmctc3RyaW5naWZ5LXNpbXBsZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qZ2xvYmFsIFkgKi9cbi8qKlxuICogPHA+UHJvdmlkZXMgWS5RdWVyeVN0cmluZy5zdHJpbmdpZnkgbWV0aG9kIGZvciBjb252ZXJ0aW5nIG9iamVjdHMgdG8gUXVlcnkgU3RyaW5ncy5cbiAqIFRoaXMgaXMgYSBzdWJzZXQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGZ1bGwgcXVlcnlzdHJpbmctc3RyaW5naWZ5LjwvcD5cbiAqIDxwPlRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBiYXJlIG1pbmltdW0gZnVuY3Rpb25hbGl0eSAoZW5jb2RpbmcgYSBoYXNoIG9mIHNpbXBsZSB2YWx1ZXMpLFxuICogd2l0aG91dCB0aGUgYWRkaXRpb25hbCBzdXBwb3J0IGZvciBuZXN0ZWQgZGF0YSBzdHJ1Y3R1cmVzLiAgRXZlcnkga2V5LXZhbHVlIHBhaXIgaXNcbiAqIGVuY29kZWQgYnkgZW5jb2RlVVJJQ29tcG9uZW50LjwvcD5cbiAqIDxwPlRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgbWluaW1hbGlzdGljIHdheSBmb3IgaW8gdG8gaGFuZGxlICBzaW5nbGUtbGV2ZWwgb2JqZWN0c1xuICogYXMgdHJhbnNhY3Rpb24gZGF0YS48L3A+XG4gKlxuICogQG1vZHVsZSBxdWVyeXN0cmluZ1xuICogQHN1Ym1vZHVsZSBxdWVyeXN0cmluZy1zdHJpbmdpZnktc2ltcGxlXG4gKi9cblxudmFyIFF1ZXJ5U3RyaW5nID0gWS5uYW1lc3BhY2UoXCJRdWVyeVN0cmluZ1wiKSxcbiAgICBFVUMgPSBlbmNvZGVVUklDb21wb25lbnQ7XG5cblxuUXVlcnlTdHJpbmcuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgYykge1xuICAgIHZhciBxcyA9IFtdLFxuICAgICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGlzIGZhbHNlOyBzdGFuZGFyZCBrZXkgbm90YXRpb24uXG4gICAgICAgIHMgPSBjICYmIGMuYXJyYXlLZXkgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgIGtleSwgaSwgbDtcblxuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGlmIChZLkxhbmcuaXNBcnJheShvYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gb2JqW2tleV0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHFzLnB1c2goRVVDKHMgPyBrZXkgKyAnW10nIDoga2V5KSArICc9JyArIEVVQyhvYmpba2V5XVtpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHFzLnB1c2goRVVDKGtleSkgKyAnPScgKyBFVUMob2JqW2tleV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxcy5qb2luKCcmJyk7XG59O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJ5dWktYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCdxdWVyeXN0cmluZy1zdHJpbmdpZnknLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiAqIFByb3ZpZGVzIFkuUXVlcnlTdHJpbmcuc3RyaW5naWZ5IG1ldGhvZCBmb3IgY29udmVydGluZyBvYmplY3RzIHRvIFF1ZXJ5IFN0cmluZ3MuXG4gKlxuICogQG1vZHVsZSBxdWVyeXN0cmluZ1xuICogQHN1Ym1vZHVsZSBxdWVyeXN0cmluZy1zdHJpbmdpZnlcbiAqL1xuXG52YXIgUXVlcnlTdHJpbmcgPSBZLm5hbWVzcGFjZShcIlF1ZXJ5U3RyaW5nXCIpLFxuICAgIHN0YWNrID0gW10sXG4gICAgTCA9IFkuTGFuZztcblxuLyoqXG4gKiBQcm92aWRlcyBZLlF1ZXJ5U3RyaW5nLmVzY2FwZSBtZXRob2QgdG8gYmUgYWJsZSB0byBvdmVycmlkZSBkZWZhdWx0IGVuY29kaW5nXG4gKiBtZXRob2QuICBUaGlzIGlzIGltcG9ydGFudCBpbiBjYXNlcyB3aGVyZSBub24tc3RhbmRhcmQgZGVsaW1pdGVycyBhcmUgdXNlZCwgaWZcbiAqIHRoZSBkZWxpbWl0ZXJzIHdvdWxkIG5vdCBub3JtYWxseSBiZSBoYW5kbGVkIHByb3Blcmx5IGJ5IHRoZSBidWlsdGluXG4gKiAoZW58ZGUpY29kZVVSSUNvbXBvbmVudCBmdW5jdGlvbnMuXG4gKiBEZWZhdWx0OiBlbmNvZGVVUklDb21wb25lbnRcbiAqXG4gKiBAbWV0aG9kIGVzY2FwZVxuICogQGZvciBRdWVyeVN0cmluZ1xuICogQHN0YXRpY1xuICoqL1xuUXVlcnlTdHJpbmcuZXNjYXBlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4vKipcbiAqIDxwPkNvbnZlcnRzIGFuIGFyYml0cmFyeSB2YWx1ZSB0byBhIFF1ZXJ5IFN0cmluZyByZXByZXNlbnRhdGlvbi48L3A+XG4gKlxuICogPHA+T2JqZWN0cyB3aXRoIGN5Y2xpY2FsIHJlZmVyZW5jZXMgd2lsbCB0cmlnZ2VyIGFuIGV4Y2VwdGlvbi48L3A+XG4gKlxuICogQG1ldGhvZCBzdHJpbmdpZnlcbiAqIEBmb3IgUXVlcnlTdHJpbmdcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvYmoge0FueX0gYW55IGFyYml0cmFyeSB2YWx1ZSB0byBjb252ZXJ0IHRvIHF1ZXJ5IHN0cmluZ1xuICogQHBhcmFtIGNmZyB7T2JqZWN0fSAob3B0aW9uYWwpIENvbmZpZ3VyYXRpb24gb2JqZWN0LiAgVGhlIHRocmVlXG4gKiBzdXBwb3J0ZWQgY29uZmlndXJhdGlvbnMgYXJlOlxuICogPHVsPjxsaT5zZXA6IFdoZW4gZGVmaW5lZCwgdGhlIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUga2V5LXZhbHVlXG4gKiBzZXBhcmF0b3IuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIiZcIi48L2xpPlxuICogPGxpPmVxOiBXaGVuIGRlZmluZWQsIHRoZSB2YWx1ZSB3aWxsIGJlIHVzZWQgdG8gam9pbiB0aGUga2V5IHRvXG4gKiB0aGUgdmFsdWUuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIj1cIi48L2xpPlxuICogPGxpPmFycmF5S2V5OiBXaGVuIHNldCB0byB0cnVlLCB0aGUga2V5IG9mIGFuIGFycmF5IHdpbGwgaGF2ZSB0aGVcbiAqICdbXScgbm90YXRpb24gYXBwZW5kZWQgdG8gdGhlIGtleS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxuICogPC9saT48L3VsPlxuICogQHBhcmFtIG5hbWUge1N0cmluZ30gKG9wdGlvbmFsKSBOYW1lIG9mIHRoZSBjdXJyZW50IGtleSwgZm9yIGhhbmRsaW5nIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LlxuICogQHN0YXRpY1xuICovXG5RdWVyeVN0cmluZy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBjLCBuYW1lKSB7XG4gICAgdmFyIGJlZ2luLCBlbmQsIGksIGwsIG4sIHMsXG4gICAgICAgIHNlcCA9IGMgJiYgYy5zZXAgPyBjLnNlcCA6IFwiJlwiLFxuICAgICAgICBlcSA9IGMgJiYgYy5lcSA/IGMuZXEgOiBcIj1cIixcbiAgICAgICAgYUsgPSBjICYmIGMuYXJyYXlLZXkgPyBjLmFycmF5S2V5IDogZmFsc2U7XG5cbiAgICBpZiAoTC5pc051bGwob2JqKSB8fCBMLmlzVW5kZWZpbmVkKG9iaikgfHwgTC5pc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBRdWVyeVN0cmluZy5lc2NhcGUobmFtZSkgKyBlcSA6ICcnO1xuICAgIH1cblxuICAgIGlmIChMLmlzQm9vbGVhbihvYmopIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXScpIHtcbiAgICAgICAgb2JqID0rIG9iajtcbiAgICB9XG5cbiAgICBpZiAoTC5pc051bWJlcihvYmopIHx8IEwuaXNTdHJpbmcob2JqKSkge1xuICAgICAgICByZXR1cm4gUXVlcnlTdHJpbmcuZXNjYXBlKG5hbWUpICsgZXEgKyBRdWVyeVN0cmluZy5lc2NhcGUob2JqKTtcbiAgICB9XG5cbiAgICBpZiAoTC5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcyA9IFtdO1xuICAgICAgICBuYW1lID0gYUsgPyBuYW1lICsgJ1tdJyA6IG5hbWU7XG4gICAgICAgIGwgPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBzLnB1c2goIFF1ZXJ5U3RyaW5nLnN0cmluZ2lmeShvYmpbaV0sIGMsIG5hbWUpICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcy5qb2luKHNlcCk7XG4gICAgfVxuICAgIC8vIG5vdyB3ZSBrbm93IGl0J3MgYW4gb2JqZWN0LlxuXG4gICAgLy8gQ2hlY2sgZm9yIGN5Y2xpY2FsIHJlZmVyZW5jZXMgaW4gbmVzdGVkIG9iamVjdHNcbiAgICBmb3IgKGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoc3RhY2tbaV0gPT09IG9iaikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcnlTdHJpbmcuc3RyaW5naWZ5LiBDeWNsaWNhbCByZWZlcmVuY2VcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgcyA9IFtdO1xuICAgIGJlZ2luID0gbmFtZSA/IG5hbWUgKyAnWycgOiAnJztcbiAgICBlbmQgPSBuYW1lID8gJ10nIDogJyc7XG4gICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBuID0gYmVnaW4gKyBpICsgZW5kO1xuICAgICAgICAgICAgcy5wdXNoKFF1ZXJ5U3RyaW5nLnN0cmluZ2lmeShvYmpbaV0sIGMsIG4pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YWNrLnBvcCgpO1xuICAgIHMgPSBzLmpvaW4oc2VwKTtcbiAgICBpZiAoIXMgJiYgbmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZSArIFwiPVwiO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xufTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wieXVpLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgncXVldWUtcHJvbW90ZScsIGZ1bmN0aW9uIChZLCBOQU1FKSB7XG5cbi8qKlxuICogQWRkcyBtZXRob2RzIHByb21vdGUsIHJlbW92ZSwgYW5kIGluZGV4T2YgdG8gUXVldWUgaW5zdGFuY2VzLlxuICpcbiAqIEBtb2R1bGUgcXVldWUtcHJvbW90ZVxuICogQGZvciBRdWV1ZVxuICovXG5cblkubWl4KFkuUXVldWUucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgcXVldWUgb2YgdGhlIHNwZWNpZmllZCBpdGVtXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluZGV4T2ZcbiAgICAgKiBAcGFyYW0gbmVlZGxlIHtNSVhFRH0gdGhlIGl0ZW0gdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBpdGVtIG9yIC0xIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGluZGV4T2YgOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIFkuQXJyYXkuaW5kZXhPZih0aGlzLl9xLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSByZWZlcmVuY2VkIGl0ZW0gdG8gdGhlIGhlYWQgb2YgdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByb21vdGVcbiAgICAgKiBAcGFyYW0gaXRlbSB7TUlYRUR9IGFuIGl0ZW0gaW4gdGhlIHF1ZXVlXG4gICAgICovXG4gICAgcHJvbW90ZSA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY2FsbGJhY2spO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9xLnVuc2hpZnQodGhpcy5fcS5zcGxpY2UoaW5kZXgsMSlbMF0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHJlZmVyZW5jZWQgaXRlbSBmcm9tIHRoZSBxdWV1ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW1vdmVcbiAgICAgKiBAcGFyYW0gaXRlbSB7TUlYRUR9IGFuIGl0ZW0gaW4gdGhlIHF1ZXVlXG4gICAgICovXG4gICAgcmVtb3ZlIDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihjYWxsYmFjayk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3Euc3BsaWNlKGluZGV4LDEpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wieXVpLWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnc2VsZWN0b3ItbmF0aXZlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuKGZ1bmN0aW9uKFkpIHtcbi8qKlxuICogVGhlIHNlbGVjdG9yLW5hdGl2ZSBtb2R1bGUgcHJvdmlkZXMgc3VwcG9ydCBmb3IgbmF0aXZlIHF1ZXJ5U2VsZWN0b3JcbiAqIEBtb2R1bGUgZG9tXG4gKiBAc3VibW9kdWxlIHNlbGVjdG9yLW5hdGl2ZVxuICogQGZvciBTZWxlY3RvclxuICovXG5cbi8qKlxuICogUHJvdmlkZXMgc3VwcG9ydCBmb3IgdXNpbmcgQ1NTIHNlbGVjdG9ycyB0byBxdWVyeSB0aGUgRE9NXG4gKiBAY2xhc3MgU2VsZWN0b3JcbiAqIEBzdGF0aWNcbiAqIEBmb3IgU2VsZWN0b3JcbiAqL1xuXG5ZLm5hbWVzcGFjZSgnU2VsZWN0b3InKTsgLy8gYWxsb3cgbmF0aXZlIG1vZHVsZSB0byBzdGFuZGFsb25lXG5cbnZhciBDT01QQVJFX0RPQ1VNRU5UX1BPU0lUSU9OID0gJ2NvbXBhcmVEb2N1bWVudFBvc2l0aW9uJyxcbiAgICBPV05FUl9ET0NVTUVOVCA9ICdvd25lckRvY3VtZW50JztcblxudmFyIFNlbGVjdG9yID0ge1xuICAgIF90eXBlczoge1xuICAgICAgICBlc2M6IHtcbiAgICAgICAgICAgIHRva2VuOiAnXFx1RTAwMCcsXG4gICAgICAgICAgICByZTogL1xcXFxbOlxcW1xcXVxcKFxcKSNcXC5cXCdcXD4rflwiXS9naVxuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgIHRva2VuOiAnXFx1RTAwMScsXG4gICAgICAgICAgICByZTogLyhcXFtbXlxcXV0qXFxdKS9nXG4gICAgICAgIH0sXG5cbiAgICAgICAgcHNldWRvOiB7XG4gICAgICAgICAgICB0b2tlbjogJ1xcdUUwMDInLFxuICAgICAgICAgICAgcmU6IC8oXFwoW15cXCldKlxcKSkvZ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqICBVc2UgdGhlIG5hdGl2ZSB2ZXJzaW9uIG9mIGBxdWVyeVNlbGVjdG9yQWxsYCwgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHVzZU5hdGl2ZVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdXNlTmF0aXZlOiB0cnVlLFxuXG4gICAgX2VzY2FwZUlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGlkID0gaWQucmVwbGFjZSgvKFs6XFxbXFxdXFwoXFwpI1xcLic8Pit+XCJdKS9nLCdcXFxcJDEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfSxcblxuICAgIF9jb21wYXJlOiAoJ3NvdXJjZUluZGV4JyBpbiBZLmNvbmZpZy5kb2MuZG9jdW1lbnRFbGVtZW50KSA/XG4gICAgICAgIGZ1bmN0aW9uKG5vZGVBLCBub2RlQikge1xuICAgICAgICAgICAgdmFyIGEgPSBub2RlQS5zb3VyY2VJbmRleCxcbiAgICAgICAgICAgICAgICBiID0gbm9kZUIuc291cmNlSW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAtMTtcblxuICAgICAgICB9IDogKFkuY29uZmlnLmRvYy5kb2N1bWVudEVsZW1lbnRbQ09NUEFSRV9ET0NVTUVOVF9QT1NJVElPTl0gP1xuICAgICAgICBmdW5jdGlvbihub2RlQSwgbm9kZUIpIHtcbiAgICAgICAgICAgIGlmIChub2RlQVtDT01QQVJFX0RPQ1VNRU5UX1BPU0lUSU9OXShub2RlQikgJiA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uKG5vZGVBLCBub2RlQikge1xuICAgICAgICAgICAgdmFyIHJhbmdlQSwgcmFuZ2VCLCBjb21wYXJlO1xuICAgICAgICAgICAgaWYgKG5vZGVBICYmIG5vZGVCKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VBID0gbm9kZUFbT1dORVJfRE9DVU1FTlRdLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgcmFuZ2VBLnNldFN0YXJ0KG5vZGVBLCAwKTtcbiAgICAgICAgICAgICAgICByYW5nZUIgPSBub2RlQltPV05FUl9ET0NVTUVOVF0uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZUIuc2V0U3RhcnQobm9kZUIsIDApO1xuICAgICAgICAgICAgICAgIGNvbXBhcmUgPSByYW5nZUEuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKDEsIHJhbmdlQik7IC8vIDEgPT09IFJhbmdlLlNUQVJUX1RPX0VORFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcblxuICAgIH0pLFxuXG4gICAgX3NvcnQ6IGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgbm9kZXMgPSBZLkFycmF5KG5vZGVzLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChub2Rlcy5zb3J0KSB7XG4gICAgICAgICAgICAgICAgbm9kZXMuc29ydChTZWxlY3Rvci5fY29tcGFyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfSxcblxuICAgIF9kZUR1cGU6IGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICAgIHZhciByZXQgPSBbXSxcbiAgICAgICAgICAgIGksIG5vZGU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgKG5vZGUgPSBub2Rlc1tpKytdKTspIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5fZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXRbcmV0Lmxlbmd0aF0gPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUuX2ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IChub2RlID0gcmV0W2krK10pOykge1xuICAgICAgICAgICAgbm9kZS5fZm91bmQgPSBudWxsO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ19mb3VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgc2V0IG9mIG5vZGVzIGJhc2VkIG9uIGEgZ2l2ZW4gQ1NTIHNlbGVjdG9yLlxuICAgICAqIEBtZXRob2QgcXVlcnlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBBIENTUyBzZWxlY3Rvci5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IG9wdGlvbmFsIEEgbm9kZSB0byBzdGFydCB0aGUgcXVlcnkgZnJvbS4gRGVmYXVsdHMgdG8gYFkuY29uZmlnLmRvY2AuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmaXJzdE9ubHkgb3B0aW9uYWwgV2hldGhlciBvciBub3QgdG8gcmV0dXJuIG9ubHkgdGhlIGZpcnN0IG1hdGNoLlxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119IFRoZSBhcnJheSBvZiBub2RlcyB0aGF0IG1hdGNoZWQgdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBxdWVyeTogZnVuY3Rpb24oc2VsZWN0b3IsIHJvb3QsIGZpcnN0T25seSwgc2tpcE5hdGl2ZSkge1xuICAgICAgICByb290ID0gcm9vdCB8fCBZLmNvbmZpZy5kb2M7XG4gICAgICAgIHZhciByZXQgPSBbXSxcbiAgICAgICAgICAgIHVzZU5hdGl2ZSA9IChZLlNlbGVjdG9yLnVzZU5hdGl2ZSAmJiBZLmNvbmZpZy5kb2MucXVlcnlTZWxlY3RvciAmJiAhc2tpcE5hdGl2ZSksXG4gICAgICAgICAgICBxdWVyaWVzID0gW1tzZWxlY3Rvciwgcm9vdF1dLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgZm4gPSAodXNlTmF0aXZlKSA/IFkuU2VsZWN0b3IuX25hdGl2ZVF1ZXJ5IDogWS5TZWxlY3Rvci5fYnJ1dGVRdWVyeTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IgJiYgZm4pIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IGdyb3VwIGludG8gc2VwZXJhdGUgcXVlcmllc1xuICAgICAgICAgICAgaWYgKCFza2lwTmF0aXZlICYmIC8vIGFscmVhZHkgZG9uZSBpZiBza2lwcGluZ1xuICAgICAgICAgICAgICAgICAgICAoIXVzZU5hdGl2ZSB8fCByb290LnRhZ05hbWUpKSB7IC8vIHNwbGl0IG5hdGl2ZSB3aGVuIGVsZW1lbnQgc2NvcGluZyBpcyBuZWVkZWRcbiAgICAgICAgICAgICAgICBxdWVyaWVzID0gU2VsZWN0b3IuX3NwbGl0UXVlcmllcyhzZWxlY3Rvciwgcm9vdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IChxdWVyeSA9IHF1ZXJpZXNbaSsrXSk7KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocXVlcnlbMF0sIHF1ZXJ5WzFdLCBmaXJzdE9ubHkpO1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RPbmx5KSB7IC8vIGNvZXJjZSBET00gQ29sbGVjdGlvbiB0byBBcnJheVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBZLkFycmF5KHJlc3VsdCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHF1ZXJpZXMubGVuZ3RoID4gMSkgeyAvLyByZW1vdmUgZHVwZXMgYW5kIHNvcnQgYnkgZG9jIG9yZGVyXG4gICAgICAgICAgICAgICAgcmV0ID0gU2VsZWN0b3IuX3NvcnQoU2VsZWN0b3IuX2RlRHVwZShyZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoZmlyc3RPbmx5KSA/IChyZXRbMF0gfHwgbnVsbCkgOiByZXQ7XG5cbiAgICB9LFxuXG4gICAgX3JlcGxhY2VTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGVzYyA9IFkuU2VsZWN0b3IuX3BhcnNlKCdlc2MnLCBzZWxlY3RvciksIC8vIHB1bGwgZXNjYXBlZCBjb2xvbiwgYnJhY2tldHMsIGV0Yy5cbiAgICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgICAgcHNldWRvcztcblxuICAgICAgICAvLyBmaXJzdCByZXBsYWNlIGVzY2FwZWQgY2hhcnMsIHdoaWNoIGNvdWxkIGJlIHByZXNlbnQgaW4gYXR0cnMgb3IgcHNldWRvc1xuICAgICAgICBzZWxlY3RvciA9IFkuU2VsZWN0b3IuX3JlcGxhY2UoJ2VzYycsIHNlbGVjdG9yKTtcblxuICAgICAgICAvLyB0aGVuIHJlcGxhY2UgcHNldWRvcyBiZWZvcmUgYXR0cnMgdG8gYXZvaWQgcmVwbGFjaW5nIDpub3QoW2Zvb10pXG4gICAgICAgIHBzZXVkb3MgPSBZLlNlbGVjdG9yLl9wYXJzZSgncHNldWRvJywgc2VsZWN0b3IpO1xuICAgICAgICBzZWxlY3RvciA9IFNlbGVjdG9yLl9yZXBsYWNlKCdwc2V1ZG8nLCBzZWxlY3Rvcik7XG5cbiAgICAgICAgYXR0cnMgPSBZLlNlbGVjdG9yLl9wYXJzZSgnYXR0cicsIHNlbGVjdG9yKTtcbiAgICAgICAgc2VsZWN0b3IgPSBZLlNlbGVjdG9yLl9yZXBsYWNlKCdhdHRyJywgc2VsZWN0b3IpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlc2M6IGVzYyxcbiAgICAgICAgICAgIGF0dHJzOiBhdHRycyxcbiAgICAgICAgICAgIHBzZXVkb3M6IHBzZXVkb3MsXG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX3Jlc3RvcmVTZWxlY3RvcjogZnVuY3Rpb24ocmVwbGFjZWQpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gcmVwbGFjZWQuc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yID0gWS5TZWxlY3Rvci5fcmVzdG9yZSgnYXR0cicsIHNlbGVjdG9yLCByZXBsYWNlZC5hdHRycyk7XG4gICAgICAgIHNlbGVjdG9yID0gWS5TZWxlY3Rvci5fcmVzdG9yZSgncHNldWRvJywgc2VsZWN0b3IsIHJlcGxhY2VkLnBzZXVkb3MpO1xuICAgICAgICBzZWxlY3RvciA9IFkuU2VsZWN0b3IuX3Jlc3RvcmUoJ2VzYycsIHNlbGVjdG9yLCByZXBsYWNlZC5lc2MpO1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfSxcblxuICAgIF9yZXBsYWNlQ29tbWFzOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSBZLlNlbGVjdG9yLl9yZXBsYWNlU2VsZWN0b3Ioc2VsZWN0b3IpLFxuICAgICAgICAgICAgc2VsZWN0b3IgPSByZXBsYWNlZC5zZWxlY3RvcjtcblxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvLC9nLCAnXFx1RTAwNycpO1xuICAgICAgICAgICAgcmVwbGFjZWQuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gWS5TZWxlY3Rvci5fcmVzdG9yZVNlbGVjdG9yKHJlcGxhY2VkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfSxcblxuICAgIC8vIGFsbG93cyBlbGVtZW50IHNjb3BlZCBxdWVyaWVzIHRvIGJlZ2luIHdpdGggY29tYmluYXRvclxuICAgIC8vIGUuZy4gcXVlcnkoJz4gcCcsIGRvY3VtZW50LmJvZHkpID09PSBxdWVyeSgnYm9keSA+IHAnKVxuICAgIF9zcGxpdFF1ZXJpZXM6IGZ1bmN0aW9uKHNlbGVjdG9yLCBub2RlKSB7XG4gICAgICAgIGlmIChzZWxlY3Rvci5pbmRleE9mKCcsJykgPiAtMSkge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBZLlNlbGVjdG9yLl9yZXBsYWNlQ29tbWFzKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cHMgPSBzZWxlY3Rvci5zcGxpdCgnXFx1RTAwNycpLCAvLyBzcGxpdCBvbiByZXBsYWNlZCBjb21tYSB0b2tlblxuICAgICAgICAgICAgcXVlcmllcyA9IFtdLFxuICAgICAgICAgICAgcHJlZml4ID0gJycsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW47XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIGVuZm9yY2UgZm9yIGVsZW1lbnQgc2NvcGluZ1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHsgLy8gRWxlbWVudHMgb25seVxuICAgICAgICAgICAgICAgIGlkID0gWS5TZWxlY3Rvci5fZXNjYXBlSWQoWS5ET00uZ2V0SWQobm9kZSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IFkuZ3VpZCgpO1xuICAgICAgICAgICAgICAgICAgICBZLkRPTS5zZXRJZChub2RlLCBpZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJ1tpZD1cIicgKyBpZCArICdcIl0gJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAgcHJlZml4ICsgZ3JvdXBzW2ldO1xuICAgICAgICAgICAgICAgIHF1ZXJpZXMucHVzaChbc2VsZWN0b3IsIG5vZGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxdWVyaWVzO1xuICAgIH0sXG5cbiAgICBfbmF0aXZlUXVlcnk6IGZ1bmN0aW9uKHNlbGVjdG9yLCByb290LCBvbmUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKFkuVUEud2Via2l0IHx8IFkuVUEub3BlcmEpICYmICAgICAgICAgIC8vIHdlYmtpdCAoY2hyb21lLCBzYWZhcmkpIGFuZCBPcGVyYVxuICAgICAgICAgICAgc2VsZWN0b3IuaW5kZXhPZignOmNoZWNrZWQnKSA+IC0xICYmICAgIC8vIGZhaWwgdG8gcGljayB1cCBcInNlbGVjdGVkXCIgIHdpdGggXCI6Y2hlY2tlZFwiXG4gICAgICAgICAgICAoWS5TZWxlY3Rvci5wc2V1ZG9zICYmIFkuU2VsZWN0b3IucHNldWRvcy5jaGVja2VkKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBZLlNlbGVjdG9yLnF1ZXJ5KHNlbGVjdG9yLCByb290LCBvbmUsIHRydWUpOyAvLyByZWRvIHdpdGggc2tpcE5hdGl2ZSB0cnVlIHRvIHRyeSBicnV0ZSBxdWVyeVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdFsncXVlcnlTZWxlY3RvcicgKyAob25lID8gJycgOiAnQWxsJyldKHNlbGVjdG9yKTtcbiAgICAgICAgfSBjYXRjaChlKSB7IC8vIGZhbGxiYWNrIHRvIGJydXRlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgcmV0dXJuIFkuU2VsZWN0b3IucXVlcnkoc2VsZWN0b3IsIHJvb3QsIG9uZSwgdHJ1ZSk7IC8vIHJlZG8gd2l0aCBza2lwTmF0aXZlIHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIG91dCBub2RlcyB0aGF0IGRvIG5vdCBtYXRjaCB0aGUgZ2l2ZW4gQ1NTIHNlbGVjdG9yLlxuICAgICAqIEBtZXRob2QgZmlsdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W119IG5vZGVzIEFuIGFycmF5IG9mIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBBIENTUyBzZWxlY3RvciB0byB0ZXN0IGVhY2ggbm9kZSBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119IFRoZSBub2RlcyB0aGF0IG1hdGNoZWQgdGhlIGdpdmVuIENTUyBzZWxlY3Rvci5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbihub2Rlcywgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdLFxuICAgICAgICAgICAgaSwgbm9kZTtcblxuICAgICAgICBpZiAobm9kZXMgJiYgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IChub2RlID0gbm9kZXNbaSsrXSk7KSB7XG4gICAgICAgICAgICAgICAgaWYgKFkuU2VsZWN0b3IudGVzdChub2RlLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W3JldC5sZW5ndGhdID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBub2RlIG1hdGNoZXMgdGhlIGdpdmVuIENTUyBzZWxlY3Rvci5cbiAgICAgKiBAbWV0aG9kIHRlc3RcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIEEgbm9kZSB0byB0ZXN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBBIENTUyBzZWxlY3RvciB0byB0ZXN0IHRoZSBub2RlIGFnYWluc3QuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCBvcHRpb25hbCBBIG5vZGUgdG8gc3RhcnQgdGhlIHF1ZXJ5IGZyb20uIERlZmF1bHRzIHRvIHRoZSBwYXJlbnQgZG9jdW1lbnQgb2YgdGhlIG5vZGUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGdpdmVuIG5vZGUgbWF0Y2hlZCB0aGUgZ2l2ZW4gQ1NTIHNlbGVjdG9yLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0ZXN0OiBmdW5jdGlvbihub2RlLCBzZWxlY3Rvciwgcm9vdCkge1xuICAgICAgICB2YXIgcmV0ID0gZmFsc2UsXG4gICAgICAgICAgICB1c2VGcmFnID0gZmFsc2UsXG4gICAgICAgICAgICBncm91cHMsXG4gICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBpLCBqLCBncm91cDtcblxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnRhZ05hbWUpIHsgLy8gb25seSB0ZXN0IEhUTUxFbGVtZW50c1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09ICdmdW5jdGlvbicpIHsgLy8gdGVzdCB3aXRoIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmV0ID0gc2VsZWN0b3IuY2FsbChub2RlLCBub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHRlc3Qgd2l0aCBxdWVyeVxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgYSByb290IGlmIG9mZi1kb2NcbiAgICAgICAgICAgICAgICBncm91cHMgPSBzZWxlY3Rvci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIGlmICghcm9vdCAmJiAhWS5ET00uaW5Eb2Mobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBvbmx5IHVzZSBmcmFnIHdoZW4gbm8gcGFyZW50IHRvIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gbm9kZVtPV05FUl9ET0NVTUVOVF0uY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QgPSBmcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRnJhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QgfHwgbm9kZVtPV05FUl9ET0NVTUVOVF07XG5cbiAgICAgICAgICAgICAgICBpZCA9IFkuU2VsZWN0b3IuX2VzY2FwZUlkKFkuRE9NLmdldElkKG5vZGUpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gWS5ndWlkKCk7XG4gICAgICAgICAgICAgICAgICAgIFkuRE9NLnNldElkKG5vZGUsIGlkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyAoZ3JvdXAgPSBncm91cHNbaSsrXSk7KSB7IC8vIFRPRE86IG9mZi1kb20gdGVzdFxuICAgICAgICAgICAgICAgICAgICBncm91cCArPSAnW2lkPVwiJyArIGlkICsgJ1wiXSc7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gWS5TZWxlY3Rvci5xdWVyeShncm91cCwgcm9vdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaXRlbSA9IGl0ZW1zW2orK107KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlRnJhZykgeyAvLyBjbGVhbnVwXG4gICAgICAgICAgICAgICAgICAgIGZyYWcucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgY29udmVuaWVuY2UgbWV0aG9kIHRvIGVtdWxhdGUgWS5Ob2RlJ3MgYU5vZGUuYW5jZXN0b3Ioc2VsZWN0b3IpLlxuICAgICAqIEBtZXRob2QgYW5jZXN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgQSBub2RlIHRvIHN0YXJ0IHRoZSBxdWVyeSBmcm9tLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBBIENTUyBzZWxlY3RvciB0byB0ZXN0IHRoZSBub2RlIGFnYWluc3QuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0ZXN0U2VsZiBvcHRpb25hbCBXaGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIHRoZSBub2RlIGluIHRoZSBzY2FuLlxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgYW5jZXN0b3Igbm9kZSBtYXRjaGluZyB0aGUgc2VsZWN0b3IsIG9yIG51bGwuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGFuY2VzdG9yOiBmdW5jdGlvbiAobm9kZSwgc2VsZWN0b3IsIHRlc3RTZWxmKSB7XG4gICAgICAgIHJldHVybiBZLkRPTS5hbmNlc3Rvcihub2RlLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICByZXR1cm4gWS5TZWxlY3Rvci50ZXN0KG4sIHNlbGVjdG9yKTtcbiAgICAgICAgfSwgdGVzdFNlbGYpO1xuICAgIH0sXG5cbiAgICBfcGFyc2U6IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5tYXRjaChZLlNlbGVjdG9yLl90eXBlc1tuYW1lXS5yZSk7XG4gICAgfSxcblxuICAgIF9yZXBsYWNlOiBmdW5jdGlvbihuYW1lLCBzZWxlY3Rvcikge1xuICAgICAgICB2YXIgbyA9IFkuU2VsZWN0b3IuX3R5cGVzW25hbWVdO1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShvLnJlLCBvLnRva2VuKTtcbiAgICB9LFxuXG4gICAgX3Jlc3RvcmU6IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdG9yLCBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IFkuU2VsZWN0b3IuX3R5cGVzW25hbWVdLnRva2VuLFxuICAgICAgICAgICAgICAgIGksIGxlbjtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKHRva2VuLCBpdGVtc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cbn07XG5cblkubWl4KFkuU2VsZWN0b3IsIFNlbGVjdG9yLCB0cnVlKTtcblxufSkoWSk7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcImRvbS1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ3NlbGVjdG9yJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJzZWxlY3Rvci1uYXRpdmVcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgndGltZXJzJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG5Qcm92aWRlcyB1dGlsaXRpZXMgZm9yIHRpbWVkIGFzeW5jaHJvbm91cyBjYWxsYmFjayBleGVjdXRpb24uXG5ZLnNvb24gaXMgYSBzZXRJbW1lZGlhdGUvcHJvY2Vzcy5uZXh0VGljay9zZXRUaW1lb3V0IHdyYXBwZXIuXG5cblRoaXMgbW9kdWxlIGluY2x1ZGVzIFthc2FwLmpzXShodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL2FzYXApIGZvciBzY2hlZHVsaW5nXG5hc3luY2hyb25vdXMgdGFza3MuXG5cbkBtb2R1bGUgdGltZXJzXG5AYXV0aG9yIFN0ZXZlbiBPbG1zdGVkXG4qKi9cblxuLy8gSGFjay4gYXNhcC5qcyBpcyB3cml0dGVuIGFzIGEgTm9kZSBtb2R1bGUgYW5kIGV4cGVjdHMgcmVxdWlyZSwgbW9kdWxlIGFuZFxuLy8gZ2xvYmFsIHRvIGJlIGF2YWlsYWJsZSBpbiB0aGUgbW9kdWxlJ3Mgc2NvcGUuXG52YXIgbW9kdWxlID0ge30sXG4gICAgZ2xvYmFsID0gWS5jb25maWcuZ2xvYmFsO1xuXG4vLyBgYXNhcGAgb25seSByZXF1aXJlcyBhIGBxdWV1ZWAgbW9kdWxlIHRoYXQgaXMgYnVuZGxlZCBpbnRvIHRoaXMgc2FtZSBmaWxlLlxuZnVuY3Rpb24gcmVxdWlyZShtb2QpIHtcbiAgICByZXR1cm4gUXVldWU7XG59XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcbmZ1bmN0aW9uIFF1ZXVlKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5jYXBhY2l0eSA9IHRoaXMuc25hcChjYXBhY2l0eSk7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZnJvbnQgPSAwO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xufVxuXG5RdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAodGhpcy5jYXBhY2l0eSA8PSBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5ncm93KHRoaXMuc25hcCh0aGlzLmNhcGFjaXR5ICogdGhpcy5ncm93RmFjdG9yKSk7XG4gICAgfVxuICAgIHZhciBpbmRleCA9ICh0aGlzLmZyb250ICsgbGVuZ3RoKSAmICh0aGlzLmNhcGFjaXR5IC0gMSk7XG4gICAgdGhpc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aCArIDE7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZyb250ID0gdGhpcy5mcm9udDtcbiAgICB2YXIgcmVzdWx0ID0gdGhpc1tmcm9udF07XG5cbiAgICB0aGlzW2Zyb250XSA9IHZvaWQgMDtcbiAgICB0aGlzLmZyb250ID0gKGZyb250ICsgMSkgJiAodGhpcy5jYXBhY2l0eSAtIDEpO1xuICAgIHRoaXMubGVuZ3RoLS07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5ncm93ID0gZnVuY3Rpb24gKGNhcGFjaXR5KSB7XG4gICAgdmFyIG9sZEZyb250ID0gdGhpcy5mcm9udDtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLmNhcGFjaXR5O1xuICAgIHZhciBvbGRRdWV1ZSA9IG5ldyBBcnJheShvbGRDYXBhY2l0eSk7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgY29weSh0aGlzLCAwLCBvbGRRdWV1ZSwgMCwgb2xkQ2FwYWNpdHkpO1xuICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLmZyb250ID0gMDtcbiAgICBpZiAob2xkRnJvbnQgKyBsZW5ndGggPD0gb2xkQ2FwYWNpdHkpIHtcbiAgICAgICAgLy8gQ2FuIHBlcmZvcm0gZGlyZWN0IGxpbmVhciBjb3B5XG4gICAgICAgIGNvcHkob2xkUXVldWUsIG9sZEZyb250LCB0aGlzLCAwLCBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENhbm5vdCBwZXJmb3JtIGNvcHkgZGlyZWN0bHksIHBlcmZvcm0gYXMgbXVjaCBhcyBwb3NzaWJsZSBhdCB0aGVcbiAgICAgICAgLy8gZW5kLCBhbmQgdGhlbiBjb3B5IHRoZSByZXN0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGJ1ZmZlclxuICAgICAgICB2YXIgbGVuZ3RoQmVmb3JlV3JhcHBpbmcgPVxuICAgICAgICAgICAgbGVuZ3RoIC0gKChvbGRGcm9udCArIGxlbmd0aCkgJiAob2xkQ2FwYWNpdHkgLSAxKSk7XG4gICAgICAgIGNvcHkoXG4gICAgICAgICAgICBvbGRRdWV1ZSxcbiAgICAgICAgICAgIG9sZEZyb250LFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBsZW5ndGhCZWZvcmVXcmFwcGluZ1xuICAgICAgICApO1xuICAgICAgICBjb3B5KFxuICAgICAgICAgICAgb2xkUXVldWUsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGxlbmd0aEJlZm9yZVdyYXBwaW5nLFxuICAgICAgICAgICAgbGVuZ3RoIC0gbGVuZ3RoQmVmb3JlV3JhcHBpbmdcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5jYXBhY2l0eTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXNbaV0gPSB2b2lkIDA7XG4gICAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLnNuYXAgPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICBpZiAodHlwZW9mIGNhcGFjaXR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbkNhcGFjaXR5O1xuICAgIH1cbiAgICByZXR1cm4gcG93MkF0TGVhc3QoXG4gICAgICAgIE1hdGgubWluKHRoaXMubWF4Q2FwYWNpdHksIE1hdGgubWF4KHRoaXMubWluQ2FwYWNpdHksIGNhcGFjaXR5KSlcbiAgICApO1xufTtcblxuUXVldWUucHJvdG90eXBlLm1heENhcGFjaXR5ID0gKDEgPDwgMzApIHwgMDtcblF1ZXVlLnByb3RvdHlwZS5taW5DYXBhY2l0eSA9IDE2O1xuUXVldWUucHJvdG90eXBlLmdyb3dGYWN0b3IgPSA4O1xuXG5mdW5jdGlvbiBjb3B5KHNvdXJjZSwgc291cmNlSW5kZXgsIHRhcmdldCwgdGFyZ2V0SW5kZXgsIGxlbmd0aCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdGFyZ2V0W2luZGV4ICsgdGFyZ2V0SW5kZXhdID0gc291cmNlW2luZGV4ICsgc291cmNlSW5kZXhdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcG93MkF0TGVhc3Qobikge1xuICAgIG4gPSBuID4+PiAwO1xuICAgIG4gPSBuIC0gMTtcbiAgICBuID0gbiB8IChuID4+IDEpO1xuICAgIG4gPSBuIHwgKG4gPj4gMik7XG4gICAgbiA9IG4gfCAobiA+PiA0KTtcbiAgICBuID0gbiB8IChuID4+IDgpO1xuICAgIG4gPSBuIHwgKG4gPj4gMTYpO1xuICAgIHJldHVybiBuICsgMTtcbn1cblwidXNlIHN0cmljdFwiO1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG5cbi8vIFF1ZXVlIGlzIGEgY2lyY3VsYXIgYnVmZmVyIHdpdGggZ29vZCBsb2NhbGl0eSBvZiByZWZlcmVuY2UgYW5kIGRvZXNuJ3Rcbi8vIGFsbG9jYXRlIG5ldyBtZW1vcnkgdW5sZXNzIHRoZXJlIGFyZSBtb3JlIHRoYW4gYEluaXRpYWxDYXBhY2l0eWAgcGFyYWxsZWxcbi8vIHRhc2tzIGluIHdoaWNoIGNhc2UgaXQgd2lsbCByZXNpemUgaXRzZWxmIGdlbmVyb3VzbHkgdG8geDggbW9yZSBjYXBhY2l0eS5cbi8vIFRoZSB1c2UgY2FzZSBvZiBhc2FwIHNob3VsZCByZXF1aXJlIG5vIG9yIGZldyBhbW91bnQgb2YgcmVzaXplcyBkdXJpbmdcbi8vIHJ1bnRpbWUuXG4vLyBDYWxsaW5nIGEgdGFzayBmcmVlcyBhIHNsb3QgaW1tZWRpYXRlbHkgc28gaWYgdGhlIGNhbGxpbmdcbi8vIGhhcyBhIHNpZGUgZWZmZWN0IG9mIHF1ZXVpbmcgaXRzZWxmIGFnYWluLCBpdCBjYW4gYmUgc3VzdGFpbmVkXG4vLyB3aXRob3V0IGFkZGl0aW9uYWwgbWVtb3J5XG4vLyBRdWV1ZSBzcGVjaWZpY2FsbHkgdXNlc1xuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaXJjdWxhcl9idWZmZXIjVXNlX2FfRmlsbF9Db3VudFxuLy8gQmVjYXVzZTpcbi8vIDEuIFdlIG5lZWQgZmFzdCAubGVuZ3RoIG9wZXJhdGlvbiwgc2luY2UgcXVldWVcbi8vICAgY291bGQgaGF2ZSBjaGFuZ2VkIGFmdGVyIGV2ZXJ5IGl0ZXJhdGlvblxuLy8gMi4gTW9kdWx1cyBjYW4gYmUgbmVnYXRlZCBieSB1c2luZyBwb3dlci1vZi10d29cbi8vICAgY2FwYWNpdGllcyBhbmQgcmVwbGFjaW5nIGl0IHdpdGggYml0d2lzZSBBTkRcbi8vIDMuIEl0IHdpbGwgbm90IGJlIHVzZWQgaW4gYSBtdWx0aS10aHJlYWRlZCBzaXR1YXRpb24uXG5cbnZhciBRdWV1ZSA9IHJlcXVpcmUoXCIuL3F1ZXVlXCIpO1xuXG4vLzEwMjQgPSBJbml0aWFsQ2FwYWNpdHlcbnZhciBxdWV1ZSA9IG5ldyBRdWV1ZSgxMDI0KTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIHJlcXVlc3RGbHVzaCA9IHZvaWQgMDtcbnZhciBoYXNTZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCI7XG52YXIgZG9tYWluO1xuXG4vLyBBdm9pZCBzaGltcyBmcm9tIGJyb3dzZXJpZnkuXG4vLyBUaGUgZXhpc3RlbmNlIG9mIGBnbG9iYWxgIGluIGJyb3dzZXJzIGlzIGd1YXJhbnRlZWQgYnkgYnJvd3NlcmlmeS5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG5cbi8vIE5vdGUgdGhhdCBzb21lIGZha2UtTm9kZSBlbnZpcm9ubWVudHMsXG4vLyBsaWtlIHRoZSBNb2NoYSB0ZXN0IHJ1bm5lciwgaW50cm9kdWNlIGEgYHByb2Nlc3NgIGdsb2JhbC5cbnZhciBpc05vZGVKUyA9ICEhcHJvY2VzcyAmJiAoe30pLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiO1xuXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0YXNrID0gcXVldWUuc2hpZnQoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFzay5jYWxsKCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gbm9kZSwgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgY29uc2lkZXJlZCBmYXRhbCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSB0byBpbnRlcnJ1cHQgZmx1c2hpbmchXG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiBpcyBzdXBwcmVzc2VkXG4gICAgICAgICAgICAgICAgLy8gbGlzdGVuaW5nIHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiKSBvciBkb21haW4oXCJlcnJvclwiKS5cbiAgICAgICAgICAgICAgICByZXF1ZXN0Rmx1c2goKTtcblxuICAgICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHNsb3ctZG93bnMuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG5pZiAoaXNOb2RlSlMpIHtcbiAgICAvLyBOb2RlLmpzXG4gICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBFbnN1cmUgZmx1c2hpbmcgaXMgbm90IGJvdW5kIHRvIGFueSBkb21haW4uXG4gICAgICAgIHZhciBjdXJyZW50RG9tYWluID0gcHJvY2Vzcy5kb21haW47XG4gICAgICAgIGlmIChjdXJyZW50RG9tYWluKSB7XG4gICAgICAgICAgICBkb21haW4gPSBkb21haW4gfHwgKDEscmVxdWlyZSkoXCJkb21haW5cIik7XG4gICAgICAgICAgICBkb21haW4uYWN0aXZlID0gcHJvY2Vzcy5kb21haW4gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgdGljayByZWN1cnNpb24gLSB1c2Ugc2V0SW1tZWRpYXRlIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgaWYgKGZsdXNoaW5nICYmIGhhc1NldEltbWVkaWF0ZSkge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnREb21haW4pIHtcbiAgICAgICAgICAgIGRvbWFpbi5hY3RpdmUgPSBwcm9jZXNzLmRvbWFpbiA9IGN1cnJlbnREb21haW47XG4gICAgICAgIH1cbiAgICB9O1xuXG59IGVsc2UgaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgIC8vIEluIElFMTAsIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgIHJlcXVlc3RGbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICB9O1xuXG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIG1vZGVybiBicm93c2Vyc1xuICAgIC8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAvLyBBdCBsZWFzdCBTYWZhcmkgVmVyc2lvbiA2LjAuNSAoODUzNi4zMC4xKSBpbnRlcm1pdHRlbnRseSBjYW5ub3QgY3JlYXRlXG4gICAgLy8gd29ya2luZyBtZXNzYWdlIHBvcnRzIHRoZSBmaXJzdCB0aW1lIGEgcGFnZSBsb2Fkcy5cbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoID0gcmVxdWVzdFBvcnRGbHVzaDtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgICAgICAgZmx1c2goKTtcbiAgICB9O1xuICAgIHZhciByZXF1ZXN0UG9ydEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBPcGVyYSByZXF1aXJlcyB1cyB0byBwcm92aWRlIGEgbWVzc2FnZSBwYXlsb2FkLCByZWdhcmRsZXNzIG9mXG4gICAgICAgIC8vIHdoZXRoZXIgd2UgdXNlIGl0LlxuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG4gICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgcmVxdWVzdFBvcnRGbHVzaCgpO1xuICAgIH07XG5cbn0gZWxzZSB7XG4gICAgLy8gb2xkIGJyb3dzZXJzXG4gICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhc2FwKHRhc2spIHtcbiAgICBpZiAoaXNOb2RlSlMgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgICAgdGFzayA9IHByb2Nlc3MuZG9tYWluLmJpbmQodGFzayk7XG4gICAgfVxuXG4gICAgcXVldWUucHVzaCh0YXNrKTtcblxuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzYXA7XG4vKipcblkuc29vbiBhY2NlcHRzIGEgY2FsbGJhY2sgZnVuY3Rpb24uICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWRcbm9uY2UgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgSmF2YVNjcmlwdCBldmVudCBsb29wLiAgSWYgdGhlIGZ1bmN0aW9uXG5yZXF1aXJlcyBhIHNwZWNpZmljIGV4ZWN1dGlvbiBjb250ZXh0IG9yIGFyZ3VtZW50cywgd3JhcCBpdCB3aXRoIFkuYmluZC5cblkuc29vbiByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgY2FuY2VsIG1ldGhvZC4gIElmIHRoZSBjYW5jZWwgbWV0aG9kIGlzXG5jYWxsZWQgYmVmb3JlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdvbid0IGJlXG5jYWxsZWQuXG5cbkBtZXRob2Qgc29vblxuQGZvciBZVUlcbkBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrRnVuY3Rpb25cbkByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggYSBjYW5jZWwgbWV0aG9kLiAgSWYgdGhlIGNhbmNlbCBtZXRob2QgaXNcbiAgICBjYWxsZWQgYmVmb3JlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdvbid0IGJlXG4gICAgY2FsbGVkLlxuKiovXG5mdW5jdGlvbiBzb29uKGNhbGxiYWNrRnVuY3Rpb24pIHtcbiAgICB2YXIgY2FuY2VsZWQ7XG5cbiAgICBzb29uLl9hc3luY2hyb25pemVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU29tZSBhc3luY2hyb25pemVycyBtYXkgcHJvdmlkZSB0aGVpciBvd24gY2FuY2VsbGF0aW9uXG4gICAgICAgIC8vIG1ldGhvZHMgc3VjaCBhcyBjbGVhckltbWVkaWF0ZSBvciBjbGVhclRpbWVvdXQgYnV0IHNvbWVcbiAgICAgICAgLy8gYXN5bmNocm9uaXplcnMgZG8gbm90LiAgRm9yIHNpbXBsaWNpdHksIGNhbmNlbGxhdGlvbiBpc1xuICAgICAgICAvLyBlbnRpcmVseSBoYW5kbGVkIGhlcmUgcmF0aGVyIHRoYW4gd3JhcHBpbmcgdGhlIG90aGVyIG1ldGhvZHMuXG4gICAgICAgIC8vIEFsbCBhc3luY2hyb25pemVycyBhcmUgZXhwZWN0ZWQgdG8gYWx3YXlzIGNhbGwgdGhpcyBhbm9ueW1vdXNcbiAgICAgICAgLy8gZnVuY3Rpb24uXG4gICAgICAgIGlmICghY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrRnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYW5jZWxlZCA9IDE7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5zb29uLl9hc3luY2hyb25pemVyID0gYXNhcDtcbnNvb24uX2ltcGwgPSAnYXNhcCc7XG5cblkuc29vbiA9IHNvb247XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcInl1aS1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ3RyYW5zaXRpb24nLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcbiogUHJvdmlkZXMgdGhlIHRyYW5zaXRpb24gbWV0aG9kIGZvciBOb2RlLlxuKiBUcmFuc2l0aW9uIGhhcyBubyBBUEkgb2YgaXRzIG93biwgYnV0IGFkZHMgdGhlIHRyYW5zaXRpb24gbWV0aG9kIHRvIE5vZGUuXG4qXG4qIEBtb2R1bGUgdHJhbnNpdGlvblxuKiBAcmVxdWlyZXMgbm9kZS1zdHlsZVxuKi9cblxudmFyIENBTUVMX1ZFTkRPUl9QUkVGSVggPSAnJyxcbiAgICBWRU5ET1JfUFJFRklYID0gJycsXG4gICAgRE9DVU1FTlQgPSBZLmNvbmZpZy5kb2MsXG4gICAgRE9DVU1FTlRfRUxFTUVOVCA9ICdkb2N1bWVudEVsZW1lbnQnLFxuICAgIERPQ1VNRU5UX1NUWUxFID0gRE9DVU1FTlRbRE9DVU1FTlRfRUxFTUVOVF0uc3R5bGUsXG4gICAgVFJBTlNJVElPTl9DQU1FTCA9ICd0cmFuc2l0aW9uJyxcbiAgICBUUkFOU0lUSU9OX1BST1BFUlRZX0NBTUVMID0gJ3RyYW5zaXRpb25Qcm9wZXJ0eScsXG4gICAgVFJBTlNJVElPTl9QUk9QRVJUWSxcbiAgICBUUkFOU0lUSU9OX0RVUkFUSU9OLFxuICAgIFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OLFxuICAgIFRSQU5TSVRJT05fREVMQVksXG4gICAgVFJBTlNJVElPTl9FTkQsXG4gICAgT05fVFJBTlNJVElPTl9FTkQsXG5cbiAgICBFTVBUWV9PQkogPSB7fSxcblxuICAgIFZFTkRPUlMgPSBbXG4gICAgICAgICdXZWJraXQnLFxuICAgICAgICAnTW96J1xuICAgIF0sXG5cbiAgICBWRU5ET1JfVFJBTlNJVElPTl9FTkQgPSB7XG4gICAgICAgIFdlYmtpdDogJ3dlYmtpdFRyYW5zaXRpb25FbmQnXG4gICAgfSxcblxuLyoqXG4gKiBBIGNsYXNzIGZvciBjb25zdHJ1Y3RpbmcgdHJhbnNpdGlvbiBpbnN0YW5jZXMuXG4gKiBBZGRzIHRoZSBcInRyYW5zaXRpb25cIiBtZXRob2QgdG8gTm9kZS5cbiAqIEBjbGFzcyBUcmFuc2l0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5UcmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vLyBPbmUgb2ZmIGhhbmRsaW5nIG9mIHRyYW5zZm9ybS1wcmVmaXhpbmcuXG5UcmFuc2l0aW9uLl9UUkFOU0ZPUk0gPSAndHJhbnNmb3JtJztcblxuVHJhbnNpdGlvbi5fdG9DYW1lbCA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5yZXBsYWNlKC8tKFthLXpdKS9naSwgZnVuY3Rpb24obTAsIG0xKSB7XG4gICAgICAgIHJldHVybiBtMS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb3BlcnR5O1xufTtcblxuVHJhbnNpdGlvbi5fdG9IeXBoZW4gPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHByb3BlcnR5ID0gcHJvcGVydHkucmVwbGFjZSgvKFtBLVpdPykoW2Etel0rKShbQS1aXT8pL2csIGZ1bmN0aW9uKG0wLCBtMSwgbTIsIG0zKSB7XG4gICAgICAgIHZhciBzdHIgPSAoKG0xKSA/ICctJyArIG0xLnRvTG93ZXJDYXNlKCkgOiAnJykgKyBtMjtcblxuICAgICAgICBpZiAobTMpIHtcbiAgICAgICAgICAgIHN0ciArPSAnLScgKyBtMy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9wZXJ0eTtcbn07XG5cblRyYW5zaXRpb24uU0hPV19UUkFOU0lUSU9OID0gJ2ZhZGVJbic7XG5UcmFuc2l0aW9uLkhJREVfVFJBTlNJVElPTiA9ICdmYWRlT3V0JztcblxuVHJhbnNpdGlvbi51c2VOYXRpdmUgPSBmYWxzZTtcblxuLy8gTWFwIHRyYW5zaXRpb24gcHJvcGVydGllcyB0byB2ZW5kb3Itc3BlY2lmaWMgdmVyc2lvbnMuXG5pZiAoJ3RyYW5zaXRpb24nIGluIERPQ1VNRU5UX1NUWUxFXG4gICAgJiYgJ3RyYW5zaXRpb25Qcm9wZXJ0eScgaW4gRE9DVU1FTlRfU1RZTEVcbiAgICAmJiAndHJhbnNpdGlvbkR1cmF0aW9uJyBpbiBET0NVTUVOVF9TVFlMRVxuICAgICYmICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nIGluIERPQ1VNRU5UX1NUWUxFXG4gICAgJiYgJ3RyYW5zaXRpb25EZWxheScgaW4gRE9DVU1FTlRfU1RZTEUpIHtcbiAgICBUcmFuc2l0aW9uLnVzZU5hdGl2ZSA9IHRydWU7XG4gICAgVHJhbnNpdGlvbi5zdXBwb3J0ZWQgPSB0cnVlOyAvLyBUT0RPOiByZW1vdmVcbn0gZWxzZSB7XG4gICAgWS5BcnJheS5lYWNoKFZFTkRPUlMsIGZ1bmN0aW9uKHZhbCkgeyAvLyB0aGVuIHZlbmRvciBzcGVjaWZpY1xuICAgICAgICB2YXIgcHJvcGVydHkgPSB2YWwgKyAnVHJhbnNpdGlvbic7XG4gICAgICAgIGlmIChwcm9wZXJ0eSBpbiBET0NVTUVOVFtET0NVTUVOVF9FTEVNRU5UXS5zdHlsZSkge1xuICAgICAgICAgICAgQ0FNRUxfVkVORE9SX1BSRUZJWCA9IHZhbDtcbiAgICAgICAgICAgIFZFTkRPUl9QUkVGSVggICAgICAgPSBUcmFuc2l0aW9uLl90b0h5cGhlbih2YWwpICsgJy0nO1xuXG4gICAgICAgICAgICBUcmFuc2l0aW9uLnVzZU5hdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBUcmFuc2l0aW9uLnN1cHBvcnRlZCA9IHRydWU7IC8vIFRPRE86IHJlbW92ZVxuICAgICAgICAgICAgVHJhbnNpdGlvbi5fVkVORE9SX1BSRUZJWCA9IHZhbDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyBNYXAgdHJhbnNmb3JtIHByb3BlcnR5IHRvIHZlbmRvci1zcGVjaWZpYyB2ZXJzaW9ucy5cbi8vIE9uZS1vZmYgcmVxdWlyZWQgZm9yIGNzc1RleHQgaW5qZWN0aW9uLlxuaWYgKHR5cGVvZiBET0NVTUVOVF9TVFlMRS50cmFuc2Zvcm0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgWS5BcnJheS5lYWNoKFZFTkRPUlMsIGZ1bmN0aW9uKHZhbCkgeyAvLyB0aGVuIHZlbmRvciBzcGVjaWZpY1xuICAgICAgICB2YXIgcHJvcGVydHkgPSB2YWwgKyAnVHJhbnNmb3JtJztcbiAgICAgICAgaWYgKHR5cGVvZiBET0NVTUVOVF9TVFlMRVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBUcmFuc2l0aW9uLl9UUkFOU0ZPUk0gPSBwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5pZiAoQ0FNRUxfVkVORE9SX1BSRUZJWCkge1xuICAgIFRSQU5TSVRJT05fQ0FNRUwgICAgICAgICAgPSBDQU1FTF9WRU5ET1JfUFJFRklYICsgJ1RyYW5zaXRpb24nO1xuICAgIFRSQU5TSVRJT05fUFJPUEVSVFlfQ0FNRUwgPSBDQU1FTF9WRU5ET1JfUFJFRklYICsgJ1RyYW5zaXRpb25Qcm9wZXJ0eSc7XG59XG5cblRSQU5TSVRJT05fUFJPUEVSVFkgICAgICAgID0gVkVORE9SX1BSRUZJWCArICd0cmFuc2l0aW9uLXByb3BlcnR5JztcblRSQU5TSVRJT05fRFVSQVRJT04gICAgICAgID0gVkVORE9SX1BSRUZJWCArICd0cmFuc2l0aW9uLWR1cmF0aW9uJztcblRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OID0gVkVORE9SX1BSRUZJWCArICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbic7XG5UUkFOU0lUSU9OX0RFTEFZICAgICAgICAgICA9IFZFTkRPUl9QUkVGSVggKyAndHJhbnNpdGlvbi1kZWxheSc7XG5cblRSQU5TSVRJT05fRU5EICAgID0gJ3RyYW5zaXRpb25lbmQnO1xuT05fVFJBTlNJVElPTl9FTkQgPSAnb24nICsgQ0FNRUxfVkVORE9SX1BSRUZJWC50b0xvd2VyQ2FzZSgpICsgJ3RyYW5zaXRpb25lbmQnO1xuVFJBTlNJVElPTl9FTkQgICAgPSBWRU5ET1JfVFJBTlNJVElPTl9FTkRbQ0FNRUxfVkVORE9SX1BSRUZJWF0gfHwgVFJBTlNJVElPTl9FTkQ7XG5cblRyYW5zaXRpb24uZnggPSB7fTtcblRyYW5zaXRpb24udG9nZ2xlcyA9IHt9O1xuXG5UcmFuc2l0aW9uLl9oYXNFbmQgPSB7fTtcblxuVHJhbnNpdGlvbi5fcmVLZXl3b3JkcyA9IC9eKD86bm9kZXxkdXJhdGlvbnxpdGVyYXRpb25zfGVhc2luZ3xkZWxheXxvbnxvbnN0YXJ0fG9uZW5kKSQvaTtcblxuWS5Ob2RlLkRPTV9FVkVOVFNbVFJBTlNJVElPTl9FTkRdID0gMTtcblxuVHJhbnNpdGlvbi5OQU1FID0gJ3RyYW5zaXRpb24nO1xuXG5UcmFuc2l0aW9uLkRFRkFVTFRfRUFTSU5HID0gJ2Vhc2UnO1xuVHJhbnNpdGlvbi5ERUZBVUxUX0RVUkFUSU9OID0gMC41O1xuVHJhbnNpdGlvbi5ERUZBVUxUX0RFTEFZID0gMDtcblxuVHJhbnNpdGlvbi5fbm9kZUF0dHJzID0ge307XG5cblRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBUcmFuc2l0aW9uLFxuICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUsIGNvbmZpZykge1xuICAgICAgICB2YXIgYW5pbSA9IHRoaXM7XG4gICAgICAgIGFuaW0uX25vZGUgPSBub2RlO1xuICAgICAgICBpZiAoIWFuaW0uX3J1bm5pbmcgJiYgY29uZmlnKSB7XG4gICAgICAgICAgICBhbmltLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICBub2RlLl90cmFuc2l0aW9uID0gYW5pbTsgLy8gY2FjaGUgZm9yIHJldXNlXG5cbiAgICAgICAgICAgIGFuaW0uX2R1cmF0aW9uID0gKCdkdXJhdGlvbicgaW4gY29uZmlnKSA/XG4gICAgICAgICAgICAgICAgY29uZmlnLmR1cmF0aW9uOiBhbmltLmNvbnN0cnVjdG9yLkRFRkFVTFRfRFVSQVRJT047XG5cbiAgICAgICAgICAgIGFuaW0uX2RlbGF5ID0gKCdkZWxheScgaW4gY29uZmlnKSA/XG4gICAgICAgICAgICAgICAgY29uZmlnLmRlbGF5OiBhbmltLmNvbnN0cnVjdG9yLkRFRkFVTFRfREVMQVk7XG5cbiAgICAgICAgICAgIGFuaW0uX2Vhc2luZyA9IGNvbmZpZy5lYXNpbmcgfHwgYW5pbS5jb25zdHJ1Y3Rvci5ERUZBVUxUX0VBU0lORztcbiAgICAgICAgICAgIGFuaW0uX2NvdW50ID0gMDsgLy8gdHJhY2sgbnVtYmVyIG9mIGFuaW1hdGVkIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGFuaW0uX3J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFuaW07XG4gICAgfSxcblxuICAgIGFkZFByb3BlcnR5OiBmdW5jdGlvbihwcm9wLCBjb25maWcpIHtcbiAgICAgICAgdmFyIGFuaW0gPSB0aGlzLFxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuX25vZGUsXG4gICAgICAgICAgICB1aWQgPSBZLnN0YW1wKG5vZGUpLFxuICAgICAgICAgICAgbm9kZUluc3RhbmNlID0gWS5vbmUobm9kZSksXG4gICAgICAgICAgICBhdHRycyA9IFRyYW5zaXRpb24uX25vZGVBdHRyc1t1aWRdLFxuICAgICAgICAgICAgY29tcHV0ZWQsXG4gICAgICAgICAgICBjb21wYXJlVmFsLFxuICAgICAgICAgICAgZHVyLFxuICAgICAgICAgICAgYXR0cixcbiAgICAgICAgICAgIHZhbDtcblxuICAgICAgICBpZiAoIWF0dHJzKSB7XG4gICAgICAgICAgICBhdHRycyA9IFRyYW5zaXRpb24uX25vZGVBdHRyc1t1aWRdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyID0gYXR0cnNbcHJvcF07XG5cbiAgICAgICAgLy8gbWlnaHQganVzdCBiZSBhIHZhbHVlXG4gICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbCA9IGNvbmZpZy52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsID0gY29uZmlnO1xuICAgICAgICAgICAgY29uZmlnID0gRU1QVFlfT0JKO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5jYWxsKG5vZGVJbnN0YW5jZSwgbm9kZUluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyICYmIGF0dHIudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgLy8gdGFrZSBjb250cm9sIGlmIGFub3RoZXIgdHJhbnNpdGlvbiBvd25zIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgIGlmIChhdHRyLnRyYW5zaXRpb24gIT09IGFuaW0pIHtcbiAgICAgICAgICAgICAgICBhdHRyLnRyYW5zaXRpb24uX2NvdW50LS07IC8vIHJlbWFwcGluZyBhdHRyIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYW5pbS5fY291bnQrKzsgLy8gcHJvcGVydGllcyBwZXIgdHJhbnNpdGlvblxuXG4gICAgICAgIC8vIG1ha2UgMCBhc3luYyBhbmQgZmlyZSBldmVudHNcbiAgICAgICAgZHVyID0gKCh0eXBlb2YgY29uZmlnLmR1cmF0aW9uICE9PSAndW5kZWZpbmVkJykgPyBjb25maWcuZHVyYXRpb24gOlxuICAgICAgICAgICAgICAgICAgICBhbmltLl9kdXJhdGlvbikgfHwgMC4wMDAxO1xuXG4gICAgICAgIGF0dHJzW3Byb3BdID0ge1xuICAgICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXIsXG4gICAgICAgICAgICBkZWxheTogKHR5cGVvZiBjb25maWcuZGVsYXkgIT09ICd1bmRlZmluZWQnKSA/IGNvbmZpZy5kZWxheSA6XG4gICAgICAgICAgICAgICAgICAgIGFuaW0uX2RlbGF5LFxuXG4gICAgICAgICAgICBlYXNpbmc6IGNvbmZpZy5lYXNpbmcgfHwgYW5pbS5fZWFzaW5nLFxuXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBhbmltXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbmF0aXZlIGVuZCBldmVudCBkb2VzbnQgZmlyZSB3aGVuIHNldHRpbmcgdG8gc2FtZSB2YWx1ZVxuICAgICAgICAvLyBzdXBwbGVtZW50aW5nIHdpdGggdGltZXJcbiAgICAgICAgLy8gdmFsIG1heSBiZSBhIHN0cmluZyBvciBudW1iZXIgKGhlaWdodDogMCwgZXRjKSwgYnV0IGNvbXB1dGVkU3R5bGUgaXMgYWx3YXlzIHN0cmluZ1xuICAgICAgICBjb21wdXRlZCA9IFkuRE9NLmdldENvbXB1dGVkU3R5bGUobm9kZSwgcHJvcCk7XG4gICAgICAgIGNvbXBhcmVWYWwgPSAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpID8gY29tcHV0ZWQgOiBwYXJzZUZsb2F0KGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAoVHJhbnNpdGlvbi51c2VOYXRpdmUgJiYgY29tcGFyZVZhbCA9PT0gdmFsKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFuaW0uX29uTmF0aXZlRW5kLmNhbGwobm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgIGVsYXBzZWRUaW1lOiBkdXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGR1ciAqIDEwMDApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZVByb3BlcnR5OiBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHZhciBhbmltID0gdGhpcyxcbiAgICAgICAgICAgIGF0dHJzID0gVHJhbnNpdGlvbi5fbm9kZUF0dHJzW1kuc3RhbXAoYW5pbS5fbm9kZSldO1xuXG4gICAgICAgIGlmIChhdHRycyAmJiBhdHRyc1twcm9wXSkge1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJzW3Byb3BdO1xuICAgICAgICAgICAgYW5pbS5fY291bnQtLTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGluaXRBdHRyczogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBhdHRyLFxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuX25vZGU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy50cmFuc2Zvcm0gJiYgIWNvbmZpZ1tUcmFuc2l0aW9uLl9UUkFOU0ZPUk1dKSB7XG4gICAgICAgICAgICBjb25maWdbVHJhbnNpdGlvbi5fVFJBTlNGT1JNXSA9IGNvbmZpZy50cmFuc2Zvcm07XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLnRyYW5zZm9ybTsgLy8gVE9ETzogY29weVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChhdHRyIGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiAhVHJhbnNpdGlvbi5fcmVLZXl3b3Jkcy50ZXN0KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShhdHRyLCBjb25maWdbYXR0cl0pO1xuXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBzaXplIGlzIGF1dG8gb3IgJSB3ZWJraXQgc3RhcnRzIGZyb20gemVybyBpbnN0ZWFkIG9mIGNvbXB1dGVkXG4gICAgICAgICAgICAgICAgLy8gKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjAyMClcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzZWxlY3RpdmUgc2V0XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3R5bGVbYXR0cl0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIFkuRE9NLnNldFN0eWxlKG5vZGUsIGF0dHIsIFkuRE9NLmdldENvbXB1dGVkU3R5bGUobm9kZSwgYXR0cikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgb3IgYW4gYW5pbWF0aW9uLlxuICAgICAqIEBtZXRob2QgcnVuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVuOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgYW5pbSA9IHRoaXMsXG4gICAgICAgICAgICBub2RlID0gYW5pbS5fbm9kZSxcbiAgICAgICAgICAgIGNvbmZpZyA9IGFuaW0uX2NvbmZpZyxcbiAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RyYW5zaXRpb246c3RhcnQnLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgaWYgKCFhbmltLl9ydW5uaW5nKSB7XG4gICAgICAgICAgICBhbmltLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5vbiAmJiBjb25maWcub24uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcub24uc3RhcnQuY2FsbChZLm9uZShub2RlKSwgZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuaW0uaW5pdEF0dHJzKGFuaW0uX2NvbmZpZyk7XG5cbiAgICAgICAgICAgIGFuaW0uX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBhbmltLl9zdGFydCgpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYW5pbTtcbiAgICB9LFxuXG4gICAgX3N0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcnVuTmF0aXZlKCk7XG4gICAgfSxcblxuICAgIF9wcmVwRHVyOiBmdW5jdGlvbihkdXIpIHtcbiAgICAgICAgZHVyID0gcGFyc2VGbG9hdChkdXIpICogMTAwMDtcblxuICAgICAgICByZXR1cm4gZHVyICsgJ21zJztcbiAgICB9LFxuXG4gICAgX3J1bk5hdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbmltID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBhbmltLl9ub2RlLFxuICAgICAgICAgICAgdWlkID0gWS5zdGFtcChub2RlKSxcbiAgICAgICAgICAgIHN0eWxlID0gbm9kZS5zdHlsZSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSksXG4gICAgICAgICAgICBhdHRycyA9IFRyYW5zaXRpb24uX25vZGVBdHRyc1t1aWRdLFxuICAgICAgICAgICAgY3NzVGV4dCA9ICcnLFxuICAgICAgICAgICAgY3NzVHJhbnNpdGlvbiA9IGNvbXB1dGVkW1RyYW5zaXRpb24uX3RvQ2FtZWwoVFJBTlNJVElPTl9QUk9QRVJUWSldLFxuXG4gICAgICAgICAgICB0cmFuc2l0aW9uVGV4dCA9IFRSQU5TSVRJT05fUFJPUEVSVFkgKyAnOiAnLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBUUkFOU0lUSU9OX0RVUkFUSU9OICsgJzogJyxcbiAgICAgICAgICAgIGVhc2luZyA9IFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OICsgJzogJyxcbiAgICAgICAgICAgIGRlbGF5ID0gVFJBTlNJVElPTl9ERUxBWSArICc6ICcsXG4gICAgICAgICAgICBoeXBoeSxcbiAgICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgICBuYW1lO1xuXG4gICAgICAgIC8vIHByZXNlcnZlIGV4aXN0aW5nIHRyYW5zaXRpb25zXG4gICAgICAgIGlmIChjc3NUcmFuc2l0aW9uICE9PSAnYWxsJykge1xuICAgICAgICAgICAgdHJhbnNpdGlvblRleHQgKz0gY3NzVHJhbnNpdGlvbiArICcsJztcbiAgICAgICAgICAgIGR1cmF0aW9uICs9IGNvbXB1dGVkW1RyYW5zaXRpb24uX3RvQ2FtZWwoVFJBTlNJVElPTl9EVVJBVElPTildICsgJywnO1xuICAgICAgICAgICAgZWFzaW5nICs9IGNvbXB1dGVkW1RyYW5zaXRpb24uX3RvQ2FtZWwoVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04pXSArICcsJztcbiAgICAgICAgICAgIGRlbGF5ICs9IGNvbXB1dGVkW1RyYW5zaXRpb24uX3RvQ2FtZWwoVFJBTlNJVElPTl9ERUxBWSldICsgJywnO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gdHJhbnNpdGlvbnMgbWFwcGVkIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgZm9yIChuYW1lIGluIGF0dHJzKSB7XG4gICAgICAgICAgICBoeXBoeSA9IFRyYW5zaXRpb24uX3RvSHlwaGVuKG5hbWUpO1xuICAgICAgICAgICAgYXR0ciA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKChhdHRyID0gYXR0cnNbbmFtZV0pICYmIGF0dHIudHJhbnNpdGlvbiA9PT0gYW5pbSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIG5vZGUuc3R5bGUpIHsgLy8gb25seSBuYXRpdmUgc3R5bGVzIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gKz0gYW5pbS5fcHJlcER1cihhdHRyLmR1cmF0aW9uKSArICcsJztcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgKz0gYW5pbS5fcHJlcER1cihhdHRyLmRlbGF5KSArICcsJztcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nICs9IChhdHRyLmVhc2luZykgKyAnLCc7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblRleHQgKz0gaHlwaHkgKyAnLCc7XG4gICAgICAgICAgICAgICAgICAgIGNzc1RleHQgKz0gaHlwaHkgKyAnOiAnICsgYXR0ci52YWx1ZSArICc7ICc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2l0aW9uVGV4dCA9IHRyYW5zaXRpb25UZXh0LnJlcGxhY2UoLywkLywgJzsnKTtcbiAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbi5yZXBsYWNlKC8sJC8sICc7Jyk7XG4gICAgICAgIGVhc2luZyA9IGVhc2luZy5yZXBsYWNlKC8sJC8sICc7Jyk7XG4gICAgICAgIGRlbGF5ID0gZGVsYXkucmVwbGFjZSgvLCQvLCAnOycpO1xuXG4gICAgICAgIC8vIG9ubHkgb25lIG5hdGl2ZSBlbmQgZXZlbnQgcGVyIG5vZGVcbiAgICAgICAgaWYgKCFUcmFuc2l0aW9uLl9oYXNFbmRbdWlkXSkge1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBhbmltLl9vbk5hdGl2ZUVuZCwgJycpO1xuICAgICAgICAgICAgVHJhbnNpdGlvbi5faGFzRW5kW3VpZF0gPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS5jc3NUZXh0ICs9IHRyYW5zaXRpb25UZXh0ICsgZHVyYXRpb24gKyBlYXNpbmcgKyBkZWxheSArIGNzc1RleHQ7XG5cbiAgICB9LFxuXG4gICAgX2VuZDogZnVuY3Rpb24oZWxhcHNlZCkge1xuICAgICAgICB2YXIgYW5pbSA9IHRoaXMsXG4gICAgICAgICAgICBub2RlID0gYW5pbS5fbm9kZSxcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYW5pbS5fY2FsbGJhY2ssXG4gICAgICAgICAgICBjb25maWcgPSBhbmltLl9jb25maWcsXG4gICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0cmFuc2l0aW9uOmVuZCcsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICAgICAgZWxhcHNlZFRpbWU6IGVsYXBzZWRcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG5vZGVJbnN0YW5jZSA9IFkub25lKG5vZGUpO1xuXG4gICAgICAgIGFuaW0uX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgYW5pbS5fY2FsbGJhY2sgPSBudWxsO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLm9uICYmIGNvbmZpZy5vbi5lbmQpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyAvLyBJRTogYWxsb3cgcHJldmlvdXMgdXBkYXRlIHRvIGZpbmlzaFxuICAgICAgICAgICAgICAgICAgICBjb25maWcub24uZW5kLmNhbGwobm9kZUluc3RhbmNlLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBuZXN0ZWQgdG8gZW5zdXJlIHByb3BlciBmaXJlIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChub2RlSW5zdGFuY2UsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyAvLyBJRTogYWxsb3cgcHJldmlvdXMgdXBkYXRlIHRvIGZpbmlzaFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG5vZGVJbnN0YW5jZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBfZW5kTmF0aXZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZSxcbiAgICAgICAgICAgIHZhbHVlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSwgJycpW1RyYW5zaXRpb24uX3RvQ2FtZWwoVFJBTlNJVElPTl9QUk9QRVJUWSldO1xuXG4gICAgICAgIG5hbWUgPSBUcmFuc2l0aW9uLl90b0h5cGhlbihuYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKCcoPzpefCxcXFxccyknICsgbmFtZSArICcsPycpLCAnLCcpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eLHwsJC8sICcnKTtcbiAgICAgICAgICAgIG5vZGUuc3R5bGVbVFJBTlNJVElPTl9DQU1FTF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25OYXRpdmVFbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLFxuICAgICAgICAgICAgdWlkID0gWS5zdGFtcChub2RlKSxcbiAgICAgICAgICAgIGV2ZW50ID0gZSwvL2UuX2V2ZW50LFxuICAgICAgICAgICAgbmFtZSA9IFRyYW5zaXRpb24uX3RvQ2FtZWwoZXZlbnQucHJvcGVydHlOYW1lKSxcbiAgICAgICAgICAgIGVsYXBzZWQgPSBldmVudC5lbGFwc2VkVGltZSxcbiAgICAgICAgICAgIGF0dHJzID0gVHJhbnNpdGlvbi5fbm9kZUF0dHJzW3VpZF0sXG4gICAgICAgICAgICBhdHRyID0gYXR0cnNbbmFtZV0sXG4gICAgICAgICAgICBhbmltID0gKGF0dHIpID8gYXR0ci50cmFuc2l0aW9uIDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb25maWc7XG5cbiAgICAgICAgaWYgKGFuaW0pIHtcbiAgICAgICAgICAgIGFuaW0ucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgICAgICAgICBhbmltLl9lbmROYXRpdmUobmFtZSk7XG4gICAgICAgICAgICBjb25maWcgPSBhbmltLl9jb25maWdbbmFtZV07XG5cbiAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Byb3BlcnR5RW5kJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgZWxhcHNlZFRpbWU6IGVsYXBzZWQsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLm9uICYmIGNvbmZpZy5vbi5lbmQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcub24uZW5kLmNhbGwoWS5vbmUobm9kZSksIGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbS5fY291bnQgPD0gMCkgIHsgLy8gYWZ0ZXIgcHJvcGVydHlFbmQgZmlyZXNcbiAgICAgICAgICAgICAgICBhbmltLl9lbmQoZWxhcHNlZCk7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZVtUUkFOU0lUSU9OX1BST1BFUlRZX0NBTUVMXSA9ICcnOyAvLyBjbGVhbiB1cCBzdHlsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYW5pbSA9IHRoaXMsXG4gICAgICAgICAgICBub2RlID0gYW5pbS5fbm9kZTtcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBhbmltLl9vbk5hdGl2ZUVuZCwgZmFsc2UpO1xuICAgICAgICAgICAgYW5pbS5fbm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5ZLlRyYW5zaXRpb24gPSBUcmFuc2l0aW9uO1xuWS5UcmFuc2l0aW9uTmF0aXZlID0gVHJhbnNpdGlvbjsgLy8gVE9ETzogcmVtb3ZlXG5cbi8qKlxuICogICBBbmltYXRlIG9uZSBvciBtb3JlIGNzcyBwcm9wZXJ0aWVzIHRvIGEgZ2l2ZW4gdmFsdWUuIFJlcXVpcmVzIHRoZSBcInRyYW5zaXRpb25cIiBtb2R1bGUuXG4gKiAgIDxwcmU+ZXhhbXBsZSB1c2FnZTpcbiAqICAgICAgIFkub25lKCcjZGVtbycpLnRyYW5zaXRpb24oe1xuICogICAgICAgICAgIGR1cmF0aW9uOiAxLCAvLyBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDAuNVxuICogICAgICAgICAgIGVhc2luZzogJ2Vhc2Utb3V0JywgLy8gZGVmYXVsdCBpcyAnZWFzZSdcbiAqICAgICAgICAgICBkZWxheTogJzEnLCAvLyBkZWxheSBzdGFydCBmb3IgMSBzZWNvbmQsIGRlZmF1bHQgaXMgMFxuICpcbiAqICAgICAgICAgICBoZWlnaHQ6ICcxMHB4JyxcbiAqICAgICAgICAgICB3aWR0aDogJzEwcHgnLFxuICpcbiAqICAgICAgICAgICBvcGFjaXR5OiB7IC8vIHBlciBwcm9wZXJ0eVxuICogICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAqICAgICAgICAgICAgICAgZHVyYXRpb246IDIsXG4gKiAgICAgICAgICAgICAgIGRlbGF5OiAyLFxuICogICAgICAgICAgICAgICBlYXNpbmc6ICdlYXNlLWluJ1xuICogICAgICAgICAgIH1cbiAqICAgICAgIH0pO1xuICogICA8L3ByZT5cbiAqICAgQGZvciBOb2RlXG4gKiAgIEBtZXRob2QgdHJhbnNpdGlvblxuICogICBAcGFyYW0ge09iamVjdH0gY29uZmlnIEFuIG9iamVjdCBjb250YWluaW5nIG9uZSBvciBtb3JlIHN0eWxlIHByb3BlcnRpZXMsIGEgZHVyYXRpb24gYW5kIGFuIGVhc2luZy5cbiAqICAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIHRyYW5zaXRpb24gaGFzIGNvbXBsZXRlZC5cbiAqICAgQGNoYWluYWJsZVxuKi9cblkuTm9kZS5wcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICB2YXJcbiAgICAgICAgdHJhbnNpdGlvbkF0dHJzID0gVHJhbnNpdGlvbi5fbm9kZUF0dHJzW1kuc3RhbXAodGhpcy5fbm9kZSldLFxuICAgICAgICBhbmltID0gKHRyYW5zaXRpb25BdHRycykgPyB0cmFuc2l0aW9uQXR0cnMudHJhbnNpdGlvbiB8fCBudWxsIDogbnVsbCxcbiAgICAgICAgZnhDb25maWcsXG4gICAgICAgIHByb3A7XG5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7IC8vIG5hbWVkIGVmZmVjdCwgcHVsbCBjb25maWcgZnJvbSByZWdpc3RyeVxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjb25maWc7XG4gICAgICAgICAgICBjb25maWcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnhDb25maWcgPSBUcmFuc2l0aW9uLmZ4W25hbWVdO1xuXG4gICAgICAgIGlmIChjb25maWcgJiYgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IFkuY2xvbmUoY29uZmlnKTtcblxuICAgICAgICAgICAgZm9yIChwcm9wIGluIGZ4Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ4Q29uZmlnLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghIChwcm9wIGluIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1twcm9wXSA9IGZ4Q29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnID0gZnhDb25maWc7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7IC8vIG5hbWUgaXMgYSBjb25maWcsIGNvbmZpZyBpcyBhIGNhbGxiYWNrIG9yIHVuZGVmaW5lZFxuICAgICAgICBjYWxsYmFjayA9IGNvbmZpZztcbiAgICAgICAgY29uZmlnID0gbmFtZTtcbiAgICB9XG5cbiAgICBpZiAoYW5pbSAmJiAhYW5pbS5fcnVubmluZykge1xuICAgICAgICBhbmltLmluaXQodGhpcywgY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhbmltID0gbmV3IFRyYW5zaXRpb24odGhpcy5fbm9kZSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBhbmltLnJ1bihjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5ZLk5vZGUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbihuYW1lLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fc2hvdygpOyAvLyBzaG93IHByaW9yIHRvIHRyYW5zaXRpb25cbiAgICBpZiAobmFtZSAmJiBZLlRyYW5zaXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyAmJiAhbmFtZS5wdXNoKSB7IC8vIG5hbWVkIGVmZmVjdCBvciBhcnJheSBvZiBlZmZlY3RzIHN1cGVyY2VkZXMgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICBjb25maWcgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IFRyYW5zaXRpb24uU0hPV19UUkFOU0lUSU9OO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbihuYW1lLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5ZLk5vZGVMaXN0LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24obmFtZSwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IHRoaXMuX25vZGVzLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbm9kZTtcblxuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzW2krK10pKSB7XG4gICAgICAgIFkub25lKG5vZGUpLnNob3cobmFtZSwgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblxudmFyIF93cmFwQ2FsbEJhY2sgPSBmdW5jdGlvbihhbmltLCBmbiwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgZm4uY2FsbChhbmltKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShhbmltLl9ub2RlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblkuTm9kZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKG5hbWUsIGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICBpZiAobmFtZSAmJiBZLlRyYW5zaXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY29uZmlnO1xuICAgICAgICAgICAgY29uZmlnID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrID0gX3dyYXBDYWxsQmFjayh0aGlzLCB0aGlzLl9oaWRlLCBjYWxsYmFjayk7IC8vIHdyYXAgd2l0aCBleGlzdGluZyBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnICYmICFuYW1lLnB1c2gpIHsgLy8gbmFtZWQgZWZmZWN0IG9yIGFycmF5IG9mIGVmZmVjdHMgc3VwZXJjZWRlcyBkZWZhdWx0XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gVHJhbnNpdGlvbi5ISURFX1RSQU5TSVRJT047XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKG5hbWUsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5ZLk5vZGVMaXN0LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24obmFtZSwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IHRoaXMuX25vZGVzLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbm9kZTtcblxuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzW2krK10pKSB7XG4gICAgICAgIFkub25lKG5vZGUpLmhpZGUobmFtZSwgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqICAgQW5pbWF0ZSBvbmUgb3IgbW9yZSBjc3MgcHJvcGVydGllcyB0byBhIGdpdmVuIHZhbHVlLiBSZXF1aXJlcyB0aGUgXCJ0cmFuc2l0aW9uXCIgbW9kdWxlLlxuICogICA8cHJlPmV4YW1wbGUgdXNhZ2U6XG4gKiAgICAgICBZLmFsbCgnLmRlbW8nKS50cmFuc2l0aW9uKHtcbiAqICAgICAgICAgICBkdXJhdGlvbjogMSwgLy8gaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAwLjVcbiAqICAgICAgICAgICBlYXNpbmc6ICdlYXNlLW91dCcsIC8vIGRlZmF1bHQgaXMgJ2Vhc2UnXG4gKiAgICAgICAgICAgZGVsYXk6ICcxJywgLy8gZGVsYXkgc3RhcnQgZm9yIDEgc2Vjb25kLCBkZWZhdWx0IGlzIDBcbiAqXG4gKiAgICAgICAgICAgaGVpZ2h0OiAnMTBweCcsXG4gKiAgICAgICAgICAgd2lkdGg6ICcxMHB4JyxcbiAqXG4gKiAgICAgICAgICAgb3BhY2l0eTogeyAvLyBwZXIgcHJvcGVydHlcbiAqICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gKiAgICAgICAgICAgICAgIGR1cmF0aW9uOiAyLFxuICogICAgICAgICAgICAgICBkZWxheTogMixcbiAqICAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZS1pbidcbiAqICAgICAgICAgICB9XG4gKiAgICAgICB9KTtcbiAqICAgPC9wcmU+XG4gKiAgIEBmb3IgTm9kZUxpc3RcbiAqICAgQG1ldGhvZCB0cmFuc2l0aW9uXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc3R5bGUgcHJvcGVydGllcywgYSBkdXJhdGlvbiBhbmQgYW4gZWFzaW5nLlxuICogICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciB0aGUgdHJhbnNpdGlvbiBoYXMgY29tcGxldGVkLiBUaGUgY2FsbGJhY2sgZmlyZXNcbiAqICAgICAgIG9uY2UgcGVyIGl0ZW0gaW4gdGhlIE5vZGVMaXN0LlxuICogICBAcGFyYW0ge0Jvb2xlYW59IGNhbGxiYWNrT25jZSBJZiB0cnVlLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25seSBhZnRlciB0aGVcbiAqICAgICAgIGxhc3QgdHJhbnNpdGlvbiBoYXMgY29tcGxldGVkXG4gKiAgIEBjaGFpbmFibGVcbiovXG5ZLk5vZGVMaXN0LnByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaywgY2FsbGJhY2tPbmNlKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5fbm9kZXMsXG4gICAgICAgIHNpemUgPSB0aGlzLnNpemUoKSxcbiAgICAgICAgIGkgPSAwLFxuICAgICAgICBjYWxsYmFja09uY2UgPSBjYWxsYmFja09uY2UgPT09IHRydWUsXG4gICAgICAgIG5vZGU7XG5cbiAgICB3aGlsZSAoKG5vZGUgPSBub2Rlc1tpKytdKSkge1xuICAgICAgICBpZiAoaSA8IHNpemUgJiYgY2FsbGJhY2tPbmNlKXtcbiAgICAgICAgICAgIFkub25lKG5vZGUpLnRyYW5zaXRpb24oY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFkub25lKG5vZGUpLnRyYW5zaXRpb24oY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblkuTm9kZS5wcm90b3R5cGUudG9nZ2xlVmlldyA9IGZ1bmN0aW9uKG5hbWUsIG9uLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3RvZ2dsZXMgPSB0aGlzLl90b2dnbGVzIHx8IFtdO1xuICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHsgLy8gbm8gdHJhbnNpdGlvbiwganVzdCB0b2dnbGVcbiAgICAgICAgb24gPSBuYW1lO1xuICAgICAgICB0aGlzLl90b2dnbGVWaWV3KG9uLCBjYWxsYmFjayk7IC8vIGNhbGwgb3JpZ2luYWwgX3RvZ2dsZVZpZXcgaW4gWS5Ob2RlXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9uID09PSAnZnVuY3Rpb24nKSB7IC8vIElnbm9yZSBcIm9uXCIgaWYgdXNlZCBmb3IgY2FsbGJhY2sgYXJndW1lbnQuXG4gICAgICAgIG9uID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb24gPT09ICd1bmRlZmluZWQnICYmIG5hbWUgaW4gdGhpcy5fdG9nZ2xlcykgeyAvLyByZXZlcnNlIGN1cnJlbnQgdG9nZ2xlXG4gICAgICAgIG9uID0gISB0aGlzLl90b2dnbGVzW25hbWVdO1xuICAgIH1cblxuICAgIG9uID0gKG9uKSA/IDEgOiAwO1xuICAgIGlmIChvbikge1xuICAgICAgICB0aGlzLl9zaG93KCk7XG4gICAgfSAgZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gX3dyYXBDYWxsQmFjayh0aGlzLCB0aGlzLl9oaWRlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdGhpcy5fdG9nZ2xlc1tuYW1lXSA9IG9uO1xuICAgIHRoaXMudHJhbnNpdGlvbihZLlRyYW5zaXRpb24udG9nZ2xlc1tuYW1lXVtvbl0sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuWS5Ob2RlTGlzdC5wcm90b3R5cGUudG9nZ2xlVmlldyA9IGZ1bmN0aW9uKG5hbWUsIG9uLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IHRoaXMuX25vZGVzLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbm9kZTtcblxuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzW2krK10pKSB7XG4gICAgICAgIG5vZGUgPSBZLm9uZShub2RlKTtcbiAgICAgICAgbm9kZS50b2dnbGVWaWV3LmFwcGx5KG5vZGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5ZLm1peChUcmFuc2l0aW9uLmZ4LCB7XG4gICAgZmFkZU91dDoge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgICBlYXNpbmc6ICdlYXNlLW91dCdcbiAgICB9LFxuXG4gICAgZmFkZUluOiB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgIGVhc2luZzogJ2Vhc2UtaW4nXG4gICAgfSxcblxuICAgIHNpemVPdXQ6IHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgZHVyYXRpb246IDAuNzUsXG4gICAgICAgIGVhc2luZzogJ2Vhc2Utb3V0J1xuICAgIH0sXG5cbiAgICBzaXplSW46IHtcbiAgICAgICAgaGVpZ2h0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXQoJ3Njcm9sbEhlaWdodCcpICsgJ3B4JztcbiAgICAgICAgfSxcbiAgICAgICAgd2lkdGg6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldCgnc2Nyb2xsV2lkdGgnKSArICdweCc7XG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgIGVhc2luZzogJ2Vhc2UtaW4nLFxuXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93ID0gdGhpcy5nZXRTdHlsZSgnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgIT09ICdoaWRkZW4nKSB7IC8vIGVuYWJsZSBzY3JvbGxIZWlnaHQvV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSgnb3ZlcmZsb3cnLCAnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25PdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zaXRpb25PdmVyZmxvdykgeyAvLyByZXZlcnQgb3ZlcnJpZGRlbiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0eWxlKCdvdmVyZmxvdycsIHRoaXMuX3RyYW5zaXRpb25PdmVyZmxvdyk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90cmFuc2l0aW9uT3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cblkubWl4KFRyYW5zaXRpb24udG9nZ2xlcywge1xuICAgIHNpemU6IFsnc2l6ZU91dCcsICdzaXplSW4nXSxcbiAgICBmYWRlOiBbJ2ZhZGVPdXQnLCAnZmFkZUluJ11cbn0pO1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJub2RlLXN0eWxlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ3dpZGdldC1iYXNlJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBQcm92aWRlcyB0aGUgYmFzZSBXaWRnZXQgY2xhc3MsIHdpdGggSFRNTCBQYXJzZXIgc3VwcG9ydFxuICpcbiAqIEBtb2R1bGUgd2lkZ2V0XG4gKiBAbWFpbiB3aWRnZXRcbiAqL1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSBiYXNlIFdpZGdldCBjbGFzc1xuICpcbiAqIEBtb2R1bGUgd2lkZ2V0XG4gKiBAc3VibW9kdWxlIHdpZGdldC1iYXNlXG4gKi9cbnZhciBMID0gWS5MYW5nLFxuICAgIE5vZGUgPSBZLk5vZGUsXG5cbiAgICBDbGFzc05hbWVNYW5hZ2VyID0gWS5DbGFzc05hbWVNYW5hZ2VyLFxuXG4gICAgX2dldENsYXNzTmFtZSA9IENsYXNzTmFtZU1hbmFnZXIuZ2V0Q2xhc3NOYW1lLFxuICAgIF9nZXRXaWRnZXRDbGFzc05hbWUsXG5cbiAgICBfdG9Jbml0aWFsQ2FwID0gWS5jYWNoZWQoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH0pLFxuXG4gICAgLy8gSy1XZWlnaHQsIElFIEdDIG9wdGltaXphdGlvbnNcbiAgICBDT05URU5UID0gXCJjb250ZW50XCIsXG4gICAgVklTSUJMRSA9IFwidmlzaWJsZVwiLFxuICAgIEhJRERFTiA9IFwiaGlkZGVuXCIsXG4gICAgRElTQUJMRUQgPSBcImRpc2FibGVkXCIsXG4gICAgRk9DVVNFRCA9IFwiZm9jdXNlZFwiLFxuICAgIFdJRFRIID0gXCJ3aWR0aFwiLFxuICAgIEhFSUdIVCA9IFwiaGVpZ2h0XCIsXG4gICAgQk9VTkRJTkdfQk9YID0gXCJib3VuZGluZ0JveFwiLFxuICAgIENPTlRFTlRfQk9YID0gXCJjb250ZW50Qm94XCIsXG4gICAgUEFSRU5UX05PREUgPSBcInBhcmVudE5vZGVcIixcbiAgICBPV05FUl9ET0NVTUVOVCA9IFwib3duZXJEb2N1bWVudFwiLFxuICAgIEFVVE8gPSBcImF1dG9cIixcbiAgICBTUkNfTk9ERSA9IFwic3JjTm9kZVwiLFxuICAgIEJPRFkgPSBcImJvZHlcIixcbiAgICBUQUJfSU5ERVggPSBcInRhYkluZGV4XCIsXG4gICAgSUQgPSBcImlkXCIsXG4gICAgUkVOREVSID0gXCJyZW5kZXJcIixcbiAgICBSRU5ERVJFRCA9IFwicmVuZGVyZWRcIixcbiAgICBERVNUUk9ZRUQgPSBcImRlc3Ryb3llZFwiLFxuICAgIFNUUklOR1MgPSBcInN0cmluZ3NcIixcbiAgICBESVYgPSBcIjxkaXY+PC9kaXY+XCIsXG4gICAgQ0hBTkdFID0gXCJDaGFuZ2VcIixcbiAgICBMT0FESU5HID0gXCJsb2FkaW5nXCIsXG5cbiAgICBfVUlTRVQgPSBcIl91aVNldFwiLFxuXG4gICAgRU1QVFlfU1RSID0gXCJcIixcbiAgICBFTVBUWV9GTiA9IGZ1bmN0aW9uKCkge30sXG5cbiAgICBUUlVFID0gdHJ1ZSxcbiAgICBGQUxTRSA9IGZhbHNlLFxuXG4gICAgVUksXG4gICAgQVRUUlMgPSB7fSxcbiAgICBVSV9BVFRSUyA9IFtWSVNJQkxFLCBESVNBQkxFRCwgSEVJR0hULCBXSURUSCwgRk9DVVNFRCwgVEFCX0lOREVYXSxcblxuICAgIFdFQktJVCA9IFkuVUEud2Via2l0LFxuXG4gICAgLy8gV2lkZ2V0IG5vZGVpZC10by1pbnN0YW5jZSBtYXAuXG4gICAgX2luc3RhbmNlcyA9IHt9O1xuXG4vKipcbiAqIEEgYmFzZSBjbGFzcyBmb3Igd2lkZ2V0cywgcHJvdmlkaW5nOlxuICogPHVsPlxuICogICAgPGxpPlRoZSByZW5kZXIgbGlmZWN5Y2xlIG1ldGhvZCwgaW4gYWRkaXRpb24gdG8gdGhlIGluaXQgYW5kIGRlc3Ryb3lcbiAqICAgICAgICBsaWZlY3ljbGUgbWV0aG9kcyBwcm92aWRlIGJ5IEJhc2U8L2xpPlxuICogICAgPGxpPkFic3RyYWN0IG1ldGhvZHMgdG8gc3VwcG9ydCBjb25zaXN0ZW50IE1WQyBzdHJ1Y3R1cmUgYWNyb3NzXG4gKiAgICAgICAgd2lkZ2V0czogcmVuZGVyZXIsIHJlbmRlclVJLCBiaW5kVUksIHN5bmNVSTwvbGk+XG4gKiAgICA8bGk+U3VwcG9ydCBmb3IgY29tbW9uIHdpZGdldCBhdHRyaWJ1dGVzLCBzdWNoIGFzIGJvdW5kaW5nQm94LCBjb250ZW50Qm94LCB2aXNpYmxlLFxuICogICAgICAgIGRpc2FibGVkLCBmb2N1c2VkLCBzdHJpbmdzPC9saT5cbiAqIDwvdWw+XG4gKlxuICogQHBhcmFtIGNvbmZpZyB7T2JqZWN0fSBPYmplY3QgbGl0ZXJhbCBzcGVjaWZ5aW5nIHdpZGdldCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMuXG4gKlxuICogQGNsYXNzIFdpZGdldFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCYXNlXG4gKi9cbmZ1bmN0aW9uIFdpZGdldChjb25maWcpIHtcblxuICAgIC8vIGt3ZWlnaHRcbiAgICB2YXIgd2lkZ2V0ID0gdGhpcyxcbiAgICAgICAgcGFyZW50Tm9kZSxcbiAgICAgICAgcmVuZGVyLFxuICAgICAgICBjb25zdHJ1Y3RvciA9IHdpZGdldC5jb25zdHJ1Y3RvcjtcblxuICAgIHdpZGdldC5fc3RycyA9IHt9O1xuICAgIHdpZGdldC5fY3NzUHJlZml4ID0gY29uc3RydWN0b3IuQ1NTX1BSRUZJWCB8fCBfZ2V0Q2xhc3NOYW1lKGNvbnN0cnVjdG9yLk5BTUUudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAvLyBXZSBuZWVkIGEgY29uZmlnIGZvciBIVE1MX1BBUlNFUiB0byB3b3JrLlxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgIFdpZGdldC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwod2lkZ2V0LCBjb25maWcpO1xuXG4gICAgcmVuZGVyID0gd2lkZ2V0LmdldChSRU5ERVIpO1xuXG4gICAgaWYgKHJlbmRlcikge1xuICAgICAgICAvLyBSZW5kZXIgY291bGQgYmUgYSBub2RlIG9yIGJvb2xlYW5cbiAgICAgICAgaWYgKHJlbmRlciAhPT0gVFJVRSkge1xuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHJlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICB3aWRnZXQucmVuZGVyKHBhcmVudE5vZGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdGF0aWMgcHJvcGVydHkgcHJvdmlkZXMgYSBzdHJpbmcgdG8gaWRlbnRpZnkgdGhlIGNsYXNzLlxuICogPHA+XG4gKiBDdXJyZW50bHkgdXNlZCB0byBhcHBseSBjbGFzcyBpZGVudGlmaWVycyB0byB0aGUgYm91bmRpbmcgYm94XG4gKiBhbmQgdG8gY2xhc3NpZnkgZXZlbnRzIGZpcmVkIGJ5IHRoZSB3aWRnZXQuXG4gKiA8L3A+XG4gKlxuICogQHByb3BlcnR5IE5BTUVcbiAqIEB0eXBlIFN0cmluZ1xuICogQHN0YXRpY1xuICovXG5XaWRnZXQuTkFNRSA9IFwid2lkZ2V0XCI7XG5cbi8qKlxuICogQ29uc3RhbnQgdXNlZCB0byBpZGVudGlmeSBzdGF0ZSBjaGFuZ2VzIG9yaWdpbmF0aW5nIGZyb21cbiAqIHRoZSBET00gKGFzIG9wcG9zZWQgdG8gdGhlIEphdmFTY3JpcHQgbW9kZWwpLlxuICpcbiAqIEBwcm9wZXJ0eSBVSV9TUkNcbiAqIEB0eXBlIFN0cmluZ1xuICogQHN0YXRpY1xuICogQGZpbmFsXG4gKi9cblVJID0gV2lkZ2V0LlVJX1NSQyA9IFwidWlcIjtcblxuLyoqXG4gKiBTdGF0aWMgcHJvcGVydHkgdXNlZCB0byBkZWZpbmUgdGhlIGRlZmF1bHQgYXR0cmlidXRlXG4gKiBjb25maWd1cmF0aW9uIGZvciB0aGUgV2lkZ2V0LlxuICpcbiAqIEBwcm9wZXJ0eSBBVFRSU1xuICogQHR5cGUgT2JqZWN0XG4gKiBAc3RhdGljXG4gKi9cbldpZGdldC5BVFRSUyA9IEFUVFJTO1xuXG4vLyBUcnlpbmcgdG8gb3B0aW1pemUga3dlaWdodCBieSBzZXR0aW5nIHVwIGF0dHJzIHRoaXMgd2F5IHNhdmVzIGFib3V0IDAuNEsgbWluJ2RcblxuLyoqXG4gKiBAYXR0cmlidXRlIGlkXG4gKiBAd3JpdGVPbmNlXG4gKiBAZGVmYXVsdCBHZW5lcmF0ZWQgdXNpbmcgZ3VpZCgpXG4gKiBAdHlwZSBTdHJpbmdcbiAqL1xuXG5BVFRSU1tJRF0gPSB7XG4gICAgdmFsdWVGbjogXCJfZ3VpZFwiLFxuICAgIHdyaXRlT25jZTogVFJVRVxufTtcblxuLyoqXG4gKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhpcyBXaWRnZXRcbiAqIGhhcyBiZWVuIHRocm91Z2ggdGhlIHJlbmRlciBsaWZlY3ljbGUgcGhhc2UuXG4gKlxuICogQGF0dHJpYnV0ZSByZW5kZXJlZFxuICogQHJlYWRPbmx5XG4gKiBAZGVmYXVsdCBmYWxzZVxuICogQHR5cGUgYm9vbGVhblxuICovXG5BVFRSU1tSRU5ERVJFRF0gPSB7XG4gICAgdmFsdWU6RkFMU0UsXG4gICAgcmVhZE9ubHk6IFRSVUVcbn07XG5cbi8qKlxuICogQGF0dHJpYnV0ZSBib3VuZGluZ0JveFxuICogQGRlc2NyaXB0aW9uIFRoZSBvdXRlcm1vc3QgRE9NIG5vZGUgZm9yIHRoZSBXaWRnZXQsIHVzZWQgZm9yIHNpemluZyBhbmQgcG9zaXRpb25pbmdcbiAqIG9mIGEgV2lkZ2V0IGFzIHdlbGwgYXMgYSBjb250YWluaW5nIGVsZW1lbnQgZm9yIGFueSBkZWNvcmF0b3IgZWxlbWVudHMgdXNlZFxuICogZm9yIHNraW5uaW5nLlxuICogQHR5cGUgU3RyaW5nIHwgTm9kZVxuICogQHdyaXRlT25jZVxuICovXG5BVFRSU1tCT1VORElOR19CT1hdID0ge1xuICAgIHZhbHVlRm46XCJfZGVmYXVsdEJCXCIsXG4gICAgc2V0dGVyOiBcIl9zZXRCQlwiLFxuICAgIHdyaXRlT25jZTogVFJVRVxufTtcblxuLyoqXG4gKiBAYXR0cmlidXRlIGNvbnRlbnRCb3hcbiAqIEBkZXNjcmlwdGlvbiBBIERPTSBub2RlIHRoYXQgaXMgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiBhIFdpZGdldCdzIGJvdW5kaW5nIGJveCB0aGF0XG4gKiBob3VzZXMgaXRzIGNvbnRlbnQuXG4gKiBAdHlwZSBTdHJpbmcgfCBOb2RlXG4gKiBAd3JpdGVPbmNlXG4gKi9cbkFUVFJTW0NPTlRFTlRfQk9YXSA9IHtcbiAgICB2YWx1ZUZuOlwiX2RlZmF1bHRDQlwiLFxuICAgIHNldHRlcjogXCJfc2V0Q0JcIixcbiAgICB3cml0ZU9uY2U6IFRSVUVcbn07XG5cbi8qKlxuICogQGF0dHJpYnV0ZSB0YWJJbmRleFxuICogQGRlc2NyaXB0aW9uIE51bWJlciAoYmV0d2VlbiAtMzI3NjcgdG8gMzI3NjcpIGluZGljYXRpbmcgdGhlIHdpZGdldCdzXG4gKiBwb3NpdGlvbiBpbiB0aGUgZGVmYXVsdCB0YWIgZmxvdy4gIFRoZSB2YWx1ZSBpcyB1c2VkIHRvIHNldCB0aGVcbiAqIFwidGFiSW5kZXhcIiBhdHRyaWJ1dGUgb24gdGhlIHdpZGdldCdzIGJvdW5kaW5nIGJveC4gIE5lZ2F0aXZlIHZhbHVlcyBhbGxvd1xuICogdGhlIHdpZGdldCB0byByZWNlaXZlIERPTSBmb2N1cyBwcm9ncmFtbWF0aWNhbGx5IChieSBjYWxsaW5nIHRoZSBmb2N1c1xuICogbWV0aG9kKSwgd2hpbGUgYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZSBkZWZhdWx0IHRhYiBmbG93LiAgQSB2YWx1ZSBvZlxuICogbnVsbCByZW1vdmVzIHRoZSBcInRhYkluZGV4XCIgYXR0cmlidXRlIGZyb20gdGhlIHdpZGdldCdzIGJvdW5kaW5nIGJveC5cbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHQgbnVsbFxuICovXG5BVFRSU1tUQUJfSU5ERVhdID0ge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHZhbGlkYXRvcjogXCJfdmFsaWRUYWJJbmRleFwiXG59O1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgZm9jdXNlZFxuICogQGRlc2NyaXB0aW9uIEJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgV2lkZ2V0LCBvciBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzLFxuICogaGFzIGZvY3VzLlxuICogQHJlYWRPbmx5XG4gKiBAZGVmYXVsdCBmYWxzZVxuICogQHR5cGUgYm9vbGVhblxuICovXG5BVFRSU1tGT0NVU0VEXSA9IHtcbiAgICB2YWx1ZTogRkFMU0UsXG4gICAgcmVhZE9ubHk6VFJVRVxufTtcblxuLyoqXG4gKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gKiBAZGVzY3JpcHRpb24gQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBXaWRnZXQgc2hvdWxkIGJlIGRpc2FibGVkLiBUaGUgZGlzYWJsZWQgaW1wbGVtZW50YXRpb25cbiAqIGlzIGxlZnQgdG8gdGhlIHNwZWNpZmljIGNsYXNzZXMgZXh0ZW5kaW5nIHdpZGdldC5cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbkFUVFJTW0RJU0FCTEVEXSA9IHtcbiAgICB2YWx1ZTogRkFMU0Vcbn07XG5cbi8qKlxuICogQGF0dHJpYnV0ZSB2aXNpYmxlXG4gKiBAZGVzY3JpcHRpb24gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBXaWRnZXQgaXMgdmlzaWJsZS5cbiAqIEBkZWZhdWx0IFRSVUVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xuQVRUUlNbVklTSUJMRV0gPSB7XG4gICAgdmFsdWU6IFRSVUVcbn07XG5cbi8qKlxuICogQGF0dHJpYnV0ZSBoZWlnaHRcbiAqIEBkZXNjcmlwdGlvbiBTdHJpbmcgd2l0aCB1bml0cywgb3IgbnVtYmVyLCByZXByZXNlbnRpbmcgdGhlIGhlaWdodCBvZiB0aGUgV2lkZ2V0LiBJZiBhIG51bWJlciBpcyBwcm92aWRlZCxcbiAqIHRoZSBkZWZhdWx0IHVuaXQsIGRlZmluZWQgYnkgdGhlIFdpZGdldHMgREVGX1VOSVQsIHByb3BlcnR5IGlzIHVzZWQuXG4gKiBAZGVmYXVsdCBFTVBUWV9TVFJcbiAqIEB0eXBlIHtTdHJpbmcgfCBOdW1iZXJ9XG4gKi9cbkFUVFJTW0hFSUdIVF0gPSB7XG4gICAgdmFsdWU6IEVNUFRZX1NUUlxufTtcblxuLyoqXG4gKiBAYXR0cmlidXRlIHdpZHRoXG4gKiBAZGVzY3JpcHRpb24gU3RyaW5nIHdpdGggdW5pdHMsIG9yIG51bWJlciwgcmVwcmVzZW50aW5nIHRoZSB3aWR0aCBvZiB0aGUgV2lkZ2V0LiBJZiBhIG51bWJlciBpcyBwcm92aWRlZCxcbiAqIHRoZSBkZWZhdWx0IHVuaXQsIGRlZmluZWQgYnkgdGhlIFdpZGdldHMgREVGX1VOSVQsIHByb3BlcnR5IGlzIHVzZWQuXG4gKiBAZGVmYXVsdCBFTVBUWV9TVFJcbiAqIEB0eXBlIHtTdHJpbmcgfCBOdW1iZXJ9XG4gKi9cbkFUVFJTW1dJRFRIXSA9IHtcbiAgICB2YWx1ZTogRU1QVFlfU1RSXG59O1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgc3RyaW5nc1xuICogQGRlc2NyaXB0aW9uIENvbGxlY3Rpb24gb2Ygc3RyaW5ncyB1c2VkIHRvIGxhYmVsIGVsZW1lbnRzIG9mIHRoZSBXaWRnZXQncyBVSS5cbiAqIEBkZWZhdWx0IG51bGxcbiAqIEB0eXBlIE9iamVjdFxuICovXG5BVFRSU1tTVFJJTkdTXSA9IHtcbiAgICB2YWx1ZToge30sXG4gICAgc2V0dGVyOiBcIl9zdHJTZXR0ZXJcIixcbiAgICBnZXR0ZXI6IFwiX3N0ckdldHRlclwiXG59O1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRvIHJlbmRlciB0aGUgd2lkZ2V0IGF1dG9tYXRpY2FsbHkgYWZ0ZXIgaW5pdCwgYW5kIG9wdGlvbmFsbHksIHRvIHdoaWNoIHBhcmVudCBub2RlLlxuICpcbiAqIEBhdHRyaWJ1dGUgcmVuZGVyXG4gKiBAdHlwZSBib29sZWFuIHwgTm9kZVxuICogQHdyaXRlT25jZVxuICovXG5BVFRSU1tSRU5ERVJdID0ge1xuICAgIHZhbHVlOkZBTFNFLFxuICAgIHdyaXRlT25jZTpUUlVFXG59O1xuXG4vKipcbiAqIFRoZSBjc3MgcHJlZml4IHdoaWNoIHRoZSBzdGF0aWMgV2lkZ2V0LmdldENsYXNzTmFtZSBtZXRob2Qgc2hvdWxkIHVzZSB3aGVuIGNvbnN0cnVjdGluZyBjbGFzcyBuYW1lc1xuICpcbiAqIEBwcm9wZXJ0eSBDU1NfUFJFRklYXG4gKiBAdHlwZSBTdHJpbmdcbiAqIEBkZWZhdWx0IFdpZGdldC5OQU1FLnRvTG93ZXJDYXNlKClcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKi9cbldpZGdldC5DU1NfUFJFRklYID0gX2dldENsYXNzTmFtZShXaWRnZXQuTkFNRS50b0xvd2VyQ2FzZSgpKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YW5kYXJkIHByZWZpeGVkIGNsYXNzbmFtZSBmb3IgdGhlIFdpZGdldCwgcHJlZml4ZWQgYnkgdGhlIGRlZmF1bHQgcHJlZml4IGRlZmluZWRcbiAqIGJ5IHRoZSA8Y29kZT5ZLmNvbmZpZy5jbGFzc05hbWVQcmVmaXg8L2NvZGU+IGF0dHJpYnV0ZSB1c2VkIGJ5IDxjb2RlPkNsYXNzTmFtZU1hbmFnZXI8L2NvZGU+IGFuZFxuICogPGNvZGU+V2lkZ2V0Lk5BTUUudG9Mb3dlckNhc2UoKTwvY29kZT4gKGUuZy4gXCJ5dWktd2lkZ2V0LXh4eHh4LXl5eXl5XCIsIGJhc2VkIG9uIGRlZmF1bHQgdmFsdWVzIGZvclxuICogdGhlIHByZWZpeCBhbmQgd2lkZ2V0IGNsYXNzIG5hbWUpLlxuICogPHA+XG4gKiBUaGUgaW5zdGFuY2UgYmFzZWQgdmVyc2lvbiBvZiB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSBzdGFuZGFyZCBwcmVmaXhlZCBjbGFzc25hbWVzLFxuICogYmFzZWQgb24gdGhlIGluc3RhbmNlcyBOQU1FLCBhcyBvcHBvc2VkIHRvIFdpZGdldC5OQU1FLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB3aGVuIHlvdVxuICogbmVlZCB0byB1c2UgYSBjb25zdGFudCBjbGFzcyBuYW1lIGFjcm9zcyBkaWZmZXJlbnQgdHlwZXMgaW5zdGFuY2VzLlxuICogPC9wPlxuICogQG1ldGhvZCBnZXRDbGFzc05hbWVcbiAqIEBwYXJhbSB7U3RyaW5nKn0gYXJncyogMC4ubiBzdHJpbmdzIHdoaWNoIHNob3VsZCBiZSBjb25jYXRlbmF0ZWQsIHVzaW5nIHRoZSBkZWZhdWx0IHNlcGFyYXRvciBkZWZpbmVkIGJ5IENsYXNzTmFtZU1hbmFnZXIsIHRvIGNyZWF0ZSB0aGUgY2xhc3MgbmFtZVxuICovXG5XaWRnZXQuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gYXJndW1lbnRzIG5lZWRzIHRvIGJlIGFycmF5J2ZpZWQgdG8gY29uY2F0XG4gICAgcmV0dXJuIF9nZXRDbGFzc05hbWUuYXBwbHkoQ2xhc3NOYW1lTWFuYWdlciwgW1dpZGdldC5DU1NfUFJFRklYXS5jb25jYXQoWS5BcnJheShhcmd1bWVudHMpLCB0cnVlKSk7XG59O1xuXG5fZ2V0V2lkZ2V0Q2xhc3NOYW1lID0gV2lkZ2V0LmdldENsYXNzTmFtZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB3aWRnZXQgaW5zdGFuY2Ugd2hvc2UgYm91bmRpbmcgYm94IGNvbnRhaW5zLCBvciBpcywgdGhlIGdpdmVuIG5vZGUuXG4gKiA8cD5cbiAqIEluIHRoZSBjYXNlIG9mIG5lc3RlZCB3aWRnZXRzLCB0aGUgbmVhcmVzdCBib3VuZGluZyBib3ggYW5jZXN0b3IgaXMgdXNlZCB0b1xuICogcmV0dXJuIHRoZSB3aWRnZXQgaW5zdGFuY2UuXG4gKiA8L3A+XG4gKiBAbWV0aG9kIGdldEJ5Tm9kZVxuICogQHN0YXRpY1xuICogQHBhcmFtIG5vZGUge05vZGUgfCBTdHJpbmd9IFRoZSBub2RlIGZvciB3aGljaCB0byByZXR1cm4gYSBXaWRnZXQgaW5zdGFuY2UuIElmIGEgc2VsZWN0b3JcbiAqIHN0cmluZyBpcyBwYXNzZWQgaW4sIHdoaWNoIHNlbGVjdHMgbW9yZSB0aGFuIG9uZSBub2RlLCB0aGUgZmlyc3Qgbm9kZSBmb3VuZCBpcyB1c2VkLlxuICogQHJldHVybiB7V2lkZ2V0fSBXaWRnZXQgaW5zdGFuY2UsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICovXG5XaWRnZXQuZ2V0QnlOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciB3aWRnZXQsXG4gICAgICAgIHdpZGdldE1hcmtlciA9IF9nZXRXaWRnZXRDbGFzc05hbWUoKTtcblxuICAgIG5vZGUgPSBOb2RlLm9uZShub2RlKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlID0gbm9kZS5hbmNlc3RvcihcIi5cIiArIHdpZGdldE1hcmtlciwgdHJ1ZSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB3aWRnZXQgPSBfaW5zdGFuY2VzW1kuc3RhbXAobm9kZSwgdHJ1ZSldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZGdldCB8fCBudWxsO1xufTtcblxuWS5leHRlbmQoV2lkZ2V0LCBZLkJhc2UsIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbGFzcyBuYW1lIHByZWZpeGVkIHdpdGggdGhlIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgKiA8Y29kZT5ZVUkuY29uZmlnLmNsYXNzTmFtZVByZWZpeDwvY29kZT4gYXR0cmlidXRlICsgdGhlIGluc3RhbmNlcyA8Y29kZT5OQU1FPC9jb2RlPiBwcm9wZXJ0eS5cbiAgICAgKiBVc2VzIDxjb2RlPllVSS5jb25maWcuY2xhc3NOYW1lRGVsaW1pdGVyPC9jb2RlPiBhdHRyaWJ1dGUgdG8gZGVsaW1pdCB0aGUgcHJvdmlkZWQgc3RyaW5ncy5cbiAgICAgKiBlLmcuXG4gICAgICogPGNvZGU+XG4gICAgICogPHByZT5cbiAgICAgKiAgICAvLyByZXR1cm5zIFwieXVpLXNsaWRlci1mb28tYmFyXCIsIGZvciBhIHNsaWRlciBpbnN0YW5jZVxuICAgICAqICAgIHZhciBzY24gPSBzbGlkZXIuZ2V0Q2xhc3NOYW1lKCdmb28nLCdiYXInKTtcbiAgICAgKlxuICAgICAqICAgIC8vIHJldHVybnMgXCJ5dWktb3ZlcmxheS1mb28tYmFyXCIsIGZvciBhbiBvdmVybGF5IGluc3RhbmNlXG4gICAgICogICAgdmFyIG9jbiA9IG92ZXJsYXkuZ2V0Q2xhc3NOYW1lKCdmb28nLCdiYXInKTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKiA8L2NvZGU+XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldENsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2xhc3NuYW1lcypdIE9uZSBvciBtb3JlIGNsYXNzbmFtZSBiaXRzIHRvIGJlIGpvaW5lZCBhbmQgcHJlZml4ZWRcbiAgICAgKi9cbiAgICBnZXRDbGFzc05hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRDbGFzc05hbWUuYXBwbHkoQ2xhc3NOYW1lTWFuYWdlciwgW3RoaXMuX2Nzc1ByZWZpeF0uY29uY2F0KFkuQXJyYXkoYXJndW1lbnRzKSwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplciBsaWZlY3ljbGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBXaWRnZXQgY2xhc3MuIFJlZ2lzdGVycyB0aGVcbiAgICAgKiB3aWRnZXQgaW5zdGFuY2UsIGFuZCBydW5zIHRocm91Z2ggdGhlIFdpZGdldCdzIEhUTUxfUEFSU0VSIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVyXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSAgY29uZmlnIHtPYmplY3R9IENvbmZpZ3VyYXRpb24gb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSB3aWRnZXRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplcjogZnVuY3Rpb24oY29uZmlnKSB7XG5cbiAgICAgICAgdmFyIGJiID0gdGhpcy5nZXQoQk9VTkRJTkdfQk9YKTtcblxuICAgICAgICBpZiAoYmIgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZShZLnN0YW1wKGJiKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTm90aWZpY2F0aW9uIGV2ZW50LCB3aGljaCB3aWRnZXQgaW1wbGVtZW50YXRpb25zIGNhbiBmaXJlLCB3aGVuXG4gICAgICAgICAqIHRoZXkgY2hhbmdlIHRoZSBjb250ZW50IG9mIHRoZSB3aWRnZXQuIFRoaXMgZXZlbnQgaGFzIG5vIGRlZmF1bHRcbiAgICAgICAgICogYmVoYXZpb3IgYW5kIGNhbm5vdCBiZSBwcmV2ZW50ZWQsIHNvIHRoZSBcIm9uXCIgb3IgXCJhZnRlclwiXG4gICAgICAgICAqIG1vbWVudHMgYXJlIGVmZmVjdGl2ZWx5IGVxdWl2YWxlbnQgKHdpdGggb24gbGlzdGVuZXJzIGJlaW5nIGludm9rZWQgYmVmb3JlXG4gICAgICAgICAqIGFmdGVyIGxpc3RlbmVycykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCB3aWRnZXQ6Y29udGVudFVwZGF0ZVxuICAgICAgICAgKiBAcHJldmVudGFibGUgZmFsc2VcbiAgICAgICAgICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZSBUaGUgRXZlbnQgRmFjYWRlXG4gICAgICAgICAqL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCB1c2VkIHRvIGFkZCBhbiBlbnRyeSB0byB0aGUgYm91bmRpbmdCb3ggaWQgdG8gaW5zdGFuY2UgbWFwLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gcG9wdWxhdGUgdGhlIGluc3RhbmNlIHdpdGggbGF6aWx5IGNyZWF0ZWQgYm91bmRpbmdCb3ggTm9kZSByZWZlcmVuY2VzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfbWFwSW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gVGhlIGJvdW5kaW5nQm94IGlkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9tYXBJbnN0YW5jZSA6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIF9pbnN0YW5jZXNbaWRdID0gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3RvciBsaWZlY3ljbGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBXaWRnZXQgY2xhc3MuIFB1cmdlcyBldmVudHMgYXR0YWNoZWRcbiAgICAgKiB0byB0aGUgYm91bmRpbmcgYm94IGFuZCBjb250ZW50IGJveCwgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIERPTSBhbmQgcmVtb3Zlc1xuICAgICAqIHRoZSBXaWRnZXQgZnJvbSB0aGUgbGlzdCBvZiByZWdpc3RlcmVkIHdpZGdldHMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlc3RydWN0b3JcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdGhpcy5nZXQoQk9VTkRJTkdfQk9YKSxcbiAgICAgICAgICAgIGJiR3VpZDtcblxuICAgICAgICBpZiAoYm91bmRpbmdCb3ggaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICBiYkd1aWQgPSBZLnN0YW1wKGJvdW5kaW5nQm94LHRydWUpO1xuXG4gICAgICAgICAgICBpZiAoYmJHdWlkIGluIF9pbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2luc3RhbmNlc1tiYkd1aWRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95Qm94KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogPHA+XG4gICAgICogRGVzdHJveSBsaWZlY3ljbGUgbWV0aG9kLiBGaXJlcyB0aGUgZGVzdHJveVxuICAgICAqIGV2ZW50LCBwcmlvciB0byBpbnZva2luZyBkZXN0cnVjdG9ycyBmb3IgdGhlXG4gICAgICogY2xhc3MgaGllcmFyY2h5LlxuICAgICAqXG4gICAgICogT3ZlcnJpZGVzIEJhc2UncyBpbXBsZW1lbnRhdGlvbiwgdG8gc3VwcG9ydCBhcmd1bWVudHMgdG8gZGVzdHJveVxuICAgICAqIDwvcD5cbiAgICAgKiA8cD5cbiAgICAgKiBTdWJzY3JpYmVycyB0byB0aGUgZGVzdHJveVxuICAgICAqIGV2ZW50IGNhbiBpbnZva2UgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCwgdG8gcHJldmVudCBkZXN0cnVjdGlvblxuICAgICAqIGZyb20gcHJvY2VlZGluZy5cbiAgICAgKiA8L3A+XG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICogQHBhcmFtIGRlc3Ryb3lBbGxOb2RlcyB7Qm9vbGVhbn0gSWYgdHJ1ZSwgYWxsIG5vZGVzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIFdpZGdldCBhcmVcbiAgICAgKiByZW1vdmVkIGFuZCBkZXN0cm95ZWQuIERlZmF1bHRzIHRvIGZhbHNlIGR1ZSB0byBwb3RlbnRpYWxseSBoaWdoIHJ1bi10aW1lIGNvc3QuXG4gICAgICogQHJldHVybiB7V2lkZ2V0fSBBIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbihkZXN0cm95QWxsTm9kZXMpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveUFsbE5vZGVzID0gZGVzdHJveUFsbE5vZGVzO1xuICAgICAgICByZXR1cm4gV2lkZ2V0LnN1cGVyY2xhc3MuZGVzdHJveS5hcHBseSh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbmQgZGVzdHJveXMgdGhlIHdpZGdldHMgcmVuZGVyZWQgYm91bmRpbmdCb3gsIGNvbnRlbnRCb3gsXG4gICAgICogYW5kIGRldGFjaGVzIGJvdW5kIFVJIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2Rlc3Ryb3lCb3hcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2Rlc3Ryb3lCb3ggOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSB0aGlzLmdldChCT1VORElOR19CT1gpLFxuICAgICAgICAgICAgY29udGVudEJveCA9IHRoaXMuZ2V0KENPTlRFTlRfQk9YKSxcbiAgICAgICAgICAgIGRlZXAgPSB0aGlzLl9kZXN0cm95QWxsTm9kZXMsXG4gICAgICAgICAgICBzYW1lO1xuXG4gICAgICAgIHNhbWUgPSBib3VuZGluZ0JveCAmJiBib3VuZGluZ0JveC5jb21wYXJlVG8oY29udGVudEJveCk7XG5cbiAgICAgICAgaWYgKHRoaXMuVUlfRVZFTlRTKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95VUlFdmVudHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VuYmluZFVJKGJvdW5kaW5nQm94KTtcblxuICAgICAgICBpZiAoY29udGVudEJveCkge1xuICAgICAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICAgICAgICBjb250ZW50Qm94LmVtcHR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50Qm94LnJlbW92ZShUUlVFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2FtZSkge1xuICAgICAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveC5lbXB0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm91bmRpbmdCb3gucmVtb3ZlKFRSVUUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIHRoZSBpbml0aWFsIERPTSBmb3IgdGhlIHdpZGdldC4gSW52b2tpbmcgdGhpc1xuICAgICAqIG1ldGhvZCB3aWxsIGxlYWQgdG8gdGhlIGNyZWF0aW5nIG9mIGFsbCBET00gZWxlbWVudHMgZm9yXG4gICAgICogdGhlIHdpZGdldCAob3IgdGhlIG1hbmlwdWxhdGlvbiBvZiBleGlzdGluZyBET00gZWxlbWVudHNcbiAgICAgKiBmb3IgdGhlIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50IHVzZSBjYXNlKS5cbiAgICAgKiA8cD5cbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBpbnZva2VkIG9uY2UgZm9yIGFuIGluaXRpYWxpemVkXG4gICAgICogd2lkZ2V0LlxuICAgICAqIDwvcD5cbiAgICAgKiA8cD5cbiAgICAgKiBJdCBkZWxlZ2F0ZXMgdG8gdGhlIHdpZGdldCBzcGVjaWZpYyByZW5kZXJlciBtZXRob2QgdG8gZG9cbiAgICAgKiB0aGUgYWN0dWFsIHdvcmsuXG4gICAgICogPC9wPlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQGZpbmFsXG4gICAgICogQHBhcmFtICBwYXJlbnROb2RlIHtPYmplY3QgfCBTdHJpbmd9IE9wdGlvbmFsLiBUaGUgTm9kZSB1bmRlciB3aGljaCB0aGVcbiAgICAgKiBXaWRnZXQgaXMgdG8gYmUgcmVuZGVyZWQuIFRoaXMgY2FuIGJlIGEgTm9kZSBpbnN0YW5jZSBvciBhIENTUyBzZWxlY3RvciBzdHJpbmcuXG4gICAgICogPHA+XG4gICAgICogSWYgdGhlIHNlbGVjdG9yIHN0cmluZyByZXR1cm5zIG1vcmUgdGhhbiBvbmUgTm9kZSwgdGhlIGZpcnN0IG5vZGUgd2lsbCBiZSB1c2VkXG4gICAgICogYXMgdGhlIHBhcmVudE5vZGUuIE5PVEU6IFRoaXMgYXJndW1lbnQgaXMgcmVxdWlyZWQgaWYgYm90aCB0aGUgYm91bmRpbmdCb3ggYW5kIGNvbnRlbnRCb3hcbiAgICAgKiBhcmUgbm90IGN1cnJlbnRseSBpbiB0aGUgZG9jdW1lbnQuIElmIGl0J3Mgbm90IHByb3ZpZGVkLCB0aGUgV2lkZ2V0IHdpbGwgYmUgcmVuZGVyZWRcbiAgICAgKiB0byB0aGUgYm9keSBvZiB0aGUgY3VycmVudCBkb2N1bWVudCBpbiB0aGlzIGNhc2UuXG4gICAgICogPC9wPlxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24ocGFyZW50Tm9kZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5nZXQoREVTVFJPWUVEKSAmJiAhdGhpcy5nZXQoUkVOREVSRUQpKSB7XG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICogTGlmZWN5Y2xlIGV2ZW50IGZvciB0aGUgcmVuZGVyIHBoYXNlLCBmaXJlZCBwcmlvciB0byByZW5kZXJpbmcgdGhlIFVJXG4gICAgICAgICAgICAgICogZm9yIHRoZSB3aWRnZXQgKHByaW9yIHRvIGludm9raW5nIHRoZSB3aWRnZXQncyByZW5kZXJlciBtZXRob2QpLlxuICAgICAgICAgICAgICAqIDxwPlxuICAgICAgICAgICAgICAqIFN1YnNjcmliZXJzIHRvIHRoZSBcIm9uXCIgbW9tZW50IG9mIHRoaXMgZXZlbnQsIHdpbGwgYmUgbm90aWZpZWRcbiAgICAgICAgICAgICAgKiBiZWZvcmUgdGhlIHdpZGdldCBpcyByZW5kZXJlZC5cbiAgICAgICAgICAgICAgKiA8L3A+XG4gICAgICAgICAgICAgICogPHA+XG4gICAgICAgICAgICAgICogU3Vic2NyaWJlcnMgdG8gdGhlIFwiYWZ0ZXJcIiBtb21lbnQgb2YgdGhpcyBldmVudCwgd2lsbCBiZSBub3RpZmllZFxuICAgICAgICAgICAgICAqIGFmdGVyIHJlbmRlcmluZyBpcyBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgKiA8L3A+XG4gICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgKiBAZXZlbnQgcmVuZGVyXG4gICAgICAgICAgICAgICogQHByZXZlbnRhYmxlIF9kZWZSZW5kZXJGblxuICAgICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGUgVGhlIEV2ZW50IEZhY2FkZVxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFJFTkRFUiwge1xuICAgICAgICAgICAgICAgIHF1ZXVhYmxlOkZBTFNFLFxuICAgICAgICAgICAgICAgIGZpcmVPbmNlOlRSVUUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhcmdldE9ubHk6VFJVRSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0Rm46IHRoaXMuX2RlZlJlbmRlckZuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5maXJlKFJFTkRFUiwge3BhcmVudE5vZGU6IChwYXJlbnROb2RlKSA/IE5vZGUub25lKHBhcmVudE5vZGUpIDogbnVsbH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlbmRlciBoYW5kbGVyXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kZWZSZW5kZXJGblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge0V2ZW50RmFjYWRlfSBlIFRoZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge05vZGV9IHBhcmVudE5vZGUgVGhlIHBhcmVudCBub2RlIHRvIHJlbmRlciB0bywgaWYgcGFzc2VkIGluIHRvIHRoZSA8Y29kZT5yZW5kZXI8L2NvZGU+IG1ldGhvZFxuICAgICAqL1xuICAgIF9kZWZSZW5kZXJGbiA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50Tm9kZSA9IGUucGFyZW50Tm9kZTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3NldChSRU5ERVJFRCwgVFJVRSk7XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlTG9hZGluZ0NsYXNzTmFtZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBET00gKG9yIG1hbmlwdWxhdGVzIERPTSBmb3IgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQpXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBieSByZW5kZXIoKSBhbmQgaXMgbm90IGNoYWluZWRcbiAgICAgKiBhdXRvbWF0aWNhbGx5IGZvciB0aGUgY2xhc3MgaGllcmFyY2h5ICh1bmxpa2UgaW5pdGlhbGl6ZXIsIGRlc3RydWN0b3IpXG4gICAgICogc28gaXQgc2hvdWxkIGJlIGNoYWluZWQgbWFudWFsbHkgZm9yIHN1YmNsYXNzZXMgaWYgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbmRlcmVyXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbmRlcmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8ga3dlaWdodFxuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcztcblxuICAgICAgICB3aWRnZXQuX3JlbmRlclVJKCk7XG4gICAgICAgIHdpZGdldC5yZW5kZXJVSSgpO1xuXG4gICAgICAgIHdpZGdldC5fYmluZFVJKCk7XG4gICAgICAgIHdpZGdldC5iaW5kVUkoKTtcblxuICAgICAgICB3aWRnZXQuX3N5bmNVSSgpO1xuICAgICAgICB3aWRnZXQuc3luY1VJKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMvU2V0cyB1cCBsaXN0ZW5lcnMgdG8gYmluZCBXaWRnZXQgU3RhdGUgdG8gVUkvRE9NXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGJ5IGZyYW1ld29yayBhbmQgaXMgbm90IGNoYWluZWRcbiAgICAgKiBhdXRvbWF0aWNhbGx5IGZvciB0aGUgY2xhc3MgaGllcmFyY2h5LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBiaW5kVUlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmluZFVJOiBFTVBUWV9GTixcblxuICAgIC8qKlxuICAgICAqIEFkZHMgbm9kZXMgdG8gdGhlIERPTVxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBieSBmcmFtZXdvcmsgYW5kIGlzIG5vdCBjaGFpbmVkXG4gICAgICogYXV0b21hdGljYWxseSBmb3IgdGhlIGNsYXNzIGhpZXJhcmNoeS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVuZGVyVUlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVuZGVyVUk6IEVNUFRZX0ZOLFxuXG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSByZW5kZXJlZCBVSSwgYmFzZWQgb24gV2lkZ2V0IFN0YXRlXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGJ5IGZyYW1ld29yayBhbmQgaXMgbm90IGNoYWluZWRcbiAgICAgKiBhdXRvbWF0aWNhbGx5IGZvciB0aGUgY2xhc3MgaGllcmFyY2h5LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzeW5jVUlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBzeW5jVUk6IEVNUFRZX0ZOLFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBoaWRlXG4gICAgICogQGRlc2NyaXB0aW9uIEhpZGVzIHRoZSBXaWRnZXQgYnkgc2V0dGluZyB0aGUgXCJ2aXNpYmxlXCIgYXR0cmlidXRlIHRvIFwiZmFsc2VcIi5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldChWSVNJQkxFLCBGQUxTRSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgc2hvd1xuICAgICAqIEBkZXNjcmlwdGlvbiBTaG93cyB0aGUgV2lkZ2V0IGJ5IHNldHRpbmcgdGhlIFwidmlzaWJsZVwiIGF0dHJpYnV0ZSB0byBcInRydWVcIi5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldChWSVNJQkxFLCBUUlVFKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBmb2N1c1xuICAgICAqIEBkZXNjcmlwdGlvbiBDYXVzZXMgdGhlIFdpZGdldCB0byByZWNlaXZlIHRoZSBmb2N1cyBieSBzZXR0aW5nIHRoZSBcImZvY3VzZWRcIlxuICAgICAqIGF0dHJpYnV0ZSB0byBcInRydWVcIi5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldChGT0NVU0VELCBUUlVFKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBibHVyXG4gICAgICogQGRlc2NyaXB0aW9uIENhdXNlcyB0aGUgV2lkZ2V0IHRvIGxvc2UgZm9jdXMgYnkgc2V0dGluZyB0aGUgXCJmb2N1c2VkXCIgYXR0cmlidXRlXG4gICAgICogdG8gXCJmYWxzZVwiXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJsdXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldChGT0NVU0VELCBGQUxTRSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZW5hYmxlXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCB0aGUgV2lkZ2V0J3MgXCJkaXNhYmxlZFwiIGF0dHJpYnV0ZSB0byBcImZhbHNlXCIuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldChESVNBQkxFRCwgRkFMU0UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGRpc2FibGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBXaWRnZXQncyBcImRpc2FibGVkXCIgYXR0cmlidXRlIHRvIFwidHJ1ZVwiLlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KERJU0FCTEVELCBUUlVFKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBfdWlTaXplQ0JcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBleHBhbmRcbiAgICAgKi9cbiAgICBfdWlTaXplQ0IgOiBmdW5jdGlvbihleHBhbmQpIHtcbiAgICAgICAgdGhpcy5nZXQoQ09OVEVOVF9CT1gpLnRvZ2dsZUNsYXNzKF9nZXRXaWRnZXRDbGFzc05hbWUoQ09OVEVOVCwgXCJleHBhbmRlZFwiKSwgZXhwYW5kKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjb2xsZWN0IHRoZSBib3VuZGluZ0JveCBhbmQgY29udGVudEJveCBhbmQgYXBwZW5kIHRvIHRoZSBwcm92aWRlZCBwYXJlbnROb2RlLCBpZiBub3RcbiAgICAgKiBhbHJlYWR5IGEgY2hpbGQuIFRoZSBvd25lciBkb2N1bWVudCBvZiB0aGUgYm91bmRpbmdCb3gsIG9yIHRoZSBvd25lciBkb2N1bWVudCBvZiB0aGUgY29udGVudEJveCB3aWxsIGJlIHVzZWRcbiAgICAgKiBhcyB0aGUgZG9jdW1lbnQgaW50byB3aGljaCB0aGUgV2lkZ2V0IGlzIHJlbmRlcmVkIGlmIGEgcGFyZW50Tm9kZSBpcyBub2RlIGlzIG5vdCBwcm92aWRlZC4gSWYgYm90aCB0aGUgYm91bmRpbmdCb3ggYW5kXG4gICAgICogdGhlIGNvbnRlbnRCb3ggYXJlIG5vdCBjdXJyZW50bHkgaW4gdGhlIGRvY3VtZW50LCBhbmQgbm8gcGFyZW50Tm9kZSBpcyBwcm92aWRlZCwgdGhlIHdpZGdldCB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICogdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQncyBib2R5LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfcmVuZGVyQm94XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IHBhcmVudE5vZGUgVGhlIHBhcmVudE5vZGUgdG8gcmVuZGVyIHRoZSB3aWRnZXQgdG8uIElmIG5vdCBwcm92aWRlZCwgYW5kIGJvdGggdGhlIGJvdW5kaW5nQm94IGFuZFxuICAgICAqIHRoZSBjb250ZW50Qm94IGFyZSBub3QgY3VycmVudGx5IGluIHRoZSBkb2N1bWVudCwgdGhlIHdpZGdldCB3aWxsIGJlIHJlbmRlcmVkIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50J3MgYm9keS5cbiAgICAgKi9cbiAgICBfcmVuZGVyQm94OiBmdW5jdGlvbihwYXJlbnROb2RlKSB7XG5cbiAgICAgICAgLy8gVE9ETzogUGVyZm9ybWFuY2UgT3B0aW1pemF0aW9uIFsgTW9yZSBlZmZlY3RpdmUgYWxnbyB0byByZWR1Y2UgTm9kZSByZWZzLCBjb21wYXJlcywgcmVwbGFjZXM/IF1cblxuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcywgLy8ga3dlaWdodFxuICAgICAgICAgICAgY29udGVudEJveCA9IHdpZGdldC5nZXQoQ09OVEVOVF9CT1gpLFxuICAgICAgICAgICAgYm91bmRpbmdCb3ggPSB3aWRnZXQuZ2V0KEJPVU5ESU5HX0JPWCksXG4gICAgICAgICAgICBzcmNOb2RlID0gd2lkZ2V0LmdldChTUkNfTk9ERSksXG4gICAgICAgICAgICBkZWZQYXJlbnROb2RlID0gd2lkZ2V0LkRFRl9QQVJFTlRfTk9ERSxcblxuICAgICAgICAgICAgZG9jID0gKHNyY05vZGUgJiYgc3JjTm9kZS5nZXQoT1dORVJfRE9DVU1FTlQpKSB8fCBib3VuZGluZ0JveC5nZXQoT1dORVJfRE9DVU1FTlQpIHx8IGNvbnRlbnRCb3guZ2V0KE9XTkVSX0RPQ1VNRU5UKTtcblxuICAgICAgICAvLyBJZiBzcmNOb2RlIChhc3N1bWUgaXQncyBhbHdheXMgaW4gZG9jKSwgaGF2ZSBjb250ZW50Qm94IHRha2UgaXRzIHBsYWNlICh3aWRnZXQgcmVuZGVyIHJlc3BvbnNpYmxlIGZvciByZS11c2Ugb2Ygc3JjTm9kZSBjb250ZW50cylcbiAgICAgICAgaWYgKHNyY05vZGUgJiYgIXNyY05vZGUuY29tcGFyZVRvKGNvbnRlbnRCb3gpICYmICFjb250ZW50Qm94LmluRG9jKGRvYykpIHtcbiAgICAgICAgICAgIHNyY05vZGUucmVwbGFjZShjb250ZW50Qm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYm91bmRpbmdCb3guY29tcGFyZVRvKGNvbnRlbnRCb3guZ2V0KFBBUkVOVF9OT0RFKSkgJiYgIWJvdW5kaW5nQm94LmNvbXBhcmVUbyhjb250ZW50Qm94KSkge1xuICAgICAgICAgICAgLy8gSWYgY29udGVudEJveCBib3ggaXMgYWxyZWFkeSBpbiB0aGUgZG9jdW1lbnQsIGhhdmUgYm91bmRpbmdCb3ggYm94IHRha2UgaXQncyBwbGFjZVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRCb3guaW5Eb2MoZG9jKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRCb3gucmVwbGFjZShib3VuZGluZ0JveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3VuZGluZ0JveC5hcHBlbmRDaGlsZChjb250ZW50Qm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlIHx8IChkZWZQYXJlbnROb2RlICYmIE5vZGUub25lKGRlZlBhcmVudE5vZGUpKTtcblxuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChib3VuZGluZ0JveCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWJvdW5kaW5nQm94LmluRG9jKGRvYykpIHtcbiAgICAgICAgICAgIE5vZGUub25lKEJPRFkpLmluc2VydChib3VuZGluZ0JveCwgMCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dGVyIGZvciB0aGUgYm91bmRpbmdCb3ggYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zZXRCQlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOb2RlfFN0cmluZ30gbm9kZVxuICAgICAqIEByZXR1cm4gTm9kZVxuICAgICAqL1xuICAgIF9zZXRCQjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0Qm94KHRoaXMuZ2V0KElEKSwgbm9kZSwgdGhpcy5CT1VORElOR19URU1QTEFURSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHRlciBmb3IgdGhlIGNvbnRlbnRCb3ggYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zZXRDQlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOb2RlfFN0cmluZ30gbm9kZVxuICAgICAqIEByZXR1cm4gTm9kZVxuICAgICAqL1xuICAgIF9zZXRDQjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuQ09OVEVOVF9URU1QTEFURSA9PT0gbnVsbCkgPyB0aGlzLmdldChCT1VORElOR19CT1gpIDogdGhpcy5fc2V0Qm94KG51bGwsIG5vZGUsIHRoaXMuQ09OVEVOVF9URU1QTEFURSwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgYm91bmRpbmdCb3ggYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogRm9yIHRoZSBXaWRnZXQgY2xhc3MsIHRoaXMgd2lsbCBtb3N0IGNvbW1vbmx5IGJlIG51bGwgKHJlc3VsdGluZyBpbiBhIG5ld1xuICAgICAqIGJvdW5kaW5nQm94IG5vZGUgaW5zdGFuY2UgYmVpbmcgY3JlYXRlZCksIHVubGVzcyBhIHNyY05vZGUgd2FzIHByb3ZpZGVkXG4gICAgICogYW5kIENPTlRFTlRfVEVNUExBVEUgaXMgbnVsbCwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHNyY05vZGUuXG4gICAgICogVGhpcyBiZWhhdmlvciB3YXMgaW50cm9kdWNlZCBpbiAzLjE3LjIgdG8gYWNjb21vZGF0ZSBzaW5nbGUtYm94IHdpZGdldHNcbiAgICAgKiB3aG9zZSBCQiAmIENCIGJvdGggcG9pbnQgdG8gc3JjTm9kZSAoZS5nLiBZLkJ1dHRvbikuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kZWZhdWx0QkJcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2RlZmF1bHRCQiA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0KFNSQ19OT0RFKSxcbiAgICAgICAgICAgIG51bGxDVCA9ICh0aGlzLkNPTlRFTlRfVEVNUExBVEUgPT09IG51bGwpO1xuXG4gICAgICAgIHJldHVybiAoKG5vZGUgJiYgbnVsbENUKSA/IG5vZGUgOiBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbnRlbnRCb3ggYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogRm9yIHRoZSBXaWRnZXQgY2xhc3MsIHRoaXMgd2lsbCBiZSB0aGUgc3JjTm9kZSBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIG51bGwgKHJlc3VsdGluZyBpblxuICAgICAqIGEgbmV3IGNvbnRlbnRCb3ggbm9kZSBpbnN0YW5jZSBiZWluZyBjcmVhdGVkKVxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZGVmYXVsdENCXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9kZWZhdWx0Q0IgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChTUkNfTk9ERSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBzZXQgdGhlIGJvdW5kaW5nL2NvbnRlbnQgYm94LCBvciBjcmVhdGUgaXQgZnJvbVxuICAgICAqIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSBpZiBub3QgZm91bmQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zZXRCb3hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBub2RlJ3MgaWQgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHtOb2RlfFN0cmluZ30gbm9kZSBUaGUgbm9kZSByZWZlcmVuY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGUgSFRNTCBzdHJpbmcgdGVtcGxhdGUgZm9yIHRoZSBub2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0JvdW5kaW5nIHRydWUgaWYgdGhpcyBpcyB0aGUgYm91bmRpbmdCb3gsIGZhbHNlIGlmIGl0J3MgdGhlIGNvbnRlbnRCb3hcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbm9kZVxuICAgICAqL1xuICAgIF9zZXRCb3ggOiBmdW5jdGlvbihpZCwgbm9kZSwgdGVtcGxhdGUsIGlzQm91bmRpbmcpIHtcblxuICAgICAgICBub2RlID0gTm9kZS5vbmUobm9kZSk7XG5cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBub2RlID0gTm9kZS5jcmVhdGUodGVtcGxhdGUpO1xuXG4gICAgICAgICAgICBpZiAoaXNCb3VuZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JiRnJvbVRlbXBsYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2JGcm9tVGVtcGxhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFub2RlLmdldChJRCkpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0KElELCBpZCB8fCBZLmd1aWQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFVJIHN0YXRlIGZvciB0aGUgV2lkZ2V0J3MgYm91bmRpbmcvY29udGVudCBib3hlcy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3JlbmRlclVJXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW5kZXJVSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckJveENsYXNzTmFtZXMoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyQm94KHRoaXMuX3BhcmVudE5vZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHN0YW5kYXJkIGNsYXNzIG5hbWVzIHRvIHRoZSBib3VuZGluZ0JveCBhbmQgY29udGVudEJveFxuICAgICAqXG4gICAgICogQG1ldGhvZCBfcmVuZGVyQm94Q2xhc3NOYW1lc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVuZGVyQm94Q2xhc3NOYW1lcyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoKSxcbiAgICAgICAgICAgIGNsLFxuICAgICAgICAgICAgYm91bmRpbmdCb3ggPSB0aGlzLmdldChCT1VORElOR19CT1gpLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBib3VuZGluZ0JveC5hZGRDbGFzcyhfZ2V0V2lkZ2V0Q2xhc3NOYW1lKCkpO1xuXG4gICAgICAgIC8vIFN0YXJ0IGZyb20gV2lkZ2V0IFN1YiBDbGFzc1xuICAgICAgICBmb3IgKGkgPSBjbGFzc2VzLmxlbmd0aC0zOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY2wgPSBjbGFzc2VzW2ldO1xuICAgICAgICAgICAgYm91bmRpbmdCb3guYWRkQ2xhc3MoY2wuQ1NTX1BSRUZJWCB8fCBfZ2V0Q2xhc3NOYW1lKGNsLk5BTUUudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIGluc3RhbmNlIGJhc2VkIG5hbWUgZm9yIGNvbnRlbnQgYm94XG4gICAgICAgIHRoaXMuZ2V0KENPTlRFTlRfQk9YKS5hZGRDbGFzcyh0aGlzLmdldENsYXNzTmFtZShDT05URU5UKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgY2xhc3MgbmFtZXMgcmVwcmVzZW50YXRpdmUgb2YgdGhlIHdpZGdldCdzIGxvYWRpbmcgc3RhdGUgZnJvbVxuICAgICAqIHRoZSBib3VuZGluZ0JveC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3JlbW92ZUxvYWRpbmdDbGFzc05hbWVzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW1vdmVMb2FkaW5nQ2xhc3NOYW1lczogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBib3VuZGluZ0JveCA9IHRoaXMuZ2V0KEJPVU5ESU5HX0JPWCksXG4gICAgICAgICAgICBjb250ZW50Qm94ID0gdGhpcy5nZXQoQ09OVEVOVF9CT1gpLFxuICAgICAgICAgICAgaW5zdENsYXNzID0gdGhpcy5nZXRDbGFzc05hbWUoTE9BRElORyksXG4gICAgICAgICAgICB3aWRnZXRDbGFzcyA9IF9nZXRXaWRnZXRDbGFzc05hbWUoTE9BRElORyk7XG5cbiAgICAgICAgYm91bmRpbmdCb3gucmVtb3ZlQ2xhc3Mod2lkZ2V0Q2xhc3MpXG4gICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKGluc3RDbGFzcyk7XG5cbiAgICAgICAgY29udGVudEJveC5yZW1vdmVDbGFzcyh3aWRnZXRDbGFzcylcbiAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhpbnN0Q2xhc3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIERPTSBhbmQgQ3VzdG9tRXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfYmluZFVJXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9iaW5kVUk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9iaW5kQXR0clVJKHRoaXMuX1VJX0FUVFJTLkJJTkQpO1xuICAgICAgICB0aGlzLl9iaW5kRE9NKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgX3VuYmluZFVJXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91bmJpbmRVSSA6IGZ1bmN0aW9uKGJvdW5kaW5nQm94KSB7XG4gICAgICAgIHRoaXMuX3VuYmluZERPTShib3VuZGluZ0JveCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgRE9NIGxpc3RlbmVycywgb24gZWxlbWVudHMgcmVuZGVyZWQgYnkgdGhlIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2JpbmRET01cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2JpbmRET00gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9Eb2N1bWVudCA9IHRoaXMuZ2V0KEJPVU5ESU5HX0JPWCkuZ2V0KE9XTkVSX0RPQ1VNRU5UKSxcbiAgICAgICAgICAgIGZvY3VzSGFuZGxlID0gV2lkZ2V0Ll9oRG9jRm9jdXM7XG5cbiAgICAgICAgLy8gU2hhcmVkIGxpc3RlbmVyIGFjcm9zcyBhbGwgV2lkZ2V0cy5cbiAgICAgICAgaWYgKCFmb2N1c0hhbmRsZSkge1xuICAgICAgICAgICAgZm9jdXNIYW5kbGUgPSBXaWRnZXQuX2hEb2NGb2N1cyA9IG9Eb2N1bWVudC5vbihcImZvY3VzXCIsIHRoaXMuX29uRG9jRm9jdXMsIHRoaXMpO1xuICAgICAgICAgICAgZm9jdXNIYW5kbGUubGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgIGNvdW50OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9jdXNIYW5kbGUubGlzdGVuZXJzW1kuc3RhbXAodGhpcywgdHJ1ZSldID0gdHJ1ZTtcbiAgICAgICAgZm9jdXNIYW5kbGUubGlzdGVuZXJzLmNvdW50Kys7XG5cbiAgICAgICAgLy9cdEZpeCBmb3IgV2Via2l0OlxuICAgICAgICAvL1x0RG9jdW1lbnQgZG9lc24ndCByZWNlaXZlIGZvY3VzIGluIFdlYmtpdCB3aGVuIHRoZSB1c2VyIG1vdXNlc1xuICAgICAgICAvL1x0ZG93biBvbiBpdCwgc28gdGhlIFwiZm9jdXNlZFwiIGF0dHJpYnV0ZSB3b24ndCBnZXQgc2V0IHRvIHRoZVxuICAgICAgICAvL1x0Y29ycmVjdCB2YWx1ZS4gS2VlcGluZyB0aGlzIGluc3RhbmNlIGJhc2VkIGZvciBub3csIHBvdGVudGlhbCBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgIC8vICBPdGhlcndpc2Ugd2UnbGwgZW5kIHVwIGxvb2tpbmcgdXAgd2lkZ2V0cyBmcm9tIHRoZSBET00gb24gZXZlcnkgbW91c2Vkb3duLlxuICAgICAgICBpZiAoV0VCS0lUKXtcbiAgICAgICAgICAgIHRoaXMuX2hEb2NNb3VzZURvd24gPSBvRG9jdW1lbnQub24oXCJtb3VzZWRvd25cIiwgdGhpcy5fb25Eb2NNb3VzZURvd24sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgX3VuYmluZERPTVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdW5iaW5kRE9NIDogZnVuY3Rpb24oYm91bmRpbmdCb3gpIHtcblxuICAgICAgICB2YXIgZm9jdXNIYW5kbGUgPSBXaWRnZXQuX2hEb2NGb2N1cyxcbiAgICAgICAgICAgIHl1aWQgPSBZLnN0YW1wKHRoaXMsIHRydWUpLFxuICAgICAgICAgICAgZm9jdXNMaXN0ZW5lcnMsXG4gICAgICAgICAgICBtb3VzZUhhbmRsZSA9IHRoaXMuX2hEb2NNb3VzZURvd247XG5cbiAgICAgICAgaWYgKGZvY3VzSGFuZGxlKSB7XG5cbiAgICAgICAgICAgIGZvY3VzTGlzdGVuZXJzID0gZm9jdXNIYW5kbGUubGlzdGVuZXJzO1xuXG4gICAgICAgICAgICBpZiAoZm9jdXNMaXN0ZW5lcnNbeXVpZF0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZm9jdXNMaXN0ZW5lcnNbeXVpZF07XG4gICAgICAgICAgICAgICAgZm9jdXNMaXN0ZW5lcnMuY291bnQtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvY3VzTGlzdGVuZXJzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9jdXNIYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgV2lkZ2V0Ll9oRG9jRm9jdXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFdFQktJVCAmJiBtb3VzZUhhbmRsZSkge1xuICAgICAgICAgICAgbW91c2VIYW5kbGUuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgd2lkZ2V0IFVJIHRvIHJlZmxlY3QgdGhlIGF0dHJpYnV0ZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3N5bmNVSVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc3luY1VJOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc3luY0F0dHJVSSh0aGlzLl9VSV9BVFRSUy5TWU5DKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9uIHRoZSB3aWRnZXQncyBib3VuZGluZyBib3ggZWxlbWVudFxuICAgICAqXG4gICAgICogQG1ldGhvZCBfdWlTZXRIZWlnaHRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IHZhbFxuICAgICAqL1xuICAgIF91aVNldEhlaWdodDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMuX3VpU2V0RGltKEhFSUdIVCwgdmFsKTtcbiAgICAgICAgdGhpcy5fdWlTaXplQ0IoKHZhbCAhPT0gRU1QVFlfU1RSICYmIHZhbCAhPT0gQVVUTykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB3aWR0aCBvbiB0aGUgd2lkZ2V0J3MgYm91bmRpbmcgYm94IGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3VpU2V0V2lkdGhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IHZhbFxuICAgICAqL1xuICAgIF91aVNldFdpZHRoOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fdWlTZXREaW0oV0lEVEgsIHZhbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgX3VpU2V0RGltXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGltIFRoZSBkaW1lbnNpb24gLSBcIndpZHRoXCIgb3IgXCJoZWlnaHRcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSB2YWwgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqL1xuICAgIF91aVNldERpbTogZnVuY3Rpb24oZGltZW5zaW9uLCB2YWwpIHtcbiAgICAgICAgdGhpcy5nZXQoQk9VTkRJTkdfQk9YKS5zZXRTdHlsZShkaW1lbnNpb24sIEwuaXNOdW1iZXIodmFsKSA/IHZhbCArIHRoaXMuREVGX1VOSVQgOiB2YWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmxlIHN0YXRlIGZvciB0aGUgVUlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3VpU2V0VmlzaWJsZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIF91aVNldFZpc2libGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLmdldChCT1VORElOR19CT1gpLnRvZ2dsZUNsYXNzKHRoaXMuZ2V0Q2xhc3NOYW1lKEhJRERFTiksICF2YWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkaXNhYmxlZCBzdGF0ZSBmb3IgdGhlIFVJXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF91aVNldERpc2FibGVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gICAgICovXG4gICAgX3VpU2V0RGlzYWJsZWQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLmdldChCT1VORElOR19CT1gpLnRvZ2dsZUNsYXNzKHRoaXMuZ2V0Q2xhc3NOYW1lKERJU0FCTEVEKSwgdmFsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZm9jdXNlZCBzdGF0ZSBmb3IgdGhlIFVJXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF91aVNldEZvY3VzZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNvdXJjZSB0aGF0IHRyaWdnZXJlZCBhbiB1cGRhdGUgdG9cbiAgICAgKiB0aGUgVUkuXG4gICAgICovXG4gICAgX3VpU2V0Rm9jdXNlZDogZnVuY3Rpb24odmFsLCBzcmMpIHtcbiAgICAgICAgIHZhciBib3VuZGluZ0JveCA9IHRoaXMuZ2V0KEJPVU5ESU5HX0JPWCk7XG4gICAgICAgICBib3VuZGluZ0JveC50b2dnbGVDbGFzcyh0aGlzLmdldENsYXNzTmFtZShGT0NVU0VEKSwgdmFsKTtcblxuICAgICAgICAgaWYgKHNyYyAhPT0gVUkpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveC5mb2N1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveC5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGFiSW5kZXggb24gdGhlIHdpZGdldCdzIHJlbmRlcmVkIFVJXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF91aVNldFRhYkluZGV4XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSBOdW1iZXJcbiAgICAgKi9cbiAgICBfdWlTZXRUYWJJbmRleDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdGhpcy5nZXQoQk9VTkRJTkdfQk9YKTtcblxuICAgICAgICBpZiAoTC5pc051bWJlcihpbmRleCkpIHtcbiAgICAgICAgICAgIGJvdW5kaW5nQm94LnNldChUQUJfSU5ERVgsIGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kaW5nQm94LnJlbW92ZUF0dHJpYnV0ZShUQUJfSU5ERVgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgX29uRG9jTW91c2VEb3duXG4gICAgICogQGRlc2NyaXB0aW9uIFwibW91c2Vkb3duXCIgZXZlbnQgaGFuZGxlciBmb3IgdGhlIG93bmVyIGRvY3VtZW50IG9mIHRoZVxuICAgICAqIHdpZGdldCdzIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZXZ0IFRoZSBldmVudCBmYWNhZGUgZm9yIHRoZSBET00gZm9jdXMgZXZlbnRcbiAgICAgKi9cbiAgICBfb25Eb2NNb3VzZURvd246IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvbUZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRvY0ZvY3VzKGV2dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRE9NIGZvY3VzIGV2ZW50IGhhbmRsZXIsIHVzZWQgdG8gc3luYyB0aGUgc3RhdGUgb2YgdGhlIFdpZGdldCB3aXRoIHRoZSBET01cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX29uRG9jRm9jdXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZXZ0IFRoZSBldmVudCBmYWNhZGUgZm9yIHRoZSBET00gZm9jdXMgZXZlbnRcbiAgICAgKi9cbiAgICBfb25Eb2NGb2N1czogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gV2lkZ2V0LmdldEJ5Tm9kZShldnQudGFyZ2V0KSxcbiAgICAgICAgICAgIGFjdGl2ZVdpZGdldCA9IFdpZGdldC5fYWN0aXZlO1xuXG4gICAgICAgIGlmIChhY3RpdmVXaWRnZXQgJiYgKGFjdGl2ZVdpZGdldCAhPT0gd2lkZ2V0KSkge1xuICAgICAgICAgICAgYWN0aXZlV2lkZ2V0Ll9kb21Gb2N1cyA9IGZhbHNlO1xuICAgICAgICAgICAgYWN0aXZlV2lkZ2V0Ll9zZXQoRk9DVVNFRCwgZmFsc2UsIHtzcmM6VUl9KTtcblxuICAgICAgICAgICAgV2lkZ2V0Ll9hY3RpdmUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpZGdldCkge1xuICAgICAgICAgICAgd2lkZ2V0Ll9kb21Gb2N1cyA9IHRydWU7XG4gICAgICAgICAgICB3aWRnZXQuX3NldChGT0NVU0VELCB0cnVlLCB7c3JjOlVJfSk7XG5cbiAgICAgICAgICAgIFdpZGdldC5fYWN0aXZlID0gd2lkZ2V0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyaWMgdG9TdHJpbmcgaW1wbGVtZW50YXRpb24gZm9yIGFsbCB3aWRnZXRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGRlZmF1bHQgc3RyaW5nIHZhbHVlIGZvciB0aGUgd2lkZ2V0IFsgZGlzcGxheXMgdGhlIE5BTUUgb2YgdGhlIGluc3RhbmNlLCBhbmQgdGhlIHVuaXF1ZSBpZCBdXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2luZyBkZXByZWNhdGVkIG5hbWUgcHJvcCBmb3Iga3dlaWdodCBzcXVlZXplLlxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCJbXCIgKyB0aGlzLmdldChJRCkgKyBcIl1cIjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB1bml0IHRvIHVzZSBmb3IgZGltZW5zaW9uIHZhbHVlc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IERFRl9VTklUXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgREVGX1VOSVQgOiBcInB4XCIsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG5vZGUgdG8gcmVuZGVyIHRoZSBib3VuZGluZyBib3ggdG8uIElmIG5vdCBzZXQsXG4gICAgICogd2lsbCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IGRvY3VtZW50IGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgREVGX1BBUkVOVF9OT0RFXG4gICAgICogQHR5cGUgU3RyaW5nIHwgTm9kZVxuICAgICAqL1xuICAgIERFRl9QQVJFTlRfTk9ERSA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSBkZWZpbmluZyB0aGUgbWFya3VwIHRlbXBsYXRlIGZvciBjb250ZW50IGJveC4gSWYgeW91ciBXaWRnZXQgZG9lc24ndFxuICAgICAqIG5lZWQgdGhlIGR1YWwgYm91bmRpbmdCb3gvY29udGVudEJveCBzdHJ1Y3R1cmUsIHNldCBDT05URU5UX1RFTVBMQVRFIHRvIG51bGwsXG4gICAgICogYW5kIGNvbnRlbnRCb3ggYW5kIGJvdW5kaW5nQm94IHdpbGwgYm90aCBwb2ludCB0byB0aGUgc2FtZSBOb2RlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IENPTlRFTlRfVEVNUExBVEVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBDT05URU5UX1RFTVBMQVRFIDogRElWLFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgZGVmaW5pbmcgdGhlIG1hcmt1cCB0ZW1wbGF0ZSBmb3IgYm91bmRpbmcgYm94LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IEJPVU5ESU5HX1RFTVBMQVRFXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgQk9VTkRJTkdfVEVNUExBVEUgOiBESVYsXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIF9ndWlkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9ndWlkIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBZLmd1aWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBfdmFsaWRUYWJJbmRleFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGFiSW5kZXhcbiAgICAgKi9cbiAgICBfdmFsaWRUYWJJbmRleCA6IGZ1bmN0aW9uICh0YWJJbmRleCkge1xuICAgICAgICByZXR1cm4gKEwuaXNOdW1iZXIodGFiSW5kZXgpIHx8IEwuaXNOdWxsKHRhYkluZGV4KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIGFmdGVyIGxpc3RlbmVycyBmb3IgdGhlIGxpc3Qgb2YgYXR0cmlidXRlcyBwcm92aWRlZFxuICAgICAqXG4gICAgICogQG1ldGhvZCBfYmluZEF0dHJVSVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cnNcbiAgICAgKi9cbiAgICBfYmluZEF0dHJVSSA6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCA9IGF0dHJzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyKGF0dHJzW2ldICsgQ0hBTkdFLCB0aGlzLl9zZXRBdHRyVUkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIF91aVNldCYjNjE7QVRUUiBOQU1FJiM2MjsgbWV0aG9kIGZvciB0aGUgbGlzdCBvZiBhdHRyaWJ1dGVzIHByb3ZpZGVkXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zeW5jQXR0clVJXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhdHRyc1xuICAgICAqL1xuICAgIF9zeW5jQXR0clVJIDogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgdmFyIGksIGwgPSBhdHRycy5sZW5ndGgsIGF0dHI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgICAgICAgIHRoaXNbX1VJU0VUICsgX3RvSW5pdGlhbENhcChhdHRyKV0odGhpcy5nZXQoYXR0cikpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgX3NldEF0dHJVSVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZVxuICAgICAqL1xuICAgIF9zZXRBdHRyVUkgOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpc1tfVUlTRVQgKyBfdG9Jbml0aWFsQ2FwKGUuYXR0ck5hbWUpXShlLm5ld1ZhbCwgZS5zcmMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHNldHRlciBmb3IgdGhlIHN0cmluZ3MgYXR0cmlidXRlLiBNZXJnZXMgcGFydGlhbCBzZXRzXG4gICAgICogaW50byB0aGUgZnVsbCBzdHJpbmcgc2V0LCB0byBhbGxvdyB1c2VycyB0byBwYXJ0aWFsIHNldHMgb2Ygc3RyaW5nc1xuICAgICAqXG4gICAgICogQG1ldGhvZCBfc3RyU2V0dGVyXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHJpbmdzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgZnVsbCBzZXQgb2Ygc3RyaW5ncyB0byBzZXRcbiAgICAgKi9cbiAgICBfc3RyU2V0dGVyIDogZnVuY3Rpb24oc3RyaW5ncykge1xuICAgICAgICByZXR1cm4gWS5tZXJnZSh0aGlzLmdldChTVFJJTkdTKSwgc3RyaW5ncyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gZ2V0IGEgc3BlY2lmaWMgc3RyaW5nIHZhbHVlXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2VkIGJ5IGRlcHJlY2F0ZWQgV2lkZ2V0TG9jYWxlIGltcGxlbWVudGF0aW9ucy5cbiAgICAgKiBAbWV0aG9kIGdldFN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXRTdHJpbmcgOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFNUUklOR1MpW2tleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gZ2V0IHRoZSBjb21wbGV0ZSBzZXQgb2Ygc3RyaW5ncyBmb3IgdGhlIHdpZGdldFxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgIFVzZWQgYnkgZGVwcmVjYXRlZCBXaWRnZXRMb2NhbGUgaW1wbGVtZW50YXRpb25zLlxuICAgICAqIEBtZXRob2QgZ2V0U3RyaW5nc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBzdHJpbmdzXG4gICAgICovXG4gICAgZ2V0U3RyaW5ncyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoU1RSSU5HUyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0cyBvZiBVSSBhdHRyaWJ1dGVzIHRvIGJpbmQgYW5kIHN5bmMgZm9yIHdpZGdldCdzIF9iaW5kVUkgYW5kIF9zeW5jVUkgaW1wbGVtZW50YXRpb25zXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX1VJX0FUVFJTXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfVUlfQVRUUlMgOiB7XG4gICAgICAgIEJJTkQ6IFVJX0FUVFJTLFxuICAgICAgICBTWU5DOiBVSV9BVFRSU1xuICAgIH1cbn0pO1xuXG5ZLldpZGdldCA9IFdpZGdldDtcblxuXG59LCAnMy4xNy4yJywge1xuICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImF0dHJpYnV0ZVwiLFxuICAgICAgICBcImJhc2UtYmFzZVwiLFxuICAgICAgICBcImJhc2UtcGx1Z2luaG9zdFwiLFxuICAgICAgICBcImNsYXNzbmFtZW1hbmFnZXJcIixcbiAgICAgICAgXCJldmVudC1mb2N1c1wiLFxuICAgICAgICBcIm5vZGUtYmFzZVwiLFxuICAgICAgICBcIm5vZGUtc3R5bGVcIlxuICAgIF0sXG4gICAgXCJza2lubmFibGVcIjogdHJ1ZVxufSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ3dpZGdldC1odG1scGFyc2VyJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBBZGRzIEhUTUwgUGFyc2VyIHN1cHBvcnQgdG8gdGhlIGJhc2UgV2lkZ2V0IGNsYXNzXG4gKlxuICogQG1vZHVsZSB3aWRnZXRcbiAqIEBzdWJtb2R1bGUgd2lkZ2V0LWh0bWxwYXJzZXJcbiAqIEBmb3IgV2lkZ2V0XG4gKi9cblxudmFyIFdpZGdldCA9IFkuV2lkZ2V0LFxuICAgIE5vZGUgPSBZLk5vZGUsXG4gICAgTGFuZyA9IFkuTGFuZyxcblxuICAgIFNSQ19OT0RFID0gXCJzcmNOb2RlXCIsXG4gICAgQ09OVEVOVF9CT1ggPSBcImNvbnRlbnRCb3hcIjtcblxuLyoqXG4gKiBPYmplY3QgaGFzaCwgZGVmaW5pbmcgaG93IGF0dHJpYnV0ZSB2YWx1ZXMgYXJlIHRvIGJlIHBhcnNlZCBmcm9tXG4gKiBtYXJrdXAgY29udGFpbmVkIGluIHRoZSB3aWRnZXQncyBjb250ZW50IGJveC4gZS5nLjpcbiAqIDxwcmU+XG4gKiAgIHtcbiAqICAgICAgIC8vIFNldCBzaW5nbGUgTm9kZSByZWZlcmVuY2VzIHVzaW5nIHNlbGVjdG9yIHN5bnRheFxuICogICAgICAgLy8gKHNlbGVjdG9yIGlzIHJ1biB0aHJvdWdoIG5vZGUub25lKVxuICogICAgICAgdGl0bGVOb2RlOiBcInNwYW4ueXVpLXRpdGxlXCIsXG4gKiAgICAgICAvLyBTZXQgTm9kZUxpc3QgcmVmZXJlbmNlcyB1c2luZyBzZWxlY3RvciBzeW50YXhcbiAqICAgICAgIC8vIChhcnJheSBpbmRpY2F0ZXMgc2VsZWN0b3IgaXMgdG8gYmUgcnVuIHRocm91Z2ggbm9kZS5hbGwpXG4gKiAgICAgICBsaXN0Tm9kZXM6IFtcImxpLnl1aS1pdGVtXCJdLFxuICogICAgICAgLy8gU2V0IG90aGVyIGF0dHJpYnV0ZSB0eXBlcywgdXNpbmcgYSBwYXJzZSBmdW5jdGlvbi5cbiAqICAgICAgIC8vIENvbnRleHQgaXMgc2V0IHRvIHRoZSB3aWRnZXQgaW5zdGFuY2UuXG4gKiAgICAgICBsYWJlbDogZnVuY3Rpb24oY29udGVudEJveCkge1xuICogICAgICAgICAgIHJldHVybiBjb250ZW50Qm94Lm9uZShcInNwYW4udGl0bGVcIikuZ2V0KFwiaW5uZXJIVE1MXCIpO1xuICogICAgICAgfVxuICogICB9XG4gKiA8L3ByZT5cbiAqXG4gKiBAcHJvcGVydHkgSFRNTF9QQVJTRVJcbiAqIEB0eXBlIE9iamVjdFxuICogQHN0YXRpY1xuICovXG5XaWRnZXQuSFRNTF9QQVJTRVIgPSB7fTtcblxuLyoqXG4gKiBUaGUgYnVpbGQgY29uZmlndXJhdGlvbiBmb3IgdGhlIFdpZGdldCBjbGFzcy5cbiAqIDxwPlxuICogRGVmaW5lcyB0aGUgc3RhdGljIGZpZWxkcyB3aGljaCBuZWVkIHRvIGJlIGFnZ3JlZ2F0ZWQsXG4gKiB3aGVuIHRoaXMgY2xhc3MgaXMgdXNlZCBhcyB0aGUgbWFpbiBjbGFzcyBwYXNzZWQgdG9cbiAqIHRoZSA8YSBocmVmPVwiQmFzZS5odG1sI21ldGhvZF9idWlsZFwiPkJhc2UuYnVpbGQ8L2E+IG1ldGhvZC5cbiAqIDwvcD5cbiAqIEBwcm9wZXJ0eSBfYnVpbGRDZmdcbiAqIEB0eXBlIE9iamVjdFxuICogQHN0YXRpY1xuICogQGZpbmFsXG4gKiBAcHJpdmF0ZVxuICovXG5XaWRnZXQuX2J1aWxkQ2ZnID0ge1xuICAgIGFnZ3JlZ2F0ZXMgOiBbXCJIVE1MX1BBUlNFUlwiXVxufTtcblxuLyoqXG4gKiBUaGUgRE9NIG5vZGUgdG8gcGFyc2UgZm9yIGNvbmZpZ3VyYXRpb24gdmFsdWVzLCBwYXNzZWQgdG8gdGhlIFdpZGdldCdzIEhUTUxfUEFSU0VSIGRlZmluaXRpb25cbiAqXG4gKiBAYXR0cmlidXRlIHNyY05vZGVcbiAqIEB0eXBlIFN0cmluZyB8IE5vZGVcbiAqIEB3cml0ZU9uY2VcbiAqL1xuV2lkZ2V0LkFUVFJTW1NSQ19OT0RFXSA9IHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBzZXR0ZXI6IE5vZGUub25lLFxuICAgIGdldHRlcjogXCJfZ2V0U3JjTm9kZVwiLFxuICAgIHdyaXRlT25jZTogdHJ1ZVxufTtcblxuWS5taXgoV2lkZ2V0LnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBfZ2V0U3JjTm9kZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgTm9kZSB0byBhcHBseSBIVE1MX1BBUlNFUiB0b1xuICAgICAqL1xuICAgIF9nZXRTcmNOb2RlIDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgfHwgdGhpcy5nZXQoQ09OVEVOVF9CT1gpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnQgdGhlIEJhc2VDb3JlIF9wcmVBZGRBdHRycyBtZXRob2QgaG9vaywgdG8gYWRkXG4gICAgICogdGhlIHNyY05vZGUgYW5kIHJlbGF0ZWQgYXR0cmlidXRlcywgc28gdGhhdCBIVE1MX1BBUlNFUlxuICAgICAqICh3aGljaCByZWxpZXMgb24gYHRoaXMuZ2V0KFwic3JjTm9kZVwiKWApIGNhbiBtZXJnZSBpbiBpdCdzXG4gICAgICogcmVzdWx0cyBiZWZvcmUgdGhlIHJlc3Qgb2YgdGhlIGF0dHJpYnV0ZXMgYXJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfcHJlQWRkQXR0cnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXR0cnMge09iamVjdH0gVGhlIGZ1bGwgaGFzaCBvZiBzdGF0aWNhbGx5IGRlZmluZWQgQVRUUlNcbiAgICAgKiBhdHRyaWJ1dGVzIGJlaW5nIGFkZGVkIGZvciB0aGlzIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlclZhbHMge09iamVjdH0gVGhlIGhhc2ggb2YgdXNlciB2YWx1ZXMgcGFzc2VkIHRvXG4gICAgICogdGhlIGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF6eSB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdG8gYWRkIHRoZSBhdHRyaWJ1dGVzIGxhemlseVxuICAgICAqL1xuICAgIF9wcmVBZGRBdHRycyA6IGZ1bmN0aW9uKGF0dHJzLCB1c2VyVmFscywgbGF6eSkge1xuXG4gICAgICAgIHZhciBwcmVBdHRycyA9IHtcbiAgICAgICAgICAgIGlkIDogYXR0cnMuaWQsXG4gICAgICAgICAgICBib3VuZGluZ0JveCA6IGF0dHJzLmJvdW5kaW5nQm94LFxuICAgICAgICAgICAgY29udGVudEJveCA6IGF0dHJzLmNvbnRlbnRCb3gsXG4gICAgICAgICAgICBzcmNOb2RlIDogYXR0cnMuc3JjTm9kZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkQXR0cnMocHJlQXR0cnMsIHVzZXJWYWxzLCBsYXp5KTtcblxuICAgICAgICBkZWxldGUgYXR0cnMuYm91bmRpbmdCb3g7XG4gICAgICAgIGRlbGV0ZSBhdHRycy5jb250ZW50Qm94O1xuICAgICAgICBkZWxldGUgYXR0cnMuc3JjTm9kZTtcbiAgICAgICAgZGVsZXRlIGF0dHJzLmlkO1xuXG4gICAgICAgIGlmICh0aGlzLl9hcHBseVBhcnNlcikge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlQYXJzZXIodXNlclZhbHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgX2FwcGx5UGFyc2VkQ29uZmlnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBjb25maWd1cmF0aW9uIGxpdGVyYWxcbiAgICAgKi9cbiAgICBfYXBwbHlQYXJzZWRDb25maWcgOiBmdW5jdGlvbihub2RlLCBjZmcsIHBhcnNlZENmZykge1xuICAgICAgICByZXR1cm4gKHBhcnNlZENmZykgPyBZLm1peChjZmcsIHBhcnNlZENmZywgZmFsc2UpIDogY2ZnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCB1c2VkIHRvIGFwcGx5IHRoZSA8Y29kZT5IVE1MX1BBUlNFUjwvY29kZT4gY29uZmlndXJhdGlvbiBmb3IgdGhlXG4gICAgICogaW5zdGFuY2UsIHRvIHJldHJpZXZlIGNvbmZpZyBkYXRhIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2FwcGx5UGFyc2VyXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSBjb25maWcge09iamVjdH0gVXNlciBjb25maWd1cmF0aW9uIG9iamVjdCAod2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCB2YWx1ZXMgZnJvbSBOb2RlKVxuICAgICAqL1xuICAgIF9hcHBseVBhcnNlciA6IGZ1bmN0aW9uKGNvbmZpZykge1xuXG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLFxuICAgICAgICAgICAgc3JjTm9kZSA9IHRoaXMuX2dldE5vZGVUb1BhcnNlKCksXG4gICAgICAgICAgICBzY2hlbWEgPSB3aWRnZXQuX2dldEh0bWxQYXJzZXIoKSxcbiAgICAgICAgICAgIHBhcnNlZENvbmZpZyxcbiAgICAgICAgICAgIHZhbDtcblxuICAgICAgICBpZiAoc2NoZW1hICYmIHNyY05vZGUpIHtcbiAgICAgICAgICAgIFkuT2JqZWN0LmVhY2goc2NoZW1hLCBmdW5jdGlvbih2LCBrLCBvKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24odikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdi5jYWxsKHdpZGdldCwgc3JjTm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKExhbmcuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gc3JjTm9kZS5hbGwodlswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBzcmNOb2RlLm9uZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQ29uZmlnID0gcGFyc2VkQ29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRDb25maWdba10gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnID0gd2lkZ2V0Ll9hcHBseVBhcnNlZENvbmZpZyhzcmNOb2RlLCBjb25maWcsIHBhcnNlZENvbmZpZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB3ZSBoYXZlIGEgbm9kZSByZWZlcmVuY2Ugd2hpY2ggd2Ugc2hvdWxkIHRyeSBhbmQgcGFyc2UuXG4gICAgICpcbiAgICAgKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBwYXJzZSBub2RlcyBnZW5lcmF0ZWQgZnJvbSBDT05URU5UX1RFTVBMQVRFLFxuICAgICAqIG9ubHkgZXhwbGljaXRseSBzZXQgc3JjTm9kZSwgb3IgY29udGVudEJveCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZ2V0Tm9kZVRvUGFyc2VcbiAgICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbm9kZSByZWZlcmVuY2UgdG8gYXBwbHkgSFRNTF9QQVJTRVIgdG8uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Tm9kZVRvUGFyc2UgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNyY05vZGUgPSB0aGlzLmdldChcInNyY05vZGVcIik7XG4gICAgICAgIHJldHVybiAoIXRoaXMuX2NiRnJvbVRlbXBsYXRlKSA/IHNyY05vZGUgOiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBIVE1MX1BBUlNFUiBkZWZpbml0aW9uIGZvciB0aGlzIGluc3RhbmNlLCBieSBtZXJnaW5nIEhUTUxfUEFSU0VSXG4gICAgICogZGVmaW5pdGlvbnMgYWNyb3NzIHRoZSBjbGFzcyBoaWVyYXJjaHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgX2dldEh0bWxQYXJzZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEhUTUxfUEFSU0VSIGRlZmluaXRpb24gZm9yIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfZ2V0SHRtbFBhcnNlciA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBSZW1vdmVkIGNhY2hpbmcgZm9yIGt3ZWlnaHQuIFRoaXMgaXMgYSBwcml2YXRlIG1ldGhvZFxuICAgICAgICAvLyBhbmQgb25seSBjYWxsZWQgb25jZSBzbyBkb24ndCBuZWVkIHRvIGNhY2hlIEhUTUxfUEFSU0VSXG4gICAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcygpLFxuICAgICAgICAgICAgcGFyc2VyID0ge30sXG4gICAgICAgICAgICBpLCBwO1xuXG4gICAgICAgIGZvciAoaSA9IGNsYXNzZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHAgPSBjbGFzc2VzW2ldLkhUTUxfUEFSU0VSO1xuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICBZLm1peChwYXJzZXIsIHAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgfVxufSk7XG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcIndpZGdldC1iYXNlXCJdfSk7XG4iLCIvKlxuWVVJIDMuMTcuMiAoYnVpbGQgOWMzYzc4ZSlcbkNvcHlyaWdodCAyMDE0IFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG5odHRwOi8veXVpbGlicmFyeS5jb20vbGljZW5zZS9cbiovXG5cbllVSS5hZGQoJ3dpZGdldC1za2luJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBQcm92aWRlcyBza2luIHJlbGF0ZWQgdXRsaWxpdHkgbWV0aG9kcy5cbiAqXG4gKiBAbW9kdWxlIHdpZGdldFxuICogQHN1Ym1vZHVsZSB3aWRnZXQtc2tpblxuICovXG52YXIgQk9VTkRJTkdfQk9YID0gXCJib3VuZGluZ0JveFwiLFxuICAgIENPTlRFTlRfQk9YID0gXCJjb250ZW50Qm94XCIsXG4gICAgU0tJTiA9IFwic2tpblwiLFxuICAgIF9nZXRDbGFzc05hbWUgPSBZLkNsYXNzTmFtZU1hbmFnZXIuZ2V0Q2xhc3NOYW1lO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHNraW4gdGhhdCdzIGN1cnJlbnRseSBhcHBsaWVkIHRvIHRoZSB3aWRnZXQuXG4gKlxuICogU2VhcmNoZXMgdXAgdGhlIFdpZGdldCdzIGFuY2VzdG9yIGF4aXMgZm9yLCBieSBkZWZhdWx0LCBhIGNsYXNzXG4gKiB5dWkzLXNraW4tKG5hbWUpLCBhbmQgcmV0dXJucyB0aGUgKG5hbWUpIHBvcnRpb24uIE90aGVyd2lzZSwgcmV0dXJucyBudWxsLlxuICpcbiAqIFRoaXMgaXMgb25seSByZWFsbHkgdXNlZnVsIGFmdGVyIHRoZSB3aWRnZXQncyBET00gc3RydWN0dXJlIGlzIGluIHRoZVxuICogZG9jdW1lbnQsIGVpdGhlciBieSByZW5kZXIgb3IgYnkgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQuXG4gKlxuICogQG1ldGhvZCBnZXRTa2luTmFtZVxuICogQGZvciBXaWRnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2tpblByZWZpeF0gVGhlIHByZWZpeCB3aGljaCB0aGUgaW1wbGVtZW50YXRpb24gdXNlcyBmb3IgdGhlIHNraW5cbiAqIChcInl1aTMtc2tpbi1cIiBpcyB0aGUgZGVmYXVsdCkuXG4gKlxuICogTk9URTogc2tpblByZWZpeCB3aWxsIGJlIHVzZWQgYXMgcGFydCBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbjpcbiAqXG4gKiAgICAgbmV3IFJlZ0V4cCgnXFxcXGInICsgc2tpblByZWZpeCArICcoXFxcXFMrKScpXG4gKlxuICogQWx0aG91Z2ggYW4gdW5saWtlbHkgdXNlIGNhc2UsIGxpdGVyYWwgY2hhcmFjdGVycyB3aGljaCBtYXkgcmVzdWx0IGluIGFuIGludmFsaWRcbiAqIHJlZ3VsYXIgZXhwcmVzc2lvbiBzaG91bGQgYmUgZXNjYXBlZC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBza2luLCBvciBudWxsLCBpZiBhIG1hdGNoaW5nIHNraW4gY2xhc3MgaXMgbm90IGZvdW5kLlxuICovXG5cblkuV2lkZ2V0LnByb3RvdHlwZS5nZXRTa2luTmFtZSA9IGZ1bmN0aW9uIChza2luUHJlZml4KSB7XG5cbiAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0KCBDT05URU5UX0JPWCApIHx8IHRoaXMuZ2V0KCBCT1VORElOR19CT1ggKSxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHNlYXJjaDtcblxuICAgIHNraW5QcmVmaXggPSBza2luUHJlZml4IHx8IF9nZXRDbGFzc05hbWUoU0tJTiwgXCJcIik7XG5cbiAgICBzZWFyY2ggPSBuZXcgUmVnRXhwKCAnXFxcXGInICsgc2tpblByZWZpeCArICcoXFxcXFMrKScgKTtcblxuICAgIGlmICggcm9vdCApIHtcbiAgICAgICAgcm9vdC5hbmNlc3RvciggZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICAgICAgbWF0Y2ggPSBub2RlLmdldCggJ2NsYXNzTmFtZScgKS5tYXRjaCggc2VhcmNoICk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCBtYXRjaCApID8gbWF0Y2hbMV0gOiBudWxsO1xufTtcblxuXG59LCAnMy4xNy4yJywge1wicmVxdWlyZXNcIjogW1wid2lkZ2V0LWJhc2VcIl19KTtcbiIsIi8qXG5ZVUkgMy4xNy4yIChidWlsZCA5YzNjNzhlKVxuQ29weXJpZ2h0IDIwMTQgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbmh0dHA6Ly95dWlsaWJyYXJ5LmNvbS9saWNlbnNlL1xuKi9cblxuWVVJLmFkZCgnd2lkZ2V0LXVpZXZlbnRzJywgZnVuY3Rpb24gKFksIE5BTUUpIHtcblxuLyoqXG4gKiBTdXBwb3J0IGZvciBXaWRnZXQgVUkgRXZlbnRzIChDdXN0b20gRXZlbnRzIGZpcmVkIGJ5IHRoZSB3aWRnZXQsIHdoaWNoIHdyYXAgdGhlIHVuZGVybHlpbmcgRE9NIGV2ZW50cyAtIGUuZy4gd2lkZ2V0OmNsaWNrLCB3aWRnZXQ6bW91c2Vkb3duKVxuICpcbiAqIEBtb2R1bGUgd2lkZ2V0XG4gKiBAc3VibW9kdWxlIHdpZGdldC11aWV2ZW50c1xuICovXG5cbnZhciBCT1VORElOR19CT1ggPSBcImJvdW5kaW5nQm94XCIsXG4gICAgV2lkZ2V0ID0gWS5XaWRnZXQsXG4gICAgUkVOREVSID0gXCJyZW5kZXJcIixcbiAgICBMID0gWS5MYW5nLFxuICAgIEVWRU5UX1BSRUZJWF9ERUxJTUlURVIgPSBcIjpcIixcblxuICAgIC8vICBNYXAgb2YgTm9kZSBpbnN0YW5jZXMgc2VydmluZyBhcyBhIGRlbGVnYXRpb24gY29udGFpbmVycyBmb3IgYSBzcGVjaWZpY1xuICAgIC8vICBldmVudCB0eXBlIHRvIFdpZGdldCBpbnN0YW5jZXMgdXNpbmcgdGhhdCBkZWxlZ2F0aW9uIGNvbnRhaW5lci5cbiAgICBfdWlldnRzID0gWS5XaWRnZXQuX3VpZXZ0cyA9IFkuV2lkZ2V0Ll91aWV2dHMgfHwge307XG5cblkubWl4KFdpZGdldC5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICAqIERlc3RydWN0b3IgbG9naWMgZm9yIFVJIGV2ZW50IGluZnJhc3RydWN0dXJlLFxuICAgICAqIGludm9rZWQgZHVyaW5nIFdpZGdldCBkZXN0cnVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2Rlc3Ryb3lVSUV2ZW50c1xuICAgICAqIEBmb3IgV2lkZ2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVzdHJveVVJRXZlbnRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgd2lkZ2V0R3VpZCA9IFkuc3RhbXAodGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgWS5lYWNoKF91aWV2dHMsIGZ1bmN0aW9uIChpbmZvLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmluc3RhbmNlc1t3aWRnZXRHdWlkXSkge1xuICAgICAgICAgICAgICAgIC8vICBVbnJlZ2lzdGVyIHRoaXMgV2lkZ2V0IGluc3RhbmNlIGFzIG5lZWRpbmcgdGhpcyBkZWxlZ2F0ZWRcbiAgICAgICAgICAgICAgICAvLyAgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZm8uaW5zdGFuY2VzW3dpZGdldEd1aWRdO1xuXG4gICAgICAgICAgICAgICAgLy8gIFRoZXJlIGFyZSBubyBtb3JlIFdpZGdldCBpbnN0YW5jZXMgdXNpbmcgdGhpcyBkZWxlZ2F0ZWRcbiAgICAgICAgICAgICAgICAvLyAgZXZlbnQgbGlzdGVuZXIsIHNvIGRldGFjaCBpdC5cblxuICAgICAgICAgICAgICAgIGlmIChZLk9iamVjdC5pc0VtcHR5KGluZm8uaW5zdGFuY2VzKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvLmhhbmRsZS5kZXRhY2goKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX3VpZXZ0c1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3VpZXZ0c1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIERPTSBldmVudHMgdGhhdCBzaG91bGQgYmUgZmlyZWQgYXMgQ3VzdG9tIEV2ZW50cyBieSB0aGVcbiAgICAgKiBXaWRnZXQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgVUlfRVZFTlRTXG4gICAgICogQGZvciBXaWRnZXRcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBVSV9FVkVOVFM6IFkuTm9kZS5ET01fRVZFTlRTLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbm9kZSBvbiB3aGljaCB0byBiaW5kIGRlbGVnYXRlIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2dldFVJRXZlbnROb2RlXG4gICAgICogQGZvciBXaWRnZXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2dldFVJRXZlbnROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChCT1VORElOR19CT1gpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBhIGRlbGVnYXRlZCBET00gZXZlbnQgbGlzdGVuZXIgb2YgdGhlIHNwZWNpZmllZCB0eXBlIHRvIHRoZVxuICAgICAqIFdpZGdldCdzIG91dHRlcm1vc3QgRE9NIGVsZW1lbnQgdG8gZmFjaWxpdGF0ZSB0aGUgZmlyaW5nIG9mIGEgQ3VzdG9tXG4gICAgICogRXZlbnQgb2YgdGhlIHNhbWUgdHlwZSBmb3IgdGhlIFdpZGdldCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2NyZWF0ZVVJRXZlbnRcbiAgICAgKiBAZm9yIFdpZGdldFxuICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlVUlFdmVudDogZnVuY3Rpb24gKHR5cGUpIHtcblxuICAgICAgICB2YXIgdWlFdnROb2RlID0gdGhpcy5fZ2V0VUlFdmVudE5vZGUoKSxcbiAgICAgICAgICAgIGtleSA9IChZLnN0YW1wKHVpRXZ0Tm9kZSkgKyB0eXBlKSxcbiAgICAgICAgICAgIGluZm8gPSBfdWlldnRzW2tleV0sXG4gICAgICAgICAgICBoYW5kbGU7XG5cbiAgICAgICAgLy8gIEZvciBlYWNoIE5vZGUgaW5zdGFuY2U6IEVuc3VyZSB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIGRlbGVnYXRlZFxuICAgICAgICAvLyAgZXZlbnQgbGlzdGVuZXIgdXNlZCB0byBmaXJlIFdpZGdldCBVSSBldmVudHMuXG5cbiAgICAgICAgaWYgKCFpbmZvKSB7XG5cbiAgICAgICAgICAgIGhhbmRsZSA9IHVpRXZ0Tm9kZS5kZWxlZ2F0ZSh0eXBlLCBmdW5jdGlvbiAoZXZ0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgd2lkZ2V0ID0gV2lkZ2V0LmdldEJ5Tm9kZSh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIFdpZGdldCBjb3VsZCBiZSBudWxsIGlmIG5vZGUgaW5zdGFuY2UgYmVsb25ncyB0b1xuICAgICAgICAgICAgICAgIC8vIGFub3RoZXIgWSBpbnN0YW5jZS5cblxuICAgICAgICAgICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpZGdldC5fZmlsdGVyVUlFdmVudChldnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuZmlyZShldnQudHlwZSwgeyBkb21FdmVudDogZXZ0IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCBcIi5cIiArIFkuV2lkZ2V0LmdldENsYXNzTmFtZSgpKTtcblxuICAgICAgICAgICAgX3VpZXZ0c1trZXldID0gaW5mbyA9IHsgaW5zdGFuY2VzOiB7fSwgaGFuZGxlOiBoYW5kbGUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBSZWdpc3RlciB0aGlzIFdpZGdldCBhcyB1c2luZyB0aGlzIE5vZGUgYXMgYSBkZWxlZ2F0aW9uIGNvbnRhaW5lci5cbiAgICAgICAgaW5mby5pbnN0YW5jZXNbWS5zdGFtcCh0aGlzKV0gPSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgZmlyZVxuICAgICAqIHRoZSBVSSBFdmVudCBvciBub3QuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG1ha2VzIHN1cmVcbiAgICAgKiB0aGF0IGZvciBuZXN0ZWQgZGVsZWdhdGVzIChuZXN0ZWQgdW5yZWxhdGVkIHdpZGdldHMpLCB3ZSBkb24ndFxuICAgICAqIGZpcmUgdGhlIFVJIGV2ZW50IGxpc3RlbmVyIG1vcmUgdGhhbiBvbmNlIGF0IGVhY2ggbGV2ZWwuXG4gICAgICpcbiAgICAgKiA8cD5Gb3IgZXhhbXBsZSwgd2l0aG91dCB0aGUgYWRkaXRpb25hbCBmaWx0ZXIsIGlmIHlvdSBoYXZlIG5lc3RlZFxuICAgICAqIHdpZGdldHMsIGVhY2ggd2lkZ2V0IHdpbGwgaGF2ZSBhIGRlbGVnYXRlIGxpc3RlbmVyLiBJZiB5b3VcbiAgICAgKiBjbGljayBvbiB0aGUgaW5uZXIgd2lkZ2V0LCB0aGUgaW5uZXIgZGVsZWdhdGUgbGlzdGVuZXInc1xuICAgICAqIGZpbHRlciB3aWxsIG1hdGNoIG9uY2UsIGJ1dCB0aGUgb3V0ZXIgd2lsbCBtYXRjaCB0d2ljZVxuICAgICAqIChiYXNlZCBvbiBkZWxlZ2F0ZSdzIGRlc2lnbikgLSBvbmNlIGZvciB0aGUgaW5uZXIgd2lkZ2V0LFxuICAgICAqIGFuZCBvbmNlIGZvciB0aGUgb3V0ZXIuPC9wPlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZmlsdGVyVUlFdmVudFxuICAgICAqIEBmb3IgV2lkZ2V0XG4gICAgICogQHBhcmFtIHtET01FdmVudEZhY2FkZX0gZXZ0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdCdzIE9LIHRvIGZpcmUgdGhlIGN1c3RvbSBVSSBldmVudCwgZmFsc2UgaWYgbm90LlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBfZmlsdGVyVUlFdmVudDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIC8vIEVpdGhlciBpdCdzIGhpdHRpbmcgdGhpcyB3aWRnZXQncyBkZWxlZ2F0ZSBjb250YWluZXIgKGFuZCBub3Qgc29tZSBvdGhlciB3aWRnZXQncyksXG4gICAgICAgIC8vIG9yIHRoZSBjb250YWluZXIgaXQncyBoaXR0aW5nIGlzIGhhbmRsaW5nIHRoaXMgd2lkZ2V0J3MgdWkgZXZlbnRzLlxuICAgICAgICByZXR1cm4gKGV2dC5jdXJyZW50VGFyZ2V0LmNvbXBhcmVUbyhldnQuY29udGFpbmVyKSB8fCBldnQuY29udGFpbmVyLmNvbXBhcmVUbyh0aGlzLl9nZXRVSUV2ZW50Tm9kZSgpKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHNwZWNpZmllZCBldmVudCBpcyBhIFVJIGV2ZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIF9pc1VJRXZlbnRcbiAgICAgKiBAZm9yIFdpZGdldFxuICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBFdmVudCBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBVSSBFdmVudCwgb3RoZXJ3aXNlXG4gICAgICogdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIF9nZXRVSUV2ZW50OiBmdW5jdGlvbiAodHlwZSkge1xuXG4gICAgICAgIGlmIChMLmlzU3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgc1R5cGUgPSB0aGlzLnBhcnNlVHlwZSh0eXBlKVsxXSxcbiAgICAgICAgICAgICAgICBpRGVsaW0sXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsO1xuXG4gICAgICAgICAgICBpZiAoc1R5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBHZXQgZGVsaW1pdGVyIGZyb20gRVQsIG9yIGhhdmUgRVQgc3VwcG9ydCB0aGlzLlxuICAgICAgICAgICAgICAgIGlEZWxpbSA9IHNUeXBlLmluZGV4T2YoRVZFTlRfUFJFRklYX0RFTElNSVRFUik7XG4gICAgICAgICAgICAgICAgaWYgKGlEZWxpbSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNUeXBlID0gc1R5cGUuc3Vic3RyaW5nKGlEZWxpbSArIEVWRU5UX1BSRUZJWF9ERUxJTUlURVIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5VSV9FVkVOVFNbc1R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGluZnJhc3RydWN0dXJlIHJlcXVpcmVkIHRvIGZpcmUgYSBVSSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBfaW5pdFVJRXZlbnRcbiAgICAgKiBAZm9yIFdpZGdldFxuICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIF9pbml0VUlFdmVudDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHNUeXBlID0gdGhpcy5fZ2V0VUlFdmVudCh0eXBlKSxcbiAgICAgICAgICAgIHF1ZXVlID0gdGhpcy5fdWlFdnRzSW5pdFF1ZXVlIHx8IHt9O1xuXG4gICAgICAgIGlmIChzVHlwZSAmJiAhcXVldWVbc1R5cGVdKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3VpRXZ0c0luaXRRdWV1ZSA9IHF1ZXVlW3NUeXBlXSA9IDE7XG5cbiAgICAgICAgICAgIHRoaXMuYWZ0ZXIoUkVOREVSLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVVSUV2ZW50KHNUeXBlKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fdWlFdnRzSW5pdFF1ZXVlW3NUeXBlXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vICBPdmVycmlkZSBvZiBcIm9uXCIgZnJvbSBCYXNlIHRvIGZhY2lsaXRhdGUgdGhlIGZpcmluZyBvZiBXaWRnZXQgZXZlbnRzXG4gICAgLy8gIGJhc2VkIG9uIERPTSBldmVudHMgb2YgdGhlIHNhbWUgbmFtZS90eXBlIChlLmcuIFwiY2xpY2tcIiwgXCJtb3VzZW92ZXJcIikuXG4gICAgLy8gIFRlbXBvcmFyeSBzb2x1dGlvbiB1bnRpbCB3ZSBoYXZlIHRoZSBhYmlsaXR5IHRvIGxpc3RlbiB0byB3aGVuXG4gICAgLy8gIHNvbWVvbmUgYWRkcyBhbiBldmVudCBsaXN0ZW5lciAoYnVnIDI1MjgyMzApXG4gICAgb246IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuX2luaXRVSUV2ZW50KHR5cGUpO1xuICAgICAgICByZXR1cm4gV2lkZ2V0LnN1cGVyY2xhc3Mub24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gIE92ZXJyaWRlIG9mIFwicHVibGlzaFwiIGZyb20gQmFzZSB0byBmYWNpbGl0YXRlIHRoZSBmaXJpbmcgb2YgV2lkZ2V0IGV2ZW50c1xuICAgIC8vICBiYXNlZCBvbiBET00gZXZlbnRzIG9mIHRoZSBzYW1lIG5hbWUvdHlwZSAoZS5nLiBcImNsaWNrXCIsIFwibW91c2VvdmVyXCIpLlxuICAgIC8vICBUZW1wb3Jhcnkgc29sdXRpb24gdW50aWwgd2UgaGF2ZSB0aGUgYWJpbGl0eSB0byBsaXN0ZW4gdG8gd2hlblxuICAgIC8vICBzb21lb25lIHB1Ymxpc2hlcyBhbiBldmVudCAoYnVnIDI1MjgyMzApXG4gICAgcHVibGlzaDogZnVuY3Rpb24gKHR5cGUsIGNvbmZpZykge1xuICAgICAgICB2YXIgc1R5cGUgPSB0aGlzLl9nZXRVSUV2ZW50KHR5cGUpO1xuICAgICAgICBpZiAoc1R5cGUgJiYgY29uZmlnICYmIGNvbmZpZy5kZWZhdWx0Rm4pIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRVSUV2ZW50KHNUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gV2lkZ2V0LnN1cGVyY2xhc3MucHVibGlzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxufSwgdHJ1ZSk7IC8vIG92ZXJ3cml0ZSBleGlzdGluZyBFdmVudFRhcmdldCBtZXRob2RzXG5cblxufSwgJzMuMTcuMicsIHtcInJlcXVpcmVzXCI6IFtcIm5vZGUtZXZlbnQtZGVsZWdhdGVcIiwgXCJ3aWRnZXQtYmFzZVwiXX0pO1xuIiwiLypcbllVSSAzLjE3LjIgKGJ1aWxkIDljM2M3OGUpXG5Db3B5cmlnaHQgMjAxNCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuaHR0cDovL3l1aWxpYnJhcnkuY29tL2xpY2Vuc2UvXG4qL1xuXG5ZVUkuYWRkKCd5dWktdGhyb3R0bGUnLCBmdW5jdGlvbiAoWSwgTkFNRSkge1xuXG4vKipcblRocm90dGxlcyBhIGNhbGwgdG8gYSBtZXRob2QgYmFzZWQgb24gdGhlIHRpbWUgYmV0d2VlbiBjYWxscy4gVGhpcyBtZXRob2QgaXMgYXR0YWNoZWRcbnRvIHRoZSBgWWAgb2JqZWN0IGFuZCBpcyA8YSBocmVmPVwiLi4vY2xhc3Nlcy9ZVUkuaHRtbCNtZXRob2RfdGhyb3R0bGVcIj5kb2N1bWVudGVkIHRoZXJlPC9hPi5cblxuICAgIHZhciBmbiA9IFkudGhyb3R0bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICB9KTtcblxuICAgIGZvciAoaTsgaTwgMzUwMDA7IGkrKykge1xuICAgICAgICBvdXQrKztcbiAgICAgICAgZm4oKTtcbiAgICB9XG5cblxuQG1vZHVsZSB5dWlcbkBzdWJtb2R1bGUgeXVpLXRocm90dGxlXG4qL1xuXG4vKiEgQmFzZWQgb24gd29yayBieSBTaW1vbiBXaWxsaXNvbjogaHR0cDovL2dpc3QuZ2l0aHViLmNvbS8yOTI1NjIgKi9cbi8qKlxuICogVGhyb3R0bGVzIGEgY2FsbCB0byBhIG1ldGhvZCBiYXNlZCBvbiB0aGUgdGltZSBiZXR3ZWVuIGNhbGxzLlxuICogQG1ldGhvZCB0aHJvdHRsZVxuICogQGZvciBZVUlcbiAqIEBwYXJhbSBmbiB7ZnVuY3Rpb259IFRoZSBmdW5jdGlvbiBjYWxsIHRvIHRocm90dGxlLlxuICogQHBhcmFtIG1zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIHRoZSBtZXRob2QgY2FsbC5cbiAqIENhbiBzZXQgZ2xvYmFsbHkgd2l0aCBZLmNvbmZpZy50aHJvdHRsZVRpbWUgb3IgYnkgY2FsbC4gUGFzc2luZyBhIC0xIHdpbGxcbiAqIGRpc2FibGUgdGhlIHRocm90dGxlLiBEZWZhdWx0cyB0byAxNTAuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gUmV0dXJucyBhIHdyYXBwZWQgZnVuY3Rpb24gdGhhdCBjYWxscyBmbiB0aHJvdHRsZWQuXG4gKiBAc2luY2UgMy4xLjBcbiAqL1xuWS50aHJvdHRsZSA9IGZ1bmN0aW9uKGZuLCBtcykge1xuICAgIG1zID0gKG1zKSA/IG1zIDogKFkuY29uZmlnLnRocm90dGxlVGltZSB8fCAxNTApO1xuXG4gICAgaWYgKG1zID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gWS5MYW5nLm5vdygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gWS5MYW5nLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gbGFzdCA+IG1zKSB7XG4gICAgICAgICAgICBsYXN0ID0gbm93O1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5cbn0sICczLjE3LjInLCB7XCJyZXF1aXJlc1wiOiBbXCJ5dWktYmFzZVwiXX0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9